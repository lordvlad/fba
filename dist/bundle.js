(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';
var isPrimitive = require(77);
var assignSymbols = require(2);
var typeOf = require(79);
function assign(target) {
    target = target || {};
    var len = arguments.length, i = 0;
    if (len === 1) {
        return target;
    }
    while (++i < len) {
        var val = arguments[i];
        if (isPrimitive(target)) {
            target = val;
        }
        if (isObject(val)) {
            extend(target, val);
        }
    }
    return target;
}
function extend(target, obj) {
    assignSymbols(target, obj);
    for (var key in obj) {
        if (hasOwn(obj, key)) {
            var val = obj[key];
            if (isObject(val)) {
                if (typeOf(target[key]) === 'undefined' && typeOf(val) === 'function') {
                    target[key] = val;
                }
                target[key] = assign(target[key] || {}, val);
            } else {
                target[key] = val;
            }
        }
    }
    return target;
}
function isObject(obj) {
    return typeOf(obj) === 'object' || typeOf(obj) === 'function';
}
function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
module.exports = assign;
},{"2":2,"77":77,"79":79}],2:[function(require,module,exports){
'use strict';
module.exports = function (receiver, objects) {
    if (receiver === null || typeof receiver === 'undefined') {
        throw new TypeError('expected first argument to be an object.');
    }
    if (typeof objects === 'undefined' || typeof Symbol === 'undefined') {
        return receiver;
    }
    if (typeof Object.getOwnPropertySymbols !== 'function') {
        return receiver;
    }
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var target = Object(receiver);
    var len = arguments.length, i = 0;
    while (++i < len) {
        var provider = Object(arguments[i]);
        var names = Object.getOwnPropertySymbols(provider);
        for (var j = 0; j < names.length; j++) {
            var key = names[j];
            if (isEnumerable.call(provider, key)) {
                target[key] = provider[key];
            }
        }
    }
    return target;
};
},{}],3:[function(require,module,exports){
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function placeHoldersCount(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
    }
    return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}
function byteLength(b64) {
    return b64.length * 3 / 4 - placeHoldersCount(b64);
}
function toByteArray(b64) {
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;
    placeHolders = placeHoldersCount(b64);
    arr = new Arr(len * 3 / 4 - placeHolders);
    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;
    for (i = 0, j = 0; i < l; i += 4, j += 3) {
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[L++] = tmp >> 16 & 255;
        arr[L++] = tmp >> 8 & 255;
        arr[L++] = tmp & 255;
    }
    if (placeHolders === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[L++] = tmp & 255;
    } else if (placeHolders === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[L++] = tmp >> 8 & 255;
        arr[L++] = tmp & 255;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var output = '';
    var parts = [];
    var maxChunkLength = 16383;
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        output += lookup[tmp >> 2];
        output += lookup[tmp << 4 & 63];
        output += '==';
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        output += lookup[tmp >> 10];
        output += lookup[tmp >> 4 & 63];
        output += lookup[tmp << 2 & 63];
        output += '=';
    }
    parts.push(output);
    return parts.join('');
}
},{}],4:[function(require,module,exports){
module.exports = {
    trueFunc: function trueFunc() {
        return true;
    },
    falseFunc: function falseFunc() {
        return false;
    }
};
},{}],5:[function(require,module,exports){

},{}],6:[function(require,module,exports){
(function (global){
'use strict';
var buffer = require(7);
var Buffer = buffer.Buffer;
var SlowBuffer = buffer.SlowBuffer;
var MAX_LEN = buffer.kMaxLength || 2147483647;
exports.alloc = function alloc(size, fill, encoding) {
    if (typeof Buffer.alloc === 'function') {
        return Buffer.alloc(size, fill, encoding);
    }
    if (typeof encoding === 'number') {
        throw new TypeError('encoding must not be number');
    }
    if (typeof size !== 'number') {
        throw new TypeError('size must be a number');
    }
    if (size > MAX_LEN) {
        throw new RangeError('size is too large');
    }
    var enc = encoding;
    var _fill = fill;
    if (_fill === undefined) {
        enc = undefined;
        _fill = 0;
    }
    var buf = new Buffer(size);
    if (typeof _fill === 'string') {
        var fillBuf = new Buffer(_fill, enc);
        var flen = fillBuf.length;
        var i = -1;
        while (++i < size) {
            buf[i] = fillBuf[i % flen];
        }
    } else {
        buf.fill(_fill);
    }
    return buf;
};
exports.allocUnsafe = function allocUnsafe(size) {
    if (typeof Buffer.allocUnsafe === 'function') {
        return Buffer.allocUnsafe(size);
    }
    if (typeof size !== 'number') {
        throw new TypeError('size must be a number');
    }
    if (size > MAX_LEN) {
        throw new RangeError('size is too large');
    }
    return new Buffer(size);
};
exports.from = function from(value, encodingOrOffset, length) {
    if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
        return Buffer.from(value, encodingOrOffset, length);
    }
    if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number');
    }
    if (typeof value === 'string') {
        return new Buffer(value, encodingOrOffset);
    }
    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        var offset = encodingOrOffset;
        if (arguments.length === 1) {
            return new Buffer(value);
        }
        if (typeof offset === 'undefined') {
            offset = 0;
        }
        var len = length;
        if (typeof len === 'undefined') {
            len = value.byteLength - offset;
        }
        if (offset >= value.byteLength) {
            throw new RangeError('\'offset\' is out of bounds');
        }
        if (len > value.byteLength - offset) {
            throw new RangeError('\'length\' is out of bounds');
        }
        return new Buffer(value.slice(offset, offset + len));
    }
    if (Buffer.isBuffer(value)) {
        var out = new Buffer(value.length);
        value.copy(out, 0, 0, value.length);
        return out;
    }
    if (value) {
        if (Array.isArray(value) || typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer || 'length' in value) {
            return new Buffer(value);
        }
        if (value.type === 'Buffer' && Array.isArray(value.data)) {
            return new Buffer(value.data);
        }
    }
    throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
};
exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
    if (typeof Buffer.allocUnsafeSlow === 'function') {
        return Buffer.allocUnsafeSlow(size);
    }
    if (typeof size !== 'number') {
        throw new TypeError('size must be a number');
    }
    if (size >= MAX_LEN) {
        throw new RangeError('size is too large');
    }
    return new SlowBuffer(size);
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"7":7}],7:[function(require,module,exports){
'use strict';
var base64 = require(3);
var ieee754 = require(72);
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 2147483647;
exports.kMaxLength = K_MAX_LENGTH;
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
    try {
        var arr = new Uint8Array(1);
        arr.__proto__ = {
            __proto__: Uint8Array.prototype,
            foo: function () {
                return 42;
            }
        };
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
        throw new RangeError('Invalid typed array length');
    }
    var buf = new Uint8Array(length);
    buf.__proto__ = Buffer.prototype;
    return buf;
}
function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
            throw new Error('If encoding is specified then the first argument must be a string');
        }
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    Object.defineProperty(Buffer, Symbol.species, {
        value: null,
        configurable: true,
        enumerable: false,
        writable: false
    });
}
Buffer.poolSize = 8192;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number');
    }
    if (value instanceof ArrayBuffer) {
        return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
    }
    return fromObject(value);
}
Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
Buffer.prototype.__proto__ = Uint8Array.prototype;
Buffer.__proto__ = Uint8Array;
function assertSize(size) {
    if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
    }
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
        return createBuffer(size);
    }
    if (fill !== undefined) {
        return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
}
Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size);
};
Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds');
    }
    var buf;
    if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
    } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
    } else {
        buf = new Uint8Array(array, byteOffset, length);
    }
    buf.__proto__ = Buffer.prototype;
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
            return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj) {
        if (isArrayBufferView(obj) || 'length' in obj) {
            if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
                return createBuffer(0);
            }
            return fromArrayLike(obj);
        }
        if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
            return fromArrayLike(obj.data);
        }
    }
    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}
function checked(length) {
    if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
    }
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) {
        length = 0;
    }
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true;
};
Buffer.compare = function compare(a, b) {
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('Arguments must be Buffers');
    }
    if (a === b)
        return 0;
    var x = a.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y)
        return -1;
    if (y < x)
        return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
        return true;
    default:
        return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
        return Buffer.alloc(0);
    }
    var i;
    if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
            length += list[i].length;
        }
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!Buffer.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
        return string.length;
    }
    if (isArrayBufferView(string) || string instanceof ArrayBuffer) {
        return string.byteLength;
    }
    if (typeof string !== 'string') {
        string = '' + string;
    }
    var len = string.length;
    if (len === 0)
        return 0;
    var loweredCase = false;
    for (;;) {
        switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
        case undefined:
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase)
                return utf8ToBytes(string).length;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === undefined || start < 0) {
        start = 0;
    }
    if (start > this.length) {
        return '';
    }
    if (end === undefined || end > this.length) {
        end = this.length;
    }
    if (end <= 0) {
        return '';
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
        return '';
    }
    if (!encoding)
        encoding = 'utf8';
    while (true) {
        switch (encoding) {
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase)
                throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
    }
}
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
    }
    for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
    }
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
    }
    for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
    }
    for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0)
        return '';
    if (arguments.length === 0)
        return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
        throw new TypeError('Argument must be a Buffer');
    if (this === b)
        return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
        if (this.length > max)
            str += ' ... ';
    }
    return '<Buffer ' + str + '>';
};
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!Buffer.isBuffer(target)) {
        throw new TypeError('Argument must be a Buffer');
    }
    if (start === undefined) {
        start = 0;
    }
    if (end === undefined) {
        end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
        thisStart = 0;
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
        return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y)
        return -1;
    if (y < x)
        return 1;
    return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0)
        return -1;
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir)
            return -1;
        else
            byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir)
            byteOffset = 0;
        else
            return -1;
    }
    if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
    }
    if (Buffer.isBuffer(val)) {
        if (val.length === 0) {
            return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) {
                return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) {
            return buf[i];
        } else {
            return buf.readUInt16BE(i * indexSize);
        }
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1)
                    foundIndex = i;
                if (i - foundIndex + 1 === valLength)
                    return foundIndex * indexSize;
            } else {
                if (foundIndex !== -1)
                    i -= i - foundIndex;
                foundIndex = -1;
            }
        }
    } else {
        if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                }
            }
            if (found)
                return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
        length = remaining;
    } else {
        length = Number(length);
        if (length > remaining) {
            length = remaining;
        }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
        throw new TypeError('Invalid hex string');
    if (length > strLen / 2) {
        length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
            return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined)
                encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
        length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
    }
    if (!encoding)
        encoding = 'utf8';
    var loweredCase = false;
    for (;;) {
        switch (encoding) {
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
            return asciiWrite(this, string, offset, length);
        case 'latin1':
        case 'binary':
            return latin1Write(this, string, offset, length);
        case 'base64':
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase)
                throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
    } else {
        return base64.fromByteArray(buf.slice(start, end));
    }
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
            case 1:
                if (firstByte < 128) {
                    codePoint = firstByte;
                }
                break;
            case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                    if (tempCodePoint > 127) {
                        codePoint = tempCodePoint;
                    }
                }
                break;
            case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                        codePoint = tempCodePoint;
                    }
                }
                break;
            case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                        codePoint = tempCodePoint;
                    }
                }
            }
        }
        if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
    }
    var res = '';
    var i = 0;
    while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
        start = 0;
    if (!end || end < 0 || end > len)
        end = len;
    var out = '';
    for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
    }
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0)
            start = 0;
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0)
            end = 0;
    } else if (end > len) {
        end = len;
    }
    if (end < start)
        end = start;
    var newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
    return newBuf;
};
function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
        throw new RangeError('offset is not uint');
    if (offset + ext > length)
        throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
        checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 256)) {
        val += this[offset + i] * mul;
    }
    return val;
};
Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
    }
    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 256)) {
        val += this[offset + --byteLength] * mul;
    }
    return val;
};
Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
        checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 256)) {
        val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
        val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
        checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
        val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
        return this[offset];
    return (255 - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
        throw new RangeError('Index out of range');
}
Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while (++i < byteLength && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
    }
    return offset + byteLength;
};
Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
    }
    return offset + byteLength;
};
Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
        value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
        value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
        throw new RangeError('Index out of range');
    if (offset < 0)
        throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157e+308, -1.7976931348623157e+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
        start = 0;
    if (!end && end !== 0)
        end = this.length;
    if (targetStart >= target.length)
        targetStart = target.length;
    if (!targetStart)
        targetStart = 0;
    if (end > 0 && end < start)
        end = start;
    if (end === start)
        return 0;
    if (target.length === 0 || this.length === 0)
        return 0;
    if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
        throw new RangeError('sourceStart out of bounds');
    if (end < 0)
        throw new RangeError('sourceEnd out of bounds');
    if (end > this.length)
        end = this.length;
    if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
    }
    var len = end - start;
    var i;
    if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
            target[i + targetStart] = this[i + start];
        }
    } else if (len < 1000) {
        for (i = 0; i < len; ++i) {
            target[i + targetStart] = this[i + start];
        }
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    }
    return len;
};
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (code < 256) {
                val = code;
            }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
            throw new TypeError('encoding must be a string');
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding);
        }
    } else if (typeof val === 'number') {
        val = val & 255;
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val)
        val = 0;
    var i;
    if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
            this[i] = val;
        }
    } else {
        var bytes = Buffer.isBuffer(val) ? val : new Buffer(val, encoding);
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.trim().replace(INVALID_BASE64_RE, '');
    if (str.length < 2)
        return '';
    while (str.length % 4 !== 0) {
        str = str + '=';
    }
    return str;
}
function toHex(n) {
    if (n < 16)
        return '0' + n.toString(16);
    return n.toString(16);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0)
                break;
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
                break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
                break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
                break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error('Invalid code point');
        }
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
            break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
            break;
        dst[i + offset] = src[i];
    }
    return i;
}
function isArrayBufferView(obj) {
    return typeof ArrayBuffer.isView === 'function' && ArrayBuffer.isView(obj);
}
function numberIsNaN(obj) {
    return obj !== obj;
}
},{"3":3,"72":72}],8:[function(require,module,exports){
exports = module.exports = require(14);
exports.version = require(18).version;
},{"14":14,"18":18}],9:[function(require,module,exports){
var $ = require(16), utils = require(17), isTag = utils.isTag, domEach = utils.domEach, hasOwn = Object.prototype.hasOwnProperty, camelCase = utils.camelCase, cssCase = utils.cssCase, rspace = /\s+/, dataAttrPrefix = 'data-', _ = {
        forEach: require(85),
        extend: require(80),
        some: require(91)
    }, primitives = {
        null: null,
        true: true,
        false: false
    }, rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/;
var getAttr = function (elem, name) {
    if (!elem || !isTag(elem))
        return;
    if (!elem.attribs) {
        elem.attribs = {};
    }
    if (!name) {
        return elem.attribs;
    }
    if (hasOwn.call(elem.attribs, name)) {
        return rboolean.test(name) ? name : elem.attribs[name];
    }
    if (elem.name === 'option' && name === 'value') {
        return $.text(elem.children);
    }
    if (elem.name === 'input' && (elem.attribs.type === 'radio' || elem.attribs.type === 'checkbox') && name === 'value') {
        return 'on';
    }
};
var setAttr = function (el, name, value) {
    if (value === null) {
        removeAttribute(el, name);
    } else {
        el.attribs[name] = value + '';
    }
};
exports.attr = function (name, value) {
    if (typeof name === 'object' || value !== undefined) {
        if (typeof value === 'function') {
            return domEach(this, function (i, el) {
                setAttr(el, name, value.call(el, i, el.attribs[name]));
            });
        }
        return domEach(this, function (i, el) {
            if (!isTag(el))
                return;
            if (typeof name === 'object') {
                _.forEach(name, function (value, name) {
                    setAttr(el, name, value);
                });
            } else {
                setAttr(el, name, value);
            }
        });
    }
    return getAttr(this[0], name);
};
var getProp = function (el, name) {
    if (!el || !isTag(el))
        return;
    return el.hasOwnProperty(name) ? el[name] : rboolean.test(name) ? getAttr(el, name) !== undefined : getAttr(el, name);
};
var setProp = function (el, name, value) {
    el[name] = rboolean.test(name) ? !!value : value;
};
exports.prop = function (name, value) {
    var i = 0, property;
    if (typeof name === 'string' && value === undefined) {
        switch (name) {
        case 'style':
            property = this.css();
            _.forEach(property, function (v, p) {
                property[i++] = p;
            });
            property.length = i;
            break;
        case 'tagName':
        case 'nodeName':
            property = this[0].name.toUpperCase();
            break;
        default:
            property = getProp(this[0], name);
        }
        return property;
    }
    if (typeof name === 'object' || value !== undefined) {
        if (typeof value === 'function') {
            return domEach(this, function (i, el) {
                setProp(el, name, value.call(el, i, getProp(el, name)));
            });
        }
        return domEach(this, function (i, el) {
            if (!isTag(el))
                return;
            if (typeof name === 'object') {
                _.forEach(name, function (val, name) {
                    setProp(el, name, val);
                });
            } else {
                setProp(el, name, value);
            }
        });
    }
};
var setData = function (el, name, value) {
    if (!el.data) {
        el.data = {};
    }
    if (typeof name === 'object')
        return _.extend(el.data, name);
    if (typeof name === 'string' && value !== undefined) {
        el.data[name] = value;
    } else if (typeof name === 'object') {
        _.extend(el.data, name);
    }
};
var readData = function (el, name) {
    var readAll = arguments.length === 1;
    var domNames, domName, jsNames, jsName, value, idx, length;
    if (readAll) {
        domNames = Object.keys(el.attribs).filter(function (attrName) {
            return attrName.slice(0, dataAttrPrefix.length) === dataAttrPrefix;
        });
        jsNames = domNames.map(function (domName) {
            return camelCase(domName.slice(dataAttrPrefix.length));
        });
    } else {
        domNames = [dataAttrPrefix + cssCase(name)];
        jsNames = [name];
    }
    for (idx = 0, length = domNames.length; idx < length; ++idx) {
        domName = domNames[idx];
        jsName = jsNames[idx];
        if (hasOwn.call(el.attribs, domName)) {
            value = el.attribs[domName];
            if (hasOwn.call(primitives, value)) {
                value = primitives[value];
            } else if (value === String(Number(value))) {
                value = Number(value);
            } else if (rbrace.test(value)) {
                try {
                    value = JSON.parse(value);
                } catch (e) {
                }
            }
            el.data[jsName] = value;
        }
    }
    return readAll ? el.data : value;
};
exports.data = function (name, value) {
    var elem = this[0];
    if (!elem || !isTag(elem))
        return;
    if (!elem.data) {
        elem.data = {};
    }
    if (!name) {
        return readData(elem);
    }
    if (typeof name === 'object' || value !== undefined) {
        domEach(this, function (i, el) {
            setData(el, name, value);
        });
        return this;
    } else if (hasOwn.call(elem.data, name)) {
        return elem.data[name];
    }
    return readData(elem, name);
};
exports.val = function (value) {
    var querying = arguments.length === 0, element = this[0];
    if (!element)
        return;
    switch (element.name) {
    case 'textarea':
        return this.text(value);
    case 'input':
        switch (this.attr('type')) {
        case 'radio':
            if (querying) {
                return this.attr('value');
            } else {
                this.attr('value', value);
                return this;
            }
            break;
        default:
            return this.attr('value', value);
        }
        return;
    case 'select':
        var option = this.find('option:selected'), returnValue;
        if (option === undefined)
            return undefined;
        if (!querying) {
            if (!this.attr().hasOwnProperty('multiple') && typeof value == 'object') {
                return this;
            }
            if (typeof value != 'object') {
                value = [value];
            }
            this.find('option').removeAttr('selected');
            for (var i = 0; i < value.length; i++) {
                this.find('option[value="' + value[i] + '"]').attr('selected', '');
            }
            return this;
        }
        returnValue = option.attr('value');
        if (this.attr().hasOwnProperty('multiple')) {
            returnValue = [];
            domEach(option, function (i, el) {
                returnValue.push(getAttr(el, 'value'));
            });
        }
        return returnValue;
    case 'option':
        if (!querying) {
            this.attr('value', value);
            return this;
        }
        return this.attr('value');
    }
};
var removeAttribute = function (elem, name) {
    if (!elem.attribs || !hasOwn.call(elem.attribs, name))
        return;
    delete elem.attribs[name];
};
exports.removeAttr = function (name) {
    domEach(this, function (i, elem) {
        removeAttribute(elem, name);
    });
    return this;
};
exports.hasClass = function (className) {
    return _.some(this, function (elem) {
        var attrs = elem.attribs, clazz = attrs && attrs['class'], idx = -1, end;
        if (clazz) {
            while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
                end = idx + className.length;
                if ((idx === 0 || rspace.test(clazz[idx - 1])) && (end === clazz.length || rspace.test(clazz[end]))) {
                    return true;
                }
            }
        }
    });
};
exports.addClass = function (value) {
    if (typeof value === 'function') {
        return domEach(this, function (i, el) {
            var className = el.attribs['class'] || '';
            exports.addClass.call([el], value.call(el, i, className));
        });
    }
    if (!value || typeof value !== 'string')
        return this;
    var classNames = value.split(rspace), numElements = this.length;
    for (var i = 0; i < numElements; i++) {
        if (!isTag(this[i]))
            continue;
        var className = getAttr(this[i], 'class'), numClasses, setClass;
        if (!className) {
            setAttr(this[i], 'class', classNames.join(' ').trim());
        } else {
            setClass = ' ' + className + ' ';
            numClasses = classNames.length;
            for (var j = 0; j < numClasses; j++) {
                var appendClass = classNames[j] + ' ';
                if (setClass.indexOf(' ' + appendClass) < 0)
                    setClass += appendClass;
            }
            setAttr(this[i], 'class', setClass.trim());
        }
    }
    return this;
};
var splitClass = function (className) {
    return className ? className.trim().split(rspace) : [];
};
exports.removeClass = function (value) {
    var classes, numClasses, removeAll;
    if (typeof value === 'function') {
        return domEach(this, function (i, el) {
            exports.removeClass.call([el], value.call(el, i, el.attribs['class'] || ''));
        });
    }
    classes = splitClass(value);
    numClasses = classes.length;
    removeAll = arguments.length === 0;
    return domEach(this, function (i, el) {
        if (!isTag(el))
            return;
        if (removeAll) {
            el.attribs.class = '';
        } else {
            var elClasses = splitClass(el.attribs.class), index, changed;
            for (var j = 0; j < numClasses; j++) {
                index = elClasses.indexOf(classes[j]);
                if (index >= 0) {
                    elClasses.splice(index, 1);
                    changed = true;
                    j--;
                }
            }
            if (changed) {
                el.attribs.class = elClasses.join(' ');
            }
        }
    });
};
exports.toggleClass = function (value, stateVal) {
    if (typeof value === 'function') {
        return domEach(this, function (i, el) {
            exports.toggleClass.call([el], value.call(el, i, el.attribs['class'] || '', stateVal), stateVal);
        });
    }
    if (!value || typeof value !== 'string')
        return this;
    var classNames = value.split(rspace), numClasses = classNames.length, state = typeof stateVal === 'boolean' ? stateVal ? 1 : -1 : 0, numElements = this.length, elementClasses, index;
    for (var i = 0; i < numElements; i++) {
        if (!isTag(this[i]))
            continue;
        elementClasses = splitClass(this[i].attribs.class);
        for (var j = 0; j < numClasses; j++) {
            index = elementClasses.indexOf(classNames[j]);
            if (state >= 0 && index < 0) {
                elementClasses.push(classNames[j]);
            } else if (state <= 0 && index >= 0) {
                elementClasses.splice(index, 1);
            }
        }
        this[i].attribs.class = elementClasses.join(' ');
    }
    return this;
};
exports.is = function (selector) {
    if (selector) {
        return this.filter(selector).length > 0;
    }
    return false;
};
},{"16":16,"17":17,"80":80,"85":85,"91":91}],10:[function(require,module,exports){
var domEach = require(17).domEach, _ = { pick: require(88) };
var toString = Object.prototype.toString;
exports.css = function (prop, val) {
    if (arguments.length === 2 || toString.call(prop) === '[object Object]') {
        return domEach(this, function (idx, el) {
            setCss(el, prop, val, idx);
        });
    } else {
        return getCss(this[0], prop);
    }
};
function setCss(el, prop, val, idx) {
    if ('string' == typeof prop) {
        var styles = getCss(el);
        if (typeof val === 'function') {
            val = val.call(el, idx, styles[prop]);
        }
        if (val === '') {
            delete styles[prop];
        } else if (val != null) {
            styles[prop] = val;
        }
        el.attribs.style = stringify(styles);
    } else if ('object' == typeof prop) {
        Object.keys(prop).forEach(function (k) {
            setCss(el, k, prop[k]);
        });
    }
}
function getCss(el, prop) {
    var styles = parse(el.attribs.style);
    if (typeof prop === 'string') {
        return styles[prop];
    } else if (Array.isArray(prop)) {
        return _.pick(styles, prop);
    } else {
        return styles;
    }
}
function stringify(obj) {
    return Object.keys(obj || {}).reduce(function (str, prop) {
        return str += '' + (str ? ' ' : '') + prop + ': ' + obj[prop] + ';';
    }, '');
}
function parse(styles) {
    styles = (styles || '').trim();
    if (!styles)
        return {};
    return styles.split(';').reduce(function (obj, str) {
        var n = str.indexOf(':');
        if (n < 1 || n === str.length - 1)
            return obj;
        obj[str.slice(0, n).trim()] = str.slice(n + 1).trim();
        return obj;
    }, {});
}
},{"17":17,"88":88}],11:[function(require,module,exports){
var submittableSelector = 'input,select,textarea,keygen', r20 = /%20/g, rCRLF = /\r?\n/g, _ = { map: require(86) };
exports.serialize = function () {
    var arr = this.serializeArray();
    var retArr = _.map(arr, function (data) {
        return encodeURIComponent(data.name) + '=' + encodeURIComponent(data.value);
    });
    return retArr.join('&').replace(r20, '+');
};
exports.serializeArray = function () {
    var Cheerio = this.constructor;
    return this.map(function () {
        var elem = this;
        var $elem = Cheerio(elem);
        if (elem.name === 'form') {
            return $elem.find(submittableSelector).toArray();
        } else {
            return $elem.filter(submittableSelector).toArray();
        }
    }).filter('[name!=""]:not(:disabled)' + ':not(:submit, :button, :image, :reset, :file)' + ':matches([checked], :not(:checkbox, :radio))').map(function (i, elem) {
        var $elem = Cheerio(elem);
        var name = $elem.attr('name');
        var val = $elem.val();
        if (val == null) {
            return null;
        } else {
            if (Array.isArray(val)) {
                return _.map(val, function (val) {
                    return {
                        name: name,
                        value: val.replace(rCRLF, '\r\n')
                    };
                });
            } else {
                return {
                    name: name,
                    value: val.replace(rCRLF, '\r\n')
                };
            }
        }
    }).get();
};
},{"86":86}],12:[function(require,module,exports){
var parse = require(15), $ = require(16), updateDOM = parse.update, evaluate = parse.evaluate, utils = require(17), domEach = utils.domEach, cloneDom = utils.cloneDom, isHtml = utils.isHtml, slice = Array.prototype.slice, _ = {
        flatten: require(84),
        bind: require(81),
        forEach: require(85)
    };
exports._makeDomArray = function makeDomArray(elem, clone) {
    if (elem == null) {
        return [];
    } else if (elem.cheerio) {
        return clone ? cloneDom(elem.get(), elem.options) : elem.get();
    } else if (Array.isArray(elem)) {
        return _.flatten(elem.map(function (el) {
            return this._makeDomArray(el, clone);
        }, this));
    } else if (typeof elem === 'string') {
        return evaluate(elem, this.options);
    } else {
        return clone ? cloneDom([elem]) : [elem];
    }
};
var _insert = function (concatenator) {
    return function () {
        var elems = slice.call(arguments), lastIdx = this.length - 1;
        return domEach(this, function (i, el) {
            var dom, domSrc;
            if (typeof elems[0] === 'function') {
                domSrc = elems[0].call(el, i, $.html(el.children));
            } else {
                domSrc = elems;
            }
            dom = this._makeDomArray(domSrc, i < lastIdx);
            concatenator(dom, el.children, el);
        });
    };
};
var uniqueSplice = function (array, spliceIdx, spliceCount, newElems, parent) {
    var spliceArgs = [
            spliceIdx,
            spliceCount
        ].concat(newElems), prev = array[spliceIdx - 1] || null, next = array[spliceIdx] || null;
    var idx, len, prevIdx, node, oldParent;
    for (idx = 0, len = newElems.length; idx < len; ++idx) {
        node = newElems[idx];
        oldParent = node.parent || node.root;
        prevIdx = oldParent && oldParent.children.indexOf(newElems[idx]);
        if (oldParent && prevIdx > -1) {
            oldParent.children.splice(prevIdx, 1);
            if (parent === oldParent && spliceIdx > prevIdx) {
                spliceArgs[0]--;
            }
        }
        node.root = null;
        node.parent = parent;
        if (node.prev) {
            node.prev.next = node.next || null;
        }
        if (node.next) {
            node.next.prev = node.prev || null;
        }
        node.prev = newElems[idx - 1] || prev;
        node.next = newElems[idx + 1] || next;
    }
    if (prev) {
        prev.next = newElems[0];
    }
    if (next) {
        next.prev = newElems[newElems.length - 1];
    }
    return array.splice.apply(array, spliceArgs);
};
exports.appendTo = function (target) {
    if (!target.cheerio) {
        target = this.constructor.call(this.constructor, target, null, this._originalRoot);
    }
    target.append(this);
    return this;
};
exports.prependTo = function (target) {
    if (!target.cheerio) {
        target = this.constructor.call(this.constructor, target, null, this._originalRoot);
    }
    target.prepend(this);
    return this;
};
exports.append = _insert(function (dom, children, parent) {
    uniqueSplice(children, children.length, 0, dom, parent);
});
exports.prepend = _insert(function (dom, children, parent) {
    uniqueSplice(children, 0, 0, dom, parent);
});
exports.wrap = function (wrapper) {
    var wrapperFn = typeof wrapper === 'function' && wrapper, lastIdx = this.length - 1;
    _.forEach(this, _.bind(function (el, i) {
        var parent = el.parent || el.root, siblings = parent.children, dom, index;
        if (!parent) {
            return;
        }
        if (wrapperFn) {
            wrapper = wrapperFn.call(el, i);
        }
        if (typeof wrapper === 'string' && !isHtml(wrapper)) {
            wrapper = this.parents().last().find(wrapper).clone();
        }
        dom = this._makeDomArray(wrapper, i < lastIdx).slice(0, 1);
        index = siblings.indexOf(el);
        updateDOM([el], dom[0]);
        uniqueSplice(siblings, index, 0, dom, parent);
    }, this));
    return this;
};
exports.after = function () {
    var elems = slice.call(arguments), lastIdx = this.length - 1;
    domEach(this, function (i, el) {
        var parent = el.parent || el.root;
        if (!parent) {
            return;
        }
        var siblings = parent.children, index = siblings.indexOf(el), domSrc, dom;
        if (index < 0)
            return;
        if (typeof elems[0] === 'function') {
            domSrc = elems[0].call(el, i, $.html(el.children));
        } else {
            domSrc = elems;
        }
        dom = this._makeDomArray(domSrc, i < lastIdx);
        uniqueSplice(siblings, index + 1, 0, dom, parent);
    });
    return this;
};
exports.insertAfter = function (target) {
    var clones = [], self = this;
    if (typeof target === 'string') {
        target = this.constructor.call(this.constructor, target, null, this._originalRoot);
    }
    target = this._makeDomArray(target);
    self.remove();
    domEach(target, function (i, el) {
        var clonedSelf = self._makeDomArray(self.clone());
        var parent = el.parent || el.root;
        if (!parent) {
            return;
        }
        var siblings = parent.children, index = siblings.indexOf(el);
        if (index < 0)
            return;
        uniqueSplice(siblings, index + 1, 0, clonedSelf, parent);
        clones.push(clonedSelf);
    });
    return this.constructor.call(this.constructor, this._makeDomArray(clones));
};
exports.before = function () {
    var elems = slice.call(arguments), lastIdx = this.length - 1;
    domEach(this, function (i, el) {
        var parent = el.parent || el.root;
        if (!parent) {
            return;
        }
        var siblings = parent.children, index = siblings.indexOf(el), domSrc, dom;
        if (index < 0)
            return;
        if (typeof elems[0] === 'function') {
            domSrc = elems[0].call(el, i, $.html(el.children));
        } else {
            domSrc = elems;
        }
        dom = this._makeDomArray(domSrc, i < lastIdx);
        uniqueSplice(siblings, index, 0, dom, parent);
    });
    return this;
};
exports.insertBefore = function (target) {
    var clones = [], self = this;
    if (typeof target === 'string') {
        target = this.constructor.call(this.constructor, target, null, this._originalRoot);
    }
    target = this._makeDomArray(target);
    self.remove();
    domEach(target, function (i, el) {
        var clonedSelf = self._makeDomArray(self.clone());
        var parent = el.parent || el.root;
        if (!parent) {
            return;
        }
        var siblings = parent.children, index = siblings.indexOf(el);
        if (index < 0)
            return;
        uniqueSplice(siblings, index, 0, clonedSelf, parent);
        clones.push(clonedSelf);
    });
    return this.constructor.call(this.constructor, this._makeDomArray(clones));
};
exports.remove = function (selector) {
    var elems = this;
    if (selector)
        elems = elems.filter(selector);
    domEach(elems, function (i, el) {
        var parent = el.parent || el.root;
        if (!parent) {
            return;
        }
        var siblings = parent.children, index = siblings.indexOf(el);
        if (index < 0)
            return;
        siblings.splice(index, 1);
        if (el.prev) {
            el.prev.next = el.next;
        }
        if (el.next) {
            el.next.prev = el.prev;
        }
        el.prev = el.next = el.parent = el.root = null;
    });
    return this;
};
exports.replaceWith = function (content) {
    var self = this;
    domEach(this, function (i, el) {
        var parent = el.parent || el.root;
        if (!parent) {
            return;
        }
        var siblings = parent.children, dom = self._makeDomArray(typeof content === 'function' ? content.call(el, i, el) : content), index;
        updateDOM(dom, null);
        index = siblings.indexOf(el);
        uniqueSplice(siblings, index, 1, dom, parent);
        el.parent = el.prev = el.next = el.root = null;
    });
    return this;
};
exports.empty = function () {
    domEach(this, function (i, el) {
        _.forEach(el.children, function (el) {
            el.next = el.prev = el.parent = null;
        });
        el.children.length = 0;
    });
    return this;
};
exports.html = function (str) {
    if (str === undefined) {
        if (!this[0] || !this[0].children)
            return null;
        return $.html(this[0].children, this.options);
    }
    var opts = this.options;
    domEach(this, function (i, el) {
        _.forEach(el.children, function (el) {
            el.next = el.prev = el.parent = null;
        });
        var content = str.cheerio ? str.clone().get() : evaluate('' + str, opts);
        updateDOM(content, el);
    });
    return this;
};
exports.toString = function () {
    return $.html(this, this.options);
};
exports.text = function (str) {
    if (str === undefined) {
        return $.text(this);
    } else if (typeof str === 'function') {
        return domEach(this, function (i, el) {
            var $el = [el];
            return exports.text.call($el, str.call(el, i, $.text($el)));
        });
    }
    domEach(this, function (i, el) {
        _.forEach(el.children, function (el) {
            el.next = el.prev = el.parent = null;
        });
        var elem = {
            data: '' + str,
            type: 'text',
            parent: el,
            prev: null,
            next: null,
            children: []
        };
        updateDOM(elem, el);
    });
    return this;
};
exports.clone = function () {
    return this._make(cloneDom(this.get(), this.options));
};
},{"15":15,"16":16,"17":17,"81":81,"84":84,"85":85}],13:[function(require,module,exports){
var select = require(22), utils = require(17), domEach = utils.domEach, uniqueSort = require(71).DomUtils.uniqueSort, isTag = utils.isTag, _ = {
        bind: require(81),
        forEach: require(85),
        reject: require(90),
        filter: require(83),
        reduce: require(89)
    };
exports.find = function (selectorOrHaystack) {
    var elems = _.reduce(this, function (memo, elem) {
        return memo.concat(_.filter(elem.children, isTag));
    }, []);
    var contains = this.constructor.contains;
    var haystack;
    if (selectorOrHaystack && typeof selectorOrHaystack !== 'string') {
        if (selectorOrHaystack.cheerio) {
            haystack = selectorOrHaystack.get();
        } else {
            haystack = [selectorOrHaystack];
        }
        return this._make(haystack.filter(function (elem) {
            var idx, len;
            for (idx = 0, len = this.length; idx < len; ++idx) {
                if (contains(this[idx], elem)) {
                    return true;
                }
            }
        }, this));
    }
    var options = {
        __proto__: this.options,
        context: this.toArray()
    };
    return this._make(select(selectorOrHaystack, elems, options));
};
exports.parent = function (selector) {
    var set = [];
    domEach(this, function (idx, elem) {
        var parentElem = elem.parent;
        if (parentElem && set.indexOf(parentElem) < 0) {
            set.push(parentElem);
        }
    });
    if (arguments.length) {
        set = exports.filter.call(set, selector, this);
    }
    return this._make(set);
};
exports.parents = function (selector) {
    var parentNodes = [];
    this.get().reverse().forEach(function (elem) {
        traverseParents(this, elem.parent, selector, Infinity).forEach(function (node) {
            if (parentNodes.indexOf(node) === -1) {
                parentNodes.push(node);
            }
        });
    }, this);
    return this._make(parentNodes);
};
exports.parentsUntil = function (selector, filter) {
    var parentNodes = [], untilNode, untilNodes;
    if (typeof selector === 'string') {
        untilNode = select(selector, this.parents().toArray(), this.options)[0];
    } else if (selector && selector.cheerio) {
        untilNodes = selector.toArray();
    } else if (selector) {
        untilNode = selector;
    }
    this.toArray().reverse().forEach(function (elem) {
        while (elem = elem.parent) {
            if (untilNode && elem !== untilNode || untilNodes && untilNodes.indexOf(elem) === -1 || !untilNode && !untilNodes) {
                if (isTag(elem) && parentNodes.indexOf(elem) === -1) {
                    parentNodes.push(elem);
                }
            } else {
                break;
            }
        }
    }, this);
    return this._make(filter ? select(filter, parentNodes, this.options) : parentNodes);
};
exports.closest = function (selector) {
    var set = [];
    if (!selector) {
        return this._make(set);
    }
    domEach(this, function (idx, elem) {
        var closestElem = traverseParents(this, elem, selector, 1)[0];
        if (closestElem && set.indexOf(closestElem) < 0) {
            set.push(closestElem);
        }
    }.bind(this));
    return this._make(set);
};
exports.next = function (selector) {
    if (!this[0]) {
        return this;
    }
    var elems = [];
    _.forEach(this, function (elem) {
        while (elem = elem.next) {
            if (isTag(elem)) {
                elems.push(elem);
                return;
            }
        }
    });
    return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
};
exports.nextAll = function (selector) {
    if (!this[0]) {
        return this;
    }
    var elems = [];
    _.forEach(this, function (elem) {
        while (elem = elem.next) {
            if (isTag(elem) && elems.indexOf(elem) === -1) {
                elems.push(elem);
            }
        }
    });
    return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
};
exports.nextUntil = function (selector, filterSelector) {
    if (!this[0]) {
        return this;
    }
    var elems = [], untilNode, untilNodes;
    if (typeof selector === 'string') {
        untilNode = select(selector, this.nextAll().get(), this.options)[0];
    } else if (selector && selector.cheerio) {
        untilNodes = selector.get();
    } else if (selector) {
        untilNode = selector;
    }
    _.forEach(this, function (elem) {
        while (elem = elem.next) {
            if (untilNode && elem !== untilNode || untilNodes && untilNodes.indexOf(elem) === -1 || !untilNode && !untilNodes) {
                if (isTag(elem) && elems.indexOf(elem) === -1) {
                    elems.push(elem);
                }
            } else {
                break;
            }
        }
    });
    return filterSelector ? exports.filter.call(elems, filterSelector, this) : this._make(elems);
};
exports.prev = function (selector) {
    if (!this[0]) {
        return this;
    }
    var elems = [];
    _.forEach(this, function (elem) {
        while (elem = elem.prev) {
            if (isTag(elem)) {
                elems.push(elem);
                return;
            }
        }
    });
    return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
};
exports.prevAll = function (selector) {
    if (!this[0]) {
        return this;
    }
    var elems = [];
    _.forEach(this, function (elem) {
        while (elem = elem.prev) {
            if (isTag(elem) && elems.indexOf(elem) === -1) {
                elems.push(elem);
            }
        }
    });
    return selector ? exports.filter.call(elems, selector, this) : this._make(elems);
};
exports.prevUntil = function (selector, filterSelector) {
    if (!this[0]) {
        return this;
    }
    var elems = [], untilNode, untilNodes;
    if (typeof selector === 'string') {
        untilNode = select(selector, this.prevAll().get(), this.options)[0];
    } else if (selector && selector.cheerio) {
        untilNodes = selector.get();
    } else if (selector) {
        untilNode = selector;
    }
    _.forEach(this, function (elem) {
        while (elem = elem.prev) {
            if (untilNode && elem !== untilNode || untilNodes && untilNodes.indexOf(elem) === -1 || !untilNode && !untilNodes) {
                if (isTag(elem) && elems.indexOf(elem) === -1) {
                    elems.push(elem);
                }
            } else {
                break;
            }
        }
    });
    return filterSelector ? exports.filter.call(elems, filterSelector, this) : this._make(elems);
};
exports.siblings = function (selector) {
    var parent = this.parent();
    var elems = _.filter(parent ? parent.children() : this.siblingsAndMe(), _.bind(function (elem) {
        return isTag(elem) && !this.is(elem);
    }, this));
    if (selector !== undefined) {
        return exports.filter.call(elems, selector, this);
    } else {
        return this._make(elems);
    }
};
exports.children = function (selector) {
    var elems = _.reduce(this, function (memo, elem) {
        return memo.concat(_.filter(elem.children, isTag));
    }, []);
    if (selector === undefined)
        return this._make(elems);
    return exports.filter.call(elems, selector, this);
};
exports.contents = function () {
    return this._make(_.reduce(this, function (all, elem) {
        all.push.apply(all, elem.children);
        return all;
    }, []));
};
exports.each = function (fn) {
    var i = 0, len = this.length;
    while (i < len && fn.call(this[i], i, this[i]) !== false)
        ++i;
    return this;
};
exports.map = function (fn) {
    return this._make(_.reduce(this, function (memo, el, i) {
        var val = fn.call(el, i, el);
        return val == null ? memo : memo.concat(val);
    }, []));
};
var makeFilterMethod = function (filterFn) {
    return function (match, container) {
        var testFn;
        container = container || this;
        if (typeof match === 'string') {
            testFn = select.compile(match, container.options);
        } else if (typeof match === 'function') {
            testFn = function (el, i) {
                return match.call(el, i, el);
            };
        } else if (match.cheerio) {
            testFn = match.is.bind(match);
        } else {
            testFn = function (el) {
                return match === el;
            };
        }
        return container._make(filterFn(this, testFn));
    };
};
exports.filter = makeFilterMethod(_.filter);
exports.not = makeFilterMethod(_.reject);
exports.has = function (selectorOrHaystack) {
    var that = this;
    return exports.filter.call(this, function () {
        return that._make(this).find(selectorOrHaystack).length > 0;
    });
};
exports.first = function () {
    return this.length > 1 ? this._make(this[0]) : this;
};
exports.last = function () {
    return this.length > 1 ? this._make(this[this.length - 1]) : this;
};
exports.eq = function (i) {
    i = +i;
    if (i === 0 && this.length <= 1)
        return this;
    if (i < 0)
        i = this.length + i;
    return this[i] ? this._make(this[i]) : this._make([]);
};
exports.get = function (i) {
    if (i == null) {
        return Array.prototype.slice.call(this);
    } else {
        return this[i < 0 ? this.length + i : i];
    }
};
exports.index = function (selectorOrNeedle) {
    var $haystack, needle;
    if (arguments.length === 0) {
        $haystack = this.parent().children();
        needle = this[0];
    } else if (typeof selectorOrNeedle === 'string') {
        $haystack = this._make(selectorOrNeedle);
        needle = this[0];
    } else {
        $haystack = this;
        needle = selectorOrNeedle.cheerio ? selectorOrNeedle[0] : selectorOrNeedle;
    }
    return $haystack.get().indexOf(needle);
};
exports.slice = function () {
    return this._make([].slice.apply(this, arguments));
};
function traverseParents(self, elem, selector, limit) {
    var elems = [];
    while (elem && elems.length < limit) {
        if (!selector || exports.filter.call([elem], selector, self).length) {
            elems.push(elem);
        }
        elem = elem.parent;
    }
    return elems;
}
exports.end = function () {
    return this.prevObject || this._make([]);
};
exports.add = function (other, context) {
    var selection = this._make(other, context);
    var contents = uniqueSort(selection.get().concat(this.get()));
    for (var i = 0; i < contents.length; ++i) {
        selection[i] = contents[i];
    }
    selection.length = contents.length;
    return selection;
};
exports.addBack = function (selector) {
    return this.add(arguments.length ? this.prevObject.filter(selector) : this.prevObject);
};
},{"17":17,"22":22,"71":71,"81":81,"83":83,"85":85,"89":89,"90":90}],14:[function(require,module,exports){
var parse = require(15), isHtml = require(17).isHtml, _ = {
        extend: require(80),
        bind: require(81),
        forEach: require(85),
        defaults: require(82)
    };
var api = [
    require(9),
    require(13),
    require(12),
    require(10),
    require(11)
];
var Cheerio = module.exports = function (selector, context, root, options) {
    if (!(this instanceof Cheerio))
        return new Cheerio(selector, context, root, options);
    this.options = _.defaults(options || {}, this.options);
    if (!selector)
        return this;
    if (root) {
        if (typeof root === 'string')
            root = parse(root, this.options);
        this._root = Cheerio.call(this, root);
    }
    if (selector.cheerio)
        return selector;
    if (isNode(selector))
        selector = [selector];
    if (Array.isArray(selector)) {
        _.forEach(selector, _.bind(function (elem, idx) {
            this[idx] = elem;
        }, this));
        this.length = selector.length;
        return this;
    }
    if (typeof selector === 'string' && isHtml(selector)) {
        return Cheerio.call(this, parse(selector, this.options).children);
    }
    if (!context) {
        context = this._root;
    } else if (typeof context === 'string') {
        if (isHtml(context)) {
            context = parse(context, this.options);
            context = Cheerio.call(this, context);
        } else {
            selector = [
                context,
                selector
            ].join(' ');
            context = this._root;
        }
    } else if (!context.cheerio) {
        context = Cheerio.call(this, context);
    }
    if (!context)
        return this;
    return context.find(selector);
};
_.extend(Cheerio, require(16));
Cheerio.prototype.cheerio = '[cheerio object]';
Cheerio.prototype.options = {
    withDomLvl1: true,
    normalizeWhitespace: false,
    xmlMode: false,
    decodeEntities: true
};
Cheerio.prototype.length = 0;
Cheerio.prototype.splice = Array.prototype.splice;
Cheerio.prototype._make = function (dom, context) {
    var cheerio = new this.constructor(dom, context, this._root, this.options);
    cheerio.prevObject = this;
    return cheerio;
};
Cheerio.prototype.toArray = function () {
    return this.get();
};
api.forEach(function (mod) {
    _.extend(Cheerio.prototype, mod);
});
var isNode = function (obj) {
    return obj.name || obj.type === 'text' || obj.type === 'comment';
};
},{"10":10,"11":11,"12":12,"13":13,"15":15,"16":16,"17":17,"80":80,"81":81,"82":82,"85":85,"9":9}],15:[function(require,module,exports){
(function (Buffer){
var htmlparser = require(71);
exports = module.exports = function (content, options) {
    var dom = exports.evaluate(content, options), root = exports.evaluate('<root></root>', options)[0];
    root.type = 'root';
    exports.update(dom, root);
    return root;
};
exports.evaluate = function (content, options) {
    var dom;
    if (typeof content === 'string' || Buffer.isBuffer(content)) {
        dom = htmlparser.parseDOM(content, options);
    } else {
        dom = content;
    }
    return dom;
};
exports.update = function (arr, parent) {
    if (!Array.isArray(arr))
        arr = [arr];
    if (parent) {
        parent.children = arr;
    } else {
        parent = null;
    }
    for (var i = 0; i < arr.length; i++) {
        var node = arr[i];
        var oldParent = node.parent || node.root, oldSiblings = oldParent && oldParent.children;
        if (oldSiblings && oldSiblings !== arr) {
            oldSiblings.splice(oldSiblings.indexOf(node), 1);
            if (node.prev) {
                node.prev.next = node.next;
            }
            if (node.next) {
                node.next.prev = node.prev;
            }
        }
        if (parent) {
            node.prev = arr[i - 1] || null;
            node.next = arr[i + 1] || null;
        } else {
            node.prev = node.next = null;
        }
        if (parent && parent.type === 'root') {
            node.root = parent;
            node.parent = null;
        } else {
            node.root = null;
            node.parent = parent;
        }
    }
    return parent;
};
}).call(this,{"isBuffer":require(76)})
},{"71":71,"76":76}],16:[function(require,module,exports){
var serialize = require(36), select = require(22), parse = require(15), _ = {
        merge: require(87),
        defaults: require(82)
    };
exports.load = function (content, options) {
    var Cheerio = require(14);
    options = _.defaults(options || {}, Cheerio.prototype.options);
    var root = parse(content, options);
    var initialize = function (selector, context, r, opts) {
        if (!(this instanceof initialize)) {
            return new initialize(selector, context, r, opts);
        }
        opts = _.defaults(opts || {}, options);
        return Cheerio.call(this, selector, context, r || root, opts);
    };
    initialize.prototype = Object.create(Cheerio.prototype);
    initialize.prototype.constructor = initialize;
    initialize.fn = initialize.prototype;
    initialize.prototype._originalRoot = root;
    _.merge(initialize, exports);
    initialize._root = root;
    initialize._options = options;
    return initialize;
};
function render(that, dom, options) {
    if (!dom) {
        if (that._root && that._root.children) {
            dom = that._root.children;
        } else {
            return '';
        }
    } else if (typeof dom === 'string') {
        dom = select(dom, that._root, options);
    }
    return serialize(dom, options);
}
exports.html = function (dom, options) {
    var Cheerio = require(14);
    if (Object.prototype.toString.call(dom) === '[object Object]' && !options && !('length' in dom) && !('type' in dom)) {
        options = dom;
        dom = undefined;
    }
    options = _.defaults(options || {}, this._options, Cheerio.prototype.options);
    return render(this, dom, options);
};
exports.xml = function (dom) {
    var options = _.defaults({ xmlMode: true }, this._options);
    return render(this, dom, options);
};
exports.text = function (elems) {
    if (!elems) {
        elems = this.root();
    }
    var ret = '', len = elems.length, elem;
    for (var i = 0; i < len; i++) {
        elem = elems[i];
        if (elem.type === 'text')
            ret += elem.data;
        else if (elem.children && elem.type !== 'comment') {
            ret += exports.text(elem.children);
        }
    }
    return ret;
};
exports.parseHTML = function (data, context, keepScripts) {
    var parsed;
    if (!data || typeof data !== 'string') {
        return null;
    }
    if (typeof context === 'boolean') {
        keepScripts = context;
    }
    parsed = this.load(data);
    if (!keepScripts) {
        parsed('script').remove();
    }
    return parsed.root()[0].children.slice();
};
exports.root = function () {
    return this(this._root);
};
exports.contains = function (container, contained) {
    if (contained === container) {
        return false;
    }
    while (contained && contained !== contained.parent) {
        contained = contained.parent;
        if (contained === container) {
            return true;
        }
    }
    return false;
};
},{"14":14,"15":15,"22":22,"36":36,"82":82,"87":87}],17:[function(require,module,exports){
var parse = require(15), render = require(36);
var tags = {
    tag: true,
    script: true,
    style: true
};
exports.isTag = function (type) {
    if (type.type)
        type = type.type;
    return tags[type] || false;
};
exports.camelCase = function (str) {
    return str.replace(/[_.-](\w|$)/g, function (_, x) {
        return x.toUpperCase();
    });
};
exports.cssCase = function (str) {
    return str.replace(/[A-Z]/g, '-$&').toLowerCase();
};
exports.domEach = function (cheerio, fn) {
    var i = 0, len = cheerio.length;
    while (i < len && fn.call(cheerio, i, cheerio[i]) !== false)
        ++i;
    return cheerio;
};
exports.cloneDom = function (dom, options) {
    return parse(render(dom, options), options).children;
};
var quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;
exports.isHtml = function (str) {
    if (str.charAt(0) === '<' && str.charAt(str.length - 1) === '>' && str.length >= 3)
        return true;
    var match = quickExpr.exec(str);
    return !!(match && match[1]);
};
},{"15":15,"36":36}],18:[function(require,module,exports){
module.exports={
  "name": "cheerio",
  "version": "0.22.0",
  "description": "Tiny, fast, and elegant implementation of core jQuery designed specifically for the server",
  "author": "Matt Mueller <mattmuelle@gmail.com> (mat.io)",
  "license": "MIT",
  "keywords": [
    "htmlparser",
    "jquery",
    "selector",
    "scraper",
    "parser",
    "html"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/cheeriojs/cheerio.git"
  },
  "main": "./index.js",
  "files": [
    "index.js",
    "lib"
  ],
  "engines": {
    "node": ">= 0.6"
  },
  "dependencies": {
    "css-select": "~1.2.0",
    "dom-serializer": "~0.1.0",
    "entities": "~1.1.1",
    "htmlparser2": "^3.9.1",
    "lodash.assignin": "^4.0.9",
    "lodash.bind": "^4.1.4",
    "lodash.defaults": "^4.0.1",
    "lodash.filter": "^4.4.0",
    "lodash.flatten": "^4.2.0",
    "lodash.foreach": "^4.3.0",
    "lodash.map": "^4.4.0",
    "lodash.merge": "^4.4.0",
    "lodash.pick": "^4.2.1",
    "lodash.reduce": "^4.4.0",
    "lodash.reject": "^4.4.0",
    "lodash.some": "^4.4.0"
  },
  "devDependencies": {
    "benchmark": "^2.1.0",
    "coveralls": "^2.11.9",
    "expect.js": "~0.3.1",
    "istanbul": "^0.4.3",
    "jsdom": "^9.2.1",
    "jquery": "^3.0.0",
    "jshint": "^2.9.2",
    "mocha": "^2.5.3",
    "xyz": "~0.5.0"
  },
  "scripts": {
    "test": "make test"
  }
}

},{}],19:[function(require,module,exports){
module.exports = {};
},{}],20:[function(require,module,exports){
var documentReady = require(35);
var nanohistory = require(233);
var nanorouter = require(240);
var nanomount = require(238);
var nanomorph = require(235);
var nanohref = require(234);
var nanoraf = require(239);
var nanobus = require(232);
module.exports = Choo;
function Choo(opts) {
    opts = opts || {};
    var routerOpts = {
        default: opts.defaultRoute || '/404',
        curry: true
    };
    var timingEnabled = opts.timing === undefined ? true : opts.timing;
    var hasWindow = typeof window !== 'undefined';
    var hasPerformance = hasWindow && window.performance && window.performance.mark;
    var router = nanorouter(routerOpts);
    var bus = nanobus();
    var rerender = null;
    var tree = null;
    var state = {};
    return {
        toString: toString,
        use: register,
        mount: mount,
        route: route,
        start: start
    };
    function route(route, handler) {
        router.on(route, function (params) {
            return function () {
                state.params = params;
                return handler(state, emit);
            };
        });
    }
    function register(cb) {
        cb(state, bus);
    }
    function start() {
        tree = router(createLocation());
        rerender = nanoraf(function () {
            if (hasPerformance && timingEnabled) {
                window.performance.mark('choo:renderStart');
            }
            var newTree = router(createLocation());
            tree = nanomorph(tree, newTree);
            if (hasPerformance && timingEnabled) {
                window.performance.mark('choo:renderEnd');
                window.performance.measure('choo:render', 'choo:renderStart', 'choo:renderEnd');
            }
        });
        bus.prependListener('render', rerender);
        if (opts.history !== false) {
            nanohistory(function (href) {
                bus.emit('pushState');
            });
            bus.prependListener('pushState', function (href) {
                if (href)
                    window.history.pushState({}, null, href);
                bus.emit('render');
                setTimeout(function () {
                    scrollIntoView();
                }, 0);
            });
            if (opts.href !== false) {
                nanohref(function (location) {
                    var href = location.href;
                    var currHref = window.location.href;
                    if (href === currHref)
                        return;
                    bus.emit('pushState', href);
                });
            }
        }
        documentReady(function () {
            bus.emit('DOMContentLoaded');
        });
        return tree;
    }
    function emit(eventName, data) {
        bus.emit(eventName, data);
    }
    function mount(selector) {
        var newTree = start();
        documentReady(function () {
            var root = document.querySelector(selector);
            nanomount(root, newTree);
            tree = root;
        });
    }
    function toString(location, _state) {
        state = _state || {};
        var html = router(location);
        assert.equal();
        return html.toString();
    }
}
function scrollIntoView() {
    var hash = window.location.hash;
    if (hash) {
        try {
            var el = document.querySelector(hash);
            if (el)
                el.scrollIntoView(true);
        } catch (e) {
        }
    }
}
function createLocation() {
    var pathname = window.location.pathname.replace(/\/$/, '');
    var hash = window.location.hash.replace(/^#/, '/');
    return pathname + hash;
}
},{"232":232,"233":233,"234":234,"235":235,"238":238,"239":239,"240":240,"35":35}],21:[function(require,module,exports){
(function (Buffer){
function isArray(arg) {
    if (Array.isArray) {
        return Array.isArray(arg);
    }
    return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;
function isBoolean(arg) {
    return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
    return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
    return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
    return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
    return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
    return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
    return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
    return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
function isError(e) {
    return objectToString(e) === '[object Error]' || e instanceof Error;
}
exports.isError = isError;
function isFunction(arg) {
    return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;
function objectToString(o) {
    return Object.prototype.toString.call(o);
}
}).call(this,{"isBuffer":require(76)})
},{"76":76}],22:[function(require,module,exports){
'use strict';
module.exports = CSSselect;
var Pseudos = require(27), DomUtils = require(42), findOne = DomUtils.findOne, findAll = DomUtils.findAll, getChildren = DomUtils.getChildren, removeSubsets = DomUtils.removeSubsets, falseFunc = require(4).falseFunc, compile = require(24), compileUnsafe = compile.compileUnsafe, compileToken = compile.compileToken;
function getSelectorFunc(searchFunc) {
    return function select(query, elems, options) {
        if (typeof query !== 'function')
            query = compileUnsafe(query, options, elems);
        if (!Array.isArray(elems))
            elems = getChildren(elems);
        else
            elems = removeSubsets(elems);
        return searchFunc(query, elems);
    };
}
var selectAll = getSelectorFunc(function selectAll(query, elems) {
    return query === falseFunc || !elems || elems.length === 0 ? [] : findAll(query, elems);
});
var selectOne = getSelectorFunc(function selectOne(query, elems) {
    return query === falseFunc || !elems || elems.length === 0 ? null : findOne(query, elems);
});
function is(elem, query, options) {
    return (typeof query === 'function' ? query : compile(query, options))(elem);
}
function CSSselect(query, elems, options) {
    return selectAll(query, elems, options);
}
CSSselect.compile = compile;
CSSselect.filters = Pseudos.filters;
CSSselect.pseudos = Pseudos.pseudos;
CSSselect.selectAll = selectAll;
CSSselect.selectOne = selectOne;
CSSselect.is = is;
CSSselect.parse = compile;
CSSselect.iterate = selectAll;
CSSselect._compileUnsafe = compileUnsafe;
CSSselect._compileToken = compileToken;
},{"24":24,"27":27,"4":4,"42":42}],23:[function(require,module,exports){
var DomUtils = require(42), hasAttrib = DomUtils.hasAttrib, getAttributeValue = DomUtils.getAttributeValue, falseFunc = require(4).falseFunc;
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
var attributeRules = {
    __proto__: null,
    equals: function (next, data) {
        var name = data.name, value = data.value;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function equalsIC(elem) {
                var attr = getAttributeValue(elem, name);
                return attr != null && attr.toLowerCase() === value && next(elem);
            };
        }
        return function equals(elem) {
            return getAttributeValue(elem, name) === value && next(elem);
        };
    },
    hyphen: function (next, data) {
        var name = data.name, value = data.value, len = value.length;
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function hyphenIC(elem) {
                var attr = getAttributeValue(elem, name);
                return attr != null && (attr.length === len || attr.charAt(len) === '-') && attr.substr(0, len).toLowerCase() === value && next(elem);
            };
        }
        return function hyphen(elem) {
            var attr = getAttributeValue(elem, name);
            return attr != null && attr.substr(0, len) === value && (attr.length === len || attr.charAt(len) === '-') && next(elem);
        };
    },
    element: function (next, data) {
        var name = data.name, value = data.value;
        if (/\s/.test(value)) {
            return falseFunc;
        }
        value = value.replace(reChars, '\\$&');
        var pattern = '(?:^|\\s)' + value + '(?:$|\\s)', flags = data.ignoreCase ? 'i' : '', regex = new RegExp(pattern, flags);
        return function element(elem) {
            var attr = getAttributeValue(elem, name);
            return attr != null && regex.test(attr) && next(elem);
        };
    },
    exists: function (next, data) {
        var name = data.name;
        return function exists(elem) {
            return hasAttrib(elem, name) && next(elem);
        };
    },
    start: function (next, data) {
        var name = data.name, value = data.value, len = value.length;
        if (len === 0) {
            return falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function startIC(elem) {
                var attr = getAttributeValue(elem, name);
                return attr != null && attr.substr(0, len).toLowerCase() === value && next(elem);
            };
        }
        return function start(elem) {
            var attr = getAttributeValue(elem, name);
            return attr != null && attr.substr(0, len) === value && next(elem);
        };
    },
    end: function (next, data) {
        var name = data.name, value = data.value, len = -value.length;
        if (len === 0) {
            return falseFunc;
        }
        if (data.ignoreCase) {
            value = value.toLowerCase();
            return function endIC(elem) {
                var attr = getAttributeValue(elem, name);
                return attr != null && attr.substr(len).toLowerCase() === value && next(elem);
            };
        }
        return function end(elem) {
            var attr = getAttributeValue(elem, name);
            return attr != null && attr.substr(len) === value && next(elem);
        };
    },
    any: function (next, data) {
        var name = data.name, value = data.value;
        if (value === '') {
            return falseFunc;
        }
        if (data.ignoreCase) {
            var regex = new RegExp(value.replace(reChars, '\\$&'), 'i');
            return function anyIC(elem) {
                var attr = getAttributeValue(elem, name);
                return attr != null && regex.test(attr) && next(elem);
            };
        }
        return function any(elem) {
            var attr = getAttributeValue(elem, name);
            return attr != null && attr.indexOf(value) >= 0 && next(elem);
        };
    },
    not: function (next, data) {
        var name = data.name, value = data.value;
        if (value === '') {
            return function notEmpty(elem) {
                return !!getAttributeValue(elem, name) && next(elem);
            };
        } else if (data.ignoreCase) {
            value = value.toLowerCase();
            return function notIC(elem) {
                var attr = getAttributeValue(elem, name);
                return attr != null && attr.toLowerCase() !== value && next(elem);
            };
        }
        return function not(elem) {
            return getAttributeValue(elem, name) !== value && next(elem);
        };
    }
};
module.exports = {
    compile: function (next, data, options) {
        if (options && options.strict && (data.ignoreCase || data.action === 'not'))
            throw SyntaxError('Unsupported attribute selector');
        return attributeRules[data.action](next, data);
    },
    rules: attributeRules
};
},{"4":4,"42":42}],24:[function(require,module,exports){
module.exports = compile;
module.exports.compileUnsafe = compileUnsafe;
module.exports.compileToken = compileToken;
var parse = require(29), DomUtils = require(42), isTag = DomUtils.isTag, Rules = require(25), sortRules = require(28), BaseFuncs = require(4), trueFunc = BaseFuncs.trueFunc, falseFunc = BaseFuncs.falseFunc, procedure = require(26);
function compile(selector, options, context) {
    var next = compileUnsafe(selector, options, context);
    return wrap(next);
}
function wrap(next) {
    return function base(elem) {
        return isTag(elem) && next(elem);
    };
}
function compileUnsafe(selector, options, context) {
    var token = parse(selector, options);
    return compileToken(token, options, context);
}
function includesScopePseudo(t) {
    return t.type === 'pseudo' && (t.name === 'scope' || Array.isArray(t.data) && t.data.some(function (data) {
        return data.some(includesScopePseudo);
    }));
}
var DESCENDANT_TOKEN = { type: 'descendant' }, SCOPE_TOKEN = {
        type: 'pseudo',
        name: 'scope'
    }, PLACEHOLDER_ELEMENT = {}, getParent = DomUtils.getParent;
function absolutize(token, context) {
    var hasContext = !!context && !!context.length && context.every(function (e) {
        return e === PLACEHOLDER_ELEMENT || !!getParent(e);
    });
    token.forEach(function (t) {
        if (t.length > 0 && isTraversal(t[0]) && t[0].type !== 'descendant') {
        } else if (hasContext && !includesScopePseudo(t)) {
            t.unshift(DESCENDANT_TOKEN);
        } else {
            return;
        }
        t.unshift(SCOPE_TOKEN);
    });
}
function compileToken(token, options, context) {
    token = token.filter(function (t) {
        return t.length > 0;
    });
    token.forEach(sortRules);
    var isArrayContext = Array.isArray(context);
    context = options && options.context || context;
    if (context && !isArrayContext)
        context = [context];
    absolutize(token, context);
    return token.map(function (rules) {
        return compileRules(rules, options, context, isArrayContext);
    }).reduce(reduceRules, falseFunc);
}
function isTraversal(t) {
    return procedure[t.type] < 0;
}
function compileRules(rules, options, context, isArrayContext) {
    var acceptSelf = isArrayContext && rules[0].name === 'scope' && rules[1].type === 'descendant';
    return rules.reduce(function (func, rule, index) {
        if (func === falseFunc)
            return func;
        return Rules[rule.type](func, rule, options, context, acceptSelf && index === 1);
    }, options && options.rootFunc || trueFunc);
}
function reduceRules(a, b) {
    if (b === falseFunc || a === trueFunc) {
        return a;
    }
    if (a === falseFunc || b === trueFunc) {
        return b;
    }
    return function combine(elem) {
        return a(elem) || b(elem);
    };
}
var Pseudos = require(27), filters = Pseudos.filters, existsOne = DomUtils.existsOne, isTag = DomUtils.isTag, getChildren = DomUtils.getChildren;
function containsTraversal(t) {
    return t.some(isTraversal);
}
filters.not = function (next, token, options, context) {
    var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict)
    };
    if (opts.strict) {
        if (token.length > 1 || token.some(containsTraversal)) {
            throw new SyntaxError('complex selectors in :not aren\'t allowed in strict mode');
        }
    }
    var func = compileToken(token, opts, context);
    if (func === falseFunc)
        return next;
    if (func === trueFunc)
        return falseFunc;
    return function (elem) {
        return !func(elem) && next(elem);
    };
};
filters.has = function (next, token, options) {
    var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict)
    };
    var context = token.some(containsTraversal) ? [PLACEHOLDER_ELEMENT] : null;
    var func = compileToken(token, opts, context);
    if (func === falseFunc)
        return falseFunc;
    if (func === trueFunc)
        return function (elem) {
            return getChildren(elem).some(isTag) && next(elem);
        };
    func = wrap(func);
    if (context) {
        return function has(elem) {
            return next(elem) && (context[0] = elem, existsOne(func, getChildren(elem)));
        };
    }
    return function has(elem) {
        return next(elem) && existsOne(func, getChildren(elem));
    };
};
filters.matches = function (next, token, options, context) {
    var opts = {
        xmlMode: !!(options && options.xmlMode),
        strict: !!(options && options.strict),
        rootFunc: next
    };
    return compileToken(token, opts, context);
};
},{"25":25,"26":26,"27":27,"28":28,"29":29,"4":4,"42":42}],25:[function(require,module,exports){
var DomUtils = require(42), isTag = DomUtils.isTag, getParent = DomUtils.getParent, getChildren = DomUtils.getChildren, getSiblings = DomUtils.getSiblings, getName = DomUtils.getName;
module.exports = {
    __proto__: null,
    attribute: require(23).compile,
    pseudo: require(27).compile,
    tag: function (next, data) {
        var name = data.name;
        return function tag(elem) {
            return getName(elem) === name && next(elem);
        };
    },
    descendant: function (next, rule, options, context, acceptSelf) {
        return function descendant(elem) {
            if (acceptSelf && next(elem))
                return true;
            var found = false;
            while (!found && (elem = getParent(elem))) {
                found = next(elem);
            }
            return found;
        };
    },
    parent: function (next, data, options) {
        if (options && options.strict)
            throw SyntaxError('Parent selector isn\'t part of CSS3');
        return function parent(elem) {
            return getChildren(elem).some(test);
        };
        function test(elem) {
            return isTag(elem) && next(elem);
        }
    },
    child: function (next) {
        return function child(elem) {
            var parent = getParent(elem);
            return !!parent && next(parent);
        };
    },
    sibling: function (next) {
        return function sibling(elem) {
            var siblings = getSiblings(elem);
            for (var i = 0; i < siblings.length; i++) {
                if (isTag(siblings[i])) {
                    if (siblings[i] === elem)
                        break;
                    if (next(siblings[i]))
                        return true;
                }
            }
            return false;
        };
    },
    adjacent: function (next) {
        return function adjacent(elem) {
            var siblings = getSiblings(elem), lastElement;
            for (var i = 0; i < siblings.length; i++) {
                if (isTag(siblings[i])) {
                    if (siblings[i] === elem)
                        break;
                    lastElement = siblings[i];
                }
            }
            return !!lastElement && next(lastElement);
        };
    },
    universal: function (next) {
        return next;
    }
};
},{"23":23,"27":27,"42":42}],26:[function(require,module,exports){
module.exports={
  "universal": 50,
  "tag": 30,
  "attribute": 1,
  "pseudo": 0,
  "descendant": -1,
  "child": -1,
  "parent": -1,
  "sibling": -1,
  "adjacent": -1
}

},{}],27:[function(require,module,exports){
var DomUtils = require(42), isTag = DomUtils.isTag, getText = DomUtils.getText, getParent = DomUtils.getParent, getChildren = DomUtils.getChildren, getSiblings = DomUtils.getSiblings, hasAttrib = DomUtils.hasAttrib, getName = DomUtils.getName, getAttribute = DomUtils.getAttributeValue, getNCheck = require(246), checkAttrib = require(23).rules.equals, BaseFuncs = require(4), trueFunc = BaseFuncs.trueFunc, falseFunc = BaseFuncs.falseFunc;
function getFirstElement(elems) {
    for (var i = 0; elems && i < elems.length; i++) {
        if (isTag(elems[i]))
            return elems[i];
    }
}
function getAttribFunc(name, value) {
    var data = {
        name: name,
        value: value
    };
    return function attribFunc(next) {
        return checkAttrib(next, data);
    };
}
function getChildFunc(next) {
    return function (elem) {
        return !!getParent(elem) && next(elem);
    };
}
var filters = {
    contains: function (next, text) {
        return function contains(elem) {
            return next(elem) && getText(elem).indexOf(text) >= 0;
        };
    },
    icontains: function (next, text) {
        var itext = text.toLowerCase();
        return function icontains(elem) {
            return next(elem) && getText(elem).toLowerCase().indexOf(itext) >= 0;
        };
    },
    'nth-child': function (next, rule) {
        var func = getNCheck(rule);
        if (func === falseFunc)
            return func;
        if (func === trueFunc)
            return getChildFunc(next);
        return function nthChild(elem) {
            var siblings = getSiblings(elem);
            for (var i = 0, pos = 0; i < siblings.length; i++) {
                if (isTag(siblings[i])) {
                    if (siblings[i] === elem)
                        break;
                    else
                        pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    'nth-last-child': function (next, rule) {
        var func = getNCheck(rule);
        if (func === falseFunc)
            return func;
        if (func === trueFunc)
            return getChildFunc(next);
        return function nthLastChild(elem) {
            var siblings = getSiblings(elem);
            for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
                if (isTag(siblings[i])) {
                    if (siblings[i] === elem)
                        break;
                    else
                        pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    'nth-of-type': function (next, rule) {
        var func = getNCheck(rule);
        if (func === falseFunc)
            return func;
        if (func === trueFunc)
            return getChildFunc(next);
        return function nthOfType(elem) {
            var siblings = getSiblings(elem);
            for (var pos = 0, i = 0; i < siblings.length; i++) {
                if (isTag(siblings[i])) {
                    if (siblings[i] === elem)
                        break;
                    if (getName(siblings[i]) === getName(elem))
                        pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    'nth-last-of-type': function (next, rule) {
        var func = getNCheck(rule);
        if (func === falseFunc)
            return func;
        if (func === trueFunc)
            return getChildFunc(next);
        return function nthLastOfType(elem) {
            var siblings = getSiblings(elem);
            for (var pos = 0, i = siblings.length - 1; i >= 0; i--) {
                if (isTag(siblings[i])) {
                    if (siblings[i] === elem)
                        break;
                    if (getName(siblings[i]) === getName(elem))
                        pos++;
                }
            }
            return func(pos) && next(elem);
        };
    },
    root: function (next) {
        return function (elem) {
            return !getParent(elem) && next(elem);
        };
    },
    scope: function (next, rule, options, context) {
        if (!context || context.length === 0) {
            return filters.root(next);
        }
        if (context.length === 1) {
            return function (elem) {
                return context[0] === elem && next(elem);
            };
        }
        return function (elem) {
            return context.indexOf(elem) >= 0 && next(elem);
        };
    },
    checkbox: getAttribFunc('type', 'checkbox'),
    file: getAttribFunc('type', 'file'),
    password: getAttribFunc('type', 'password'),
    radio: getAttribFunc('type', 'radio'),
    reset: getAttribFunc('type', 'reset'),
    image: getAttribFunc('type', 'image'),
    submit: getAttribFunc('type', 'submit')
};
var pseudos = {
    empty: function (elem) {
        return !getChildren(elem).some(function (elem) {
            return isTag(elem) || elem.type === 'text';
        });
    },
    'first-child': function (elem) {
        return getFirstElement(getSiblings(elem)) === elem;
    },
    'last-child': function (elem) {
        var siblings = getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            if (siblings[i] === elem)
                return true;
            if (isTag(siblings[i]))
                break;
        }
        return false;
    },
    'first-of-type': function (elem) {
        var siblings = getSiblings(elem);
        for (var i = 0; i < siblings.length; i++) {
            if (isTag(siblings[i])) {
                if (siblings[i] === elem)
                    return true;
                if (getName(siblings[i]) === getName(elem))
                    break;
            }
        }
        return false;
    },
    'last-of-type': function (elem) {
        var siblings = getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
            if (isTag(siblings[i])) {
                if (siblings[i] === elem)
                    return true;
                if (getName(siblings[i]) === getName(elem))
                    break;
            }
        }
        return false;
    },
    'only-of-type': function (elem) {
        var siblings = getSiblings(elem);
        for (var i = 0, j = siblings.length; i < j; i++) {
            if (isTag(siblings[i])) {
                if (siblings[i] === elem)
                    continue;
                if (getName(siblings[i]) === getName(elem))
                    return false;
            }
        }
        return true;
    },
    'only-child': function (elem) {
        var siblings = getSiblings(elem);
        for (var i = 0; i < siblings.length; i++) {
            if (isTag(siblings[i]) && siblings[i] !== elem)
                return false;
        }
        return true;
    },
    link: function (elem) {
        return hasAttrib(elem, 'href');
    },
    visited: falseFunc,
    selected: function (elem) {
        if (hasAttrib(elem, 'selected'))
            return true;
        else if (getName(elem) !== 'option')
            return false;
        var parent = getParent(elem);
        if (!parent || getName(parent) !== 'select' || hasAttrib(parent, 'multiple'))
            return false;
        var siblings = getChildren(parent), sawElem = false;
        for (var i = 0; i < siblings.length; i++) {
            if (isTag(siblings[i])) {
                if (siblings[i] === elem) {
                    sawElem = true;
                } else if (!sawElem) {
                    return false;
                } else if (hasAttrib(siblings[i], 'selected')) {
                    return false;
                }
            }
        }
        return sawElem;
    },
    disabled: function (elem) {
        return hasAttrib(elem, 'disabled');
    },
    enabled: function (elem) {
        return !hasAttrib(elem, 'disabled');
    },
    checked: function (elem) {
        return hasAttrib(elem, 'checked') || pseudos.selected(elem);
    },
    required: function (elem) {
        return hasAttrib(elem, 'required');
    },
    optional: function (elem) {
        return !hasAttrib(elem, 'required');
    },
    parent: function (elem) {
        return !pseudos.empty(elem);
    },
    header: function (elem) {
        var name = getName(elem);
        return name === 'h1' || name === 'h2' || name === 'h3' || name === 'h4' || name === 'h5' || name === 'h6';
    },
    button: function (elem) {
        var name = getName(elem);
        return name === 'button' || name === 'input' && getAttribute(elem, 'type') === 'button';
    },
    input: function (elem) {
        var name = getName(elem);
        return name === 'input' || name === 'textarea' || name === 'select' || name === 'button';
    },
    text: function (elem) {
        var attr;
        return getName(elem) === 'input' && (!(attr = getAttribute(elem, 'type')) || attr.toLowerCase() === 'text');
    }
};
function verifyArgs(func, name, subselect) {
    if (subselect === null) {
        if (func.length > 1 && name !== 'scope') {
            throw new SyntaxError('pseudo-selector :' + name + ' requires an argument');
        }
    } else {
        if (func.length === 1) {
            throw new SyntaxError('pseudo-selector :' + name + ' doesn\'t have any arguments');
        }
    }
}
var re_CSS3 = /^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;
module.exports = {
    compile: function (next, data, options, context) {
        var name = data.name, subselect = data.data;
        if (options && options.strict && !re_CSS3.test(name)) {
            throw SyntaxError(':' + name + ' isn\'t part of CSS3');
        }
        if (typeof filters[name] === 'function') {
            verifyArgs(filters[name], name, subselect);
            return filters[name](next, subselect, options, context);
        } else if (typeof pseudos[name] === 'function') {
            var func = pseudos[name];
            verifyArgs(func, name, subselect);
            if (next === trueFunc)
                return func;
            return function pseudoArgs(elem) {
                return func(elem, subselect) && next(elem);
            };
        } else {
            throw new SyntaxError('unmatched pseudo-class :' + name);
        }
    },
    filters: filters,
    pseudos: pseudos
};
},{"23":23,"246":246,"4":4,"42":42}],28:[function(require,module,exports){
module.exports = sortByProcedure;
var procedure = require(26);
var attributes = {
    __proto__: null,
    exists: 10,
    equals: 8,
    not: 7,
    start: 6,
    end: 6,
    any: 5,
    hyphen: 4,
    element: 4
};
function sortByProcedure(arr) {
    var procs = arr.map(getProcedure);
    for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
            continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
        }
    }
}
function getProcedure(token) {
    var proc = procedure[token.type];
    if (proc === procedure.attribute) {
        proc = attributes[token.action];
        if (proc === attributes.equals && token.name === 'id') {
            proc = 9;
        }
        if (token.ignoreCase) {
            proc >>= 1;
        }
    } else if (proc === procedure.pseudo) {
        if (!token.data) {
            proc = 3;
        } else if (token.name === 'has' || token.name === 'contains') {
            proc = 0;
        } else if (token.name === 'matches' || token.name === 'not') {
            proc = 0;
            for (var i = 0; i < token.data.length; i++) {
                if (token.data[i].length !== 1)
                    continue;
                var cur = getProcedure(token.data[i][0]);
                if (cur === 0) {
                    proc = 0;
                    break;
                }
                if (cur > proc)
                    proc = cur;
            }
            if (token.data.length > 1 && proc > 0)
                proc -= 1;
        } else {
            proc = 1;
        }
    }
    return proc;
}
},{"26":26}],29:[function(require,module,exports){
'use strict';
module.exports = parse;
var re_name = /^(?:\\.|[\w\-\u00c0-\uFFFF])+/, re_escape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi, re_attr = /^\s*((?:\\.|[\w\u00c0-\uFFFF\-])+)\s*(?:(\S?)=\s*(?:(['"])(.*?)\3|(#?(?:\\.|[\w\u00c0-\uFFFF\-])*)|)|)\s*(i)?\]/;
var actionTypes = {
    __proto__: null,
    'undefined': 'exists',
    '': 'equals',
    '~': 'element',
    '^': 'start',
    '$': 'end',
    '*': 'any',
    '!': 'not',
    '|': 'hyphen'
};
var simpleSelectors = {
    __proto__: null,
    '>': 'child',
    '<': 'parent',
    '~': 'sibling',
    '+': 'adjacent'
};
var attribSelectors = {
    __proto__: null,
    '#': [
        'id',
        'equals'
    ],
    '.': [
        'class',
        'element'
    ]
};
var unpackPseudos = {
    __proto__: null,
    'has': true,
    'not': true,
    'matches': true
};
var stripQuotesFromPseudos = {
    __proto__: null,
    'contains': true,
    'icontains': true
};
var quotes = {
    __proto__: null,
    '"': true,
    '\'': true
};
function funescape(_, escaped, escapedWhitespace) {
    var high = '0x' + escaped - 65536;
    return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
}
function unescapeCSS(str) {
    return str.replace(re_escape, funescape);
}
function isWhitespace(c) {
    return c === ' ' || c === '\n' || c === '\t' || c === '\f' || c === '\r';
}
function parse(selector, options) {
    var subselects = [];
    selector = parseSelector(subselects, selector + '', options);
    if (selector !== '') {
        throw new SyntaxError('Unmatched selector: ' + selector);
    }
    return subselects;
}
function parseSelector(subselects, selector, options) {
    var tokens = [], sawWS = false, data, firstChar, name, quot;
    function getName() {
        var sub = selector.match(re_name)[0];
        selector = selector.substr(sub.length);
        return unescapeCSS(sub);
    }
    function stripWhitespace(start) {
        while (isWhitespace(selector.charAt(start)))
            start++;
        selector = selector.substr(start);
    }
    stripWhitespace(0);
    while (selector !== '') {
        firstChar = selector.charAt(0);
        if (isWhitespace(firstChar)) {
            sawWS = true;
            stripWhitespace(1);
        } else if (firstChar in simpleSelectors) {
            tokens.push({ type: simpleSelectors[firstChar] });
            sawWS = false;
            stripWhitespace(1);
        } else if (firstChar === ',') {
            if (tokens.length === 0) {
                throw new SyntaxError('empty sub-selector');
            }
            subselects.push(tokens);
            tokens = [];
            sawWS = false;
            stripWhitespace(1);
        } else {
            if (sawWS) {
                if (tokens.length > 0) {
                    tokens.push({ type: 'descendant' });
                }
                sawWS = false;
            }
            if (firstChar === '*') {
                selector = selector.substr(1);
                tokens.push({ type: 'universal' });
            } else if (firstChar in attribSelectors) {
                selector = selector.substr(1);
                tokens.push({
                    type: 'attribute',
                    name: attribSelectors[firstChar][0],
                    action: attribSelectors[firstChar][1],
                    value: getName(),
                    ignoreCase: false
                });
            } else if (firstChar === '[') {
                selector = selector.substr(1);
                data = selector.match(re_attr);
                if (!data) {
                    throw new SyntaxError('Malformed attribute selector: ' + selector);
                }
                selector = selector.substr(data[0].length);
                name = unescapeCSS(data[1]);
                if (!options || ('lowerCaseAttributeNames' in options ? options.lowerCaseAttributeNames : !options.xmlMode)) {
                    name = name.toLowerCase();
                }
                tokens.push({
                    type: 'attribute',
                    name: name,
                    action: actionTypes[data[2]],
                    value: unescapeCSS(data[4] || data[5] || ''),
                    ignoreCase: !!data[6]
                });
            } else if (firstChar === ':') {
                if (selector.charAt(1) === ':') {
                    selector = selector.substr(2);
                    tokens.push({
                        type: 'pseudo-element',
                        name: getName().toLowerCase()
                    });
                    continue;
                }
                selector = selector.substr(1);
                name = getName().toLowerCase();
                data = null;
                if (selector.charAt(0) === '(') {
                    if (name in unpackPseudos) {
                        quot = selector.charAt(1);
                        var quoted = quot in quotes;
                        selector = selector.substr(quoted + 1);
                        data = [];
                        selector = parseSelector(data, selector, options);
                        if (quoted) {
                            if (selector.charAt(0) !== quot) {
                                throw new SyntaxError('unmatched quotes in :' + name);
                            } else {
                                selector = selector.substr(1);
                            }
                        }
                        if (selector.charAt(0) !== ')') {
                            throw new SyntaxError('missing closing parenthesis in :' + name + ' ' + selector);
                        }
                        selector = selector.substr(1);
                    } else {
                        var pos = 1, counter = 1;
                        for (; counter > 0 && pos < selector.length; pos++) {
                            if (selector.charAt(pos) === '(')
                                counter++;
                            else if (selector.charAt(pos) === ')')
                                counter--;
                        }
                        if (counter) {
                            throw new SyntaxError('parenthesis not matched');
                        }
                        data = selector.substr(1, pos - 2);
                        selector = selector.substr(pos);
                        if (name in stripQuotesFromPseudos) {
                            quot = data.charAt(0);
                            if (quot === data.slice(-1) && quot in quotes) {
                                data = data.slice(1, -1);
                            }
                            data = unescapeCSS(data);
                        }
                    }
                }
                tokens.push({
                    type: 'pseudo',
                    name: name,
                    data: data
                });
            } else if (re_name.test(selector)) {
                name = getName();
                if (!options || ('lowerCaseTags' in options ? options.lowerCaseTags : !options.xmlMode)) {
                    name = name.toLowerCase();
                }
                tokens.push({
                    type: 'tag',
                    name: name
                });
            } else {
                if (tokens.length && tokens[tokens.length - 1].type === 'descendant') {
                    tokens.pop();
                }
                addToken(subselects, tokens);
                return selector;
            }
        }
    }
    addToken(subselects, tokens);
    return selector;
}
function addToken(subselects, tokens) {
    if (subselects.length > 0 && tokens.length === 0) {
        throw new SyntaxError('empty sub-selector');
    }
    subselects.push(tokens);
}
},{}],30:[function(require,module,exports){
'use strict';
var createThunk = require(32);
function Procedure() {
    this.argTypes = [];
    this.shimArgs = [];
    this.arrayArgs = [];
    this.arrayBlockIndices = [];
    this.scalarArgs = [];
    this.offsetArgs = [];
    this.offsetArgIndex = [];
    this.indexArgs = [];
    this.shapeArgs = [];
    this.funcName = '';
    this.pre = null;
    this.body = null;
    this.post = null;
    this.debug = false;
}
function compileCwise(user_args) {
    var proc = new Procedure();
    proc.pre = user_args.pre;
    proc.body = user_args.body;
    proc.post = user_args.post;
    var proc_args = user_args.args.slice(0);
    proc.argTypes = proc_args;
    for (var i = 0; i < proc_args.length; ++i) {
        var arg_type = proc_args[i];
        if (arg_type === 'array' || typeof arg_type === 'object' && arg_type.blockIndices) {
            proc.argTypes[i] = 'array';
            proc.arrayArgs.push(i);
            proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
            proc.shimArgs.push('array' + i);
            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
                throw new Error('cwise: pre() block may not reference array args');
            }
            if (i < proc.post.args.length && proc.post.args[i].count > 0) {
                throw new Error('cwise: post() block may not reference array args');
            }
        } else if (arg_type === 'scalar') {
            proc.scalarArgs.push(i);
            proc.shimArgs.push('scalar' + i);
        } else if (arg_type === 'index') {
            proc.indexArgs.push(i);
            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) {
                throw new Error('cwise: pre() block may not reference array index');
            }
            if (i < proc.body.args.length && proc.body.args[i].lvalue) {
                throw new Error('cwise: body() block may not write to array index');
            }
            if (i < proc.post.args.length && proc.post.args[i].count > 0) {
                throw new Error('cwise: post() block may not reference array index');
            }
        } else if (arg_type === 'shape') {
            proc.shapeArgs.push(i);
            if (i < proc.pre.args.length && proc.pre.args[i].lvalue) {
                throw new Error('cwise: pre() block may not write to array shape');
            }
            if (i < proc.body.args.length && proc.body.args[i].lvalue) {
                throw new Error('cwise: body() block may not write to array shape');
            }
            if (i < proc.post.args.length && proc.post.args[i].lvalue) {
                throw new Error('cwise: post() block may not write to array shape');
            }
        } else if (typeof arg_type === 'object' && arg_type.offset) {
            proc.argTypes[i] = 'offset';
            proc.offsetArgs.push({
                array: arg_type.array,
                offset: arg_type.offset
            });
            proc.offsetArgIndex.push(i);
        } else {
            throw new Error('cwise: Unknown argument type ' + proc_args[i]);
        }
    }
    if (proc.arrayArgs.length <= 0) {
        throw new Error('cwise: No array arguments specified');
    }
    if (proc.pre.args.length > proc_args.length) {
        throw new Error('cwise: Too many arguments in pre() block');
    }
    if (proc.body.args.length > proc_args.length) {
        throw new Error('cwise: Too many arguments in body() block');
    }
    if (proc.post.args.length > proc_args.length) {
        throw new Error('cwise: Too many arguments in post() block');
    }
    proc.debug = !!user_args.printCode || !!user_args.debug;
    proc.funcName = user_args.funcName || 'cwise';
    proc.blockSize = user_args.blockSize || 64;
    return createThunk(proc);
}
module.exports = compileCwise;
},{"32":32}],31:[function(require,module,exports){
'use strict';
var uniq = require(273);
function innerFill(order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;
    for (i = 0; i < dimension; ++i) {
        vars.push([
            'i',
            i,
            '=0'
        ].join(''));
    }
    for (j = 0; j < nargs; ++j) {
        for (i = 0; i < dimension; ++i) {
            pidx = idx;
            idx = order[i];
            if (i === 0) {
                vars.push([
                    'd',
                    j,
                    's',
                    i,
                    '=t',
                    j,
                    'p',
                    idx
                ].join(''));
            } else {
                vars.push([
                    'd',
                    j,
                    's',
                    i,
                    '=(t',
                    j,
                    'p',
                    idx,
                    '-s',
                    pidx,
                    '*t',
                    j,
                    'p',
                    pidx,
                    ')'
                ].join(''));
            }
        }
    }
    code.push('var ' + vars.join(','));
    for (i = dimension - 1; i >= 0; --i) {
        idx = order[i];
        code.push([
            'for(i',
            i,
            '=0;i',
            i,
            '<s',
            idx,
            ';++i',
            i,
            '){'
        ].join(''));
    }
    code.push(body);
    for (i = 0; i < dimension; ++i) {
        pidx = idx;
        idx = order[i];
        for (j = 0; j < nargs; ++j) {
            code.push([
                'p',
                j,
                '+=d',
                j,
                's',
                i
            ].join(''));
        }
        if (has_index) {
            if (i > 0) {
                code.push([
                    'index[',
                    pidx,
                    ']-=s',
                    pidx
                ].join(''));
            }
            code.push([
                '++index[',
                idx,
                ']'
            ].join(''));
        }
        code.push('}');
    }
    return code.join('\n');
}
function outerFill(matched, order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];
    for (var i = 0; i < nargs; ++i) {
        code.push([
            'var offset',
            i,
            '=p',
            i
        ].join(''));
    }
    for (var i = matched; i < dimension; ++i) {
        code.push([
            'for(var j' + i + '=SS[',
            order[i],
            ']|0;j',
            i,
            '>0;){'
        ].join(''));
        code.push([
            'if(j',
            i,
            '<',
            blockSize,
            '){'
        ].join(''));
        code.push([
            's',
            order[i],
            '=j',
            i
        ].join(''));
        code.push([
            'j',
            i,
            '=0'
        ].join(''));
        code.push([
            '}else{s',
            order[i],
            '=',
            blockSize
        ].join(''));
        code.push([
            'j',
            i,
            '-=',
            blockSize,
            '}'
        ].join(''));
        if (has_index) {
            code.push([
                'index[',
                order[i],
                ']=j',
                i
            ].join(''));
        }
    }
    for (var i = 0; i < nargs; ++i) {
        var indexStr = ['offset' + i];
        for (var j = matched; j < dimension; ++j) {
            indexStr.push([
                'j',
                j,
                '*t',
                i,
                'p',
                order[j]
            ].join(''));
        }
        code.push([
            'p',
            i,
            '=(',
            indexStr.join('+'),
            ')'
        ].join(''));
    }
    code.push(innerFill(order, proc, body));
    for (var i = matched; i < dimension; ++i) {
        code.push('}');
    }
    return code.join('\n');
}
function countMatches(orders) {
    var matched = 0, dimension = orders[0].length;
    while (matched < dimension) {
        for (var j = 1; j < orders.length; ++j) {
            if (orders[j][matched] !== orders[0][matched]) {
                return matched;
            }
        }
        ++matched;
    }
    return matched;
}
function processBlock(block, proc, dtypes) {
    var code = block.body;
    var pre = [];
    var post = [];
    for (var i = 0; i < block.args.length; ++i) {
        var carg = block.args[i];
        if (carg.count <= 0) {
            continue;
        }
        var re = new RegExp(carg.name, 'g');
        var ptrStr = '';
        var arrNum = proc.arrayArgs.indexOf(i);
        switch (proc.argTypes[i]) {
        case 'offset':
            var offArgIndex = proc.offsetArgIndex.indexOf(i);
            var offArg = proc.offsetArgs[offArgIndex];
            arrNum = offArg.array;
            ptrStr = '+q' + offArgIndex;
        case 'array':
            ptrStr = 'p' + arrNum + ptrStr;
            var localStr = 'l' + i;
            var arrStr = 'a' + arrNum;
            if (proc.arrayBlockIndices[arrNum] === 0) {
                if (carg.count === 1) {
                    if (dtypes[arrNum] === 'generic') {
                        if (carg.lvalue) {
                            pre.push([
                                'var ',
                                localStr,
                                '=',
                                arrStr,
                                '.get(',
                                ptrStr,
                                ')'
                            ].join(''));
                            code = code.replace(re, localStr);
                            post.push([
                                arrStr,
                                '.set(',
                                ptrStr,
                                ',',
                                localStr,
                                ')'
                            ].join(''));
                        } else {
                            code = code.replace(re, [
                                arrStr,
                                '.get(',
                                ptrStr,
                                ')'
                            ].join(''));
                        }
                    } else {
                        code = code.replace(re, [
                            arrStr,
                            '[',
                            ptrStr,
                            ']'
                        ].join(''));
                    }
                } else if (dtypes[arrNum] === 'generic') {
                    pre.push([
                        'var ',
                        localStr,
                        '=',
                        arrStr,
                        '.get(',
                        ptrStr,
                        ')'
                    ].join(''));
                    code = code.replace(re, localStr);
                    if (carg.lvalue) {
                        post.push([
                            arrStr,
                            '.set(',
                            ptrStr,
                            ',',
                            localStr,
                            ')'
                        ].join(''));
                    }
                } else {
                    pre.push([
                        'var ',
                        localStr,
                        '=',
                        arrStr,
                        '[',
                        ptrStr,
                        ']'
                    ].join(''));
                    code = code.replace(re, localStr);
                    if (carg.lvalue) {
                        post.push([
                            arrStr,
                            '[',
                            ptrStr,
                            ']=',
                            localStr
                        ].join(''));
                    }
                }
            } else {
                var reStrArr = [carg.name], ptrStrArr = [ptrStr];
                for (var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
                    reStrArr.push('\\s*\\[([^\\]]+)\\]');
                    ptrStrArr.push('$' + (j + 1) + '*t' + arrNum + 'b' + j);
                }
                re = new RegExp(reStrArr.join(''), 'g');
                ptrStr = ptrStrArr.join('+');
                if (dtypes[arrNum] === 'generic') {
                    throw new Error('cwise: Generic arrays not supported in combination with blocks!');
                } else {
                    code = code.replace(re, [
                        arrStr,
                        '[',
                        ptrStr,
                        ']'
                    ].join(''));
                }
            }
            break;
        case 'scalar':
            code = code.replace(re, 'Y' + proc.scalarArgs.indexOf(i));
            break;
        case 'index':
            code = code.replace(re, 'index');
            break;
        case 'shape':
            code = code.replace(re, 'shape');
            break;
        }
    }
    return [
        pre.join('\n'),
        code,
        post.join('\n')
    ].join('\n').trim();
}
function typeSummary(dtypes) {
    var summary = new Array(dtypes.length);
    var allEqual = true;
    for (var i = 0; i < dtypes.length; ++i) {
        var t = dtypes[i];
        var digits = t.match(/\d+/);
        if (!digits) {
            digits = '';
        } else {
            digits = digits[0];
        }
        if (t.charAt(0) === 0) {
            summary[i] = 'u' + t.charAt(1) + digits;
        } else {
            summary[i] = t.charAt(0) + digits;
        }
        if (i > 0) {
            allEqual = allEqual && summary[i] === summary[i - 1];
        }
    }
    if (allEqual) {
        return summary[0];
    }
    return summary.join('');
}
function generateCWiseOp(proc, typesig) {
    var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
    var orders = new Array(proc.arrayArgs.length);
    var dtypes = new Array(proc.arrayArgs.length);
    for (var i = 0; i < proc.arrayArgs.length; ++i) {
        dtypes[i] = typesig[2 * i];
        orders[i] = typesig[2 * i + 1];
    }
    var blockBegin = [], blockEnd = [];
    var loopBegin = [], loopEnd = [];
    var loopOrders = [];
    for (var i = 0; i < proc.arrayArgs.length; ++i) {
        if (proc.arrayBlockIndices[i] < 0) {
            loopBegin.push(0);
            loopEnd.push(dimension);
            blockBegin.push(dimension);
            blockEnd.push(dimension + proc.arrayBlockIndices[i]);
        } else {
            loopBegin.push(proc.arrayBlockIndices[i]);
            loopEnd.push(proc.arrayBlockIndices[i] + dimension);
            blockBegin.push(0);
            blockEnd.push(proc.arrayBlockIndices[i]);
        }
        var newOrder = [];
        for (var j = 0; j < orders[i].length; j++) {
            if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) {
                newOrder.push(orders[i][j] - loopBegin[i]);
            }
        }
        loopOrders.push(newOrder);
    }
    var arglist = ['SS'];
    var code = ['\'use strict\''];
    var vars = [];
    for (var j = 0; j < dimension; ++j) {
        vars.push([
            's',
            j,
            '=SS[',
            j,
            ']'
        ].join(''));
    }
    for (var i = 0; i < proc.arrayArgs.length; ++i) {
        arglist.push('a' + i);
        arglist.push('t' + i);
        arglist.push('p' + i);
        for (var j = 0; j < dimension; ++j) {
            vars.push([
                't',
                i,
                'p',
                j,
                '=t',
                i,
                '[',
                loopBegin[i] + j,
                ']'
            ].join(''));
        }
        for (var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j) {
            vars.push([
                't',
                i,
                'b',
                j,
                '=t',
                i,
                '[',
                blockBegin[i] + j,
                ']'
            ].join(''));
        }
    }
    for (var i = 0; i < proc.scalarArgs.length; ++i) {
        arglist.push('Y' + i);
    }
    if (proc.shapeArgs.length > 0) {
        vars.push('shape=SS.slice(0)');
    }
    if (proc.indexArgs.length > 0) {
        var zeros = new Array(dimension);
        for (var i = 0; i < dimension; ++i) {
            zeros[i] = '0';
        }
        vars.push([
            'index=[',
            zeros.join(','),
            ']'
        ].join(''));
    }
    for (var i = 0; i < proc.offsetArgs.length; ++i) {
        var off_arg = proc.offsetArgs[i];
        var init_string = [];
        for (var j = 0; j < off_arg.offset.length; ++j) {
            if (off_arg.offset[j] === 0) {
                continue;
            } else if (off_arg.offset[j] === 1) {
                init_string.push([
                    't',
                    off_arg.array,
                    'p',
                    j
                ].join(''));
            } else {
                init_string.push([
                    off_arg.offset[j],
                    '*t',
                    off_arg.array,
                    'p',
                    j
                ].join(''));
            }
        }
        if (init_string.length === 0) {
            vars.push('q' + i + '=0');
        } else {
            vars.push([
                'q',
                i,
                '=',
                init_string.join('+')
            ].join(''));
        }
    }
    var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
    vars = vars.concat(thisVars);
    code.push('var ' + vars.join(','));
    for (var i = 0; i < proc.arrayArgs.length; ++i) {
        code.push('p' + i + '|=0');
    }
    if (proc.pre.body.length > 3) {
        code.push(processBlock(proc.pre, proc, dtypes));
    }
    var body = processBlock(proc.body, proc, dtypes);
    var matched = countMatches(loopOrders);
    if (matched < dimension) {
        code.push(outerFill(matched, loopOrders[0], proc, body));
    } else {
        code.push(innerFill(loopOrders[0], proc, body));
    }
    if (proc.post.body.length > 3) {
        code.push(processBlock(proc.post, proc, dtypes));
    }
    if (proc.debug) {
        console.log('-----Generated cwise routine for ', typesig, ':\n' + code.join('\n') + '\n----------');
    }
    var loopName = [
        proc.funcName || 'unnamed',
        '_cwise_loop_',
        orders[0].join('s'),
        'm',
        matched,
        typeSummary(dtypes)
    ].join('');
    var f = new Function([
        'function ',
        loopName,
        '(',
        arglist.join(','),
        '){',
        code.join('\n'),
        '} return ',
        loopName
    ].join(''));
    return f();
}
module.exports = generateCWiseOp;
},{"273":273}],32:[function(require,module,exports){
'use strict';
var compile = require(31);
function createThunk(proc) {
    var code = [
        '\'use strict\'',
        'var CACHED={}'
    ];
    var vars = [];
    var thunkName = proc.funcName + '_cwise_thunk';
    code.push([
        'return function ',
        thunkName,
        '(',
        proc.shimArgs.join(','),
        '){'
    ].join(''));
    var typesig = [];
    var string_typesig = [];
    var proc_args = [[
            'array',
            proc.arrayArgs[0],
            '.shape.slice(',
            Math.max(0, proc.arrayBlockIndices[0]),
            proc.arrayBlockIndices[0] < 0 ? ',' + proc.arrayBlockIndices[0] + ')' : ')'
        ].join('')];
    var shapeLengthConditions = [], shapeConditions = [];
    for (var i = 0; i < proc.arrayArgs.length; ++i) {
        var j = proc.arrayArgs[i];
        vars.push([
            't',
            j,
            '=array',
            j,
            '.dtype,',
            'r',
            j,
            '=array',
            j,
            '.order'
        ].join(''));
        typesig.push('t' + j);
        typesig.push('r' + j);
        string_typesig.push('t' + j);
        string_typesig.push('r' + j + '.join()');
        proc_args.push('array' + j + '.data');
        proc_args.push('array' + j + '.stride');
        proc_args.push('array' + j + '.offset|0');
        if (i > 0) {
            shapeLengthConditions.push('array' + proc.arrayArgs[0] + '.shape.length===array' + j + '.shape.length+' + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
            shapeConditions.push('array' + proc.arrayArgs[0] + '.shape[shapeIndex+' + Math.max(0, proc.arrayBlockIndices[0]) + ']===array' + j + '.shape[shapeIndex+' + Math.max(0, proc.arrayBlockIndices[i]) + ']');
        }
    }
    if (proc.arrayArgs.length > 1) {
        code.push('if (!(' + shapeLengthConditions.join(' && ') + ')) throw new Error(\'cwise: Arrays do not all have the same dimensionality!\')');
        code.push('for(var shapeIndex=array' + proc.arrayArgs[0] + '.shape.length-' + Math.abs(proc.arrayBlockIndices[0]) + '; shapeIndex-->0;) {');
        code.push('if (!(' + shapeConditions.join(' && ') + ')) throw new Error(\'cwise: Arrays do not all have the same shape!\')');
        code.push('}');
    }
    for (var i = 0; i < proc.scalarArgs.length; ++i) {
        proc_args.push('scalar' + proc.scalarArgs[i]);
    }
    vars.push([
        'type=[',
        string_typesig.join(','),
        '].join()'
    ].join(''));
    vars.push('proc=CACHED[type]');
    code.push('var ' + vars.join(','));
    code.push([
        'if(!proc){',
        'CACHED[type]=proc=compile([',
        typesig.join(','),
        '])}',
        'return proc(',
        proc_args.join(','),
        ')}'
    ].join(''));
    if (proc.debug) {
        console.log('-----Generated thunk:\n' + code.join('\n') + '\n----------');
    }
    var thunk = new Function('compile', code.join('\n'));
    return thunk(compile.bind(undefined, proc));
}
module.exports = createThunk;
},{"31":31}],33:[function(require,module,exports){
module.exports = require(30);
},{"30":30}],34:[function(require,module,exports){
!function () {
    var d3 = { version: '3.5.17' };
    var d3_arraySlice = [].slice, d3_array = function (list) {
            return d3_arraySlice.call(list);
        };
    var d3_document = this.document;
    function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
    }
    function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
    }
    if (d3_document) {
        try {
            d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        } catch (e) {
            d3_array = function (list) {
                var i = list.length, array = new Array(i);
                while (i--)
                    array[i] = list[i];
                return array;
            };
        }
    }
    if (!Date.now)
        Date.now = function () {
            return +new Date();
        };
    if (d3_document) {
        try {
            d3_document.createElement('DIV').style.setProperty('opacity', 0, '');
        } catch (error) {
            var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function (name, value) {
                d3_element_setAttribute.call(this, name, value + '');
            };
            d3_element_prototype.setAttributeNS = function (space, local, value) {
                d3_element_setAttributeNS.call(this, space, local, value + '');
            };
            d3_style_prototype.setProperty = function (name, value, priority) {
                d3_style_setProperty.call(this, name, value + '', priority);
            };
        }
    }
    d3.ascending = d3_ascending;
    function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    d3.descending = function (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    };
    d3.min = function (array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null && a > b)
                    a = b;
        } else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && a > b)
                    a = b;
        }
        return a;
    };
    d3.max = function (array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null && b > a)
                    a = b;
        } else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b > a)
                    a = b;
        }
        return a;
    };
    d3.extent = function (array, f) {
        var i = -1, n = array.length, a, b, c;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = c = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null) {
                    if (a > b)
                        a = b;
                    if (c < b)
                        c = b;
                }
        } else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = c = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null) {
                    if (a > b)
                        a = b;
                    if (c < b)
                        c = b;
                }
        }
        return [
            a,
            c
        ];
    };
    function d3_number(x) {
        return x === null ? NaN : +x;
    }
    function d3_numeric(x) {
        return !isNaN(x);
    }
    d3.sum = function (array, f) {
        var s = 0, n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = +array[i]))
                    s += a;
        } else {
            while (++i < n)
                if (d3_numeric(a = +f.call(array, array[i], i)))
                    s += a;
        }
        return s;
    };
    d3.mean = function (array, f) {
        var s = 0, n = array.length, a, i = -1, j = n;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = d3_number(array[i])))
                    s += a;
                else
                    --j;
        } else {
            while (++i < n)
                if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
                    s += a;
                else
                    --j;
        }
        if (j)
            return s / j;
    };
    d3.quantile = function (values, p) {
        var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
        return e ? v + e * (values[h] - v) : v;
    };
    d3.median = function (array, f) {
        var numbers = [], n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = d3_number(array[i])))
                    numbers.push(a);
        } else {
            while (++i < n)
                if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
                    numbers.push(a);
        }
        if (numbers.length)
            return d3.quantile(numbers.sort(d3_ascending), 0.5);
    };
    d3.variance = function (array, f) {
        var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
        if (arguments.length === 1) {
            while (++i < n) {
                if (d3_numeric(a = d3_number(array[i]))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        } else {
            while (++i < n) {
                if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        }
        if (j > 1)
            return s / (j - 1);
    };
    d3.deviation = function () {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
    };
    function d3_bisector(compare) {
        return {
            left: function (a, x, lo, hi) {
                if (arguments.length < 3)
                    lo = 0;
                if (arguments.length < 4)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0)
                        lo = mid + 1;
                    else
                        hi = mid;
                }
                return lo;
            },
            right: function (a, x, lo, hi) {
                if (arguments.length < 3)
                    lo = 0;
                if (arguments.length < 4)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0)
                        hi = mid;
                    else
                        lo = mid + 1;
                }
                return lo;
            }
        };
    }
    var d3_bisect = d3_bisector(d3_ascending);
    d3.bisectLeft = d3_bisect.left;
    d3.bisect = d3.bisectRight = d3_bisect.right;
    d3.bisector = function (f) {
        return d3_bisector(f.length === 1 ? function (d, x) {
            return d3_ascending(f(d), x);
        } : f);
    };
    d3.shuffle = function (array, i0, i1) {
        if ((m = arguments.length) < 3) {
            i1 = array.length;
            if (m < 2)
                i0 = 0;
        }
        var m = i1 - i0, t, i;
        while (m) {
            i = Math.random() * m-- | 0;
            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
    };
    d3.permute = function (array, indexes) {
        var i = indexes.length, permutes = new Array(i);
        while (i--)
            permutes[i] = array[indexes[i]];
        return permutes;
    };
    d3.pairs = function (array) {
        var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
        while (i < n)
            pairs[i] = [
                p0 = p1,
                p1 = array[++i]
            ];
        return pairs;
    };
    d3.transpose = function (matrix) {
        if (!(n = matrix.length))
            return [];
        for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m;) {
            for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
                row[j] = matrix[j][i];
            }
        }
        return transpose;
    };
    function d3_transposeLength(d) {
        return d.length;
    }
    d3.zip = function () {
        return d3.transpose(arguments);
    };
    d3.keys = function (map) {
        var keys = [];
        for (var key in map)
            keys.push(key);
        return keys;
    };
    d3.values = function (map) {
        var values = [];
        for (var key in map)
            values.push(map[key]);
        return values;
    };
    d3.entries = function (map) {
        var entries = [];
        for (var key in map)
            entries.push({
                key: key,
                value: map[key]
            });
        return entries;
    };
    d3.merge = function (arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while (++i < n)
            j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
                merged[--j] = array[m];
            }
        }
        return merged;
    };
    var abs = Math.abs;
    d3.range = function (start, stop, step) {
        if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
                stop = start;
                start = 0;
            }
        }
        if ((stop - start) / step === Infinity)
            throw new Error('infinite range');
        var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
        start *= k, stop *= k, step *= k;
        if (step < 0)
            while ((j = start + step * ++i) > stop)
                range.push(j / k);
        else
            while ((j = start + step * ++i) < stop)
                range.push(j / k);
        return range;
    };
    function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1)
            k *= 10;
        return k;
    }
    function d3_class(ctor, properties) {
        for (var key in properties) {
            Object.defineProperty(ctor.prototype, key, {
                value: properties[key],
                enumerable: false
            });
        }
    }
    d3.map = function (object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
            object.forEach(function (key, value) {
                map.set(key, value);
            });
        } else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (arguments.length === 1)
                while (++i < n)
                    map.set(i, object[i]);
            else
                while (++i < n)
                    map.set(f.call(object, o = object[i], i), o);
        } else {
            for (var key in object)
                map.set(key, object[key]);
        }
        return map;
    };
    function d3_Map() {
        this._ = Object.create(null);
    }
    var d3_map_proto = '__proto__', d3_map_zero = '\0';
    d3_class(d3_Map, {
        has: d3_map_has,
        get: function (key) {
            return this._[d3_map_escape(key)];
        },
        set: function (key, value) {
            return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function () {
            var values = [];
            for (var key in this._)
                values.push(this._[key]);
            return values;
        },
        entries: function () {
            var entries = [];
            for (var key in this._)
                entries.push({
                    key: d3_map_unescape(key),
                    value: this._[key]
                });
            return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
            for (var key in this._)
                f.call(this, d3_map_unescape(key), this._[key]);
        }
    });
    function d3_map_escape(key) {
        return (key += '') === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
    }
    function d3_map_unescape(key) {
        return (key += '')[0] === d3_map_zero ? key.slice(1) : key;
    }
    function d3_map_has(key) {
        return d3_map_escape(key) in this._;
    }
    function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
    }
    function d3_map_keys() {
        var keys = [];
        for (var key in this._)
            keys.push(d3_map_unescape(key));
        return keys;
    }
    function d3_map_size() {
        var size = 0;
        for (var key in this._)
            ++size;
        return size;
    }
    function d3_map_empty() {
        for (var key in this._)
            return false;
        return true;
    }
    d3.nest = function () {
        var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
        function map(mapType, array, depth) {
            if (depth >= keys.length)
                return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
                if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                    values.push(object);
                } else {
                    valuesByKey.set(keyValue, [object]);
                }
            }
            if (mapType) {
                object = mapType();
                setter = function (keyValue, values) {
                    object.set(keyValue, map(mapType, values, depth));
                };
            } else {
                object = {};
                setter = function (keyValue, values) {
                    object[keyValue] = map(mapType, values, depth);
                };
            }
            valuesByKey.forEach(setter);
            return object;
        }
        function entries(map, depth) {
            if (depth >= keys.length)
                return map;
            var array = [], sortKey = sortKeys[depth++];
            map.forEach(function (key, keyMap) {
                array.push({
                    key: key,
                    values: entries(keyMap, depth)
                });
            });
            return sortKey ? array.sort(function (a, b) {
                return sortKey(a.key, b.key);
            }) : array;
        }
        nest.map = function (array, mapType) {
            return map(mapType, array, 0);
        };
        nest.entries = function (array) {
            return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function (d) {
            keys.push(d);
            return nest;
        };
        nest.sortKeys = function (order) {
            sortKeys[keys.length - 1] = order;
            return nest;
        };
        nest.sortValues = function (order) {
            sortValues = order;
            return nest;
        };
        nest.rollup = function (f) {
            rollup = f;
            return nest;
        };
        return nest;
    };
    d3.set = function (array) {
        var set = new d3_Set();
        if (array)
            for (var i = 0, n = array.length; i < n; ++i)
                set.add(array[i]);
        return set;
    };
    function d3_Set() {
        this._ = Object.create(null);
    }
    d3_class(d3_Set, {
        has: d3_map_has,
        add: function (key) {
            this._[d3_map_escape(key += '')] = true;
            return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
            for (var key in this._)
                f.call(this, d3_map_unescape(key));
        }
    });
    d3.behavior = {};
    function d3_identity(d) {
        return d;
    }
    d3.rebind = function (target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n)
            target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
    };
    function d3_rebind(target, source, method) {
        return function () {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }
    function d3_vendorSymbol(object, name) {
        if (name in object)
            return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object)
                return prefixName;
        }
    }
    var d3_vendorPrefixes = [
        'webkit',
        'ms',
        'moz',
        'Moz',
        'o',
        'O'
    ];
    function d3_noop() {
    }
    d3.dispatch = function () {
        var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
        while (++i < n)
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
    };
    function d3_dispatch() {
    }
    d3_dispatch.prototype.on = function (type, listener) {
        var i = type.indexOf('.'), name = '';
        if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
        }
        if (type)
            return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
            if (listener == null)
                for (type in this) {
                    if (this.hasOwnProperty(type))
                        this[type].on(name, null);
                }
            return this;
        }
    };
    function d3_dispatch_event(dispatch) {
        var listeners = [], listenerByName = new d3_Map();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n)
                if (l = z[i].on)
                    l.apply(this, arguments);
            return dispatch;
        }
        event.on = function (name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2)
                return l && l.on;
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener)
                listeners.push(listenerByName.set(name, { on: listener }));
            return dispatch;
        };
        return event;
    }
    d3.event = null;
    function d3_eventPreventDefault() {
        d3.event.preventDefault();
    }
    function d3_eventSource() {
        var e = d3.event, s;
        while (s = e.sourceEvent)
            e = s;
        return e;
    }
    function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
        while (++i < n)
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function (thiz, argumentz) {
            return function (e1) {
                try {
                    var e0 = e1.sourceEvent = d3.event;
                    e1.target = target;
                    d3.event = e1;
                    dispatch[e1.type].apply(thiz, argumentz);
                } finally {
                    d3.event = e0;
                }
            };
        };
        return dispatch;
    }
    d3.requote = function (s) {
        return s.replace(d3_requote_re, '\\$&');
    };
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var d3_subclass = {}.__proto__ ? function (object, prototype) {
        object.__proto__ = prototype;
    } : function (object, prototype) {
        for (var property in prototype)
            object[property] = prototype[property];
    };
    function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
    }
    var d3_select = function (s, n) {
            return n.querySelector(s);
        }, d3_selectAll = function (s, n) {
            return n.querySelectorAll(s);
        }, d3_selectMatches = function (n, s) {
            var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, 'matchesSelector')];
            d3_selectMatches = function (n, s) {
                return d3_selectMatcher.call(n, s);
            };
            return d3_selectMatches(n, s);
        };
    if (typeof Sizzle === 'function') {
        d3_select = function (s, n) {
            return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
    }
    d3.selection = function () {
        return d3.select(d3_document.documentElement);
    };
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function (selector) {
        var subgroups = [], subgroup, subnode, group, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                    if (subnode && '__data__' in node)
                        subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selector(selector) {
        return typeof selector === 'function' ? selector : function () {
            return d3_select(selector, this);
        };
    }
    d3_selectionPrototype.selectAll = function (selector) {
        var subgroups = [], subgroup, node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                    subgroup.parentNode = node;
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selectorAll(selector) {
        return typeof selector === 'function' ? selector : function () {
            return d3_selectAll(selector, this);
        };
    }
    var d3_nsXhtml = 'http://www.w3.org/1999/xhtml';
    var d3_nsPrefix = {
        svg: 'http://www.w3.org/2000/svg',
        xhtml: d3_nsXhtml,
        xlink: 'http://www.w3.org/1999/xlink',
        xml: 'http://www.w3.org/XML/1998/namespace',
        xmlns: 'http://www.w3.org/2000/xmlns/'
    };
    d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function (name) {
            var i = name.indexOf(':'), prefix = name;
            if (i >= 0 && (prefix = name.slice(0, i)) !== 'xmlns')
                name = name.slice(i + 1);
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
                space: d3_nsPrefix[prefix],
                local: name
            } : name;
        }
    };
    d3_selectionPrototype.attr = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === 'string') {
                var node = this.node();
                name = d3.ns.qualify(name);
                return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name)
                this.each(d3_selection_attr(value, name[value]));
            return this;
        }
        return this.each(d3_selection_attr(name, value));
    };
    function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
            this.setAttribute(name, value);
        }
        function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.removeAttribute(name);
            else
                this.setAttribute(name, x);
        }
        function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.removeAttributeNS(name.space, name.local);
            else
                this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === 'function' ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
    }
    function d3_collapse(s) {
        return s.trim().replace(/\s+/g, ' ');
    }
    d3_selectionPrototype.classed = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === 'string') {
                var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
                if (value = node.classList) {
                    while (++i < n)
                        if (!value.contains(name[i]))
                            return false;
                } else {
                    value = node.getAttribute('class');
                    while (++i < n)
                        if (!d3_selection_classedRe(name[i]).test(value))
                            return false;
                }
                return true;
            }
            for (value in name)
                this.each(d3_selection_classed(value, name[value]));
            return this;
        }
        return this.each(d3_selection_classed(name, value));
    };
    function d3_selection_classedRe(name) {
        return new RegExp('(?:^|\\s+)' + d3.requote(name) + '(?:\\s+|$)', 'g');
    }
    function d3_selection_classes(name) {
        return (name + '').trim().split(/^|\s+/);
    }
    function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
            var i = -1;
            while (++i < n)
                name[i](this, value);
        }
        function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while (++i < n)
                name[i](this, x);
        }
        return typeof value === 'function' ? classedFunction : classedConstant;
    }
    function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function (node, value) {
            if (c = node.classList)
                return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute('class') || '';
            if (value) {
                re.lastIndex = 0;
                if (!re.test(c))
                    node.setAttribute('class', d3_collapse(c + ' ' + name));
            } else {
                node.setAttribute('class', d3_collapse(c.replace(re, ' ')));
            }
        };
    }
    d3_selectionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== 'string') {
                if (n < 2)
                    value = '';
                for (priority in name)
                    this.each(d3_selection_style(priority, name[priority], value));
                return this;
            }
            if (n < 2) {
                var node = this.node();
                return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = '';
        }
        return this.each(d3_selection_style(name, value, priority));
    };
    function d3_selection_style(name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleConstant() {
            this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.style.removeProperty(name);
            else
                this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === 'function' ? styleFunction : styleConstant;
    }
    d3_selectionPrototype.property = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === 'string')
                return this.node()[name];
            for (value in name)
                this.each(d3_selection_property(value, name[value]));
            return this;
        }
        return this.each(d3_selection_property(name, value));
    };
    function d3_selection_property(name, value) {
        function propertyNull() {
            delete this[name];
        }
        function propertyConstant() {
            this[name] = value;
        }
        function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                delete this[name];
            else
                this[name] = x;
        }
        return value == null ? propertyNull : typeof value === 'function' ? propertyFunction : propertyConstant;
    }
    d3_selectionPrototype.text = function (value) {
        return arguments.length ? this.each(typeof value === 'function' ? function () {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? '' : v;
        } : value == null ? function () {
            this.textContent = '';
        } : function () {
            this.textContent = value;
        }) : this.node().textContent;
    };
    d3_selectionPrototype.html = function (value) {
        return arguments.length ? this.each(typeof value === 'function' ? function () {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? '' : v;
        } : value == null ? function () {
            this.innerHTML = '';
        } : function () {
            this.innerHTML = value;
        }) : this.node().innerHTML;
    };
    d3_selectionPrototype.append = function (name) {
        name = d3_selection_creator(name);
        return this.select(function () {
            return this.appendChild(name.apply(this, arguments));
        });
    };
    function d3_selection_creator(name) {
        function create() {
            var document = this.ownerDocument, namespace = this.namespaceURI;
            return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
        }
        function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === 'function' ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
    }
    d3_selectionPrototype.insert = function (name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function () {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
    };
    d3_selectionPrototype.remove = function () {
        return this.each(d3_selectionRemove);
    };
    function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent)
            parent.removeChild(this);
    }
    d3_selectionPrototype.data = function (value, key) {
        var i = -1, n = this.length, group, node;
        if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
                if (node = group[i]) {
                    value[i] = node.__data__;
                }
            }
            return value;
        }
        function bind(group, groupData) {
            var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
            if (key) {
                var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
                for (i = -1; ++i < n;) {
                    if (node = group[i]) {
                        if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
                            exitNodes[i] = node;
                        } else {
                            nodeByKeyValue.set(keyValue, node);
                        }
                        keyValues[i] = keyValue;
                    }
                }
                for (i = -1; ++i < m;) {
                    if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    } else if (node !== true) {
                        updateNodes[i] = node;
                        node.__data__ = nodeData;
                    }
                    nodeByKeyValue.set(keyValue, true);
                }
                for (i = -1; ++i < n;) {
                    if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
                        exitNodes[i] = group[i];
                    }
                }
            } else {
                for (i = -1; ++i < n0;) {
                    node = group[i];
                    nodeData = groupData[i];
                    if (node) {
                        node.__data__ = nodeData;
                        updateNodes[i] = node;
                    } else {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                }
                for (; i < m; ++i) {
                    enterNodes[i] = d3_selection_dataNode(groupData[i]);
                }
                for (; i < n; ++i) {
                    exitNodes[i] = group[i];
                }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
        if (typeof value === 'function') {
            while (++i < n) {
                bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
        } else {
            while (++i < n) {
                bind(group = this[i], value);
            }
        }
        update.enter = function () {
            return enter;
        };
        update.exit = function () {
            return exit;
        };
        return update;
    };
    function d3_selection_dataNode(data) {
        return { __data__: data };
    }
    d3_selectionPrototype.datum = function (value) {
        return arguments.length ? this.property('__data__', value) : this.property('__data__');
    };
    d3_selectionPrototype.filter = function (filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== 'function')
            filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_filter(selector) {
        return function () {
            return d3_selectMatches(this, selector);
        };
    }
    d3_selectionPrototype.order = function () {
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
                if (node = group[i]) {
                    if (next && next !== node.nextSibling)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    };
    d3_selectionPrototype.sort = function (comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m;)
            this[j].sort(comparator);
        return this.order();
    };
    function d3_selection_sortComparator(comparator) {
        if (!arguments.length)
            comparator = d3_ascending;
        return function (a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
    }
    d3_selectionPrototype.each = function (callback) {
        return d3_selection_each(this, function (node, i, j) {
            callback.call(node, node.__data__, i, j);
        });
    };
    function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
                if (node = group[i])
                    callback(node, i, j);
            }
        }
        return groups;
    }
    d3_selectionPrototype.call = function (callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
    };
    d3_selectionPrototype.empty = function () {
        return !this.node();
    };
    d3_selectionPrototype.node = function () {
        for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                var node = group[i];
                if (node)
                    return node;
            }
        }
        return null;
    };
    d3_selectionPrototype.size = function () {
        var n = 0;
        d3_selection_each(this, function () {
            ++n;
        });
        return n;
    };
    function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
    }
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter;
    d3.selection.enter.prototype = d3_selection_enterPrototype;
    d3_selection_enterPrototype.append = d3_selectionPrototype.append;
    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
    d3_selection_enterPrototype.node = d3_selectionPrototype.node;
    d3_selection_enterPrototype.call = d3_selectionPrototype.call;
    d3_selection_enterPrototype.size = d3_selectionPrototype.size;
    d3_selection_enterPrototype.select = function (selector) {
        var subgroups = [], subgroup, subnode, upgroup, group, node;
        for (var j = -1, m = this.length; ++j < m;) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                    subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    d3_selection_enterPrototype.insert = function (name, before) {
        if (arguments.length < 2)
            before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
    };
    function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function (d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0)
                j0 = j, i0 = 0;
            if (i >= i0)
                i0 = i + 1;
            while (!(node = group[i0]) && ++i0 < n);
            return node;
        };
    }
    d3.select = function (node) {
        var group;
        if (typeof node === 'string') {
            group = [d3_select(node, d3_document)];
            group.parentNode = d3_document.documentElement;
        } else {
            group = [node];
            group.parentNode = d3_documentElement(node);
        }
        return d3_selection([group]);
    };
    d3.selectAll = function (nodes) {
        var group;
        if (typeof nodes === 'string') {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
        } else {
            group = d3_array(nodes);
            group.parentNode = null;
        }
        return d3_selection([group]);
    };
    d3_selectionPrototype.on = function (type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof type !== 'string') {
                if (n < 2)
                    listener = false;
                for (capture in type)
                    this.each(d3_selection_on(capture, type[capture], listener));
                return this;
            }
            if (n < 2)
                return (n = this.node()['__on' + type]) && n._;
            capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
    };
    function d3_selection_on(type, listener, capture) {
        var name = '__on' + type, i = type.indexOf('.'), wrap = d3_selection_onListener;
        if (i > 0)
            type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter)
            type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
            var l = this[name];
            if (l) {
                this.removeEventListener(type, l, l.$);
                delete this[name];
            }
        }
        function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
        }
        function removeAll() {
            var re = new RegExp('^__on([^.]+)' + d3.requote(type) + '$'), match;
            for (var name in this) {
                if (match = name.match(re)) {
                    var l = this[name];
                    this.removeEventListener(match[1], l, l.$);
                    delete this[name];
                }
            }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
    }
    var d3_selection_onFilters = d3.map({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout'
    });
    if (d3_document) {
        d3_selection_onFilters.forEach(function (k) {
            if ('on' + k in d3_document)
                d3_selection_onFilters.remove(k);
        });
    }
    function d3_selection_onListener(listener, argumentz) {
        return function (e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
                listener.apply(this, argumentz);
            } finally {
                d3.event = o;
            }
        };
    }
    function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function (e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
                l.call(target, e);
            }
        };
    }
    var d3_event_dragSelect, d3_event_dragId = 0;
    function d3_event_dragSuppress(node) {
        var name = '.dragsuppress-' + ++d3_event_dragId, click = 'click' + name, w = d3.select(d3_window(node)).on('touchmove' + name, d3_eventPreventDefault).on('dragstart' + name, d3_eventPreventDefault).on('selectstart' + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
            d3_event_dragSelect = 'onselectstart' in node ? false : d3_vendorSymbol(node.style, 'userSelect');
        }
        if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = 'none';
        }
        return function (suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect)
                style[d3_event_dragSelect] = select;
            if (suppressClick) {
                var off = function () {
                    w.on(click, null);
                };
                w.on(click, function () {
                    d3_eventPreventDefault();
                    off();
                }, true);
                setTimeout(off, 0);
            }
        };
    }
    d3.mouse = function (container) {
        return d3_mousePoint(container, d3_eventSource());
    };
    var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
    function d3_mousePoint(container, e) {
        if (e.changedTouches)
            e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
                var window = d3_window(container);
                if (window.scrollX || window.scrollY) {
                    svg = d3.select('body').append('svg').style({
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        margin: 0,
                        padding: 0,
                        border: 'none'
                    }, 'important');
                    var ctm = svg[0][0].getScreenCTM();
                    d3_mouse_bug44083 = !(ctm.f || ctm.e);
                    svg.remove();
                }
            }
            if (d3_mouse_bug44083)
                point.x = e.pageX, point.y = e.pageY;
            else
                point.x = e.clientX, point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [
                point.x,
                point.y
            ];
        }
        var rect = container.getBoundingClientRect();
        return [
            e.clientX - rect.left - container.clientLeft,
            e.clientY - rect.top - container.clientTop
        ];
    }
    d3.touch = function (container, touches, identifier) {
        if (arguments.length < 3)
            identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches)
            for (var i = 0, n = touches.length, touch; i < n; ++i) {
                if ((touch = touches[i]).identifier === identifier) {
                    return d3_mousePoint(container, touch);
                }
            }
    };
    d3.behavior.drag = function () {
        var event = d3_eventDispatch(drag, 'drag', 'dragstart', 'dragend'), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, 'mousemove', 'mouseup'), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, 'touchmove', 'touchend');
        function drag() {
            this.on('mousedown.drag', mousedown).on('touchstart.drag', touchstart);
        }
        function dragstart(id, position, subject, move, end) {
            return function () {
                var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = '.drag' + (dragId == null ? '' : '-' + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
                if (origin) {
                    dragOffset = origin.apply(that, arguments);
                    dragOffset = [
                        dragOffset.x - position0[0],
                        dragOffset.y - position0[1]
                    ];
                } else {
                    dragOffset = [
                        0,
                        0
                    ];
                }
                dispatch({ type: 'dragstart' });
                function moved() {
                    var position1 = position(parent, dragId), dx, dy;
                    if (!position1)
                        return;
                    dx = position1[0] - position0[0];
                    dy = position1[1] - position0[1];
                    dragged |= dx | dy;
                    position0 = position1;
                    dispatch({
                        type: 'drag',
                        x: position1[0] + dragOffset[0],
                        y: position1[1] + dragOffset[1],
                        dx: dx,
                        dy: dy
                    });
                }
                function ended() {
                    if (!position(parent, dragId))
                        return;
                    dragSubject.on(move + dragName, null).on(end + dragName, null);
                    dragRestore(dragged);
                    dispatch({ type: 'dragend' });
                }
            };
        }
        drag.origin = function (x) {
            if (!arguments.length)
                return origin;
            origin = x;
            return drag;
        };
        return d3.rebind(drag, event, 'on');
    };
    function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
    }
    d3.touches = function (container, touches) {
        if (arguments.length < 2)
            touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function (touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
        }) : [];
    };
    var ε = 0.000001, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
    function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }
    function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
    }
    function d3_asin(x) {
        return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
    }
    function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
    }
    var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
    d3.interpolateZoom = function (p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        if (d2 < ε2) {
            S = Math.log(w1 / w0) / ρ;
            i = function (t) {
                return [
                    ux0 + t * dx,
                    uy0 + t * dy,
                    w0 * Math.exp(ρ * t * S)
                ];
            };
        } else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / ρ;
            i = function (t) {
                var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
                return [
                    ux0 + u * dx,
                    uy0 + u * dy,
                    w0 * coshr0 / d3_cosh(ρ * s + r0)
                ];
            };
        }
        i.duration = S * 1000;
        return i;
    };
    d3.behavior.zoom = function () {
        var view = {
                x: 0,
                y: 0,
                k: 1
            }, translate0, center0, center, size = [
                960,
                500
            ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = 'mousedown.zoom', mousemove = 'mousemove.zoom', mouseup = 'mouseup.zoom', mousewheelTimer, touchstart = 'touchstart.zoom', touchtime, event = d3_eventDispatch(zoom, 'zoomstart', 'zoom', 'zoomend'), x0, x1, y0, y1;
        if (!d3_behavior_zoomWheel) {
            d3_behavior_zoomWheel = 'onwheel' in d3_document ? (d3_behavior_zoomDelta = function () {
                return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
            }, 'wheel') : 'onmousewheel' in d3_document ? (d3_behavior_zoomDelta = function () {
                return d3.event.wheelDelta;
            }, 'mousewheel') : (d3_behavior_zoomDelta = function () {
                return -d3.event.detail;
            }, 'MozMousePixelScroll');
        }
        function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + '.zoom', mousewheeled).on('dblclick.zoom', dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function (g) {
            g.each(function () {
                var dispatch = event.of(this, arguments), view1 = view;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each('start.zoom', function () {
                        view = this.__chart__ || {
                            x: 0,
                            y: 0,
                            k: 1
                        };
                        zoomstarted(dispatch);
                    }).tween('zoom:zoom', function () {
                        var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([
                                (cx - view.x) / view.k,
                                (cy - view.y) / view.k,
                                dx / view.k
                            ], [
                                (cx - view1.x) / view1.k,
                                (cy - view1.y) / view1.k,
                                dx / view1.k
                            ]);
                        return function (t) {
                            var l = i(t), k = dx / l[2];
                            this.__chart__ = view = {
                                x: cx - l[0] * k,
                                y: cy - l[1] * k,
                                k: k
                            };
                            zoomed(dispatch);
                        };
                    }).each('interrupt.zoom', function () {
                        zoomended(dispatch);
                    }).each('end.zoom', function () {
                        zoomended(dispatch);
                    });
                } else {
                    this.__chart__ = view;
                    zoomstarted(dispatch);
                    zoomed(dispatch);
                    zoomended(dispatch);
                }
            });
        };
        zoom.translate = function (_) {
            if (!arguments.length)
                return [
                    view.x,
                    view.y
                ];
            view = {
                x: +_[0],
                y: +_[1],
                k: view.k
            };
            rescale();
            return zoom;
        };
        zoom.scale = function (_) {
            if (!arguments.length)
                return view.k;
            view = {
                x: view.x,
                y: view.y,
                k: null
            };
            scaleTo(+_);
            rescale();
            return zoom;
        };
        zoom.scaleExtent = function (_) {
            if (!arguments.length)
                return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.center = function (_) {
            if (!arguments.length)
                return center;
            center = _ && [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.size = function (_) {
            if (!arguments.length)
                return size;
            size = _ && [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.duration = function (_) {
            if (!arguments.length)
                return duration;
            duration = +_;
            return zoom;
        };
        zoom.x = function (z) {
            if (!arguments.length)
                return x1;
            x1 = z;
            x0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        zoom.y = function (z) {
            if (!arguments.length)
                return y1;
            y1 = z;
            y0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        function location(p) {
            return [
                (p[0] - view.x) / view.k,
                (p[1] - view.y) / view.k
            ];
        }
        function point(l) {
            return [
                l[0] * view.k + view.x,
                l[1] * view.k + view.y
            ];
        }
        function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
            that.__chart__ = {
                x: view.x,
                y: view.y,
                k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p, l);
            that = d3.select(that);
            if (duration > 0)
                that = that.transition().duration(duration);
            that.call(zoom.event);
        }
        function rescale() {
            if (x1)
                x1.domain(x0.range().map(function (x) {
                    return (x - view.x) / view.k;
                }).map(x0.invert));
            if (y1)
                y1.domain(y0.range().map(function (y) {
                    return (y - view.y) / view.k;
                }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
            if (!zooming++)
                dispatch({ type: 'zoomstart' });
        }
        function zoomed(dispatch) {
            rescale();
            dispatch({
                type: 'zoom',
                scale: view.k,
                translate: [
                    view.x,
                    view.y
                ]
            });
        }
        function zoomended(dispatch) {
            if (!--zooming)
                dispatch({ type: 'zoomend' }), center0 = null;
        }
        function mousedowned() {
            var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
                dragged = 1;
                translateTo(d3.mouse(that), location0);
                zoomed(dispatch);
            }
            function ended() {
                subject.on(mousemove, null).on(mouseup, null);
                dragRestore(dragged);
                zoomended(dispatch);
            }
        }
        function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = '.zoom-' + d3.event.changedTouches[0].identifier, touchmove = 'touchmove' + zoomName, touchend = 'touchend' + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
                var touches = d3.touches(that);
                scale0 = view.k;
                touches.forEach(function (t) {
                    if (t.identifier in locations0)
                        locations0[t.identifier] = location(t);
                });
                return touches;
            }
            function started() {
                var target = d3.event.target;
                d3.select(target).on(touchmove, moved).on(touchend, ended);
                targets.push(target);
                var changed = d3.event.changedTouches;
                for (var i = 0, n = changed.length; i < n; ++i) {
                    locations0[changed[i].identifier] = null;
                }
                var touches = relocate(), now = Date.now();
                if (touches.length === 1) {
                    if (now - touchtime < 500) {
                        var p = touches[0];
                        zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                        d3_eventPreventDefault();
                    }
                    touchtime = now;
                } else if (touches.length > 1) {
                    var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                    distance0 = dx * dx + dy * dy;
                }
            }
            function moved() {
                var touches = d3.touches(that), p0, l0, p1, l1;
                d3_selection_interrupt.call(that);
                for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                    p1 = touches[i];
                    if (l1 = locations0[p1.identifier]) {
                        if (l0)
                            break;
                        p0 = p1, l0 = l1;
                    }
                }
                if (l1) {
                    var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                    p0 = [
                        (p0[0] + p1[0]) / 2,
                        (p0[1] + p1[1]) / 2
                    ];
                    l0 = [
                        (l0[0] + l1[0]) / 2,
                        (l0[1] + l1[1]) / 2
                    ];
                    scaleTo(scale1 * scale0);
                }
                touchtime = null;
                translateTo(p0, l0);
                zoomed(dispatch);
            }
            function ended() {
                if (d3.event.touches.length) {
                    var changed = d3.event.changedTouches;
                    for (var i = 0, n = changed.length; i < n; ++i) {
                        delete locations0[changed[i].identifier];
                    }
                    for (var identifier in locations0) {
                        return void relocate();
                    }
                }
                d3.selectAll(targets).on(zoomName, null);
                subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
                dragRestore();
                zoomended(dispatch);
            }
        }
        function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer)
                clearTimeout(mousewheelTimer);
            else
                d3_selection_interrupt.call(this), translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function () {
                mousewheelTimer = null;
                zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * 0.002) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
        }
        function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, 'on');
    };
    var d3_behavior_zoomInfinity = [
            0,
            Infinity
        ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
    d3.color = d3_color;
    function d3_color() {
    }
    d3_color.prototype.toString = function () {
        return this.rgb() + '';
    };
    d3.hsl = d3_hsl;
    function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse('' + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
    }
    var d3_hslPrototype = d3_hsl.prototype = new d3_color();
    d3_hslPrototype.brighter = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
    };
    d3_hslPrototype.darker = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
    };
    d3_hslPrototype.rgb = function () {
        return d3_hsl_rgb(this.h, this.s, this.l);
    };
    function d3_hsl_rgb(h, s, l) {
        var m1, m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
            if (h > 360)
                h -= 360;
            else if (h < 0)
                h += 360;
            if (h < 60)
                return m1 + (m2 - m1) * h / 60;
            if (h < 180)
                return m2;
            if (h < 240)
                return m1 + (m2 - m1) * (240 - h) / 60;
            return m1;
        }
        function vv(h) {
            return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
    }
    d3.hcl = d3_hcl;
    function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
    }
    var d3_hclPrototype = d3_hcl.prototype = new d3_color();
    d3_hclPrototype.brighter = function (k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.darker = function (k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.rgb = function () {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
    };
    function d3_hcl_lab(h, c, l) {
        if (isNaN(h))
            h = 0;
        if (isNaN(c))
            c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
    }
    d3.lab = d3_lab;
    function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
    }
    var d3_lab_K = 18;
    var d3_lab_X = 0.95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
    var d3_labPrototype = d3_lab.prototype = new d3_color();
    d3_labPrototype.brighter = function (k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.darker = function (k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.rgb = function () {
        return d3_lab_rgb(this.l, this.a, this.b);
    };
    function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), d3_xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), d3_xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z));
    }
    function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
    }
    function d3_lab_xyz(x) {
        return x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
    }
    function d3_xyz_lab(x) {
        return x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
    }
    function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));
    }
    d3.rgb = d3_rgb;
    function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse('' + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
    }
    function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
    }
    function d3_rgbString(value) {
        return d3_rgbNumber(value) + '';
    }
    var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
    d3_rgbPrototype.brighter = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        var r = this.r, g = this.g, b = this.b, i = 30;
        if (!r && !g && !b)
            return new d3_rgb(i, i, i);
        if (r && r < i)
            r = i;
        if (g && g < i)
            g = i;
        if (b && b < i)
            b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
    };
    d3_rgbPrototype.darker = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
    };
    d3_rgbPrototype.hsl = function () {
        return d3_rgb_hsl(this.r, this.g, this.b);
    };
    d3_rgbPrototype.toString = function () {
        return '#' + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
    };
    function d3_rgb_hex(v) {
        return v < 16 ? '0' + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }
    function d3_rgb_parse(format, rgb, hsl) {
        var r = 0, g = 0, b = 0, m1, m2, color;
        m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
        if (m1) {
            m2 = m1[2].split(',');
            switch (m1[1]) {
            case 'hsl': {
                    return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                }
            case 'rgb': {
                    return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
                }
            }
        }
        if (color = d3_rgb_names.get(format)) {
            return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === '#' && !isNaN(color = parseInt(format.slice(1), 16))) {
            if (format.length === 4) {
                r = (color & 3840) >> 4;
                r = r >> 4 | r;
                g = color & 240;
                g = g >> 4 | g;
                b = color & 15;
                b = b << 4 | b;
            } else if (format.length === 7) {
                r = (color & 16711680) >> 16;
                g = (color & 65280) >> 8;
                b = color & 255;
            }
        }
        return rgb(r, g, b);
    }
    function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
        if (d) {
            s = l < 0.5 ? d / (max + min) : d / (2 - max - min);
            if (r == max)
                h = (g - b) / d + (g < b ? 6 : 0);
            else if (g == max)
                h = (b - r) / d + 2;
            else
                h = (r - g) / d + 4;
            h *= 60;
        } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
    }
    function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / d3_lab_X), y = d3_xyz_lab((0.2126729 * r + 0.7151522 * g + 0.072175 * b) / d3_lab_Y), z = d3_xyz_lab((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
    }
    function d3_rgb_xyz(r) {
        return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
    }
    function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === '%' ? Math.round(f * 2.55) : f;
    }
    var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    });
    d3_rgb_names.forEach(function (key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
    });
    function d3_functor(v) {
        return typeof v === 'function' ? v : function () {
            return v;
        };
    }
    d3.functor = d3_functor;
    d3.xhr = d3_xhrType(d3_identity);
    function d3_xhrType(response) {
        return function (url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === 'function')
                callback = mimeType, mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
        };
    }
    function d3_xhr(url, mimeType, response, callback) {
        var xhr = {}, dispatch = d3.dispatch('beforesend', 'progress', 'load', 'error'), headers = {}, request = new XMLHttpRequest(), responseType = null;
        if (this.XDomainRequest && !('withCredentials' in request) && /^(http(s)?:)?\/\//.test(url))
            request = new XDomainRequest();
        'onload' in request ? request.onload = request.onerror = respond : request.onreadystatechange = function () {
            request.readyState > 3 && respond();
        };
        function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
                try {
                    result = response.call(xhr, request);
                } catch (e) {
                    dispatch.error.call(xhr, e);
                    return;
                }
                dispatch.load.call(xhr, result);
            } else {
                dispatch.error.call(xhr, request);
            }
        }
        request.onprogress = function (event) {
            var o = d3.event;
            d3.event = event;
            try {
                dispatch.progress.call(xhr, request);
            } finally {
                d3.event = o;
            }
        };
        xhr.header = function (name, value) {
            name = (name + '').toLowerCase();
            if (arguments.length < 2)
                return headers[name];
            if (value == null)
                delete headers[name];
            else
                headers[name] = value + '';
            return xhr;
        };
        xhr.mimeType = function (value) {
            if (!arguments.length)
                return mimeType;
            mimeType = value == null ? null : value + '';
            return xhr;
        };
        xhr.responseType = function (value) {
            if (!arguments.length)
                return responseType;
            responseType = value;
            return xhr;
        };
        xhr.response = function (value) {
            response = value;
            return xhr;
        };
        [
            'get',
            'post'
        ].forEach(function (method) {
            xhr[method] = function () {
                return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
            };
        });
        xhr.send = function (method, data, callback) {
            if (arguments.length === 2 && typeof data === 'function')
                callback = data, data = null;
            request.open(method, url, true);
            if (mimeType != null && !('accept' in headers))
                headers['accept'] = mimeType + ',*/*';
            if (request.setRequestHeader)
                for (var name in headers)
                    request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType)
                request.overrideMimeType(mimeType);
            if (responseType != null)
                request.responseType = responseType;
            if (callback != null)
                xhr.on('error', callback).on('load', function (request) {
                    callback(null, request);
                });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
        };
        xhr.abort = function () {
            request.abort();
            return xhr;
        };
        d3.rebind(xhr, dispatch, 'on');
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    }
    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function (error, request) {
            callback(error == null ? request : null);
        } : callback;
    }
    function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== 'text' ? request.response : request.responseText;
    }
    d3.dsv = function (delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + '\n]'), delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
            if (arguments.length < 3)
                callback = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function (_) {
                return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr;
        }
        function response(request) {
            return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
            return function (request) {
                return dsv.parse(request.responseText, f);
            };
        }
        dsv.parse = function (text, f) {
            var o;
            return dsv.parseRows(text, function (row, i) {
                if (o)
                    return o(row, i - 1);
                var a = new Function('d', 'return {' + row.map(function (name, i) {
                    return JSON.stringify(name) + ': d[' + i + ']';
                }).join(',') + '}');
                o = f ? function (row, i) {
                    return f(a(row), i);
                } : a;
            });
        };
        dsv.parseRows = function (text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
                if (I >= N)
                    return EOF;
                if (eol)
                    return eol = false, EOL;
                var j = I;
                if (text.charCodeAt(j) === 34) {
                    var i = j;
                    while (i++ < N) {
                        if (text.charCodeAt(i) === 34) {
                            if (text.charCodeAt(i + 1) !== 34)
                                break;
                            ++i;
                        }
                    }
                    I = i + 2;
                    var c = text.charCodeAt(i + 1);
                    if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(i + 2) === 10)
                            ++I;
                    } else if (c === 10) {
                        eol = true;
                    }
                    return text.slice(j + 1, i).replace(/""/g, '"');
                }
                while (I < N) {
                    var c = text.charCodeAt(I++), k = 1;
                    if (c === 10)
                        eol = true;
                    else if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(I) === 10)
                            ++I, ++k;
                    } else if (c !== delimiterCode)
                        continue;
                    return text.slice(j, I - k);
                }
                return text.slice(j);
            }
            while ((t = token()) !== EOF) {
                var a = [];
                while (t !== EOL && t !== EOF) {
                    a.push(t);
                    t = token();
                }
                if (f && (a = f(a, n++)) == null)
                    continue;
                rows.push(a);
            }
            return rows;
        };
        dsv.format = function (rows) {
            if (Array.isArray(rows[0]))
                return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function (row) {
                for (var field in row) {
                    if (!fieldSet.has(field)) {
                        fields.push(fieldSet.add(field));
                    }
                }
            });
            return [fields.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
                return fields.map(function (field) {
                    return formatValue(row[field]);
                }).join(delimiter);
            })).join('\n');
        };
        dsv.formatRows = function (rows) {
            return rows.map(formatRow).join('\n');
        };
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
    };
    d3.csv = d3.dsv(',', 'text/csv');
    d3.tsv = d3.dsv('\t', 'text/tab-separated-values');
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, 'requestAnimationFrame')] || function (callback) {
            setTimeout(callback, 17);
        };
    d3.timer = function () {
        d3_timer.apply(this, arguments);
    };
    function d3_timer(callback, delay, then) {
        var n = arguments.length;
        if (n < 2)
            delay = 0;
        if (n < 3)
            then = Date.now();
        var time = then + delay, timer = {
                c: callback,
                t: time,
                n: null
            };
        if (d3_timer_queueTail)
            d3_timer_queueTail.n = timer;
        else
            d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
        return timer;
    }
    function d3_timer_step() {
        var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }
    d3.timer.flush = function () {
        d3_timer_mark();
        d3_timer_sweep();
    };
    function d3_timer_mark() {
        var now = Date.now(), timer = d3_timer_queueHead;
        while (timer) {
            if (now >= timer.t && timer.c(now - timer.t))
                timer.c = null;
            timer = timer.n;
        }
        return now;
    }
    function d3_timer_sweep() {
        var t0, t1 = d3_timer_queueHead, time = Infinity;
        while (t1) {
            if (t1.c) {
                if (t1.t < time)
                    time = t1.t;
                t1 = (t0 = t1).n;
            } else {
                t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            }
        }
        d3_timer_queueTail = t0;
        return time;
    }
    function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
    }
    d3.round = function (x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
    };
    var d3_formatPrefixes = [
        'y',
        'z',
        'a',
        'f',
        'p',
        'n',
        'µ',
        'm',
        '',
        'k',
        'M',
        'G',
        'T',
        'P',
        'E',
        'Z',
        'Y'
    ].map(d3_formatPrefix);
    d3.formatPrefix = function (value, precision) {
        var i = 0;
        if (value = +value) {
            if (value < 0)
                value *= -1;
            if (precision)
                value = d3.round(value, d3_format_precision(value, precision));
            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
    };
    function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
            scale: i > 8 ? function (d) {
                return d / k;
            } : function (d) {
                return d * k;
            },
            symbol: d
        };
    }
    function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function (value, width) {
                var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
                while (i > 0 && g > 0) {
                    if (length + g + 1 > width)
                        g = Math.max(1, width - length);
                    t.push(value.substring(i -= g, i + g));
                    if ((length += g + 1) > width)
                        break;
                    g = locale_grouping[j = (j + 1) % locale_grouping.length];
                }
                return t.reverse().join(locale_thousands);
            } : d3_identity;
        return function (specifier) {
            var match = d3_format_re.exec(specifier), fill = match[1] || ' ', align = match[2] || '>', sign = match[3] || '-', symbol = match[4] || '', zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = '', suffix = '', integer = false, exponent = true;
            if (precision)
                precision = +precision.substring(1);
            if (zfill || fill === '0' && align === '=') {
                zfill = fill = '0';
                align = '=';
            }
            switch (type) {
            case 'n':
                comma = true;
                type = 'g';
                break;
            case '%':
                scale = 100;
                suffix = '%';
                type = 'f';
                break;
            case 'p':
                scale = 100;
                suffix = '%';
                type = 'r';
                break;
            case 'b':
            case 'o':
            case 'x':
            case 'X':
                if (symbol === '#')
                    prefix = '0' + type.toLowerCase();
            case 'c':
                exponent = false;
            case 'd':
                integer = true;
                precision = 0;
                break;
            case 's':
                scale = -1;
                type = 'r';
                break;
            }
            if (symbol === '$')
                prefix = locale_currency[0], suffix = locale_currency[1];
            if (type == 'r' && !precision)
                type = 'g';
            if (precision != null) {
                if (type == 'g')
                    precision = Math.max(1, Math.min(21, precision));
                else if (type == 'e' || type == 'f')
                    precision = Math.max(0, Math.min(20, precision));
            }
            type = d3_format_types.get(type) || d3_format_typeDefault;
            var zcomma = zfill && comma;
            return function (value) {
                var fullSuffix = suffix;
                if (integer && value % 1)
                    return '';
                var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign === '-' ? '' : sign;
                if (scale < 0) {
                    var unit = d3.formatPrefix(value, precision);
                    value = unit.scale(value);
                    fullSuffix = unit.symbol + suffix;
                } else {
                    value *= scale;
                }
                value = type(value, precision);
                var i = value.lastIndexOf('.'), before, after;
                if (i < 0) {
                    var j = exponent ? value.lastIndexOf('e') : -1;
                    if (j < 0)
                        before = value, after = '';
                    else
                        before = value.substring(0, j), after = value.substring(j);
                } else {
                    before = value.substring(0, i);
                    after = locale_decimal + value.substring(i + 1);
                }
                if (!zfill && comma)
                    before = formatGroup(before, Infinity);
                var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : '';
                if (zcomma)
                    before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
                negative += prefix;
                value = before + after;
                return (align === '<' ? negative + value + padding : align === '>' ? padding + negative + value : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
            };
        };
    }
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var d3_format_types = d3.map({
        b: function (x) {
            return x.toString(2);
        },
        c: function (x) {
            return String.fromCharCode(x);
        },
        o: function (x) {
            return x.toString(8);
        },
        x: function (x) {
            return x.toString(16);
        },
        X: function (x) {
            return x.toString(16).toUpperCase();
        },
        g: function (x, p) {
            return x.toPrecision(p);
        },
        e: function (x, p) {
            return x.toExponential(p);
        },
        f: function (x, p) {
            return x.toFixed(p);
        },
        r: function (x, p) {
            return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
    });
    function d3_format_typeDefault(x) {
        return x + '';
    }
    var d3_time = d3.time = {}, d3_date = Date;
    function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
    }
    d3_date_utc.prototype = {
        getDate: function () {
            return this._.getUTCDate();
        },
        getDay: function () {
            return this._.getUTCDay();
        },
        getFullYear: function () {
            return this._.getUTCFullYear();
        },
        getHours: function () {
            return this._.getUTCHours();
        },
        getMilliseconds: function () {
            return this._.getUTCMilliseconds();
        },
        getMinutes: function () {
            return this._.getUTCMinutes();
        },
        getMonth: function () {
            return this._.getUTCMonth();
        },
        getSeconds: function () {
            return this._.getUTCSeconds();
        },
        getTime: function () {
            return this._.getTime();
        },
        getTimezoneOffset: function () {
            return 0;
        },
        valueOf: function () {
            return this._.valueOf();
        },
        setDate: function () {
            d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function () {
            d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function () {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function () {
            d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function () {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function () {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function () {
            d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function () {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function () {
            d3_time_prototype.setTime.apply(this._, arguments);
        }
    };
    var d3_time_prototype = Date.prototype;
    function d3_time_interval(local, step, number) {
        function round(date) {
            var d0 = local(date), d1 = offset(d0, 1);
            return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
            step(date = local(new d3_date(date - 1)), 1);
            return date;
        }
        function offset(date, k) {
            step(date = new d3_date(+date), k);
            return date;
        }
        function range(t0, t1, dt) {
            var time = ceil(t0), times = [];
            if (dt > 1) {
                while (time < t1) {
                    if (!(number(time) % dt))
                        times.push(new Date(+time));
                    step(time, 1);
                }
            } else {
                while (time < t1)
                    times.push(new Date(+time)), step(time, 1);
            }
            return times;
        }
        function range_utc(t0, t1, dt) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = t0;
                return range(utc, t1, dt);
            } finally {
                d3_date = Date;
            }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
    }
    function d3_time_interval_utc(method) {
        return function (date, k) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = date;
                return method(utc, k)._;
            } finally {
                d3_date = Date;
            }
        };
    }
    d3_time.year = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
    }, function (date, offset) {
        date.setFullYear(date.getFullYear() + offset);
    }, function (date) {
        return date.getFullYear();
    });
    d3_time.years = d3_time.year.range;
    d3_time.years.utc = d3_time.year.utc.range;
    d3_time.day = d3_time_interval(function (date) {
        var day = new d3_date(2000, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
    }, function (date, offset) {
        date.setDate(date.getDate() + offset);
    }, function (date) {
        return date.getDate() - 1;
    });
    d3_time.days = d3_time.day.range;
    d3_time.days.utc = d3_time.day.utc.range;
    d3_time.dayOfYear = function (date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 60000) / 86400000);
    };
    [
        'sunday',
        'monday',
        'tuesday',
        'wednesday',
        'thursday',
        'friday',
        'saturday'
    ].forEach(function (day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function (date) {
            (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
            return date;
        }, function (date, offset) {
            date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function (date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + 's'] = interval.range;
        d3_time[day + 's'].utc = interval.utc.range;
        d3_time[day + 'OfYear'] = function (date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
    });
    d3_time.week = d3_time.sunday;
    d3_time.weeks = d3_time.sunday.range;
    d3_time.weeks.utc = d3_time.sunday.utc.range;
    d3_time.weekOfYear = d3_time.sundayOfYear;
    function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
            var n = template.length;
            function format(date) {
                var string = [], i = -1, j = 0, c, p, f;
                while (++i < n) {
                    if (template.charCodeAt(i) === 37) {
                        string.push(template.slice(j, i));
                        if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null)
                            c = template.charAt(++i);
                        if (f = d3_time_formats[c])
                            c = f(date, p == null ? c === 'e' ? ' ' : '0' : p);
                        string.push(c);
                        j = i + 1;
                    }
                }
                string.push(template.slice(j, i));
                return string.join('');
            }
            format.parse = function (string) {
                var d = {
                        y: 1900,
                        m: 0,
                        d: 1,
                        H: 0,
                        M: 0,
                        S: 0,
                        L: 0,
                        Z: null
                    }, i = d3_time_parse(d, template, string, 0);
                if (i != string.length)
                    return null;
                if ('p' in d)
                    d.H = d.H % 12 + d.p * 12;
                var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
                if ('j' in d)
                    date.setFullYear(d.y, 0, d.j);
                else if ('W' in d || 'U' in d) {
                    if (!('w' in d))
                        d.w = 'W' in d ? 1 : 0;
                    date.setFullYear(d.y, 0, 1);
                    date.setFullYear(d.y, 0, 'W' in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
                } else
                    date.setFullYear(d.y, d.m, d.d);
                date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
                return localZ ? date._ : date;
            };
            format.toString = function () {
                return template;
            };
            return format;
        }
        function d3_time_parse(date, template, string, j) {
            var c, p, t, i = 0, n = template.length, m = string.length;
            while (i < n) {
                if (j >= m)
                    return -1;
                c = template.charCodeAt(i++);
                if (c === 37) {
                    t = template.charAt(i++);
                    p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
                    if (!p || (j = p(date, string, j)) < 0)
                        return -1;
                } else if (c != string.charCodeAt(j++)) {
                    return -1;
                }
            }
            return j;
        }
        d3_time_format.utc = function (template) {
            var local = d3_time_format(template);
            function format(date) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date();
                    utc._ = date;
                    return local(utc);
                } finally {
                    d3_date = Date;
                }
            }
            format.parse = function (string) {
                try {
                    d3_date = d3_date_utc;
                    var date = local.parse(string);
                    return date && date._;
                } finally {
                    d3_date = Date;
                }
            };
            format.toString = local.toString;
            return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function (p, i) {
            d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
            a: function (d) {
                return locale_shortDays[d.getDay()];
            },
            A: function (d) {
                return locale_days[d.getDay()];
            },
            b: function (d) {
                return locale_shortMonths[d.getMonth()];
            },
            B: function (d) {
                return locale_months[d.getMonth()];
            },
            c: d3_time_format(locale_dateTime),
            d: function (d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            e: function (d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            H: function (d, p) {
                return d3_time_formatPad(d.getHours(), p, 2);
            },
            I: function (d, p) {
                return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
            },
            j: function (d, p) {
                return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
            },
            L: function (d, p) {
                return d3_time_formatPad(d.getMilliseconds(), p, 3);
            },
            m: function (d, p) {
                return d3_time_formatPad(d.getMonth() + 1, p, 2);
            },
            M: function (d, p) {
                return d3_time_formatPad(d.getMinutes(), p, 2);
            },
            p: function (d) {
                return locale_periods[+(d.getHours() >= 12)];
            },
            S: function (d, p) {
                return d3_time_formatPad(d.getSeconds(), p, 2);
            },
            U: function (d, p) {
                return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
            },
            w: function (d) {
                return d.getDay();
            },
            W: function (d, p) {
                return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
            },
            x: d3_time_format(locale_date),
            X: d3_time_format(locale_time),
            y: function (d, p) {
                return d3_time_formatPad(d.getFullYear() % 100, p, 2);
            },
            Y: function (d, p) {
                return d3_time_formatPad(d.getFullYear() % 10000, p, 4);
            },
            Z: d3_time_zone,
            '%': function () {
                return '%';
            }
        };
        var d3_time_parsers = {
            a: d3_time_parseWeekdayAbbrev,
            A: d3_time_parseWeekday,
            b: d3_time_parseMonthAbbrev,
            B: d3_time_parseMonth,
            c: d3_time_parseLocaleFull,
            d: d3_time_parseDay,
            e: d3_time_parseDay,
            H: d3_time_parseHour24,
            I: d3_time_parseHour24,
            j: d3_time_parseDayOfYear,
            L: d3_time_parseMilliseconds,
            m: d3_time_parseMonthNumber,
            M: d3_time_parseMinutes,
            p: d3_time_parseAmPm,
            S: d3_time_parseSeconds,
            U: d3_time_parseWeekNumberSunday,
            w: d3_time_parseWeekdayNumber,
            W: d3_time_parseWeekNumberMonday,
            x: d3_time_parseLocaleDate,
            X: d3_time_parseLocaleTime,
            y: d3_time_parseYear,
            Y: d3_time_parseFullYear,
            Z: d3_time_parseZone,
            '%': d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n = d3_time_dayAbbrevRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
            d3_time_dayRe.lastIndex = 0;
            var n = d3_time_dayRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n = d3_time_monthAbbrevRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
            d3_time_monthRe.lastIndex = 0;
            var n = d3_time_monthRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
            var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
            return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
    }
    var d3_time_formatPads = {
            '-': '',
            _: ' ',
            '0': '0'
        }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
    function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? '-' : '', string = (sign ? -value : value) + '', length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function d3_time_formatRe(names) {
        return new RegExp('^(?:' + names.map(d3.requote).join('|') + ')', 'i');
    }
    function d3_time_formatLookup(names) {
        var map = new d3_Map(), i = -1, n = names.length;
        while (++i < n)
            map.set(names[i].toLowerCase(), i);
        return map;
    }
    function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
    }
    function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1;
    }
    function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2000);
    }
    function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
    }
    function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
    }
    function d3_time_zone(d) {
        var z = d.getTimezoneOffset(), zs = z > 0 ? '-' : '+', zh = abs(z) / 60 | 0, zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, '0', 2) + d3_time_formatPad(zm, '0', 2);
    }
    function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function d3_time_formatMulti(formats) {
        var n = formats.length, i = -1;
        while (++i < n)
            formats[i][0] = this(formats[i][0]);
        return function (date) {
            var i = 0, f = formats[i];
            while (!f[1](date))
                f = formats[++i];
            return f[0](date);
        };
    }
    d3.locale = function (locale) {
        return {
            numberFormat: d3_locale_numberFormat(locale),
            timeFormat: d3_locale_timeFormat(locale)
        };
    };
    var d3_locale_enUS = d3.locale({
        decimal: '.',
        thousands: ',',
        grouping: [3],
        currency: [
            '$',
            ''
        ],
        dateTime: '%a %b %e %X %Y',
        date: '%m/%d/%Y',
        time: '%H:%M:%S',
        periods: [
            'AM',
            'PM'
        ],
        days: [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday'
        ],
        shortDays: [
            'Sun',
            'Mon',
            'Tue',
            'Wed',
            'Thu',
            'Fri',
            'Sat'
        ],
        months: [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
        ],
        shortMonths: [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec'
        ]
    });
    d3.format = d3_locale_enUS.numberFormat;
    d3.geo = {};
    function d3_adder() {
    }
    d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function (y) {
            d3_adderSum(y, this.t, d3_adderTemp);
            d3_adderSum(d3_adderTemp.s, this.s, this);
            if (this.s)
                this.t += d3_adderTemp.t;
            else
                this.s = d3_adderTemp.t;
        },
        reset: function () {
            this.s = this.t = 0;
        },
        valueOf: function () {
            return this.s;
        }
    };
    var d3_adderTemp = new d3_adder();
    function d3_adderSum(a, b, o) {
        var x = o.s = a + b, bv = x - a, av = x - bv;
        o.t = a - av + (b - bv);
    }
    d3.geo.stream = function (object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, listener);
        } else {
            d3_geo_streamGeometry(object, listener);
        }
    };
    function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
    }
    var d3_geo_streamObjectType = {
        Feature: function (feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function (object, listener) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n)
                d3_geo_streamGeometry(features[i].geometry, listener);
        }
    };
    var d3_geo_streamGeometryType = {
        Sphere: function (object, listener) {
            listener.sphere();
        },
        Point: function (object, listener) {
            object = object.coordinates;
            listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function (object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function (object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function (object, listener) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n)
                d3_geo_streamGeometry(geometries[i], listener);
        }
    };
    function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        listener.lineStart();
        while (++i < n)
            coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
    }
    function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1, n = coordinates.length;
        listener.polygonStart();
        while (++i < n)
            d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
    }
    d3.geo.area = function (object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
    };
    var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
    var d3_geo_area = {
        sphere: function () {
            d3_geo_areaSum += 4 * π;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function () {
            d3_geo_areaRingSum.reset();
            d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function () {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += area < 0 ? 4 * π + area : area;
            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
    };
    function d3_geo_areaRingStart() {
        var λ00, φ00, λ0, cosφ0, sinφ0;
        d3_geo_area.point = function (λ, φ) {
            d3_geo_area.point = nextPoint;
            λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), sinφ0 = Math.sin(φ);
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            φ = φ * d3_radians / 2 + π / 4;
            var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
            d3_geo_areaRingSum.add(Math.atan2(v, u));
            λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
        }
        d3_geo_area.lineEnd = function () {
            nextPoint(λ00, φ00);
        };
    }
    function d3_geo_cartesian(spherical) {
        var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
        return [
            cosφ * Math.cos(λ),
            cosφ * Math.sin(λ),
            Math.sin(φ)
        ];
    }
    function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function d3_geo_cartesianCross(a, b) {
        return [
            a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0]
        ];
    }
    function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
    }
    function d3_geo_cartesianScale(vector, k) {
        return [
            vector[0] * k,
            vector[1] * k,
            vector[2] * k
        ];
    }
    function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
    }
    function d3_geo_spherical(cartesian) {
        return [
            Math.atan2(cartesian[1], cartesian[0]),
            d3_asin(cartesian[2])
        ];
    }
    function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
    }
    d3.geo.bounds = function () {
        var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
        var bound = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
                bound.point = ringPoint;
                bound.lineStart = ringStart;
                bound.lineEnd = ringEnd;
                dλSum = 0;
                d3_geo_area.polygonStart();
            },
            polygonEnd: function () {
                d3_geo_area.polygonEnd();
                bound.point = point;
                bound.lineStart = lineStart;
                bound.lineEnd = lineEnd;
                if (d3_geo_areaRingSum < 0)
                    λ0 = -(λ1 = 180), φ0 = -(φ1 = 90);
                else if (dλSum > ε)
                    φ1 = 90;
                else if (dλSum < -ε)
                    φ0 = -90;
                range[0] = λ0, range[1] = λ1;
            }
        };
        function point(λ, φ) {
            ranges.push(range = [
                λ0 = λ,
                λ1 = λ
            ]);
            if (φ < φ0)
                φ0 = φ;
            if (φ > φ1)
                φ1 = φ;
        }
        function linePoint(λ, φ) {
            var p = d3_geo_cartesian([
                λ * d3_radians,
                φ * d3_radians
            ]);
            if (p0) {
                var normal = d3_geo_cartesianCross(p0, p), equatorial = [
                        normal[1],
                        -normal[0],
                        0
                    ], inflection = d3_geo_cartesianCross(equatorial, normal);
                d3_geo_cartesianNormalize(inflection);
                inflection = d3_geo_spherical(inflection);
                var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
                if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = inflection[1] * d3_degrees;
                    if (φi > φ1)
                        φ1 = φi;
                } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
                    var φi = -inflection[1] * d3_degrees;
                    if (φi < φ0)
                        φ0 = φi;
                } else {
                    if (φ < φ0)
                        φ0 = φ;
                    if (φ > φ1)
                        φ1 = φ;
                }
                if (antimeridian) {
                    if (λ < λ_) {
                        if (angle(λ0, λ) > angle(λ0, λ1))
                            λ1 = λ;
                    } else {
                        if (angle(λ, λ1) > angle(λ0, λ1))
                            λ0 = λ;
                    }
                } else {
                    if (λ1 >= λ0) {
                        if (λ < λ0)
                            λ0 = λ;
                        if (λ > λ1)
                            λ1 = λ;
                    } else {
                        if (λ > λ_) {
                            if (angle(λ0, λ) > angle(λ0, λ1))
                                λ1 = λ;
                        } else {
                            if (angle(λ, λ1) > angle(λ0, λ1))
                                λ0 = λ;
                        }
                    }
                }
            } else {
                point(λ, φ);
            }
            p0 = p, λ_ = λ;
        }
        function lineStart() {
            bound.point = linePoint;
        }
        function lineEnd() {
            range[0] = λ0, range[1] = λ1;
            bound.point = point;
            p0 = null;
        }
        function ringPoint(λ, φ) {
            if (p0) {
                var dλ = λ - λ_;
                dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
            } else
                λ__ = λ, φ__ = φ;
            d3_geo_area.point(λ, φ);
            linePoint(λ, φ);
        }
        function ringStart() {
            d3_geo_area.lineStart();
        }
        function ringEnd() {
            ringPoint(λ__, φ__);
            d3_geo_area.lineEnd();
            if (abs(dλSum) > ε)
                λ0 = -(λ1 = 180);
            range[0] = λ0, range[1] = λ1;
            p0 = null;
        }
        function angle(λ0, λ1) {
            return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
        }
        function compareRanges(a, b) {
            return a[0] - b[0];
        }
        function withinRange(x, range) {
            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function (feature) {
            φ1 = λ1 = -(λ0 = φ0 = Infinity);
            ranges = [];
            d3.geo.stream(feature, bound);
            var n = ranges.length;
            if (n) {
                ranges.sort(compareRanges);
                for (var i = 1, a = ranges[0], b, merged = [a]; i < n; ++i) {
                    b = ranges[i];
                    if (withinRange(b[0], a) || withinRange(b[1], a)) {
                        if (angle(a[0], b[1]) > angle(a[0], a[1]))
                            a[1] = b[1];
                        if (angle(b[0], a[1]) > angle(a[0], a[1]))
                            a[0] = b[0];
                    } else {
                        merged.push(a = b);
                    }
                }
                var best = -Infinity, dλ;
                for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
                    b = merged[i];
                    if ((dλ = angle(a[1], b[0])) > best)
                        best = dλ, λ0 = b[0], λ1 = a[1];
                }
            }
            ranges = range = null;
            return λ0 === Infinity || φ0 === Infinity ? [
                [
                    NaN,
                    NaN
                ],
                [
                    NaN,
                    NaN
                ]
            ] : [
                [
                    λ0,
                    φ0
                ],
                [
                    λ1,
                    φ1
                ]
            ];
        };
    }();
    d3.geo.centroid = function (object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
        if (m < ε2) {
            x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
            if (d3_geo_centroidW1 < ε)
                x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
            m = x * x + y * y + z * z;
            if (m < ε2)
                return [
                    NaN,
                    NaN
                ];
        }
        return [
            Math.atan2(y, x) * d3_degrees,
            d3_asin(z / Math.sqrt(m)) * d3_degrees
        ];
    };
    var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
    var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function () {
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function () {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
    };
    function d3_geo_centroidPoint(λ, φ) {
        λ *= d3_radians;
        var cosφ = Math.cos(φ *= d3_radians);
        d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
    }
    function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
    }
    function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        d3_geo_centroid.point = function (λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            x0 = cosφ * Math.cos(λ);
            y0 = cosφ * Math.sin(λ);
            z0 = Math.sin(φ);
            d3_geo_centroid.point = nextPoint;
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
    }
    function d3_geo_centroidRingStart() {
        var λ00, φ00, x0, y0, z0;
        d3_geo_centroid.point = function (λ, φ) {
            λ00 = λ, φ00 = φ;
            d3_geo_centroid.point = nextPoint;
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians);
            x0 = cosφ * Math.cos(λ);
            y0 = cosφ * Math.sin(λ);
            z0 = Math.sin(φ);
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function () {
            nextPoint(λ00, φ00);
            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
            d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(λ, φ) {
            λ *= d3_radians;
            var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
            d3_geo_centroidX2 += v * cx;
            d3_geo_centroidY2 += v * cy;
            d3_geo_centroidZ2 += v * cz;
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_compose(a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert)
            compose.invert = function (x, y) {
                return x = b.invert(x, y), x && a.invert(x[0], x[1]);
            };
        return compose;
    }
    function d3_true() {
        return true;
    }
    function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [], clip = [];
        segments.forEach(function (segment) {
            if ((n = segment.length - 1) <= 0)
                return;
            var n, p0 = segment[0], p1 = segment[n];
            if (d3_geo_sphericalEqual(p0, p1)) {
                listener.lineStart();
                for (var i = 0; i < n; ++i)
                    listener.point((p0 = segment[i])[0], p0[1]);
                listener.lineEnd();
                return;
            }
            var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
            a.o = b;
            subject.push(a);
            clip.push(b);
            a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
            b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
            a.o = b;
            subject.push(a);
            clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length)
            return;
        for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
            clip[i].e = entry = !entry;
        }
        var start = subject[0], points, point;
        while (1) {
            var current = start, isSubject = true;
            while (current.v)
                if ((current = current.n) === start)
                    return;
            points = current.z;
            listener.lineStart();
            do {
                current.v = current.o.v = true;
                if (current.e) {
                    if (isSubject) {
                        for (var i = 0, n = points.length; i < n; ++i)
                            listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.n.x, 1, listener);
                    }
                    current = current.n;
                } else {
                    if (isSubject) {
                        points = current.p.z;
                        for (var i = points.length - 1; i >= 0; --i)
                            listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.p.x, -1, listener);
                    }
                    current = current.p;
                }
                current = current.o;
                points = current.z;
                isSubject = !isSubject;
            } while (!current.v);
            listener.lineEnd();
        }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length))
            return;
        var n, i = 0, a = array[0], b;
        while (++i < n) {
            a.n = b = array[i];
            b.p = a;
            a = b;
        }
        a.n = b = array[0];
        b.p = a;
    }
    function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function (rotate, listener) {
            var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function () {
                    clip.point = point;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = d3.merge(segments);
                    var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                    if (segments.length) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
                    } else if (clipStartInside) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd();
                    }
                    if (polygonStarted)
                        listener.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                },
                sphere: function () {
                    listener.polygonStart();
                    listener.lineStart();
                    interpolate(null, null, 1, listener);
                    listener.lineEnd();
                    listener.polygonEnd();
                }
            };
            function point(λ, φ) {
                var point = rotate(λ, φ);
                if (pointVisible(λ = point[0], φ = point[1]))
                    listener.point(λ, φ);
            }
            function pointLine(λ, φ) {
                var point = rotate(λ, φ);
                line.point(point[0], point[1]);
            }
            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }
            function lineEnd() {
                clip.point = point;
                line.lineEnd();
            }
            var segments;
            var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
            function pointRing(λ, φ) {
                ring.push([
                    λ,
                    φ
                ]);
                var point = rotate(λ, φ);
                ringListener.point(point[0], point[1]);
            }
            function ringStart() {
                ringListener.lineStart();
                ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringListener.lineEnd();
                var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                ring.pop();
                polygon.push(ring);
                ring = null;
                if (!n)
                    return;
                if (clean & 1) {
                    segment = ringSegments[0];
                    var n = segment.length - 1, i = -1, point;
                    if (n > 0) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        while (++i < n)
                            listener.point((point = segment[i])[0], point[1]);
                        listener.lineEnd();
                    }
                    return;
                }
                if (n > 1 && clean & 2)
                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
            }
            return clip;
        };
    }
    function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
    }
    function d3_geo_clipBufferListener() {
        var lines = [], line;
        return {
            lineStart: function () {
                lines.push(line = []);
            },
            point: function (λ, φ) {
                line.push([
                    λ,
                    φ
                ]);
            },
            lineEnd: d3_noop,
            buffer: function () {
                var buffer = lines;
                lines = [];
                line = null;
                return buffer;
            },
            rejoin: function () {
                if (lines.length > 1)
                    lines.push(lines.pop().concat(lines.shift()));
            }
        };
    }
    function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
    }
    var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [
        -π,
        -π / 2
    ]);
    function d3_geo_clipAntimeridianLine(listener) {
        var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
        return {
            lineStart: function () {
                listener.lineStart();
                clean = 1;
            },
            point: function (λ1, φ1) {
                var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
                if (abs(dλ - π) < ε) {
                    listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    listener.point(λ1, φ0);
                    clean = 0;
                } else if (sλ0 !== sλ1 && dλ >= π) {
                    if (abs(λ0 - sλ0) < ε)
                        λ0 -= sλ0 * ε;
                    if (abs(λ1 - sλ1) < ε)
                        λ1 -= sλ1 * ε;
                    φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
                    listener.point(sλ0, φ0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(sλ1, φ0);
                    clean = 0;
                }
                listener.point(λ0 = λ1, φ0 = φ1);
                sλ0 = sλ1;
            },
            lineEnd: function () {
                listener.lineEnd();
                λ0 = φ0 = NaN;
            },
            clean: function () {
                return 2 - clean;
            }
        };
    }
    function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
        var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
        return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var φ;
        if (from == null) {
            φ = direction * halfπ;
            listener.point(-π, φ);
            listener.point(0, φ);
            listener.point(π, φ);
            listener.point(π, 0);
            listener.point(π, -φ);
            listener.point(0, -φ);
            listener.point(-π, -φ);
            listener.point(-π, 0);
            listener.point(-π, φ);
        } else if (abs(from[0] - to[0]) > ε) {
            var s = from[0] < to[0] ? π : -π;
            φ = direction * s / 2;
            listener.point(-s, φ);
            listener.point(0, φ);
            listener.point(s, φ);
        } else {
            listener.point(to[0], to[1]);
        }
    }
    function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0], parallel = point[1], meridianNormal = [
                Math.sin(meridian),
                -Math.cos(meridian),
                0
            ], polarAngle = 0, winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
            var ring = polygon[i], m = ring.length;
            if (!m)
                continue;
            var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
            while (true) {
                if (j === m)
                    j = 0;
                point = ring[j];
                var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
                d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
                polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
                if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
                    var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                    d3_geo_cartesianNormalize(arc);
                    var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                    d3_geo_cartesianNormalize(intersection);
                    var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                    if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
                        winding += antimeridian ^ dλ >= 0 ? 1 : -1;
                    }
                }
                if (!j++)
                    break;
                λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
            }
        }
        return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;
    }
    function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [
            0,
            -radius
        ] : [
            -π,
            radius - π
        ]);
        function visible(λ, φ) {
            return Math.cos(λ) * Math.cos(φ) > cr;
        }
        function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return {
                lineStart: function () {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function (λ, φ) {
                    var point1 = [
                            λ,
                            φ
                        ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
                    if (!point0 && (v00 = v0 = v))
                        listener.lineStart();
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                            point1[0] += ε;
                            point1[1] += ε;
                            v = visible(point1[0], point1[1]);
                        }
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            listener.lineStart();
                            point2 = intersect(point1, point0);
                            listener.point(point2[0], point2[1]);
                        } else {
                            point2 = intersect(point0, point1);
                            listener.point(point2[0], point2[1]);
                            listener.lineEnd();
                        }
                        point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                            } else {
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                            }
                        }
                    }
                    if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                        listener.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function () {
                    if (v0)
                        listener.lineEnd();
                    point0 = null;
                },
                clean: function () {
                    return clean | (v00 && v0) << 1;
                }
            };
        }
        function intersect(a, b, two) {
            var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
            var n1 = [
                    1,
                    0,
                    0
                ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant)
                return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
            d3_geo_cartesianAdd(A, B);
            var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
            if (t2 < 0)
                return;
            var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
            d3_geo_cartesianAdd(q, A);
            q = d3_geo_spherical(q);
            if (!two)
                return q;
            var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
            if (λ1 < λ0)
                z = λ0, λ0 = λ1, λ1 = z;
            var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
            if (!polar && φ1 < φ0)
                z = φ0, φ0 = φ1, φ1 = z;
            if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
                var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                d3_geo_cartesianAdd(q1, A);
                return [
                    q,
                    d3_geo_spherical(q1)
                ];
            }
        }
        function code(λ, φ) {
            var r = smallRadius ? radius : π - radius, code = 0;
            if (λ < -r)
                code |= 1;
            else if (λ > r)
                code |= 2;
            if (φ < -r)
                code |= 4;
            else if (φ > r)
                code |= 8;
            return code;
        }
    }
    function d3_geom_clipLine(x0, y0, x1, y1) {
        return function (line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0)
                return;
            r /= dx;
            if (dx < 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            } else if (dx > 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0)
                return;
            r /= dx;
            if (dx < 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            } else if (dx > 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0)
                return;
            r /= dy;
            if (dy < 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            } else if (dy > 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0)
                return;
            r /= dy;
            if (dy < 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            } else if (dy > 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            if (t0 > 0)
                line.a = {
                    x: ax + t0 * dx,
                    y: ay + t0 * dy
                };
            if (t1 < 1)
                line.b = {
                    x: ax + t1 * dx,
                    y: ay + t1 * dy
                };
            return line;
        };
    }
    var d3_geo_clipExtentMAX = 1000000000;
    d3.geo.clipExtent = function () {
        var x0, y0, x1, y1, stream, clip, clipExtent = {
                stream: function (output) {
                    if (stream)
                        stream.valid = false;
                    stream = clip(output);
                    stream.valid = true;
                    return stream;
                },
                extent: function (_) {
                    if (!arguments.length)
                        return [
                            [
                                x0,
                                y0
                            ],
                            [
                                x1,
                                y1
                            ]
                        ];
                    clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                    if (stream)
                        stream.valid = false, stream = null;
                    return clipExtent;
                }
            };
        return clipExtent.extent([
            [
                0,
                0
            ],
            [
                960,
                500
            ]
        ]);
    };
    function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function (listener) {
            var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    listener = bufferListener;
                    segments = [];
                    polygon = [];
                    clean = true;
                },
                polygonEnd: function () {
                    listener = listener_;
                    segments = d3.merge(segments);
                    var clipStartInside = insidePolygon([
                            x0,
                            y1
                        ]), inside = clean && clipStartInside, visible = segments.length;
                    if (inside || visible) {
                        listener.polygonStart();
                        if (inside) {
                            listener.lineStart();
                            interpolate(null, null, 1, listener);
                            listener.lineEnd();
                        }
                        if (visible) {
                            d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                        }
                        listener.polygonEnd();
                    }
                    segments = polygon = ring = null;
                }
            };
            function insidePolygon(p) {
                var wn = 0, n = polygon.length, y = p[1];
                for (var i = 0; i < n; ++i) {
                    for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                        b = v[j];
                        if (a[1] <= y) {
                            if (b[1] > y && d3_cross2d(a, b, p) > 0)
                                ++wn;
                        } else {
                            if (b[1] <= y && d3_cross2d(a, b, p) < 0)
                                --wn;
                        }
                        a = b;
                    }
                }
                return wn !== 0;
            }
            function interpolate(from, to, direction, listener) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                    do {
                        listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                    } while ((a = (a + direction + 4) % 4) !== a1);
                } else {
                    listener.point(to[0], to[1]);
                }
            }
            function pointVisible(x, y) {
                return x0 <= x && x <= x1 && y0 <= y && y <= y1;
            }
            function point(x, y) {
                if (pointVisible(x, y))
                    listener.point(x, y);
            }
            var x__, y__, v__, x_, y_, v_, first, clean;
            function lineStart() {
                clip.point = linePoint;
                if (polygon)
                    polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_)
                        bufferListener.rejoin();
                    segments.push(bufferListener.buffer());
                }
                clip.point = point;
                if (v_)
                    listener.lineEnd();
            }
            function linePoint(x, y) {
                x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
                y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                var v = pointVisible(x, y);
                if (polygon)
                    ring.push([
                        x,
                        y
                    ]);
                if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                        listener.lineStart();
                        listener.point(x, y);
                    }
                } else {
                    if (v && v_)
                        listener.point(x, y);
                    else {
                        var l = {
                            a: {
                                x: x_,
                                y: y_
                            },
                            b: {
                                x: x,
                                y: y
                            }
                        };
                        if (clipLine(l)) {
                            if (!v_) {
                                listener.lineStart();
                                listener.point(l.a.x, l.a.y);
                            }
                            listener.point(l.b.x, l.b.y);
                            if (!v)
                                listener.lineEnd();
                            clean = false;
                        } else if (v) {
                            listener.lineStart();
                            listener.point(x, y);
                            clean = false;
                        }
                    }
                }
                x_ = x, y_ = y, v_ = v;
            }
            return clip;
        };
        function corner(p, direction) {
            return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
            return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
    }
    function d3_geo_conic(projectAt) {
        var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
        p.parallels = function (_) {
            if (!arguments.length)
                return [
                    φ0 / π * 180,
                    φ1 / π * 180
                ];
            return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
        };
        return p;
    }
    function d3_geo_conicEqualArea(φ0, φ1) {
        var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
        function forward(λ, φ) {
            var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
            return [
                ρ * Math.sin(λ *= n),
                ρ0 - ρ * Math.cos(λ)
            ];
        }
        forward.invert = function (x, y) {
            var ρ0_y = ρ0 - y;
            return [
                Math.atan2(x, ρ0_y) / n,
                d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))
            ];
        };
        return forward;
    }
    (d3.geo.conicEqualArea = function () {
        return d3_geo_conic(d3_geo_conicEqualArea);
    }).raw = d3_geo_conicEqualArea;
    d3.geo.albers = function () {
        return d3.geo.conicEqualArea().rotate([
            96,
            0
        ]).center([
            -0.6,
            38.7
        ]).parallels([
            29.5,
            45.5
        ]).scale(1070);
    };
    d3.geo.albersUsa = function () {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([
            154,
            0
        ]).center([
            -2,
            58.5
        ]).parallels([
            55,
            65
        ]);
        var hawaii = d3.geo.conicEqualArea().rotate([
            157,
            0
        ]).center([
            -3,
            19.9
        ]).parallels([
            8,
            18
        ]);
        var point, pointStream = {
                point: function (x, y) {
                    point = [
                        x,
                        y
                    ];
                }
            }, lower48Point, alaskaPoint, hawaiiPoint;
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            point = null;
            (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
            return point;
        }
        albersUsa.invert = function (coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function (stream) {
            var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
            return {
                point: function (x, y) {
                    lower48Stream.point(x, y);
                    alaskaStream.point(x, y);
                    hawaiiStream.point(x, y);
                },
                sphere: function () {
                    lower48Stream.sphere();
                    alaskaStream.sphere();
                    hawaiiStream.sphere();
                },
                lineStart: function () {
                    lower48Stream.lineStart();
                    alaskaStream.lineStart();
                    hawaiiStream.lineStart();
                },
                lineEnd: function () {
                    lower48Stream.lineEnd();
                    alaskaStream.lineEnd();
                    hawaiiStream.lineEnd();
                },
                polygonStart: function () {
                    lower48Stream.polygonStart();
                    alaskaStream.polygonStart();
                    hawaiiStream.polygonStart();
                },
                polygonEnd: function () {
                    lower48Stream.polygonEnd();
                    alaskaStream.polygonEnd();
                    hawaiiStream.polygonEnd();
                }
            };
        };
        albersUsa.precision = function (_) {
            if (!arguments.length)
                return lower48.precision();
            lower48.precision(_);
            alaska.precision(_);
            hawaii.precision(_);
            return albersUsa;
        };
        albersUsa.scale = function (_) {
            if (!arguments.length)
                return lower48.scale();
            lower48.scale(_);
            alaska.scale(_ * 0.35);
            hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function (_) {
            if (!arguments.length)
                return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([
                [
                    x - 0.455 * k,
                    y - 0.238 * k
                ],
                [
                    x + 0.455 * k,
                    y + 0.238 * k
                ]
            ]).stream(pointStream).point;
            alaskaPoint = alaska.translate([
                x - 0.307 * k,
                y + 0.201 * k
            ]).clipExtent([
                [
                    x - 0.425 * k + ε,
                    y + 0.12 * k + ε
                ],
                [
                    x - 0.214 * k - ε,
                    y + 0.234 * k - ε
                ]
            ]).stream(pointStream).point;
            hawaiiPoint = hawaii.translate([
                x - 0.205 * k,
                y + 0.212 * k
            ]).clipExtent([
                [
                    x - 0.214 * k + ε,
                    y + 0.166 * k + ε
                ],
                [
                    x - 0.115 * k - ε,
                    y + 0.234 * k - ε
                ]
            ]).stream(pointStream).point;
            return albersUsa;
        };
        return albersUsa.scale(1070);
    };
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
            point: d3_noop,
            lineStart: d3_noop,
            lineEnd: d3_noop,
            polygonStart: function () {
                d3_geo_pathAreaPolygon = 0;
                d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
            },
            polygonEnd: function () {
                d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
                d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
            }
        };
    function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function (x, y) {
            d3_geo_pathArea.point = nextPoint;
            x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
            d3_geo_pathAreaPolygon += y0 * x - x0 * y;
            x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function () {
            nextPoint(x00, y00);
        };
    }
    var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
    var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0)
            d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1)
            d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0)
            d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1)
            d3_geo_pathBoundsY1 = y;
    }
    function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
        var stream = {
            point: point,
            lineStart: function () {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function () {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function () {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function (_) {
                pointCircle = d3_geo_pathBufferCircle(_);
                return stream;
            },
            result: function () {
                if (buffer.length) {
                    var result = buffer.join('');
                    buffer = [];
                    return result;
                }
            }
        };
        function point(x, y) {
            buffer.push('M', x, ',', y, pointCircle);
        }
        function pointLineStart(x, y) {
            buffer.push('M', x, ',', y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            buffer.push('L', x, ',', y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            buffer.push('Z');
        }
        return stream;
    }
    function d3_geo_pathBufferCircle(radius) {
        return 'm0,' + radius + 'a' + radius + ',' + radius + ' 0 1,1 0,' + -2 * radius + 'a' + radius + ',' + radius + ' 0 1,1 0,' + 2 * radius + 'z';
    }
    var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function () {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function () {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
    };
    function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
    }
    function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
    }
    function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
    }
    function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            z = y0 * x - x0 * y;
            d3_geo_centroidX2 += z * (x0 + x);
            d3_geo_centroidY2 += z * (y0 + y);
            d3_geo_centroidZ2 += z * 3;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function () {
            nextPoint(x00, y00);
        };
    }
    function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
            point: point,
            lineStart: function () {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function () {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function () {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function (_) {
                pointRadius = _;
                return stream;
            },
            result: d3_noop
        };
        function point(x, y) {
            context.moveTo(x + pointRadius, y);
            context.arc(x, y, pointRadius, 0, τ);
        }
        function pointLineStart(x, y) {
            context.moveTo(x, y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            context.lineTo(x, y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            context.closePath();
        }
        return stream;
    }
    function d3_geo_resample(project) {
        var δ2 = 0.5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
        function resample(stream) {
            return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
            return d3_geo_transformPoint(stream, function (x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            });
        }
        function resampleRecursive(stream) {
            var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
            var resample = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    stream.polygonStart();
                    resample.lineStart = ringStart;
                },
                polygonEnd: function () {
                    stream.polygonEnd();
                    resample.lineStart = lineStart;
                }
            };
            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN;
                resample.point = linePoint;
                stream.lineStart();
            }
            function linePoint(λ, φ) {
                var c = d3_geo_cartesian([
                        λ,
                        φ
                    ]), p = project(λ, φ);
                resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }
            function lineEnd() {
                resample.point = point;
                stream.lineEnd();
            }
            function ringStart() {
                lineStart();
                resample.point = ringPoint;
                resample.lineEnd = ringEnd;
            }
            function ringPoint(λ, φ) {
                linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                resample.point = linePoint;
            }
            function ringEnd() {
                resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
                resample.lineEnd = lineEnd;
                lineEnd();
            }
            return resample;
        }
        function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * δ2 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
                }
            }
        }
        resample.precision = function (_) {
            if (!arguments.length)
                return Math.sqrt(δ2);
            maxDepth = (δ2 = _ * _) > 0 && 16;
            return resample;
        };
        return resample;
    }
    d3.geo.path = function () {
        var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
        function path(object) {
            if (object) {
                if (typeof pointRadius === 'function')
                    contextStream.pointRadius(+pointRadius.apply(this, arguments));
                if (!cacheStream || !cacheStream.valid)
                    cacheStream = projectStream(contextStream);
                d3.geo.stream(object, cacheStream);
            }
            return contextStream.result();
        }
        path.area = function (object) {
            d3_geo_pathAreaSum = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathArea));
            return d3_geo_pathAreaSum;
        };
        path.centroid = function (object) {
            d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
            return d3_geo_centroidZ2 ? [
                d3_geo_centroidX2 / d3_geo_centroidZ2,
                d3_geo_centroidY2 / d3_geo_centroidZ2
            ] : d3_geo_centroidZ1 ? [
                d3_geo_centroidX1 / d3_geo_centroidZ1,
                d3_geo_centroidY1 / d3_geo_centroidZ1
            ] : d3_geo_centroidZ0 ? [
                d3_geo_centroidX0 / d3_geo_centroidZ0,
                d3_geo_centroidY0 / d3_geo_centroidZ0
            ] : [
                NaN,
                NaN
            ];
        };
        path.bounds = function (object) {
            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
            d3.geo.stream(object, projectStream(d3_geo_pathBounds));
            return [
                [
                    d3_geo_pathBoundsX0,
                    d3_geo_pathBoundsY0
                ],
                [
                    d3_geo_pathBoundsX1,
                    d3_geo_pathBoundsY1
                ]
            ];
        };
        path.projection = function (_) {
            if (!arguments.length)
                return projection;
            projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
            return reset();
        };
        path.context = function (_) {
            if (!arguments.length)
                return context;
            contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
            if (typeof pointRadius !== 'function')
                contextStream.pointRadius(pointRadius);
            return reset();
        };
        path.pointRadius = function (_) {
            if (!arguments.length)
                return pointRadius;
            pointRadius = typeof _ === 'function' ? _ : (contextStream.pointRadius(+_), +_);
            return path;
        };
        function reset() {
            cacheStream = null;
            return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
    };
    function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function (x, y) {
            return project([
                x * d3_degrees,
                y * d3_degrees
            ]);
        });
        return function (stream) {
            return d3_geo_projectionRadians(resample(stream));
        };
    }
    d3.geo.transform = function (methods) {
        return {
            stream: function (stream) {
                var transform = new d3_geo_transform(stream);
                for (var k in methods)
                    transform[k] = methods[k];
                return transform;
            }
        };
    };
    function d3_geo_transform(stream) {
        this.stream = stream;
    }
    d3_geo_transform.prototype = {
        point: function (x, y) {
            this.stream.point(x, y);
        },
        sphere: function () {
            this.stream.sphere();
        },
        lineStart: function () {
            this.stream.lineStart();
        },
        lineEnd: function () {
            this.stream.lineEnd();
        },
        polygonStart: function () {
            this.stream.polygonStart();
        },
        polygonEnd: function () {
            this.stream.polygonEnd();
        }
    };
    function d3_geo_transformPoint(stream, point) {
        return {
            point: point,
            sphere: function () {
                stream.sphere();
            },
            lineStart: function () {
                stream.lineStart();
            },
            lineEnd: function () {
                stream.lineEnd();
            },
            polygonStart: function () {
                stream.polygonStart();
            },
            polygonEnd: function () {
                stream.polygonEnd();
            }
        };
    }
    d3.geo.projection = d3_geo_projection;
    d3.geo.projectionMutator = d3_geo_projectionMutator;
    function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function () {
            return project;
        })();
    }
    function d3_geo_projectionMutator(projectAt) {
        var project, rotate, projectRotate, projectResample = d3_geo_resample(function (x, y) {
                x = project(x, y);
                return [
                    x[0] * k + δx,
                    δy - x[1] * k
                ];
            }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
        function projection(point) {
            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
            return [
                point[0] * k + δx,
                δy - point[1] * k
            ];
        }
        function invert(point) {
            point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
            return point && [
                point[0] * d3_degrees,
                point[1] * d3_degrees
            ];
        }
        projection.stream = function (output) {
            if (stream)
                stream.valid = false;
            stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
            stream.valid = true;
            return stream;
        };
        projection.clipAngle = function (_) {
            if (!arguments.length)
                return clipAngle;
            preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
            return invalidate();
        };
        projection.clipExtent = function (_) {
            if (!arguments.length)
                return clipExtent;
            clipExtent = _;
            postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
            return invalidate();
        };
        projection.scale = function (_) {
            if (!arguments.length)
                return k;
            k = +_;
            return reset();
        };
        projection.translate = function (_) {
            if (!arguments.length)
                return [
                    x,
                    y
                ];
            x = +_[0];
            y = +_[1];
            return reset();
        };
        projection.center = function (_) {
            if (!arguments.length)
                return [
                    λ * d3_degrees,
                    φ * d3_degrees
                ];
            λ = _[0] % 360 * d3_radians;
            φ = _[1] % 360 * d3_radians;
            return reset();
        };
        projection.rotate = function (_) {
            if (!arguments.length)
                return [
                    δλ * d3_degrees,
                    δφ * d3_degrees,
                    δγ * d3_degrees
                ];
            δλ = _[0] % 360 * d3_radians;
            δφ = _[1] % 360 * d3_radians;
            δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
            return reset();
        };
        d3.rebind(projection, projectResample, 'precision');
        function reset() {
            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
            var center = project(λ, φ);
            δx = x - center[0] * k;
            δy = y + center[1] * k;
            return invalidate();
        }
        function invalidate() {
            if (stream)
                stream.valid = false, stream = null;
            return projection;
        }
        return function () {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return reset();
        };
    }
    function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function (x, y) {
            stream.point(x * d3_radians, y * d3_radians);
        });
    }
    function d3_geo_equirectangular(λ, φ) {
        return [
            λ,
            φ
        ];
    }
    (d3.geo.equirectangular = function () {
        return d3_geo_projection(d3_geo_equirectangular);
    }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
    d3.geo.rotation = function (rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function (coordinates) {
            coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
    };
    function d3_geo_identityRotation(λ, φ) {
        return [
            λ > π ? λ - τ : λ < -π ? λ + τ : λ,
            φ
        ];
    }
    d3_geo_identityRotation.invert = d3_geo_equirectangular;
    function d3_geo_rotation(δλ, δφ, δγ) {
        return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
    }
    function d3_geo_forwardRotationλ(δλ) {
        return function (λ, φ) {
            return λ += δλ, [
                λ > π ? λ - τ : λ < -π ? λ + τ : λ,
                φ
            ];
        };
    }
    function d3_geo_rotationλ(δλ) {
        var rotation = d3_geo_forwardRotationλ(δλ);
        rotation.invert = d3_geo_forwardRotationλ(-δλ);
        return rotation;
    }
    function d3_geo_rotationφγ(δφ, δγ) {
        var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
        function rotation(λ, φ) {
            var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
            return [
                Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ),
                d3_asin(k * cosδγ + y * sinδγ)
            ];
        }
        rotation.invert = function (λ, φ) {
            var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
            return [
                Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ),
                d3_asin(k * cosδφ - x * sinδφ)
            ];
        };
        return rotation;
    }
    d3.geo.circle = function () {
        var origin = [
                0,
                0
            ], angle, precision = 6, interpolate;
        function circle() {
            var center = typeof origin === 'function' ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
            interpolate(null, null, 1, {
                point: function (x, y) {
                    ring.push(x = rotate(x, y));
                    x[0] *= d3_degrees, x[1] *= d3_degrees;
                }
            });
            return {
                type: 'Polygon',
                coordinates: [ring]
            };
        }
        circle.origin = function (x) {
            if (!arguments.length)
                return origin;
            origin = x;
            return circle;
        };
        circle.angle = function (x) {
            if (!arguments.length)
                return angle;
            interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
            return circle;
        };
        circle.precision = function (_) {
            if (!arguments.length)
                return precision;
            interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
            return circle;
        };
        return circle.angle(90);
    };
    function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius), sr = Math.sin(radius);
        return function (from, to, direction, listener) {
            var step = direction * precision;
            if (from != null) {
                from = d3_geo_circleAngle(cr, from);
                to = d3_geo_circleAngle(cr, to);
                if (direction > 0 ? from < to : from > to)
                    from += direction * τ;
            } else {
                from = radius + direction * τ;
                to = radius - 0.5 * step;
            }
            for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
                listener.point((point = d3_geo_spherical([
                    cr,
                    -sr * Math.cos(t),
                    -sr * Math.sin(t)
                ]))[0], point[1]);
            }
        };
    }
    function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
    }
    d3.geo.distance = function (a, b) {
        var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
        return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
    };
    d3.geo.graticule = function () {
        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule() {
            return {
                type: 'MultiLineString',
                coordinates: lines()
            };
        }
        function lines() {
            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
                return abs(x % DX) > ε;
            }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
                return abs(y % DY) > ε;
            }).map(y));
        }
        graticule.lines = function () {
            return lines().map(function (coordinates) {
                return {
                    type: 'LineString',
                    coordinates: coordinates
                };
            });
        };
        graticule.outline = function () {
            return {
                type: 'Polygon',
                coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
            };
        };
        graticule.extent = function (_) {
            if (!arguments.length)
                return graticule.minorExtent();
            return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function (_) {
            if (!arguments.length)
                return [
                    [
                        X0,
                        Y0
                    ],
                    [
                        X1,
                        Y1
                    ]
                ];
            X0 = +_[0][0], X1 = +_[1][0];
            Y0 = +_[0][1], Y1 = +_[1][1];
            if (X0 > X1)
                _ = X0, X0 = X1, X1 = _;
            if (Y0 > Y1)
                _ = Y0, Y0 = Y1, Y1 = _;
            return graticule.precision(precision);
        };
        graticule.minorExtent = function (_) {
            if (!arguments.length)
                return [
                    [
                        x0,
                        y0
                    ],
                    [
                        x1,
                        y1
                    ]
                ];
            x0 = +_[0][0], x1 = +_[1][0];
            y0 = +_[0][1], y1 = +_[1][1];
            if (x0 > x1)
                _ = x0, x0 = x1, x1 = _;
            if (y0 > y1)
                _ = y0, y0 = y1, y1 = _;
            return graticule.precision(precision);
        };
        graticule.step = function (_) {
            if (!arguments.length)
                return graticule.minorStep();
            return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function (_) {
            if (!arguments.length)
                return [
                    DX,
                    DY
                ];
            DX = +_[0], DY = +_[1];
            return graticule;
        };
        graticule.minorStep = function (_) {
            if (!arguments.length)
                return [
                    dx,
                    dy
                ];
            dx = +_[0], dy = +_[1];
            return graticule;
        };
        graticule.precision = function (_) {
            if (!arguments.length)
                return precision;
            precision = +_;
            x = d3_geo_graticuleX(y0, y1, 90);
            y = d3_geo_graticuleY(x0, x1, precision);
            X = d3_geo_graticuleX(Y0, Y1, 90);
            Y = d3_geo_graticuleY(X0, X1, precision);
            return graticule;
        };
        return graticule.majorExtent([
            [
                -180,
                -90 + ε
            ],
            [
                180,
                90 - ε
            ]
        ]).minorExtent([
            [
                -180,
                -80 - ε
            ],
            [
                180,
                80 + ε
            ]
        ]);
    };
    function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - ε, dy).concat(y1);
        return function (x) {
            return y.map(function (y) {
                return [
                    x,
                    y
                ];
            });
        };
    }
    function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - ε, dx).concat(x1);
        return function (y) {
            return x.map(function (x) {
                return [
                    x,
                    y
                ];
            });
        };
    }
    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }
    d3.geo.greatArc = function () {
        var source = d3_source, source_, target = d3_target, target_;
        function greatArc() {
            return {
                type: 'LineString',
                coordinates: [
                    source_ || source.apply(this, arguments),
                    target_ || target.apply(this, arguments)
                ]
            };
        }
        greatArc.distance = function () {
            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function (_) {
            if (!arguments.length)
                return source;
            source = _, source_ = typeof _ === 'function' ? null : _;
            return greatArc;
        };
        greatArc.target = function (_) {
            if (!arguments.length)
                return target;
            target = _, target_ = typeof _ === 'function' ? null : _;
            return greatArc;
        };
        greatArc.precision = function () {
            return arguments.length ? greatArc : 0;
        };
        return greatArc;
    };
    d3.geo.interpolate = function (source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
    };
    function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
        var interpolate = d ? function (t) {
            var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [
                Math.atan2(y, x) * d3_degrees,
                Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees
            ];
        } : function () {
            return [
                x0 * d3_degrees,
                y0 * d3_degrees
            ];
        };
        interpolate.distance = d;
        return interpolate;
    }
    d3.geo.length = function (object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
    };
    var d3_geo_lengthSum;
    var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_lengthLineStart() {
        var λ0, sinφ0, cosφ0;
        d3_geo_length.point = function (λ, φ) {
            λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
            d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function () {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(λ, φ) {
            var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
            λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
        }
    }
    function d3_geo_azimuthal(scale, angle) {
        function azimuthal(λ, φ) {
            var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
            return [
                k * cosφ * Math.sin(λ),
                k * Math.sin(φ)
            ];
        }
        azimuthal.invert = function (x, y) {
            var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
            return [
                Math.atan2(x * sinc, ρ * cosc),
                Math.asin(ρ && y * sinc / ρ)
            ];
        };
        return azimuthal;
    }
    var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function (cosλcosφ) {
        return Math.sqrt(2 / (1 + cosλcosφ));
    }, function (ρ) {
        return 2 * Math.asin(ρ / 2);
    });
    (d3.geo.azimuthalEqualArea = function () {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
    }).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function (cosλcosφ) {
        var c = Math.acos(cosλcosφ);
        return c && c / Math.sin(c);
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function () {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
    }).raw = d3_geo_azimuthalEquidistant;
    function d3_geo_conicConformal(φ0, φ1) {
        var cosφ0 = Math.cos(φ0), t = function (φ) {
                return Math.tan(π / 4 + φ / 2);
            }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
        if (!n)
            return d3_geo_mercator;
        function forward(λ, φ) {
            if (F > 0) {
                if (φ < -halfπ + ε)
                    φ = -halfπ + ε;
            } else {
                if (φ > halfπ - ε)
                    φ = halfπ - ε;
            }
            var ρ = F / Math.pow(t(φ), n);
            return [
                ρ * Math.sin(n * λ),
                F - ρ * Math.cos(n * λ)
            ];
        }
        forward.invert = function (x, y) {
            var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
            return [
                Math.atan2(x, ρ0_y) / n,
                2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ
            ];
        };
        return forward;
    }
    (d3.geo.conicConformal = function () {
        return d3_geo_conic(d3_geo_conicConformal);
    }).raw = d3_geo_conicConformal;
    function d3_geo_conicEquidistant(φ0, φ1) {
        var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
        if (abs(n) < ε)
            return d3_geo_equirectangular;
        function forward(λ, φ) {
            var ρ = G - φ;
            return [
                ρ * Math.sin(n * λ),
                G - ρ * Math.cos(n * λ)
            ];
        }
        forward.invert = function (x, y) {
            var ρ0_y = G - y;
            return [
                Math.atan2(x, ρ0_y) / n,
                G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y)
            ];
        };
        return forward;
    }
    (d3.geo.conicEquidistant = function () {
        return d3_geo_conic(d3_geo_conicEquidistant);
    }).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function (cosλcosφ) {
        return 1 / cosλcosφ;
    }, Math.atan);
    (d3.geo.gnomonic = function () {
        return d3_geo_projection(d3_geo_gnomonic);
    }).raw = d3_geo_gnomonic;
    function d3_geo_mercator(λ, φ) {
        return [
            λ,
            Math.log(Math.tan(π / 4 + φ / 2))
        ];
    }
    d3_geo_mercator.invert = function (x, y) {
        return [
            x,
            2 * Math.atan(Math.exp(y)) - halfπ
        ];
    };
    function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
        m.scale = function () {
            var v = scale.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function () {
            var v = translate.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function (_) {
            var v = clipExtent.apply(m, arguments);
            if (v === m) {
                if (clipAuto = _ == null) {
                    var k = π * scale(), t = translate();
                    clipExtent([
                        [
                            t[0] - k,
                            t[1] - k
                        ],
                        [
                            t[0] + k,
                            t[1] + k
                        ]
                    ]);
                }
            } else if (clipAuto) {
                v = null;
            }
            return v;
        };
        return m.clipExtent(null);
    }
    (d3.geo.mercator = function () {
        return d3_geo_mercatorProjection(d3_geo_mercator);
    }).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function () {
        return 1;
    }, Math.asin);
    (d3.geo.orthographic = function () {
        return d3_geo_projection(d3_geo_orthographic);
    }).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function (cosλcosφ) {
        return 1 / (1 + cosλcosφ);
    }, function (ρ) {
        return 2 * Math.atan(ρ);
    });
    (d3.geo.stereographic = function () {
        return d3_geo_projection(d3_geo_stereographic);
    }).raw = d3_geo_stereographic;
    function d3_geo_transverseMercator(λ, φ) {
        return [
            Math.log(Math.tan(π / 4 + φ / 2)),
            -λ
        ];
    }
    d3_geo_transverseMercator.invert = function (x, y) {
        return [
            -y,
            2 * Math.atan(Math.exp(x)) - halfπ
        ];
    };
    (d3.geo.transverseMercator = function () {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
        projection.center = function (_) {
            return _ ? center([
                -_[1],
                _[0]
            ]) : (_ = center(), [
                _[1],
                -_[0]
            ]);
        };
        projection.rotate = function (_) {
            return _ ? rotate([
                _[0],
                _[1],
                _.length > 2 ? _[2] + 90 : 90
            ]) : (_ = rotate(), [
                _[0],
                _[1],
                _[2] - 90
            ]);
        };
        return rotate([
            0,
            0,
            90
        ]);
    }).raw = d3_geo_transverseMercator;
    d3.geom = {};
    function d3_geom_pointX(d) {
        return d[0];
    }
    function d3_geom_pointY(d) {
        return d[1];
    }
    d3.geom.hull = function (vertices) {
        var x = d3_geom_pointX, y = d3_geom_pointY;
        if (arguments.length)
            return hull(vertices);
        function hull(data) {
            if (data.length < 3)
                return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for (i = 0; i < n; i++) {
                points.push([
                    +fx.call(this, data[i], i),
                    +fy.call(this, data[i], i),
                    i
                ]);
            }
            points.sort(d3_geom_hullOrder);
            for (i = 0; i < n; i++)
                flippedPoints.push([
                    points[i][0],
                    -points[i][1]
                ]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i = upper.length - 1; i >= 0; --i)
                polygon.push(data[points[upper[i]][2]]);
            for (i = +skipLeft; i < lower.length - skipRight; ++i)
                polygon.push(data[points[lower[i]][2]]);
            return polygon;
        }
        hull.x = function (_) {
            return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function (_) {
            return arguments.length ? (y = _, hull) : y;
        };
        return hull;
    };
    function d3_geom_hullUpper(points) {
        var n = points.length, hull = [
                0,
                1
            ], hs = 2;
        for (var i = 2; i < n; i++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0)
                --hs;
            hull[hs++] = i;
        }
        return hull.slice(0, hs);
    }
    function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
    }
    d3.geom.polygon = function (coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
    };
    var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
    d3_geom_polygonPrototype.area = function () {
        var i = -1, n = this.length, a, b = this[n - 1], area = 0;
        while (++i < n) {
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
        }
        return area * 0.5;
    };
    d3_geom_polygonPrototype.centroid = function (k) {
        var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
        if (!arguments.length)
            k = -1 / (6 * this.area());
        while (++i < n) {
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
        }
        return [
            x * k,
            y * k
        ];
    };
    d3_geom_polygonPrototype.clip = function (subject) {
        var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
        while (++i < n) {
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while (++j < m) {
                d = input[j];
                if (d3_geom_polygonInside(d, a, b)) {
                    if (!d3_geom_polygonInside(c, a, b)) {
                        subject.push(d3_geom_polygonIntersect(c, d, a, b));
                    }
                    subject.push(d);
                } else if (d3_geom_polygonInside(c, a, b)) {
                    subject.push(d3_geom_polygonIntersect(c, d, a, b));
                }
                c = d;
            }
            if (closed)
                subject.push(subject[0]);
            a = b;
        }
        return subject;
    };
    function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [
            x1 + ua * x21,
            y1 + ua * y21
        ];
    }
    function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0], b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
    }
    var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
    function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
    }
    function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
    }
    function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
    }
    function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
                x: x,
                y: y
            }, previous = beach.P, next = beach.N, disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length, iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiAddBeach(site) {
        var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
        while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > ε)
                node = node.L;
            else {
                dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
                if (dxr > ε) {
                    if (!node.R) {
                        lArc = node;
                        break;
                    }
                    node = node.R;
                } else {
                    if (dxl > -ε) {
                        lArc = node.P;
                        rArc = node;
                    } else if (dxr > -ε) {
                        lArc = node;
                        rArc = node.N;
                    } else {
                        lArc = rArc = node;
                    }
                    break;
                }
            }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc)
            return;
        if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
        }
        if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
                x: (cy * hb - by * hc) / d + ax,
                y: (bx * hc - cx * hb) / d + ay
            };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
        if (!pby2)
            return rfocx;
        var lArc = arc.P;
        if (!lArc)
            return -Infinity;
        site = lArc.site;
        var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
        if (!plby2)
            return lfocx;
        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
        if (aby2)
            return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
    }
    function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc)
            return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
    }
    function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
    }
    d3_geom_voronoiCell.prototype.prepare = function () {
        var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
        while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a)
                halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
    };
    function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
        while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare())
                continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
                end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
                start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
                if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
                    halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
                        x: x0,
                        y: abs(x2 - x0) < ε ? y2 : y1
                    } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
                        x: abs(y2 - y1) < ε ? x2 : x1,
                        y: y1
                    } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
                        x: x1,
                        y: abs(x2 - x1) < ε ? y2 : y0
                    } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
                        x: abs(y2 - y0) < ε ? x2 : x0,
                        y: y0
                    } : null), cell.site, null));
                    ++nHalfEdges;
                }
            }
        }
    }
    function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
    }
    function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
    }
    function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P, rArc = arc.N;
        if (!lArc || !rArc)
            return;
        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
        if (lSite === rSite)
            return;
        var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -ε2)
            return;
        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null, node = d3_geom_voronoiCircles._;
        while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                if (node.L)
                    node = node.L;
                else {
                    before = node.P;
                    break;
                }
            } else {
                if (node.R)
                    node = node.R;
                else {
                    before = node;
                    break;
                }
            }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before)
            d3_geom_voronoiFirstCircle = circle;
    }
    function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
            if (!circle.P)
                d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
        }
    }
    function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
        while (i--) {
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
                e.a = e.b = null;
                edges.splice(i, 1);
            }
        }
    }
    function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb)
            return true;
        var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
        if (ry === ly) {
            if (fx < x0 || fx >= x1)
                return;
            if (lx > rx) {
                if (!va)
                    va = {
                        x: fx,
                        y: y0
                    };
                else if (va.y >= y1)
                    return;
                vb = {
                    x: fx,
                    y: y1
                };
            } else {
                if (!va)
                    va = {
                        x: fx,
                        y: y1
                    };
                else if (va.y < y0)
                    return;
                vb = {
                    x: fx,
                    y: y0
                };
            }
        } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
                if (lx > rx) {
                    if (!va)
                        va = {
                            x: (y0 - fb) / fm,
                            y: y0
                        };
                    else if (va.y >= y1)
                        return;
                    vb = {
                        x: (y1 - fb) / fm,
                        y: y1
                    };
                } else {
                    if (!va)
                        va = {
                            x: (y1 - fb) / fm,
                            y: y1
                        };
                    else if (va.y < y0)
                        return;
                    vb = {
                        x: (y0 - fb) / fm,
                        y: y0
                    };
                }
            } else {
                if (ly < ry) {
                    if (!va)
                        va = {
                            x: x0,
                            y: fm * x0 + fb
                        };
                    else if (va.x >= x1)
                        return;
                    vb = {
                        x: x1,
                        y: fm * x1 + fb
                    };
                } else {
                    if (!va)
                        va = {
                            x: x1,
                            y: fm * x1 + fb
                        };
                    else if (va.x < x0)
                        return;
                    vb = {
                        x: x0,
                        y: fm * x0 + fb
                    };
                }
            }
        }
        edge.a = va;
        edge.b = vb;
        return true;
    }
    function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
    }
    function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va)
            d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb)
            d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
    }
    function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
    }
    function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
        } else if (edge.l === rSite) {
            edge.b = vertex;
        } else {
            edge.a = vertex;
        }
    }
    function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a, vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
    }
    d3_geom_voronoiHalfEdge.prototype = {
        start: function () {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function () {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
    };
    function d3_geom_voronoiRedBlackTree() {
        this._ = null;
    }
    function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
    }
    d3_geom_voronoiRedBlackTree.prototype = {
        insert: function (after, node) {
            var parent, grandpa, uncle;
            if (after) {
                node.P = after;
                node.N = after.N;
                if (after.N)
                    after.N.P = node;
                after.N = node;
                if (after.R) {
                    after = after.R;
                    while (after.L)
                        after = after.L;
                    after.L = node;
                } else {
                    after.R = node;
                }
                parent = after;
            } else if (this._) {
                after = d3_geom_voronoiRedBlackFirst(this._);
                node.P = null;
                node.N = after;
                after.P = after.L = node;
                parent = after;
            } else {
                node.P = node.N = null;
                this._ = node;
                parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
                grandpa = parent.U;
                if (parent === grandpa.L) {
                    uncle = grandpa.R;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.R) {
                            d3_geom_voronoiRedBlackRotateLeft(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                    }
                } else {
                    uncle = grandpa.L;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.L) {
                            d3_geom_voronoiRedBlackRotateRight(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                    }
                }
                parent = after.U;
            }
            this._.C = false;
        },
        remove: function (node) {
            if (node.N)
                node.N.P = node.P;
            if (node.P)
                node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left)
                next = right;
            else if (!right)
                next = left;
            else
                next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
                if (parent.L === node)
                    parent.L = next;
                else
                    parent.R = next;
            } else {
                this._ = next;
            }
            if (left && right) {
                red = next.C;
                next.C = node.C;
                next.L = left;
                left.U = next;
                if (next !== right) {
                    parent = next.U;
                    next.U = node.U;
                    node = next.R;
                    parent.L = node;
                    next.R = right;
                    right.U = next;
                } else {
                    next.U = parent;
                    parent = next;
                    node = next.R;
                }
            } else {
                red = node.C;
                node = next;
            }
            if (node)
                node.U = parent;
            if (red)
                return;
            if (node && node.C) {
                node.C = false;
                return;
            }
            do {
                if (node === this._)
                    break;
                if (node === parent.L) {
                    sibling = parent.R;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        sibling = parent.R;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.R || !sibling.R.C) {
                            sibling.L.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateRight(this, sibling);
                            sibling = parent.R;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.R.C = false;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        node = this._;
                        break;
                    }
                } else {
                    sibling = parent.L;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        sibling = parent.L;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.L || !sibling.L.C) {
                            sibling.R.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                            sibling = parent.L;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.L.C = false;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        node = this._;
                        break;
                    }
                }
                sibling.C = true;
                node = parent;
                parent = parent.U;
            } while (!node.C);
            if (node)
                node.C = false;
        }
    };
    function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node, q = node.R, parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R)
            p.R.U = p;
        q.L = p;
    }
    function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node, q = node.L, parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L)
            p.L.U = p;
        q.R = p;
    }
    function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L)
            node = node.L;
        return node;
    }
    function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
                if (site.x !== x0 || site.y !== y0) {
                    d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                    d3_geom_voronoiAddBeach(site);
                    x0 = site.x, y0 = site.y;
                }
                site = sites.pop();
            } else if (circle) {
                d3_geom_voronoiRemoveBeach(circle.arc);
            } else {
                break;
            }
        }
        if (bbox)
            d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
    }
    function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
    }
    d3.geom.voronoi = function (points) {
        var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
        if (points)
            return voronoi(points);
        function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function (cell, i) {
                var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function (e) {
                        var s = e.start();
                        return [
                            s.x,
                            s.y
                        ];
                    }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [
                        [
                            x0,
                            y1
                        ],
                        [
                            x1,
                            y1
                        ],
                        [
                            x1,
                            y0
                        ],
                        [
                            x0,
                            y0
                        ]
                    ] : [];
                polygon.point = data[i];
            });
            return polygons;
        }
        function sites(data) {
            return data.map(function (d, i) {
                return {
                    x: Math.round(fx(d, i) / ε) * ε,
                    y: Math.round(fy(d, i) / ε) * ε,
                    i: i
                };
            });
        }
        voronoi.links = function (data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function (edge) {
                return edge.l && edge.r;
            }).map(function (edge) {
                return {
                    source: data[edge.l.i],
                    target: data[edge.r.i]
                };
            });
        };
        voronoi.triangles = function (data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function (cell, i) {
                var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
                while (++j < m) {
                    e0 = e1;
                    s0 = s1;
                    e1 = edges[j].edge;
                    s1 = e1.l === site ? e1.r : e1.l;
                    if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                        triangles.push([
                            data[i],
                            data[s0.i],
                            data[s1.i]
                        ]);
                    }
                }
            });
            return triangles;
        };
        voronoi.x = function (_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function (_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function (_) {
            if (!arguments.length)
                return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
        };
        voronoi.size = function (_) {
            if (!arguments.length)
                return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [
                [
                    0,
                    0
                ],
                _
            ]);
        };
        return voronoi;
    };
    var d3_geom_voronoiClipExtent = [
        [
            -1000000,
            -1000000
        ],
        [
            1000000,
            1000000
        ]
    ];
    function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
    }
    d3.geom.delaunay = function (vertices) {
        return d3.geom.voronoi().triangles(vertices);
    };
    d3.geom.quadtree = function (points, x1, y1, x2, y2) {
        var x = d3_geom_pointX, y = d3_geom_pointY, compat;
        if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y2 = y1;
                x2 = x1;
                y1 = x1 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
                x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [], ys = [];
                n = data.length;
                if (compat)
                    for (i = 0; i < n; ++i) {
                        d = data[i];
                        if (d.x < x1_)
                            x1_ = d.x;
                        if (d.y < y1_)
                            y1_ = d.y;
                        if (d.x > x2_)
                            x2_ = d.x;
                        if (d.y > y2_)
                            y2_ = d.y;
                        xs.push(d.x);
                        ys.push(d.y);
                    }
                else
                    for (i = 0; i < n; ++i) {
                        var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                        if (x_ < x1_)
                            x1_ = x_;
                        if (y_ < y1_)
                            y1_ = y_;
                        if (x_ > x2_)
                            x2_ = x_;
                        if (y_ > y2_)
                            y2_ = y_;
                        xs.push(x_);
                        ys.push(y_);
                    }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy)
                y2_ = y1_ + dx;
            else
                x2_ = x1_ + dy;
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y))
                    return;
                if (n.leaf) {
                    var nx = n.x, ny = n.y;
                    if (nx != null) {
                        if (abs(nx - x) + abs(ny - y) < 0.01) {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        } else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    } else {
                        n.x = x, n.y = y, n.point = d;
                    }
                } else {
                    insertChild(n, d, x, y, x1, y1, x2, y2);
                }
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var xm = (x1 + x2) * 0.5, ym = (y1 + y2) * 0.5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right)
                    x1 = xm;
                else
                    x2 = xm;
                if (below)
                    y1 = ym;
                else
                    y2 = ym;
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function (d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function (f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function (point) {
                return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
                while (++i < n) {
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                }
                --i;
            } else
                data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
        }
        quadtree.x = function (_) {
            return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function (_) {
            return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function (_) {
            if (!arguments.length)
                return x1 == null ? null : [
                    [
                        x1,
                        y1
                    ],
                    [
                        x2,
                        y2
                    ]
                ];
            if (_ == null)
                x1 = y1 = x2 = y2 = null;
            else
                x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
            return quadtree;
        };
        quadtree.size = function (_) {
            if (!arguments.length)
                return x1 == null ? null : [
                    x2 - x1,
                    y2 - y1
                ];
            if (_ == null)
                x1 = y1 = x2 = y2 = null;
            else
                x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            return quadtree;
        };
        return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * 0.5, sy = (y1 + y2) * 0.5, children = node.nodes;
            if (children[0])
                d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1])
                d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2])
                d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3])
                d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
    }
    function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity, closestPoint;
        (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0)
                return;
            if (point = node.point) {
                var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                if (distance2 < minDistance2) {
                    var distance = Math.sqrt(minDistance2 = distance2);
                    x0 = x - distance, y0 = y - distance;
                    x3 = x + distance, y3 = y + distance;
                    closestPoint = point;
                }
            }
            var children = node.nodes, xm = (x1 + x2) * 0.5, ym = (y1 + y2) * 0.5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                if (node = children[i & 3])
                    switch (i & 3) {
                    case 0:
                        find(node, x1, y1, xm, ym);
                        break;
                    case 1:
                        find(node, xm, y1, x2, ym);
                        break;
                    case 2:
                        find(node, x1, ym, xm, y2);
                        break;
                    case 3:
                        find(node, xm, ym, x2, y2);
                        break;
                    }
            }
        }(root, x0, y0, x3, y3));
        return closestPoint;
    }
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
        return function (t) {
            return '#' + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
    }
    d3.interpolateObject = d3_interpolateObject;
    function d3_interpolateObject(a, b) {
        var i = {}, c = {}, k;
        for (k in a) {
            if (k in b) {
                i[k] = d3_interpolate(a[k], b[k]);
            } else {
                c[k] = a[k];
            }
        }
        for (k in b) {
            if (!(k in a)) {
                c[k] = b[k];
            }
        }
        return function (t) {
            for (k in i)
                c[k] = i[k](t);
            return c;
        };
    }
    d3.interpolateNumber = d3_interpolateNumber;
    function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function (t) {
            return a * (1 - t) + b * t;
        };
    }
    d3.interpolateString = d3_interpolateString;
    function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
        a = a + '', b = b + '';
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i])
                    s[i] += bs;
                else
                    s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i])
                    s[i] += bm;
                else
                    s[++i] = bm;
            } else {
                s[++i] = null;
                q.push({
                    i: i,
                    x: d3_interpolateNumber(am, bm)
                });
            }
            bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i])
                s[i] += bs;
            else
                s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function (t) {
            return b(t) + '';
        }) : function () {
            return b;
        } : (b = q.length, function (t) {
            for (var i = 0, o; i < b; ++i)
                s[(o = q[i]).i] = o.x(t);
            return s.join('');
        });
    }
    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, 'g');
    d3.interpolate = d3_interpolate;
    function d3_interpolate(a, b) {
        var i = d3.interpolators.length, f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b)));
        return f;
    }
    d3.interpolators = [function (a, b) {
            var t = typeof b;
            return (t === 'string' ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === 'object' && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
        }];
    d3.interpolateArray = d3_interpolateArray;
    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for (i = 0; i < n0; ++i)
            x.push(d3_interpolate(a[i], b[i]));
        for (; i < na; ++i)
            c[i] = a[i];
        for (; i < nb; ++i)
            c[i] = b[i];
        return function (t) {
            for (i = 0; i < n0; ++i)
                c[i] = x[i](t);
            return c;
        };
    }
    var d3_ease_default = function () {
        return d3_identity;
    };
    var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function () {
            return d3_ease_quad;
        },
        cubic: function () {
            return d3_ease_cubic;
        },
        sin: function () {
            return d3_ease_sin;
        },
        exp: function () {
            return d3_ease_exp;
        },
        circle: function () {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function () {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = d3.map({
        'in': d3_identity,
        out: d3_ease_reverse,
        'in-out': d3_ease_reflect,
        'out-in': function (f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });
    d3.ease = function (name) {
        var i = name.indexOf('-'), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : 'in';
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
    };
    function d3_ease_clamp(f) {
        return function (t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
    }
    function d3_ease_reverse(f) {
        return function (t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function (t) {
            return 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0)
            return 0;
        if (t >= 1)
            return 1;
        var t2 = t * t, t3 = t2 * t;
        return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
    }
    function d3_ease_poly(e) {
        return function (t) {
            return Math.pow(t, e);
        };
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfπ);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2)
            p = 0.45;
        if (arguments.length)
            s = p / τ * Math.asin(1 / a);
        else
            a = 1, s = p / 4;
        return function (t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
        };
    }
    function d3_ease_back(s) {
        if (!s)
            s = 1.70158;
        return function (t) {
            return t * t * ((s + 1) * t - s);
        };
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    }
    d3.interpolateHcl = d3_interpolateHcl;
    function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
        if (isNaN(bc))
            bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh))
            bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
            bh -= 360;
        else if (bh < -180)
            bh += 360;
        return function (t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + '';
        };
    }
    d3.interpolateHsl = d3_interpolateHsl;
    function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
        if (isNaN(bs))
            bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh))
            bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
            bh -= 360;
        else if (bh < -180)
            bh += 360;
        return function (t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + '';
        };
    }
    d3.interpolateLab = d3_interpolateLab;
    function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
        return function (t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + '';
        };
    }
    d3.interpolateRound = d3_interpolateRound;
    function d3_interpolateRound(a, b) {
        b -= a;
        return function (t) {
            return Math.round(a + b * t);
        };
    }
    d3.transform = function (string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, 'g');
        return (d3.transform = function (string) {
            if (string != null) {
                g.setAttribute('transform', string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
    };
    function d3_transform(m) {
        var r0 = [
                m.a,
                m.b
            ], r1 = [
                m.c,
                m.d
            ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [
            m.e,
            m.f
        ];
        this.scale = [
            kx,
            ky
        ];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
    }
    d3_transform.prototype.toString = function () {
        return 'translate(' + this.translate + ')rotate(' + this.rotate + ')skewX(' + this.skew + ')scale(' + this.scale + ')';
    };
    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
    d3.interpolateTransform = d3_interpolateTransform;
    function d3_interpolateTransformPop(s) {
        return s.length ? s.pop() + ',' : '';
    }
    function d3_interpolateTranslate(ta, tb, s, q) {
        if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
            var i = s.push('translate(', null, ',', null, ')');
            q.push({
                i: i - 4,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: i - 2,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        } else if (tb[0] || tb[1]) {
            s.push('translate(' + tb + ')');
        }
    }
    function d3_interpolateRotate(ra, rb, s, q) {
        if (ra !== rb) {
            if (ra - rb > 180)
                rb += 360;
            else if (rb - ra > 180)
                ra += 360;
            q.push({
                i: s.push(d3_interpolateTransformPop(s) + 'rotate(', null, ')') - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        } else if (rb) {
            s.push(d3_interpolateTransformPop(s) + 'rotate(' + rb + ')');
        }
    }
    function d3_interpolateSkew(wa, wb, s, q) {
        if (wa !== wb) {
            q.push({
                i: s.push(d3_interpolateTransformPop(s) + 'skewX(', null, ')') - 2,
                x: d3_interpolateNumber(wa, wb)
            });
        } else if (wb) {
            s.push(d3_interpolateTransformPop(s) + 'skewX(' + wb + ')');
        }
    }
    function d3_interpolateScale(ka, kb, s, q) {
        if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
            var i = s.push(d3_interpolateTransformPop(s) + 'scale(', null, ',', null, ')');
            q.push({
                i: i - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: i - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        } else if (kb[0] !== 1 || kb[1] !== 1) {
            s.push(d3_interpolateTransformPop(s) + 'scale(' + kb + ')');
        }
    }
    function d3_interpolateTransform(a, b) {
        var s = [], q = [];
        a = d3.transform(a), b = d3.transform(b);
        d3_interpolateTranslate(a.translate, b.translate, s, q);
        d3_interpolateRotate(a.rotate, b.rotate, s, q);
        d3_interpolateSkew(a.skew, b.skew, s, q);
        d3_interpolateScale(a.scale, b.scale, s, q);
        a = b = null;
        return function (t) {
            var i = -1, n = q.length, o;
            while (++i < n)
                s[(o = q[i]).i] = o.x(t);
            return s.join('');
        };
    }
    function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
            return (x - a) / b;
        };
    }
    function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
            return Math.max(0, Math.min(1, (x - a) / b));
        };
    }
    d3.layout = {};
    d3.layout.bundle = function () {
        return function (links) {
            var paths = [], i = -1, n = links.length;
            while (++i < n)
                paths.push(d3_layout_bundlePath(links[i]));
            return paths;
        };
    };
    function d3_layout_bundlePath(link) {
        var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [start];
        while (start !== lca) {
            start = start.parent;
            points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
        }
        return points;
    }
    function d3_layout_bundleAncestors(node) {
        var ancestors = [], parent = node.parent;
        while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b)
            return a;
        var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
        while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
        }
        return sharedNode;
    }
    d3.layout.chord = function () {
        var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
        function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while (++i < n) {
                x = 0, j = -1;
                while (++j < n) {
                    x += matrix[i][j];
                }
                groupSums.push(x);
                subgroupIndex.push(d3.range(n));
                k += x;
            }
            if (sortGroups) {
                groupIndex.sort(function (a, b) {
                    return sortGroups(groupSums[a], groupSums[b]);
                });
            }
            if (sortSubgroups) {
                subgroupIndex.forEach(function (d, i) {
                    d.sort(function (a, b) {
                        return sortSubgroups(matrix[i][a], matrix[i][b]);
                    });
                });
            }
            k = (τ - padding * n) / k;
            x = 0, i = -1;
            while (++i < n) {
                x0 = x, j = -1;
                while (++j < n) {
                    var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                    subgroups[di + '-' + dj] = {
                        index: di,
                        subindex: dj,
                        startAngle: a0,
                        endAngle: a1,
                        value: v
                    };
                }
                groups[di] = {
                    index: di,
                    startAngle: x0,
                    endAngle: x,
                    value: groupSums[di]
                };
                x += padding;
            }
            i = -1;
            while (++i < n) {
                j = i - 1;
                while (++j < n) {
                    var source = subgroups[i + '-' + j], target = subgroups[j + '-' + i];
                    if (source.value || target.value) {
                        chords.push(source.value < target.value ? {
                            source: target,
                            target: source
                        } : {
                            source: source,
                            target: target
                        });
                    }
                }
            }
            if (sortChords)
                resort();
        }
        function resort() {
            chords.sort(function (a, b) {
                return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
        }
        chord.matrix = function (x) {
            if (!arguments.length)
                return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
        };
        chord.padding = function (x) {
            if (!arguments.length)
                return padding;
            padding = x;
            chords = groups = null;
            return chord;
        };
        chord.sortGroups = function (x) {
            if (!arguments.length)
                return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
        };
        chord.sortSubgroups = function (x) {
            if (!arguments.length)
                return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
        };
        chord.sortChords = function (x) {
            if (!arguments.length)
                return sortChords;
            sortChords = x;
            if (chords)
                resort();
            return chord;
        };
        chord.chords = function () {
            if (!chords)
                relayout();
            return chords;
        };
        chord.groups = function () {
            if (!groups)
                relayout();
            return groups;
        };
        return chord;
    };
    d3.layout.force = function () {
        var force = {}, event = d3.dispatch('start', 'tick', 'end'), timer, size = [
                1,
                1
            ], drag, alpha, friction = 0.9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = 0.1, theta2 = 0.64, nodes = [], links = [], distances, strengths, charges;
        function repulse(node) {
            return function (quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                    if (dw * dw / theta2 < dn) {
                        if (dn < chargeDistance2) {
                            var k = quad.charge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                        return true;
                    }
                    if (quad.point && dn && dn < chargeDistance2) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            };
        }
        force.tick = function () {
            if ((alpha *= 0.99) < 0.005) {
                timer = null;
                event.end({
                    type: 'end',
                    alpha: alpha = 0
                });
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : 0.5);
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size[0] / 2;
                y = size[1] / 2;
                i = -1;
                if (k)
                    while (++i < n) {
                        o = nodes[i];
                        o.x += (x - o.x) * k;
                        o.y += (y - o.y) * k;
                    }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                i = -1;
                while (++i < n) {
                    if (!(o = nodes[i]).fixed) {
                        q.visit(repulse(o));
                    }
                }
            }
            i = -1;
            while (++i < n) {
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                } else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }
            event.tick({
                type: 'tick',
                alpha: alpha
            });
        };
        force.nodes = function (x) {
            if (!arguments.length)
                return nodes;
            nodes = x;
            return force;
        };
        force.links = function (x) {
            if (!arguments.length)
                return links;
            links = x;
            return force;
        };
        force.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return force;
        };
        force.linkDistance = function (x) {
            if (!arguments.length)
                return linkDistance;
            linkDistance = typeof x === 'function' ? x : +x;
            return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function (x) {
            if (!arguments.length)
                return linkStrength;
            linkStrength = typeof x === 'function' ? x : +x;
            return force;
        };
        force.friction = function (x) {
            if (!arguments.length)
                return friction;
            friction = +x;
            return force;
        };
        force.charge = function (x) {
            if (!arguments.length)
                return charge;
            charge = typeof x === 'function' ? x : +x;
            return force;
        };
        force.chargeDistance = function (x) {
            if (!arguments.length)
                return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
        };
        force.gravity = function (x) {
            if (!arguments.length)
                return gravity;
            gravity = +x;
            return force;
        };
        force.theta = function (x) {
            if (!arguments.length)
                return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
        };
        force.alpha = function (x) {
            if (!arguments.length)
                return alpha;
            x = +x;
            if (alpha) {
                if (x > 0) {
                    alpha = x;
                } else {
                    timer.c = null, timer.t = NaN, timer = null;
                    event.end({
                        type: 'end',
                        alpha: alpha = 0
                    });
                }
            } else if (x > 0) {
                event.start({
                    type: 'start',
                    alpha: alpha = x
                });
                timer = d3_timer(force.tick);
            }
            return force;
        };
        force.start = function () {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
                (o = nodes[i]).index = i;
                o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
                o = links[i];
                if (typeof o.source == 'number')
                    o.source = nodes[o.source];
                if (typeof o.target == 'number')
                    o.target = nodes[o.target];
                ++o.source.weight;
                ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
                o = nodes[i];
                if (isNaN(o.x))
                    o.x = position('x', w);
                if (isNaN(o.y))
                    o.y = position('y', h);
                if (isNaN(o.px))
                    o.px = o.x;
                if (isNaN(o.py))
                    o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === 'function')
                for (i = 0; i < m; ++i)
                    distances[i] = +linkDistance.call(this, links[i], i);
            else
                for (i = 0; i < m; ++i)
                    distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === 'function')
                for (i = 0; i < m; ++i)
                    strengths[i] = +linkStrength.call(this, links[i], i);
            else
                for (i = 0; i < m; ++i)
                    strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === 'function')
                for (i = 0; i < n; ++i)
                    charges[i] = +charge.call(this, nodes[i], i);
            else
                for (i = 0; i < n; ++i)
                    charges[i] = charge;
            function position(dimension, size) {
                if (!neighbors) {
                    neighbors = new Array(n);
                    for (j = 0; j < n; ++j) {
                        neighbors[j] = [];
                    }
                    for (j = 0; j < m; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                var candidates = neighbors[i], j = -1, l = candidates.length, x;
                while (++j < l)
                    if (!isNaN(x = candidates[j][dimension]))
                        return x;
                return Math.random() * size;
            }
            return force.resume();
        };
        force.resume = function () {
            return force.alpha(0.1);
        };
        force.stop = function () {
            return force.alpha(0);
        };
        force.drag = function () {
            if (!drag)
                drag = d3.behavior.drag().origin(d3_identity).on('dragstart.force', d3_layout_forceDragstart).on('drag.force', dragmove).on('dragend.force', d3_layout_forceDragend);
            if (!arguments.length)
                return drag;
            this.on('mouseover.force', d3_layout_forceMouseover).on('mouseout.force', d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
        }
        return d3.rebind(force, event, 'on');
    };
    function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
    }
    function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
                c = nodes[i];
                if (c == null)
                    continue;
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - 0.5;
                quad.point.y += Math.random() - 0.5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }
    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
    d3.layout.hierarchy = function () {
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        function hierarchy(root) {
            var stack = [root], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
                nodes.push(node);
                if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                    var n, childs, child;
                    while (--n >= 0) {
                        stack.push(child = childs[n]);
                        child.parent = node;
                        child.depth = node.depth + 1;
                    }
                    if (value)
                        node.value = 0;
                    node.children = childs;
                } else {
                    if (value)
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    delete node.children;
                }
            }
            d3_layout_hierarchyVisitAfter(root, function (node) {
                var childs, parent;
                if (sort && (childs = node.children))
                    childs.sort(sort);
                if (value && (parent = node.parent))
                    parent.value += node.value;
            });
            return nodes;
        }
        hierarchy.sort = function (x) {
            if (!arguments.length)
                return sort;
            sort = x;
            return hierarchy;
        };
        hierarchy.children = function (x) {
            if (!arguments.length)
                return children;
            children = x;
            return hierarchy;
        };
        hierarchy.value = function (x) {
            if (!arguments.length)
                return value;
            value = x;
            return hierarchy;
        };
        hierarchy.revalue = function (root) {
            if (value) {
                d3_layout_hierarchyVisitBefore(root, function (node) {
                    if (node.children)
                        node.value = 0;
                });
                d3_layout_hierarchyVisitAfter(root, function (node) {
                    var parent;
                    if (!node.children)
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    if (parent = node.parent)
                        parent.value += node.value;
                });
            }
            return root;
        };
        return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, 'sort', 'children', 'value');
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [node];
        while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
                var n, children;
                while (--n >= 0)
                    nodes.push(children[n]);
            }
        }
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [node], nodes2 = [];
        while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
                var i = -1, n, children;
                while (++i < n)
                    nodes.push(children[i]);
            }
        }
        while ((node = nodes2.pop()) != null) {
            callback(node);
        }
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function (parent) {
            return (parent.children || []).map(function (child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    d3.layout.partition = function () {
        var hierarchy = d3.layout.hierarchy(), size = [
                1,
                1
            ];
        function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
                var i = -1, n, c, d;
                dx = node.value ? dx / node.value : 0;
                while (++i < n) {
                    position(c = children[i], x, d = c.value * dx, dy);
                    x += d;
                }
            }
        }
        function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
                var i = -1, n;
                while (++i < n)
                    d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
        }
        function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
        }
        partition.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
    };
    d3.layout.pie = function () {
        var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
        function pie(data) {
            var n = data.length, values = data.map(function (d, i) {
                    return +value.call(pie, d, i);
                }), a = +(typeof startAngle === 'function' ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === 'function' ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === 'function' ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
            if (sort != null)
                index.sort(sort === d3_layout_pieSortByValue ? function (i, j) {
                    return values[j] - values[i];
                } : function (i, j) {
                    return sort(data[i], data[j]);
                });
            index.forEach(function (i) {
                arcs[i] = {
                    data: data[i],
                    value: v = values[i],
                    startAngle: a,
                    endAngle: a += v * k + pa,
                    padAngle: p
                };
            });
            return arcs;
        }
        pie.value = function (_) {
            if (!arguments.length)
                return value;
            value = _;
            return pie;
        };
        pie.sort = function (_) {
            if (!arguments.length)
                return sort;
            sort = _;
            return pie;
        };
        pie.startAngle = function (_) {
            if (!arguments.length)
                return startAngle;
            startAngle = _;
            return pie;
        };
        pie.endAngle = function (_) {
            if (!arguments.length)
                return endAngle;
            endAngle = _;
            return pie;
        };
        pie.padAngle = function (_) {
            if (!arguments.length)
                return padAngle;
            padAngle = _;
            return pie;
        };
        return pie;
    };
    var d3_layout_pieSortByValue = {};
    d3.layout.stack = function () {
        var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
        function stack(data, index) {
            if (!(n = data.length))
                return data;
            var series = data.map(function (d, i) {
                return values.call(stack, d, i);
            });
            var points = series.map(function (d) {
                return d.map(function (v, i) {
                    return [
                        x.call(stack, v, i),
                        y.call(stack, v, i)
                    ];
                });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var m = series[0].length, n, i, j, o;
            for (j = 0; j < m; ++j) {
                out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                for (i = 1; i < n; ++i) {
                    out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                }
            }
            return data;
        }
        stack.values = function (x) {
            if (!arguments.length)
                return values;
            values = x;
            return stack;
        };
        stack.order = function (x) {
            if (!arguments.length)
                return order;
            order = typeof x === 'function' ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
            return stack;
        };
        stack.offset = function (x) {
            if (!arguments.length)
                return offset;
            offset = typeof x === 'function' ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
            return stack;
        };
        stack.x = function (z) {
            if (!arguments.length)
                return x;
            x = z;
            return stack;
        };
        stack.y = function (z) {
            if (!arguments.length)
                return y;
            y = z;
            return stack;
        };
        stack.out = function (z) {
            if (!arguments.length)
                return out;
            out = z;
            return stack;
        };
        return stack;
    };
    function d3_layout_stackX(d) {
        return d.x;
    }
    function d3_layout_stackY(d) {
        return d.y;
    }
    function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
    }
    var d3_layout_stackOrders = d3.map({
        'inside-out': function (data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function (a, b) {
                    return max[a] - max[b];
                }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
                j = index[i];
                if (top < bottom) {
                    top += sums[j];
                    tops.push(j);
                } else {
                    bottom += sums[j];
                    bottoms.push(j);
                }
            }
            return bottoms.reverse().concat(tops);
        },
        reverse: function (data) {
            return d3.range(data.length).reverse();
        },
        'default': d3_layout_stackOrderDefault
    });
    var d3_layout_stackOffsets = d3.map({
        silhouette: function (data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++)
                    o += data[i][j][1];
                if (o > max)
                    max = o;
                sums.push(o);
            }
            for (j = 0; j < m; ++j) {
                y0[j] = (max - sums[j]) / 2;
            }
            return y0;
        },
        wiggle: function (data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
                for (i = 0, s1 = 0; i < n; ++i)
                    s1 += data[i][j][1];
                for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                    for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                        s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                    }
                    s2 += s3 * data[i][j][1];
                }
                y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                if (o < o0)
                    o0 = o;
            }
            for (j = 0; j < m; ++j)
                y0[j] -= o0;
            return y0;
        },
        expand: function (data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++)
                    o += data[i][j][1];
                if (o)
                    for (i = 0; i < n; i++)
                        data[i][j][1] /= o;
                else
                    for (i = 0; i < n; i++)
                        data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j)
                y0[j] = 0;
            return y0;
        },
        zero: d3_layout_stackOffsetZero
    });
    function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
    }
    function d3_layout_stackOffsetZero(data) {
        var j = -1, m = data[0].length, y0 = [];
        while (++j < m)
            y0[j] = 0;
        return y0;
    }
    function d3_layout_stackMaxIndex(array) {
        var i = 1, j = 0, v = array[0][1], k, n = array.length;
        for (; i < n; ++i) {
            if ((k = array[i][1]) > v) {
                j = i;
                v = k;
            }
        }
        return j;
    }
    function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
    }
    function d3_layout_stackSum(p, d) {
        return p + d[1];
    }
    d3.layout.histogram = function () {
        var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
                bin = bins[i] = [];
                bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                bin.y = 0;
            }
            if (m > 0) {
                i = -1;
                while (++i < n) {
                    x = values[i];
                    if (x >= range[0] && x <= range[1]) {
                        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                        bin.y += k;
                        bin.push(data[i]);
                    }
                }
            }
            return bins;
        }
        histogram.value = function (x) {
            if (!arguments.length)
                return valuer;
            valuer = x;
            return histogram;
        };
        histogram.range = function (x) {
            if (!arguments.length)
                return ranger;
            ranger = d3_functor(x);
            return histogram;
        };
        histogram.bins = function (x) {
            if (!arguments.length)
                return binner;
            binner = typeof x === 'number' ? function (range) {
                return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
        };
        histogram.frequency = function (x) {
            if (!arguments.length)
                return frequency;
            frequency = !!x;
            return histogram;
        };
        return histogram;
    };
    function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
    }
    function d3_layout_histogramBinFixed(range, n) {
        var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
        while (++x <= n)
            f[x] = m * x + b;
        return f;
    }
    function d3_layout_histogramRange(values) {
        return [
            d3.min(values),
            d3.max(values)
        ];
    }
    d3.layout.pack = function () {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [
                1,
                1
            ], radius;
        function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === 'function' ? radius : function () {
                    return radius;
                };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function (d) {
                d.r = +r(d.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
                var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                d3_layout_hierarchyVisitAfter(root, function (d) {
                    d.r += dr;
                });
                d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                d3_layout_hierarchyVisitAfter(root, function (d) {
                    d.r -= dr;
                });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
        }
        pack.size = function (_) {
            if (!arguments.length)
                return size;
            size = _;
            return pack;
        };
        pack.radius = function (_) {
            if (!arguments.length)
                return radius;
            radius = _ == null || typeof _ === 'function' ? _ : +_;
            return pack;
        };
        pack.padding = function (_) {
            if (!arguments.length)
                return padding;
            padding = +_;
            return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
    };
    function d3_layout_packSort(a, b) {
        return a.value - b.value;
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
        return 0.999 * dr * dr > dx * dx + dy * dy;
    }
    function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length))
            return;
        var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin);
            xMax = Math.max(node.x + node.r, xMax);
            yMin = Math.min(node.y - node.r, yMin);
            yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
                c = nodes[2];
                d3_layout_packPlace(a, b, c);
                bound(c);
                d3_layout_packInsert(a, c);
                a._pack_prev = c;
                d3_layout_packInsert(c, b);
                b = a._pack_next;
                for (i = 3; i < n; i++) {
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0, s1 = 1, s2 = 1;
                    for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                        if (d3_layout_packIntersects(j, c)) {
                            isect = 1;
                            break;
                        }
                    }
                    if (isect == 1) {
                        for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                            if (d3_layout_packIntersects(k, c)) {
                                break;
                            }
                        }
                    }
                    if (isect) {
                        if (s1 < s2 || s1 == s2 && b.r < a.r)
                            d3_layout_packSplice(a, b = j);
                        else
                            d3_layout_packSplice(a = k, b);
                        i--;
                    } else {
                        d3_layout_packInsert(a, c);
                        b = c;
                        bound(c);
                    }
                }
            }
        }
        var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
        for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
            var i = -1, n = children.length;
            while (++i < n)
                d3_layout_packTransform(children[i], x, y, k);
        }
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = 0.5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
        } else {
            c.x = a.x + db;
            c.y = a.y;
        }
    }
    d3.layout.tree = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [
                1,
                1
            ], nodeSize = null;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize)
                d3_layout_hierarchyVisitBefore(root0, sizeNode);
            else {
                var left = root0, right = root0, bottom = root0;
                d3_layout_hierarchyVisitBefore(root0, function (node) {
                    if (node.x < left.x)
                        left = node;
                    if (node.x > right.x)
                        right = node;
                    if (node.depth > bottom.depth)
                        bottom = node;
                });
                var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                d3_layout_hierarchyVisitBefore(root0, function (node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                });
            }
            return nodes;
        }
        function wrapTree(root0) {
            var root1 = {
                    A: null,
                    children: [root0]
                }, queue = [root1], node1;
            while ((node1 = queue.pop()) != null) {
                for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                    queue.push((children[i] = child = {
                        _: children[i],
                        parent: node1,
                        children: (child = children[i].children) && child.slice() || [],
                        A: null,
                        a: null,
                        z: 0,
                        m: 0,
                        c: 0,
                        s: 0,
                        t: null,
                        i: i
                    }).a = child);
                }
            }
            return root1.children[0];
        }
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
                d3_layout_treeShift(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                } else {
                    v.z = midpoint;
                }
            } else if (w) {
                v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
            if (w) {
                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                    vom = d3_layout_treeLeft(vom);
                    vop = d3_layout_treeRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                        d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                }
                if (vim && !d3_layout_treeRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                }
                if (vip && !d3_layout_treeLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                }
            }
            return ancestor;
        }
        function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
        }
        tree.separation = function (x) {
            if (!arguments.length)
                return separation;
            separation = x;
            return tree;
        };
        tree.size = function (x) {
            if (!arguments.length)
                return nodeSize ? null : size;
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
        };
        tree.nodeSize = function (x) {
            if (!arguments.length)
                return nodeSize ? size : null;
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
    }
    function d3_layout_treeRight(v) {
        var children = v.children, n;
        return (n = children.length) ? children[n - 1] : v.t;
    }
    function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
    }
    function d3_layout_treeShift(v) {
        var shift = 0, change = 0, children = v.children, i = children.length, w;
        while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
        }
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    d3.layout.cluster = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [
                1,
                1
            ], nodeSize = false;
        function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_hierarchyVisitAfter(root, function (node) {
                var children = node.children;
                if (children && children.length) {
                    node.x = d3_layout_clusterX(children);
                    node.y = d3_layout_clusterY(children);
                } else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function (node) {
                node.x = (node.x - root.x) * size[0];
                node.y = (root.y - node.y) * size[1];
            } : function (node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
        }
        cluster.separation = function (x) {
            if (!arguments.length)
                return separation;
            separation = x;
            return cluster;
        };
        cluster.size = function (x) {
            if (!arguments.length)
                return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
        };
        cluster.nodeSize = function (x) {
            if (!arguments.length)
                return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
    };
    function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function (child) {
            return child.y;
        });
    }
    function d3_layout_clusterX(children) {
        return children.reduce(function (x, child) {
            return x + child.x;
        }, 0) / children.length;
    }
    function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
    }
    function d3_layout_clusterRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
    }
    d3.layout.treemap = function () {
        var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [
                1,
                1
            ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = 'squarify', ratio = 0.5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === 'slice' ? rect.dx : mode === 'dice' ? rect.dy : mode === 'slice-dice' ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while ((n = remaining.length) > 0) {
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== 'squarify' || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    } else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while (child = remaining.pop()) {
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
                if (!(r = row[i].area))
                    continue;
                if (r < rmin)
                    rmin = r;
                if (r > rmax)
                    rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy)
                    v = rect.dy;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            } else {
                if (flush || v > rect.dx)
                    v = rect.dx;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = root.y = 0;
            if (root.value)
                root.dx = size[0], root.dy = size[1];
            else
                root.dx = root.dy = 0;
            if (stickies)
                hierarchy.revalue(root);
            scale([root], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky)
                stickies = nodes;
            return nodes;
        }
        treemap.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return treemap;
        };
        treemap.padding = function (x) {
            if (!arguments.length)
                return padding;
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === 'number' ? [
                    p,
                    p,
                    p,
                    p
                ] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === 'function' ? padFunction : type === 'number' ? (x = [
                x,
                x,
                x,
                x
            ], padConstant) : padConstant;
            return treemap;
        };
        treemap.round = function (x) {
            if (!arguments.length)
                return round != Number;
            round = x ? Math.round : Number;
            return treemap;
        };
        treemap.sticky = function (x) {
            if (!arguments.length)
                return sticky;
            sticky = x;
            stickies = null;
            return treemap;
        };
        treemap.ratio = function (x) {
            if (!arguments.length)
                return ratio;
            ratio = x;
            return treemap;
        };
        treemap.mode = function (x) {
            if (!arguments.length)
                return mode;
            mode = x + '';
            return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }
    d3.random = {
        normal: function (µ, σ) {
            var n = arguments.length;
            if (n < 2)
                σ = 1;
            if (n < 1)
                µ = 0;
            return function () {
                var x, y, r;
                do {
                    x = Math.random() * 2 - 1;
                    y = Math.random() * 2 - 1;
                    r = x * x + y * y;
                } while (!r || r > 1);
                return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
            };
        },
        logNormal: function () {
            var random = d3.random.normal.apply(d3, arguments);
            return function () {
                return Math.exp(random());
            };
        },
        bates: function (m) {
            var random = d3.random.irwinHall(m);
            return function () {
                return random() / m;
            };
        },
        irwinHall: function (m) {
            return function () {
                for (var s = 0, j = 0; j < m; j++)
                    s += Math.random();
                return s;
            };
        }
    };
    d3.scale = {};
    function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start < stop ? [
            start,
            stop
        ] : [
            stop,
            start
        ];
    }
    function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function (x) {
            return i(u(x));
        };
    }
    function d3_scale_nice(domain, nice) {
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
        if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
    }
    function d3_scale_niceStep(step) {
        return step ? {
            floor: function (x) {
                return Math.floor(x / step) * step;
            },
            ceil: function (x) {
                return Math.ceil(x / step) * step;
            }
        } : d3_scale_niceIdentity;
    }
    var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
    };
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function (x) {
            var j = d3.bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        };
    }
    d3.scale.linear = function () {
        return d3_scale_linear([
            0,
            1
        ], [
            0,
            1
        ], d3_interpolate, false);
    };
    function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function (y) {
            return input(y);
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(Number);
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.rangeRound = function (x) {
            return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function (x) {
            if (!arguments.length)
                return clamp;
            clamp = x;
            return rescale();
        };
        scale.interpolate = function (x) {
            if (!arguments.length)
                return interpolate;
            interpolate = x;
            return rescale();
        };
        scale.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
            d3_scale_linearNice(domain, m);
            return rescale();
        };
        scale.copy = function () {
            return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
    }
    function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, 'range', 'rangeRound', 'interpolate', 'clamp');
    }
    function d3_scale_linearNice(domain, m) {
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        return domain;
    }
    function d3_scale_linearTickRange(domain, m) {
        if (m == null)
            m = 10;
        var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
        if (err <= 0.15)
            step *= 10;
        else if (err <= 0.35)
            step *= 5;
        else if (err <= 0.75)
            step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * 0.5;
        extent[2] = step;
        return extent;
    }
    function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
    }
    function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
            var match = d3_format_re.exec(format);
            match.shift();
            if (match[8] === 's') {
                var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                if (!match[7])
                    match[7] = '.' + d3_scale_linearPrecision(prefix.scale(range[2]));
                match[8] = 'f';
                format = d3.format(match.join(''));
                return function (d) {
                    return format(prefix.scale(d)) + prefix.symbol;
                };
            }
            if (!match[7])
                match[7] = '.' + d3_scale_linearFormatPrecision(match[8], range);
            format = match.join('');
        } else {
            format = ',.' + d3_scale_linearPrecision(range[2]) + 'f';
        }
        return d3.format(format);
    }
    var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
    };
    function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + 0.01);
    }
    function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== 'e') : p - (type === '%') * 2;
    }
    d3.scale.log = function () {
        return d3_scale_log(d3.scale.linear().domain([
            0,
            1
        ]), 10, true, [
            1,
            10
        ]);
    };
    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function (x) {
            return pow(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        };
        scale.base = function (_) {
            if (!arguments.length)
                return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
        };
        scale.nice = function () {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
        };
        scale.ticks = function () {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
                if (positive) {
                    for (; i < j; i++)
                        for (var k = 1; k < n; k++)
                            ticks.push(pow(i) * k);
                    ticks.push(pow(i));
                } else {
                    ticks.push(pow(i));
                    for (; i++ < j;)
                        for (var k = n - 1; k > 0; k--)
                            ticks.push(pow(i) * k);
                }
                for (i = 0; ticks[i] < u; i++) {
                }
                for (j = ticks.length; ticks[j - 1] > v; j--) {
                }
                ticks = ticks.slice(i, j);
            }
            return ticks;
        };
        scale.tickFormat = function (n, format) {
            if (!arguments.length)
                return d3_scale_logFormat;
            if (arguments.length < 2)
                format = d3_scale_logFormat;
            else if (typeof format !== 'function')
                format = d3.format(format);
            var k = Math.max(1, base * n / scale.ticks().length);
            return function (d) {
                var i = d / pow(Math.round(log(d)));
                if (i * base < base - 0.5)
                    i *= base;
                return i <= k ? format(d) : '';
            };
        };
        scale.copy = function () {
            return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    var d3_scale_logFormat = d3.format('.0e'), d3_scale_logNiceNegative = {
            floor: function (x) {
                return -Math.ceil(-x);
            },
            ceil: function (x) {
                return -Math.floor(-x);
            }
        };
    d3.scale.pow = function () {
        return d3_scale_pow(d3.scale.linear(), 1, [
            0,
            1
        ]);
    };
    function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
            return linear(powp(x));
        }
        scale.invert = function (x) {
            return powb(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
        };
        scale.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
            return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function (x) {
            if (!arguments.length)
                return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
        };
        scale.copy = function () {
            return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_scale_powPow(e) {
        return function (x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
    }
    d3.scale.sqrt = function () {
        return d3.scale.pow().exponent(0.5);
    };
    d3.scale.ordinal = function () {
        return d3_scale_ordinal([], {
            t: 'range',
            a: [[]]
        });
    };
    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || (ranger.t === 'range' ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
            return d3.range(domain.length).map(function (i) {
                return start + step * i;
            });
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n)
                if (!index.has(xi = x[i]))
                    index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            rangeBand = 0;
            ranger = {
                t: 'range',
                a: arguments
            };
            return scale;
        };
        scale.rangePoints = function (x, padding) {
            if (arguments.length < 2)
                padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: 'rangePoints',
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundPoints = function (x, padding) {
            if (arguments.length < 2)
                padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
                t: 'rangeRoundPoints',
                a: arguments
            };
            return scale;
        };
        scale.rangeBands = function (x, padding, outerPadding) {
            if (arguments.length < 2)
                padding = 0;
            if (arguments.length < 3)
                outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse)
                range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
                t: 'rangeBands',
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundBands = function (x, padding, outerPadding) {
            if (arguments.length < 2)
                padding = 0;
            if (arguments.length < 3)
                outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse)
                range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: 'rangeRoundBands',
                a: arguments
            };
            return scale;
        };
        scale.rangeBand = function () {
            return rangeBand;
        };
        scale.rangeExtent = function () {
            return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function () {
            return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
    }
    d3.scale.category10 = function () {
        return d3.scale.ordinal().range(d3_category10);
    };
    d3.scale.category20 = function () {
        return d3.scale.ordinal().range(d3_category20);
    };
    d3.scale.category20b = function () {
        return d3.scale.ordinal().range(d3_category20b);
    };
    d3.scale.category20c = function () {
        return d3.scale.ordinal().range(d3_category20c);
    };
    var d3_category10 = [
        2062260,
        16744206,
        2924588,
        14034728,
        9725885,
        9197131,
        14907330,
        8355711,
        12369186,
        1556175
    ].map(d3_rgbString);
    var d3_category20 = [
        2062260,
        11454440,
        16744206,
        16759672,
        2924588,
        10018698,
        14034728,
        16750742,
        9725885,
        12955861,
        9197131,
        12885140,
        14907330,
        16234194,
        8355711,
        13092807,
        12369186,
        14408589,
        1556175,
        10410725
    ].map(d3_rgbString);
    var d3_category20b = [
        3750777,
        5395619,
        7040719,
        10264286,
        6519097,
        9216594,
        11915115,
        13556636,
        9202993,
        12426809,
        15186514,
        15190932,
        8666169,
        11356490,
        14049643,
        15177372,
        8077683,
        10834324,
        13528509,
        14589654
    ].map(d3_rgbString);
    var d3_category20c = [
        3244733,
        7057110,
        10406625,
        13032431,
        15095053,
        16616764,
        16625259,
        16634018,
        3253076,
        7652470,
        10607003,
        13101504,
        7695281,
        10394312,
        12369372,
        14342891,
        6513507,
        9868950,
        12434877,
        14277081
    ].map(d3_rgbString);
    d3.scale.quantile = function () {
        return d3_scale_quantile([], []);
    };
    function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while (++k < q)
                thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
        }
        function scale(x) {
            if (!isNaN(x = +x))
                return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.quantiles = function () {
            return thresholds;
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            return y < 0 ? [
                NaN,
                NaN
            ] : [
                y > 0 ? thresholds[y - 1] : domain[0],
                y < thresholds.length ? thresholds[y] : domain[domain.length - 1]
            ];
        };
        scale.copy = function () {
            return d3_scale_quantile(domain, range);
        };
        return rescale();
    }
    d3.scale.quantize = function () {
        return d3_scale_quantize(0, 1, [
            0,
            1
        ]);
    };
    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return [
                    x0,
                    x1
                ];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [
                y,
                y + 1 / kx
            ];
        };
        scale.copy = function () {
            return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
    }
    d3.scale.threshold = function () {
        return d3_scale_threshold([0.5], [
            0,
            1
        ]);
    };
    function d3_scale_threshold(domain, range) {
        function scale(x) {
            if (x <= x)
                return range[d3.bisect(domain, x)];
        }
        scale.domain = function (_) {
            if (!arguments.length)
                return domain;
            domain = _;
            return scale;
        };
        scale.range = function (_) {
            if (!arguments.length)
                return range;
            range = _;
            return scale;
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            return [
                domain[y - 1],
                domain[y]
            ];
        };
        scale.copy = function () {
            return d3_scale_threshold(domain, range);
        };
        return scale;
    }
    d3.scale.identity = function () {
        return d3_scale_identity([
            0,
            1
        ]);
    };
    function d3_scale_identity(domain) {
        function identity(x) {
            return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(identity);
            return identity;
        };
        identity.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function () {
            return d3_scale_identity(domain);
        };
        return identity;
    }
    d3.svg = {};
    function d3_zero() {
        return 0;
    }
    d3.svg.arc = function () {
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
        function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0)
                rc = r1, r1 = r0, r0 = rc;
            if (da >= τε)
                return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : '') + 'Z';
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                if (!cw)
                    p1 *= -1;
                if (r1)
                    p1 = d3_asin(rp / r1 * Math.sin(ap));
                if (r0)
                    p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
                x0 = r1 * Math.cos(a0 + p1);
                y0 = r1 * Math.sin(a0 + p1);
                x1 = r1 * Math.cos(a1 - p1);
                y1 = r1 * Math.sin(a1 - p1);
                var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
                if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                    var h1 = (a0 + a1) / 2;
                    x0 = r1 * Math.cos(h1);
                    y0 = r1 * Math.sin(h1);
                    x1 = y1 = null;
                }
            } else {
                x0 = y0 = 0;
            }
            if (r0) {
                x2 = r0 * Math.cos(a1 - p0);
                y2 = r0 * Math.sin(a1 - p0);
                x3 = r0 * Math.cos(a0 + p0);
                y3 = r0 * Math.sin(a0 + p0);
                var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
                if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                    var h0 = (a0 + a1) / 2;
                    x2 = r0 * Math.cos(h0);
                    y2 = r0 * Math.sin(h0);
                    x3 = y3 = null;
                }
            } else {
                x2 = y2 = 0;
            }
            if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > 0.001) {
                cr = r0 < r1 ^ cw ? 0 : 1;
                var rc1 = rc, rc0 = rc;
                if (da < π) {
                    var oc = x3 == null ? [
                            x2,
                            y2
                        ] : x1 == null ? [
                            x0,
                            y0
                        ] : d3_geom_polygonIntersect([
                            x0,
                            y0
                        ], [
                            x3,
                            y3
                        ], [
                            x1,
                            y1
                        ], [
                            x2,
                            y2
                        ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                    rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                    rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
                }
                if (x1 != null) {
                    var t30 = d3_svg_arcCornerTangents(x3 == null ? [
                            x2,
                            y2
                        ] : [
                            x3,
                            y3
                        ], [
                            x0,
                            y0
                        ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([
                            x1,
                            y1
                        ], [
                            x2,
                            y2
                        ], r1, rc1, cw);
                    if (rc === rc1) {
                        path.push('M', t30[0], 'A', rc1, ',', rc1, ' 0 0,', cr, ' ', t30[1], 'A', r1, ',', r1, ' 0 ', 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ',', cw, ' ', t12[1], 'A', rc1, ',', rc1, ' 0 0,', cr, ' ', t12[0]);
                    } else {
                        path.push('M', t30[0], 'A', rc1, ',', rc1, ' 0 1,', cr, ' ', t12[0]);
                    }
                } else {
                    path.push('M', x0, ',', y0);
                }
                if (x3 != null) {
                    var t03 = d3_svg_arcCornerTangents([
                            x0,
                            y0
                        ], [
                            x3,
                            y3
                        ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([
                            x2,
                            y2
                        ], x1 == null ? [
                            x0,
                            y0
                        ] : [
                            x1,
                            y1
                        ], r0, -rc0, cw);
                    if (rc === rc0) {
                        path.push('L', t21[0], 'A', rc0, ',', rc0, ' 0 0,', cr, ' ', t21[1], 'A', r0, ',', r0, ' 0 ', cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ',', 1 - cw, ' ', t03[1], 'A', rc0, ',', rc0, ' 0 0,', cr, ' ', t03[0]);
                    } else {
                        path.push('L', t21[0], 'A', rc0, ',', rc0, ' 0 0,', cr, ' ', t03[0]);
                    }
                } else {
                    path.push('L', x2, ',', y2);
                }
            } else {
                path.push('M', x0, ',', y0);
                if (x1 != null)
                    path.push('A', r1, ',', r1, ' 0 ', l1, ',', cw, ' ', x1, ',', y1);
                path.push('L', x2, ',', y2);
                if (x3 != null)
                    path.push('A', r0, ',', r0, ' 0 ', l0, ',', 1 - cw, ' ', x3, ',', y3);
            }
            path.push('Z');
            return path.join('');
        }
        function circleSegment(r1, cw) {
            return 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,' + cw + ' 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,' + cw + ' 0,' + r1;
        }
        arc.innerRadius = function (v) {
            if (!arguments.length)
                return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
        };
        arc.outerRadius = function (v) {
            if (!arguments.length)
                return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
        };
        arc.cornerRadius = function (v) {
            if (!arguments.length)
                return cornerRadius;
            cornerRadius = d3_functor(v);
            return arc;
        };
        arc.padRadius = function (v) {
            if (!arguments.length)
                return padRadius;
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
        };
        arc.startAngle = function (v) {
            if (!arguments.length)
                return startAngle;
            startAngle = d3_functor(v);
            return arc;
        };
        arc.endAngle = function (v) {
            if (!arguments.length)
                return endAngle;
            endAngle = d3_functor(v);
            return arc;
        };
        arc.padAngle = function (v) {
            if (!arguments.length)
                return padAngle;
            padAngle = d3_functor(v);
            return arc;
        };
        arc.centroid = function () {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
            return [
                Math.cos(a) * r,
                Math.sin(a) * r
            ];
        };
        return arc;
    };
    var d3_svg_arcAuto = 'auto';
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
    }
    function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
    }
    function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
            cx0 = cx1, cy0 = cy1;
        return [
            [
                cx0 - ox,
                cy0 - oy
            ],
            [
                cx0 * r1 / r,
                cy0 * r1 / r
            ]
        ];
    }
    function d3_svg_line(projection) {
        var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = 0.7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push('M', interpolate(projection(points), tension));
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points.push([
                        +fx.call(this, d, i),
                        +fy.call(this, d, i)
                    ]);
                } else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length)
                segment();
            return segments.length ? segments.join('') : null;
        }
        line.x = function (_) {
            if (!arguments.length)
                return x;
            x = _;
            return line;
        };
        line.y = function (_) {
            if (!arguments.length)
                return y;
            y = _;
            return line;
        };
        line.defined = function (_) {
            if (!arguments.length)
                return defined;
            defined = _;
            return line;
        };
        line.interpolate = function (_) {
            if (!arguments.length)
                return interpolateKey;
            if (typeof _ === 'function')
                interpolateKey = interpolate = _;
            else
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
        };
        line.tension = function (_) {
            if (!arguments.length)
                return tension;
            tension = _;
            return line;
        };
        return line;
    }
    d3.svg.line = function () {
        return d3_svg_line(d3_identity);
    };
    var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        'linear-closed': d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        'step-before': d3_svg_lineStepBefore,
        'step-after': d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        'basis-open': d3_svg_lineBasisOpen,
        'basis-closed': d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        'cardinal-open': d3_svg_lineCardinalOpen,
        'cardinal-closed': d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function (key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.length > 1 ? points.join('L') : points + 'Z';
    }
    function d3_svg_lineLinearClosed(points) {
        return points.join('L') + 'Z';
    }
    function d3_svg_lineStep(points) {
        var i = 0, n = points.length, p = points[0], path = [
                p[0],
                ',',
                p[1]
            ];
        while (++i < n)
            path.push('H', (p[0] + (p = points[i])[0]) / 2, 'V', p[1]);
        if (n > 1)
            path.push('H', p[0]);
        return path.join('');
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0, n = points.length, p = points[0], path = [
                p[0],
                ',',
                p[1]
            ];
        while (++i < n)
            path.push('V', (p = points[i])[1], 'H', p[0]);
        return path.join('');
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0, n = points.length, p = points[0], path = [
                p[0],
                ',',
                p[1]
            ];
        while (++i < n)
            path.push('H', (p = points[i])[0], 'V', p[1]);
        return path.join('');
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length, path = '', p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad) {
            path += 'Q' + (p[0] - t0[0] * 2 / 3) + ',' + (p[1] - t0[1] * 2 / 3) + ',' + p[0] + ',' + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += 'C' + (p0[0] + t0[0]) + ',' + (p0[1] + t0[1]) + ',' + (p[0] - t[0]) + ',' + (p[1] - t[1]) + ',' + p[0] + ',' + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
                p = points[pi];
                t = tangents[i];
                path += 'S' + (p[0] - t[0]) + ',' + (p[1] - t[1]) + ',' + p[0] + ',' + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += 'Q' + (p[0] + t[0] * 2 / 3) + ',' + (p[1] + t[1] * 2 / 3) + ',' + lp[0] + ',' + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([
                a * (p2[0] - p0[0]),
                a * (p2[1] - p0[1])
            ]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3)
            return d3_svg_lineLinear(points);
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [
                x0,
                x0,
                x0,
                (pi = points[1])[0]
            ], py = [
                y0,
                y0,
                y0,
                pi[1]
            ], path = [
                x0,
                ',',
                y0,
                'L',
                d3_svg_lineDot4(d3_svg_lineBasisBezier3, px),
                ',',
                d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
            ];
        points.push(points[n - 1]);
        while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push('L', pi);
        return path.join('');
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4)
            return d3_svg_lineLinear(points);
        var path = [], i = -1, n = points.length, pi, px = [0], py = [0];
        while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + ',' + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join('');
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [
            d3_svg_lineDot4(d3_svg_lineBasisBezier3, px),
            ',',
            d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
        ];
        --i;
        while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join('');
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [
            0,
            2 / 3,
            1 / 3,
            0
        ], d3_svg_lineBasisBezier2 = [
            0,
            1 / 3,
            2 / 3,
            0
        ], d3_svg_lineBasisBezier3 = [
            0,
            1 / 6,
            2 / 3,
            1 / 6
        ];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push('C', d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < ε) {
                m[i] = m[i + 1] = 0;
            } else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([
                s || 0,
                m[i] * s || 0
            ]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    d3.svg.line.radial = function () {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
    };
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - halfπ;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = 'L', tension = 0.7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function () {
                    return x;
                } : d3_functor(x1), fy1 = y0 === y1 ? function () {
                    return y;
                } : d3_functor(y1), x, y;
            function segment() {
                segments.push('M', interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), 'Z');
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points0.push([
                        x = +fx0.call(this, d, i),
                        y = +fy0.call(this, d, i)
                    ]);
                    points1.push([
                        +fx1.call(this, d, i),
                        +fy1.call(this, d, i)
                    ]);
                } else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length)
                segment();
            return segments.length ? segments.join('') : null;
        }
        area.x = function (_) {
            if (!arguments.length)
                return x1;
            x0 = x1 = _;
            return area;
        };
        area.x0 = function (_) {
            if (!arguments.length)
                return x0;
            x0 = _;
            return area;
        };
        area.x1 = function (_) {
            if (!arguments.length)
                return x1;
            x1 = _;
            return area;
        };
        area.y = function (_) {
            if (!arguments.length)
                return y1;
            y0 = y1 = _;
            return area;
        };
        area.y0 = function (_) {
            if (!arguments.length)
                return y0;
            y0 = _;
            return area;
        };
        area.y1 = function (_) {
            if (!arguments.length)
                return y1;
            y1 = _;
            return area;
        };
        area.defined = function (_) {
            if (!arguments.length)
                return defined;
            defined = _;
            return area;
        };
        area.interpolate = function (_) {
            if (!arguments.length)
                return interpolateKey;
            if (typeof _ === 'function')
                interpolateKey = interpolate = _;
            else
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? 'M' : 'L';
            return area;
        };
        area.tension = function (_) {
            if (!arguments.length)
                return tension;
            tension = _;
            return area;
        };
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    d3.svg.area = function () {
        return d3_svg_area(d3_identity);
    };
    d3.svg.area.radial = function () {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
    };
    d3.svg.chord = function () {
        var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return 'M' + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + 'Z';
        }
        function subgroup(self, f, d, i) {
            var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
            return {
                r: r,
                a0: a0,
                a1: a1,
                p0: [
                    r * Math.cos(a0),
                    r * Math.sin(a0)
                ],
                p1: [
                    r * Math.cos(a1),
                    r * Math.sin(a1)
                ]
            };
        }
        function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
            return 'A' + r + ',' + r + ' 0 ' + +(a > π) + ',1 ' + p;
        }
        function curve(r0, p0, r1, p1) {
            return 'Q 0,0 ' + p1;
        }
        chord.radius = function (v) {
            if (!arguments.length)
                return radius;
            radius = d3_functor(v);
            return chord;
        };
        chord.source = function (v) {
            if (!arguments.length)
                return source;
            source = d3_functor(v);
            return chord;
        };
        chord.target = function (v) {
            if (!arguments.length)
                return target;
            target = d3_functor(v);
            return chord;
        };
        chord.startAngle = function (v) {
            if (!arguments.length)
                return startAngle;
            startAngle = d3_functor(v);
            return chord;
        };
        chord.endAngle = function (v) {
            if (!arguments.length)
                return endAngle;
            endAngle = d3_functor(v);
            return chord;
        };
        return chord;
    };
    function d3_svg_chordRadius(d) {
        return d.radius;
    }
    d3.svg.diagonal = function () {
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [
                    p0,
                    {
                        x: p0.x,
                        y: m
                    },
                    {
                        x: p3.x,
                        y: m
                    },
                    p3
                ];
            p = p.map(projection);
            return 'M' + p[0] + 'C' + p[1] + ' ' + p[2] + ' ' + p[3];
        }
        diagonal.source = function (x) {
            if (!arguments.length)
                return source;
            source = d3_functor(x);
            return diagonal;
        };
        diagonal.target = function (x) {
            if (!arguments.length)
                return target;
            target = d3_functor(x);
            return diagonal;
        };
        diagonal.projection = function (x) {
            if (!arguments.length)
                return projection;
            projection = x;
            return diagonal;
        };
        return diagonal;
    };
    function d3_svg_diagonalProjection(d) {
        return [
            d.x,
            d.y
        ];
    }
    d3.svg.diagonal.radial = function () {
        var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
        diagonal.projection = function (x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
    };
    function d3_svg_diagonalRadialProjection(projection) {
        return function () {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
            return [
                r * Math.cos(a),
                r * Math.sin(a)
            ];
        };
    }
    d3.svg.symbol = function () {
        var type = d3_svg_symbolType, size = d3_svg_symbolSize;
        function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function (x) {
            if (!arguments.length)
                return type;
            type = d3_functor(x);
            return symbol;
        };
        symbol.size = function (x) {
            if (!arguments.length)
                return size;
            size = d3_functor(x);
            return symbol;
        };
        return symbol;
    };
    function d3_svg_symbolSize() {
        return 64;
    }
    function d3_svg_symbolType() {
        return 'circle';
    }
    function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / π);
        return 'M0,' + r + 'A' + r + ',' + r + ' 0 1,1 0,' + -r + 'A' + r + ',' + r + ' 0 1,1 0,' + r + 'Z';
    }
    var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function (size) {
            var r = Math.sqrt(size / 5) / 2;
            return 'M' + -3 * r + ',' + -r + 'H' + -r + 'V' + -3 * r + 'H' + r + 'V' + -r + 'H' + 3 * r + 'V' + r + 'H' + r + 'V' + 3 * r + 'H' + -r + 'V' + r + 'H' + -3 * r + 'Z';
        },
        diamond: function (size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return 'M0,' + -ry + 'L' + rx + ',0' + ' 0,' + ry + ' ' + -rx + ',0' + 'Z';
        },
        square: function (size) {
            var r = Math.sqrt(size) / 2;
            return 'M' + -r + ',' + -r + 'L' + r + ',' + -r + ' ' + r + ',' + r + ' ' + -r + ',' + r + 'Z';
        },
        'triangle-down': function (size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return 'M0,' + ry + 'L' + rx + ',' + -ry + ' ' + -rx + ',' + -ry + 'Z';
        },
        'triangle-up': function (size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return 'M0,' + -ry + 'L' + rx + ',' + ry + ' ' + -rx + ',' + ry + 'Z';
        }
    });
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    d3_selectionPrototype.transition = function (name) {
        var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
                time: Date.now(),
                ease: d3_ease_cubicInOut,
                delay: 0,
                duration: 250
            };
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i])
                    d3_transitionNode(node, i, ns, id, transition);
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_selectionPrototype.interrupt = function (name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
    };
    var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
    function d3_selection_interruptNS(ns) {
        return function () {
            var lock, activeId, active;
            if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
                active.timer.c = null;
                active.timer.t = NaN;
                if (--lock.count)
                    delete lock[activeId];
                else
                    delete this[ns];
                lock.active += 0.5;
                active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
        };
    }
    function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
    }
    var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
    d3_transitionPrototype.call = d3_selectionPrototype.call;
    d3_transitionPrototype.empty = d3_selectionPrototype.empty;
    d3_transitionPrototype.node = d3_selectionPrototype.node;
    d3_transitionPrototype.size = d3_selectionPrototype.size;
    d3.transition = function (selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
    };
    d3.transition.prototype = d3_transitionPrototype;
    d3_transitionPrototype.select = function (selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                    if ('__data__' in node)
                        subnode.__data__ = node.__data__;
                    d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                    subgroup.push(subnode);
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.selectAll = function (selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    transition = node[ns][id];
                    subnodes = selector.call(node, node.__data__, i, j);
                    subgroups.push(subgroup = []);
                    for (var k = -1, o = subnodes.length; ++k < o;) {
                        if (subnode = subnodes[k])
                            d3_transitionNode(subnode, k, ns, id, transition);
                        subgroup.push(subnode);
                    }
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.filter = function (filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== 'function')
            filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_transition(subgroups, this.namespace, this.id);
    };
    d3_transitionPrototype.tween = function (name, tween) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2)
            return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function (node) {
            node[ns][id].tween.remove(name);
        } : function (node) {
            node[ns][id].tween.set(name, tween);
        });
    };
    function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id, ns = groups.namespace;
        return d3_selection_each(groups, typeof value === 'function' ? function (node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function (node) {
            node[ns][id].tween.set(name, value);
        }));
    }
    d3_transitionPrototype.attr = function (nameNS, value) {
        if (arguments.length < 2) {
            for (value in nameNS)
                this.attr(value, nameNS[value]);
            return this;
        }
        var interpolate = nameNS == 'transform' ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
            return b == null ? attrNull : (b += '', function () {
                var a = this.getAttribute(name), i;
                return a !== b && (i = interpolate(a, b), function (t) {
                    this.setAttribute(name, i(t));
                });
            });
        }
        function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += '', function () {
                var a = this.getAttributeNS(name.space, name.local), i;
                return a !== b && (i = interpolate(a, b), function (t) {
                    this.setAttributeNS(name.space, name.local, i(t));
                });
            });
        }
        return d3_transition_tween(this, 'attr.' + nameNS, value, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.attrTween = function (nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function (t) {
                this.setAttribute(name, f(t));
            };
        }
        function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function (t) {
                this.setAttributeNS(name.space, name.local, f(t));
            };
        }
        return this.tween('attr.' + nameNS, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== 'string') {
                if (n < 2)
                    value = '';
                for (priority in name)
                    this.style(priority, name[priority], value);
                return this;
            }
            priority = '';
        }
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleString(b) {
            return b == null ? styleNull : (b += '', function () {
                var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                return a !== b && (i = d3_interpolate(a, b), function (t) {
                    this.style.setProperty(name, i(t), priority);
                });
            });
        }
        return d3_transition_tween(this, 'style.' + name, value, styleString);
    };
    d3_transitionPrototype.styleTween = function (name, tween, priority) {
        if (arguments.length < 3)
            priority = '';
        function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f && function (t) {
                this.style.setProperty(name, f(t), priority);
            };
        }
        return this.tween('style.' + name, styleTween);
    };
    d3_transitionPrototype.text = function (value) {
        return d3_transition_tween(this, 'text', value, d3_transition_text);
    };
    function d3_transition_text(b) {
        if (b == null)
            b = '';
        return function () {
            this.textContent = b;
        };
    }
    d3_transitionPrototype.remove = function () {
        var ns = this.namespace;
        return this.each('end.transition', function () {
            var p;
            if (this[ns].count < 2 && (p = this.parentNode))
                p.removeChild(this);
        });
    };
    d3_transitionPrototype.ease = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].ease;
        if (typeof value !== 'function')
            value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function (node) {
            node[ns][id].ease = value;
        });
    };
    d3_transitionPrototype.delay = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === 'function' ? function (node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function (node) {
            node[ns][id].delay = value;
        }));
    };
    d3_transitionPrototype.duration = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === 'function' ? function (node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function (node) {
            node[ns][id].duration = value;
        }));
    };
    d3_transitionPrototype.each = function (type, listener) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
                d3_transitionInheritId = id;
                d3_selection_each(this, function (node, i, j) {
                    d3_transitionInherit = node[ns][id];
                    type.call(node, node.__data__, i, j);
                });
            } finally {
                d3_transitionInherit = inherit;
                d3_transitionInheritId = inheritId;
            }
        } else {
            d3_selection_each(this, function (node) {
                var transition = node[ns][id];
                (transition.event || (transition.event = d3.dispatch('start', 'end', 'interrupt'))).on(type, listener);
            });
        }
        return this;
    };
    d3_transitionPrototype.transition = function () {
        var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if (node = group[i]) {
                    transition = node[ns][id0];
                    d3_transitionNode(node, i, ns, id1, {
                        time: transition.time,
                        ease: transition.ease,
                        delay: transition.delay + transition.duration,
                        duration: transition.duration
                    });
                }
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id1);
    };
    function d3_transitionNamespace(name) {
        return name == null ? '__transition__' : '__transition_' + name + '__';
    }
    function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
                active: 0,
                count: 0
            }), transition = lock[id], time, timer, duration, ease, tweens;
        function schedule(elapsed) {
            var delay = transition.delay;
            timer.t = delay + time;
            if (delay <= elapsed)
                return start(elapsed - delay);
            timer.c = start;
        }
        function start(elapsed) {
            var activeId = lock.active, active = lock[activeId];
            if (active) {
                active.timer.c = null;
                active.timer.t = NaN;
                --lock.count;
                delete lock[activeId];
                active.event && active.event.interrupt.call(node, node.__data__, active.index);
            }
            for (var cancelId in lock) {
                if (+cancelId < id) {
                    var cancel = lock[cancelId];
                    cancel.timer.c = null;
                    cancel.timer.t = NaN;
                    --lock.count;
                    delete lock[cancelId];
                }
            }
            timer.c = tick;
            d3_timer(function () {
                if (timer.c && tick(elapsed || 1)) {
                    timer.c = null;
                    timer.t = NaN;
                }
                return 1;
            }, 0, time);
            lock.active = id;
            transition.event && transition.event.start.call(node, node.__data__, i);
            tweens = [];
            transition.tween.forEach(function (key, value) {
                if (value = value.call(node, node.__data__, i)) {
                    tweens.push(value);
                }
            });
            ease = transition.ease;
            duration = transition.duration;
        }
        function tick(elapsed) {
            var t = elapsed / duration, e = ease(t), n = tweens.length;
            while (n > 0) {
                tweens[--n].call(node, e);
            }
            if (t >= 1) {
                transition.event && transition.event.end.call(node, node.__data__, i);
                if (--lock.count)
                    delete lock[id];
                else
                    delete node[ns];
                return 1;
            }
        }
        if (!transition) {
            time = inherit.time;
            timer = d3_timer(schedule, 0, time);
            transition = lock[id] = {
                tween: new d3_Map(),
                time: time,
                timer: timer,
                delay: inherit.delay,
                duration: inherit.duration,
                ease: inherit.ease,
                index: i
            };
            inherit = null;
            ++lock.count;
        }
    }
    d3.svg.axis = function () {
        var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [10], tickValues = null, tickFormat_;
        function axis(g) {
            g.each(function () {
                var g = d3.select(this);
                var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
                var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll('.tick').data(ticks, scale1), tickEnter = tick.enter().insert('g', '.domain').attr('class', 'tick').style('opacity', ε), tickExit = d3.transition(tick.exit()).style('opacity', ε).remove(), tickUpdate = d3.transition(tick.order()).style('opacity', 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
                var range = d3_scaleRange(scale1), path = g.selectAll('.domain').data([0]), pathUpdate = (path.enter().append('path').attr('class', 'domain'), d3.transition(path));
                tickEnter.append('line');
                tickEnter.append('text');
                var lineEnter = tickEnter.select('line'), lineUpdate = tickUpdate.select('line'), text = tick.select('text').text(tickFormat), textEnter = tickEnter.select('text'), textUpdate = tickUpdate.select('text'), sign = orient === 'top' || orient === 'left' ? -1 : 1, x1, x2, y1, y2;
                if (orient === 'bottom' || orient === 'top') {
                    tickTransform = d3_svg_axisX, x1 = 'x', y1 = 'y', x2 = 'x2', y2 = 'y2';
                    text.attr('dy', sign < 0 ? '0em' : '.71em').style('text-anchor', 'middle');
                    pathUpdate.attr('d', 'M' + range[0] + ',' + sign * outerTickSize + 'V0H' + range[1] + 'V' + sign * outerTickSize);
                } else {
                    tickTransform = d3_svg_axisY, x1 = 'y', y1 = 'x', x2 = 'y2', y2 = 'x2';
                    text.attr('dy', '.32em').style('text-anchor', sign < 0 ? 'end' : 'start');
                    pathUpdate.attr('d', 'M' + sign * outerTickSize + ',' + range[0] + 'H0V' + range[1] + 'H' + sign * outerTickSize);
                }
                lineEnter.attr(y2, sign * innerTickSize);
                textEnter.attr(y1, sign * tickSpacing);
                lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
                textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
                if (scale1.rangeBand) {
                    var x = scale1, dx = x.rangeBand() / 2;
                    scale0 = scale1 = function (d) {
                        return x(d) + dx;
                    };
                } else if (scale0.rangeBand) {
                    scale0 = scale1;
                } else {
                    tickExit.call(tickTransform, scale1, scale0);
                }
                tickEnter.call(tickTransform, scale0, scale1);
                tickUpdate.call(tickTransform, scale1, scale1);
            });
        }
        axis.scale = function (x) {
            if (!arguments.length)
                return scale;
            scale = x;
            return axis;
        };
        axis.orient = function (x) {
            if (!arguments.length)
                return orient;
            orient = x in d3_svg_axisOrients ? x + '' : d3_svg_axisDefaultOrient;
            return axis;
        };
        axis.ticks = function () {
            if (!arguments.length)
                return tickArguments_;
            tickArguments_ = d3_array(arguments);
            return axis;
        };
        axis.tickValues = function (x) {
            if (!arguments.length)
                return tickValues;
            tickValues = x;
            return axis;
        };
        axis.tickFormat = function (x) {
            if (!arguments.length)
                return tickFormat_;
            tickFormat_ = x;
            return axis;
        };
        axis.tickSize = function (x) {
            var n = arguments.length;
            if (!n)
                return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
        };
        axis.innerTickSize = function (x) {
            if (!arguments.length)
                return innerTickSize;
            innerTickSize = +x;
            return axis;
        };
        axis.outerTickSize = function (x) {
            if (!arguments.length)
                return outerTickSize;
            outerTickSize = +x;
            return axis;
        };
        axis.tickPadding = function (x) {
            if (!arguments.length)
                return tickPadding;
            tickPadding = +x;
            return axis;
        };
        axis.tickSubdivide = function () {
            return arguments.length && axis;
        };
        return axis;
    };
    var d3_svg_axisDefaultOrient = 'bottom', d3_svg_axisOrients = {
            top: 1,
            right: 1,
            bottom: 1,
            left: 1
        };
    function d3_svg_axisX(selection, x0, x1) {
        selection.attr('transform', function (d) {
            var v0 = x0(d);
            return 'translate(' + (isFinite(v0) ? v0 : x1(d)) + ',0)';
        });
    }
    function d3_svg_axisY(selection, y0, y1) {
        selection.attr('transform', function (d) {
            var v0 = y0(d);
            return 'translate(0,' + (isFinite(v0) ? v0 : y1(d)) + ')';
        });
    }
    d3.svg.brush = function () {
        var event = d3_eventDispatch(brush, 'brushstart', 'brush', 'brushend'), x = null, y = null, xExtent = [
                0,
                0
            ], yExtent = [
                0,
                0
            ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
        function brush(g) {
            g.each(function () {
                var g = d3.select(this).style('pointer-events', 'all').style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)').on('mousedown.brush', brushstart).on('touchstart.brush', brushstart);
                var background = g.selectAll('.background').data([0]);
                background.enter().append('rect').attr('class', 'background').style('visibility', 'hidden').style('cursor', 'crosshair');
                g.selectAll('.extent').data([0]).enter().append('rect').attr('class', 'extent').style('cursor', 'move');
                var resize = g.selectAll('.resize').data(resizes, d3_identity);
                resize.exit().remove();
                resize.enter().append('g').attr('class', function (d) {
                    return 'resize ' + d;
                }).style('cursor', function (d) {
                    return d3_svg_brushCursor[d];
                }).append('rect').attr('x', function (d) {
                    return /[ew]$/.test(d) ? -3 : null;
                }).attr('y', function (d) {
                    return /^[ns]/.test(d) ? -3 : null;
                }).attr('width', 6).attr('height', 6).style('visibility', 'hidden');
                resize.style('display', brush.empty() ? 'none' : null);
                var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
                if (x) {
                    range = d3_scaleRange(x);
                    backgroundUpdate.attr('x', range[0]).attr('width', range[1] - range[0]);
                    redrawX(gUpdate);
                }
                if (y) {
                    range = d3_scaleRange(y);
                    backgroundUpdate.attr('y', range[0]).attr('height', range[1] - range[0]);
                    redrawY(gUpdate);
                }
                redraw(gUpdate);
            });
        }
        brush.event = function (g) {
            g.each(function () {
                var event_ = event.of(this, arguments), extent1 = {
                        x: xExtent,
                        y: yExtent,
                        i: xExtentDomain,
                        j: yExtentDomain
                    }, extent0 = this.__chart__ || extent1;
                this.__chart__ = extent1;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each('start.brush', function () {
                        xExtentDomain = extent0.i;
                        yExtentDomain = extent0.j;
                        xExtent = extent0.x;
                        yExtent = extent0.y;
                        event_({ type: 'brushstart' });
                    }).tween('brush:brush', function () {
                        var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                        xExtentDomain = yExtentDomain = null;
                        return function (t) {
                            xExtent = extent1.x = xi(t);
                            yExtent = extent1.y = yi(t);
                            event_({
                                type: 'brush',
                                mode: 'resize'
                            });
                        };
                    }).each('end.brush', function () {
                        xExtentDomain = extent1.i;
                        yExtentDomain = extent1.j;
                        event_({
                            type: 'brush',
                            mode: 'resize'
                        });
                        event_({ type: 'brushend' });
                    });
                } else {
                    event_({ type: 'brushstart' });
                    event_({
                        type: 'brush',
                        mode: 'resize'
                    });
                    event_({ type: 'brushend' });
                }
            });
        };
        function redraw(g) {
            g.selectAll('.resize').attr('transform', function (d) {
                return 'translate(' + xExtent[+/e$/.test(d)] + ',' + yExtent[+/^s/.test(d)] + ')';
            });
        }
        function redrawX(g) {
            g.select('.extent').attr('x', xExtent[0]);
            g.selectAll('.extent,.n>rect,.s>rect').attr('width', xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
            g.select('.extent').attr('y', yExtent[0]);
            g.selectAll('.extent,.e>rect,.w>rect').attr('height', yExtent[1] - yExtent[0]);
        }
        function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed('extent'), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window(target)).on('keydown.brush', keydown).on('keyup.brush', keyup);
            if (d3.event.changedTouches) {
                w.on('touchmove.brush', brushmove).on('touchend.brush', brushend);
            } else {
                w.on('mousemove.brush', brushmove).on('mouseup.brush', brushend);
            }
            g.interrupt().selectAll('*').interrupt();
            if (dragging) {
                origin[0] = xExtent[0] - origin[0];
                origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
                var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                offset = [
                    xExtent[1 - ex] - origin[0],
                    yExtent[1 - ey] - origin[1]
                ];
                origin[0] = xExtent[ex];
                origin[1] = yExtent[ey];
            } else if (d3.event.altKey)
                center = origin.slice();
            g.style('pointer-events', 'none').selectAll('.resize').style('display', null);
            d3.select('body').style('cursor', eventTarget.style('cursor'));
            event_({ type: 'brushstart' });
            brushmove();
            function keydown() {
                if (d3.event.keyCode == 32) {
                    if (!dragging) {
                        center = null;
                        origin[0] -= xExtent[1];
                        origin[1] -= yExtent[1];
                        dragging = 2;
                    }
                    d3_eventPreventDefault();
                }
            }
            function keyup() {
                if (d3.event.keyCode == 32 && dragging == 2) {
                    origin[0] += xExtent[1];
                    origin[1] += yExtent[1];
                    dragging = 0;
                    d3_eventPreventDefault();
                }
            }
            function brushmove() {
                var point = d3.mouse(target), moved = false;
                if (offset) {
                    point[0] += offset[0];
                    point[1] += offset[1];
                }
                if (!dragging) {
                    if (d3.event.altKey) {
                        if (!center)
                            center = [
                                (xExtent[0] + xExtent[1]) / 2,
                                (yExtent[0] + yExtent[1]) / 2
                            ];
                        origin[0] = xExtent[+(point[0] < center[0])];
                        origin[1] = yExtent[+(point[1] < center[1])];
                    } else
                        center = null;
                }
                if (resizingX && move1(point, x, 0)) {
                    redrawX(g);
                    moved = true;
                }
                if (resizingY && move1(point, y, 1)) {
                    redrawY(g);
                    moved = true;
                }
                if (moved) {
                    redraw(g);
                    event_({
                        type: 'brush',
                        mode: dragging ? 'move' : 'resize'
                    });
                }
            }
            function move1(point, scale, i) {
                var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
                if (dragging) {
                    r0 -= position;
                    r1 -= size + position;
                }
                min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
                if (dragging) {
                    max = (min += position) + size;
                } else {
                    if (center)
                        position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                    if (position < min) {
                        max = min;
                        min = position;
                    } else {
                        max = position;
                    }
                }
                if (extent[0] != min || extent[1] != max) {
                    if (i)
                        yExtentDomain = null;
                    else
                        xExtentDomain = null;
                    extent[0] = min;
                    extent[1] = max;
                    return true;
                }
            }
            function brushend() {
                brushmove();
                g.style('pointer-events', 'all').selectAll('.resize').style('display', brush.empty() ? 'none' : null);
                d3.select('body').style('cursor', null);
                w.on('mousemove.brush', null).on('mouseup.brush', null).on('touchmove.brush', null).on('touchend.brush', null).on('keydown.brush', null).on('keyup.brush', null);
                dragRestore();
                event_({ type: 'brushend' });
            }
        }
        brush.x = function (z) {
            if (!arguments.length)
                return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.y = function (z) {
            if (!arguments.length)
                return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.clamp = function (z) {
            if (!arguments.length)
                return x && y ? [
                    xClamp,
                    yClamp
                ] : x ? xClamp : y ? yClamp : null;
            if (x && y)
                xClamp = !!z[0], yClamp = !!z[1];
            else if (x)
                xClamp = !!z;
            else if (y)
                yClamp = !!z;
            return brush;
        };
        brush.extent = function (z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
                if (x) {
                    if (xExtentDomain) {
                        x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                    } else {
                        x0 = xExtent[0], x1 = xExtent[1];
                        if (x.invert)
                            x0 = x.invert(x0), x1 = x.invert(x1);
                        if (x1 < x0)
                            t = x0, x0 = x1, x1 = t;
                    }
                }
                if (y) {
                    if (yExtentDomain) {
                        y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                    } else {
                        y0 = yExtent[0], y1 = yExtent[1];
                        if (y.invert)
                            y0 = y.invert(y0), y1 = y.invert(y1);
                        if (y1 < y0)
                            t = y0, y0 = y1, y1 = t;
                    }
                }
                return x && y ? [
                    [
                        x0,
                        y0
                    ],
                    [
                        x1,
                        y1
                    ]
                ] : x ? [
                    x0,
                    x1
                ] : y && [
                    y0,
                    y1
                ];
            }
            if (x) {
                x0 = z[0], x1 = z[1];
                if (y)
                    x0 = x0[0], x1 = x1[0];
                xExtentDomain = [
                    x0,
                    x1
                ];
                if (x.invert)
                    x0 = x(x0), x1 = x(x1);
                if (x1 < x0)
                    t = x0, x0 = x1, x1 = t;
                if (x0 != xExtent[0] || x1 != xExtent[1])
                    xExtent = [
                        x0,
                        x1
                    ];
            }
            if (y) {
                y0 = z[0], y1 = z[1];
                if (x)
                    y0 = y0[1], y1 = y1[1];
                yExtentDomain = [
                    y0,
                    y1
                ];
                if (y.invert)
                    y0 = y(y0), y1 = y(y1);
                if (y1 < y0)
                    t = y0, y0 = y1, y1 = t;
                if (y0 != yExtent[0] || y1 != yExtent[1])
                    yExtent = [
                        y0,
                        y1
                    ];
            }
            return brush;
        };
        brush.clear = function () {
            if (!brush.empty()) {
                xExtent = [
                    0,
                    0
                ], yExtent = [
                    0,
                    0
                ];
                xExtentDomain = yExtentDomain = null;
            }
            return brush;
        };
        brush.empty = function () {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, 'on');
    };
    var d3_svg_brushCursor = {
        n: 'ns-resize',
        e: 'ew-resize',
        s: 'ns-resize',
        w: 'ew-resize',
        nw: 'nwse-resize',
        ne: 'nesw-resize',
        se: 'nwse-resize',
        sw: 'nesw-resize'
    };
    var d3_svg_brushResizes = [
        [
            'n',
            'e',
            's',
            'w',
            'nw',
            'ne',
            'se',
            'sw'
        ],
        [
            'e',
            'w'
        ],
        [
            'n',
            's'
        ],
        []
    ];
    var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
    var d3_time_formatUtc = d3_time_format.utc;
    var d3_time_formatIso = d3_time_formatUtc('%Y-%m-%dT%H:%M:%S.%LZ');
    d3_time_format.iso = Date.prototype.toISOString && +new Date('2000-01-01T00:00:00.000Z') ? d3_time_formatIsoNative : d3_time_formatIso;
    function d3_time_formatIsoNative(date) {
        return date.toISOString();
    }
    d3_time_formatIsoNative.parse = function (string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    };
    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
    d3_time.second = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 1000) * 1000);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1000);
    }, function (date) {
        return date.getSeconds();
    });
    d3_time.seconds = d3_time.second.range;
    d3_time.seconds.utc = d3_time.second.utc.range;
    d3_time.minute = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 60000) * 60000);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 60000);
    }, function (date) {
        return date.getMinutes();
    });
    d3_time.minutes = d3_time.minute.range;
    d3_time.minutes.utc = d3_time.minute.utc.range;
    d3_time.hour = d3_time_interval(function (date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 3600000 - timezone) + timezone) * 3600000);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 3600000);
    }, function (date) {
        return date.getHours();
    });
    d3_time.hours = d3_time.hour.range;
    d3_time.hours.utc = d3_time.hour.utc.range;
    d3_time.month = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
    }, function (date, offset) {
        date.setMonth(date.getMonth() + offset);
    }, function (date) {
        return date.getMonth();
    });
    d3_time.months = d3_time.month.range;
    d3_time.months.utc = d3_time.month.utc.range;
    function d3_time_scale(linear, methods, format) {
        function scale(x) {
            return linear(x);
        }
        scale.invert = function (x) {
            return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return linear.domain().map(d3_time_scaleDate);
            linear.domain(x);
            return scale;
        };
        function tickMethod(extent, count) {
            var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
            return i == d3_time_scaleSteps.length ? [
                methods.year,
                d3_scale_linearTickRange(extent.map(function (d) {
                    return d / 31536000000;
                }), count)[2]
            ] : !i ? [
                d3_time_scaleMilliseconds,
                d3_scale_linearTickRange(extent, count)[2]
            ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function (interval, skip) {
            var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === 'number' && tickMethod(extent, interval);
            if (method)
                interval = method[0], skip = method[1];
            function skipped(date) {
                return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
            }
            return scale.domain(d3_scale_nice(domain, skip > 1 ? {
                floor: function (date) {
                    while (skipped(date = interval.floor(date)))
                        date = d3_time_scaleDate(date - 1);
                    return date;
                },
                ceil: function (date) {
                    while (skipped(date = interval.ceil(date)))
                        date = d3_time_scaleDate(+date + 1);
                    return date;
                }
            } : interval));
        };
        scale.ticks = function (interval, skip) {
            var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === 'number' ? tickMethod(extent, interval) : !interval.range && [
                    { range: interval },
                    skip
                ];
            if (method)
                interval = method[0], skip = method[1];
            return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function () {
            return format;
        };
        scale.copy = function () {
            return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_time_scaleDate(t) {
        return new Date(t);
    }
    var d3_time_scaleSteps = [
        1000,
        5000,
        15000,
        30000,
        60000,
        300000,
        900000,
        1800000,
        3600000,
        10800000,
        21600000,
        43200000,
        86400000,
        172800000,
        604800000,
        2592000000,
        7776000000,
        31536000000
    ];
    var d3_time_scaleLocalMethods = [
        [
            d3_time.second,
            1
        ],
        [
            d3_time.second,
            5
        ],
        [
            d3_time.second,
            15
        ],
        [
            d3_time.second,
            30
        ],
        [
            d3_time.minute,
            1
        ],
        [
            d3_time.minute,
            5
        ],
        [
            d3_time.minute,
            15
        ],
        [
            d3_time.minute,
            30
        ],
        [
            d3_time.hour,
            1
        ],
        [
            d3_time.hour,
            3
        ],
        [
            d3_time.hour,
            6
        ],
        [
            d3_time.hour,
            12
        ],
        [
            d3_time.day,
            1
        ],
        [
            d3_time.day,
            2
        ],
        [
            d3_time.week,
            1
        ],
        [
            d3_time.month,
            1
        ],
        [
            d3_time.month,
            3
        ],
        [
            d3_time.year,
            1
        ]
    ];
    var d3_time_scaleLocalFormat = d3_time_format.multi([
        [
            '.%L',
            function (d) {
                return d.getMilliseconds();
            }
        ],
        [
            ':%S',
            function (d) {
                return d.getSeconds();
            }
        ],
        [
            '%I:%M',
            function (d) {
                return d.getMinutes();
            }
        ],
        [
            '%I %p',
            function (d) {
                return d.getHours();
            }
        ],
        [
            '%a %d',
            function (d) {
                return d.getDay() && d.getDate() != 1;
            }
        ],
        [
            '%b %d',
            function (d) {
                return d.getDate() != 1;
            }
        ],
        [
            '%B',
            function (d) {
                return d.getMonth();
            }
        ],
        [
            '%Y',
            d3_true
        ]
    ]);
    var d3_time_scaleMilliseconds = {
        range: function (start, stop, step) {
            return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
    };
    d3_time_scaleLocalMethods.year = d3_time.year;
    d3_time.scale = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
    };
    var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function (m) {
        return [
            m[0].utc,
            m[1]
        ];
    });
    var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([
        [
            '.%L',
            function (d) {
                return d.getUTCMilliseconds();
            }
        ],
        [
            ':%S',
            function (d) {
                return d.getUTCSeconds();
            }
        ],
        [
            '%I:%M',
            function (d) {
                return d.getUTCMinutes();
            }
        ],
        [
            '%I %p',
            function (d) {
                return d.getUTCHours();
            }
        ],
        [
            '%a %d',
            function (d) {
                return d.getUTCDay() && d.getUTCDate() != 1;
            }
        ],
        [
            '%b %d',
            function (d) {
                return d.getUTCDate() != 1;
            }
        ],
        [
            '%B',
            function (d) {
                return d.getUTCMonth();
            }
        ],
        [
            '%Y',
            d3_true
        ]
    ]);
    d3_time_scaleUtcMethods.year = d3_time.year.utc;
    d3_time.scale.utc = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
    };
    d3.text = d3_xhrType(function (request) {
        return request.responseText;
    });
    d3.json = function (url, callback) {
        return d3_xhr(url, 'application/json', d3_json, callback);
    };
    function d3_json(request) {
        return JSON.parse(request.responseText);
    }
    d3.html = function (url, callback) {
        return d3_xhr(url, 'text/html', d3_html, callback);
    };
    function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
    }
    d3.xml = d3_xhrType(function (request) {
        return request.responseXML;
    });
    if (typeof define === 'function' && define.amd)
        this.d3 = d3, define(d3);
    else if (typeof module === 'object' && module.exports)
        module.exports = d3;
    else
        this.d3 = d3;
}();
},{}],35:[function(require,module,exports){
'use strict';
module.exports = ready;
function ready(callback) {
    var state = document.readyState;
    if (state === 'complete' || state === 'interactive') {
        return setTimeout(callback, 0);
    }
    document.addEventListener('DOMContentLoaded', function onLoad() {
        callback();
    });
}
},{}],36:[function(require,module,exports){
var ElementType = require(37);
var entities = require(50);
var booleanAttributes = {
    __proto__: null,
    allowfullscreen: true,
    async: true,
    autofocus: true,
    autoplay: true,
    checked: true,
    controls: true,
    default: true,
    defer: true,
    disabled: true,
    hidden: true,
    ismap: true,
    loop: true,
    multiple: true,
    muted: true,
    open: true,
    readonly: true,
    required: true,
    reversed: true,
    scoped: true,
    seamless: true,
    selected: true,
    typemustmatch: true
};
var unencodedElements = {
    __proto__: null,
    style: true,
    script: true,
    xmp: true,
    iframe: true,
    noembed: true,
    noframes: true,
    plaintext: true,
    noscript: true
};
function formatAttrs(attributes, opts) {
    if (!attributes)
        return;
    var output = '', value;
    for (var key in attributes) {
        value = attributes[key];
        if (output) {
            output += ' ';
        }
        if (!value && booleanAttributes[key]) {
            output += key;
        } else {
            output += key + '="' + (opts.decodeEntities ? entities.encodeXML(value) : value) + '"';
        }
    }
    return output;
}
var singleTag = {
    __proto__: null,
    area: true,
    base: true,
    basefont: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    isindex: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true
};
var render = module.exports = function (dom, opts) {
    if (!Array.isArray(dom) && !dom.cheerio)
        dom = [dom];
    opts = opts || {};
    var output = '';
    for (var i = 0; i < dom.length; i++) {
        var elem = dom[i];
        if (elem.type === 'root')
            output += render(elem.children, opts);
        else if (ElementType.isTag(elem))
            output += renderTag(elem, opts);
        else if (elem.type === ElementType.Directive)
            output += renderDirective(elem);
        else if (elem.type === ElementType.Comment)
            output += renderComment(elem);
        else if (elem.type === ElementType.CDATA)
            output += renderCdata(elem);
        else
            output += renderText(elem, opts);
    }
    return output;
};
function renderTag(elem, opts) {
    if (elem.name === 'svg')
        opts = {
            decodeEntities: opts.decodeEntities,
            xmlMode: true
        };
    var tag = '<' + elem.name, attribs = formatAttrs(elem.attribs, opts);
    if (attribs) {
        tag += ' ' + attribs;
    }
    if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {
        tag += '/>';
    } else {
        tag += '>';
        if (elem.children) {
            tag += render(elem.children, opts);
        }
        if (!singleTag[elem.name] || opts.xmlMode) {
            tag += '</' + elem.name + '>';
        }
    }
    return tag;
}
function renderDirective(elem) {
    return '<' + elem.data + '>';
}
function renderText(elem, opts) {
    var data = elem.data || '';
    if (opts.decodeEntities && !(elem.parent && elem.parent.name in unencodedElements)) {
        data = entities.encodeXML(data);
    }
    return data;
}
function renderCdata(elem) {
    return '<![CDATA[' + elem.children[0].data + ']]>';
}
function renderComment(elem) {
    return '<!--' + elem.data + '-->';
}
},{"37":37,"50":50}],37:[function(require,module,exports){
module.exports = {
    Text: 'text',
    Directive: 'directive',
    Comment: 'comment',
    Script: 'script',
    Style: 'style',
    Tag: 'tag',
    CDATA: 'cdata',
    isTag: function (elem) {
        return elem.type === 'tag' || elem.type === 'script' || elem.type === 'style';
    }
};
},{}],38:[function(require,module,exports){
module.exports = {
    Text: 'text',
    Directive: 'directive',
    Comment: 'comment',
    Script: 'script',
    Style: 'style',
    Tag: 'tag',
    CDATA: 'cdata',
    Doctype: 'doctype',
    isTag: function (elem) {
        return elem.type === 'tag' || elem.type === 'script' || elem.type === 'style';
    }
};
},{}],39:[function(require,module,exports){
var ElementType = require(38);
var re_whitespace = /\s+/g;
var NodePrototype = require(41);
var ElementPrototype = require(40);
function DomHandler(callback, options, elementCB) {
    if (typeof callback === 'object') {
        elementCB = options;
        options = callback;
        callback = null;
    } else if (typeof options === 'function') {
        elementCB = options;
        options = defaultOpts;
    }
    this._callback = callback;
    this._options = options || defaultOpts;
    this._elementCB = elementCB;
    this.dom = [];
    this._done = false;
    this._tagStack = [];
    this._parser = this._parser || null;
}
var defaultOpts = {
    normalizeWhitespace: false,
    withStartIndices: false
};
DomHandler.prototype.onparserinit = function (parser) {
    this._parser = parser;
};
DomHandler.prototype.onreset = function () {
    DomHandler.call(this, this._callback, this._options, this._elementCB);
};
DomHandler.prototype.onend = function () {
    if (this._done)
        return;
    this._done = true;
    this._parser = null;
    this._handleCallback(null);
};
DomHandler.prototype._handleCallback = DomHandler.prototype.onerror = function (error) {
    if (typeof this._callback === 'function') {
        this._callback(error, this.dom);
    } else {
        if (error)
            throw error;
    }
};
DomHandler.prototype.onclosetag = function () {
    var elem = this._tagStack.pop();
    if (this._elementCB)
        this._elementCB(elem);
};
DomHandler.prototype._addDomElement = function (element) {
    var parent = this._tagStack[this._tagStack.length - 1];
    var siblings = parent ? parent.children : this.dom;
    var previousSibling = siblings[siblings.length - 1];
    element.next = null;
    if (this._options.withStartIndices) {
        element.startIndex = this._parser.startIndex;
    }
    if (this._options.withDomLvl1) {
        element.__proto__ = element.type === 'tag' ? ElementPrototype : NodePrototype;
    }
    if (previousSibling) {
        element.prev = previousSibling;
        previousSibling.next = element;
    } else {
        element.prev = null;
    }
    siblings.push(element);
    element.parent = parent || null;
};
DomHandler.prototype.onopentag = function (name, attribs) {
    var element = {
        type: name === 'script' ? ElementType.Script : name === 'style' ? ElementType.Style : ElementType.Tag,
        name: name,
        attribs: attribs,
        children: []
    };
    this._addDomElement(element);
    this._tagStack.push(element);
};
DomHandler.prototype.ontext = function (data) {
    var normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;
    var lastTag;
    if (!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length - 1]).type === ElementType.Text) {
        if (normalize) {
            lastTag.data = (lastTag.data + data).replace(re_whitespace, ' ');
        } else {
            lastTag.data += data;
        }
    } else {
        if (this._tagStack.length && (lastTag = this._tagStack[this._tagStack.length - 1]) && (lastTag = lastTag.children[lastTag.children.length - 1]) && lastTag.type === ElementType.Text) {
            if (normalize) {
                lastTag.data = (lastTag.data + data).replace(re_whitespace, ' ');
            } else {
                lastTag.data += data;
            }
        } else {
            if (normalize) {
                data = data.replace(re_whitespace, ' ');
            }
            this._addDomElement({
                data: data,
                type: ElementType.Text
            });
        }
    }
};
DomHandler.prototype.oncomment = function (data) {
    var lastTag = this._tagStack[this._tagStack.length - 1];
    if (lastTag && lastTag.type === ElementType.Comment) {
        lastTag.data += data;
        return;
    }
    var element = {
        data: data,
        type: ElementType.Comment
    };
    this._addDomElement(element);
    this._tagStack.push(element);
};
DomHandler.prototype.oncdatastart = function () {
    var element = {
        children: [{
                data: '',
                type: ElementType.Text
            }],
        type: ElementType.CDATA
    };
    this._addDomElement(element);
    this._tagStack.push(element);
};
DomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function () {
    this._tagStack.pop();
};
DomHandler.prototype.onprocessinginstruction = function (name, data) {
    this._addDomElement({
        name: name,
        data: data,
        type: ElementType.Directive
    });
};
module.exports = DomHandler;
},{"38":38,"40":40,"41":41}],40:[function(require,module,exports){
var NodePrototype = require(41);
var ElementPrototype = module.exports = Object.create(NodePrototype);
var domLvl1 = { tagName: 'name' };
Object.keys(domLvl1).forEach(function (key) {
    var shorthand = domLvl1[key];
    Object.defineProperty(ElementPrototype, key, {
        get: function () {
            return this[shorthand] || null;
        },
        set: function (val) {
            this[shorthand] = val;
            return val;
        }
    });
});
},{"41":41}],41:[function(require,module,exports){
var NodePrototype = module.exports = {
    get firstChild() {
        var children = this.children;
        return children && children[0] || null;
    },
    get lastChild() {
        var children = this.children;
        return children && children[children.length - 1] || null;
    },
    get nodeType() {
        return nodeTypes[this.type] || nodeTypes.element;
    }
};
var domLvl1 = {
    tagName: 'name',
    childNodes: 'children',
    parentNode: 'parent',
    previousSibling: 'prev',
    nextSibling: 'next',
    nodeValue: 'data'
};
var nodeTypes = {
    element: 1,
    text: 3,
    cdata: 4,
    comment: 8
};
Object.keys(domLvl1).forEach(function (key) {
    var shorthand = domLvl1[key];
    Object.defineProperty(NodePrototype, key, {
        get: function () {
            return this[shorthand] || null;
        },
        set: function (val) {
            this[shorthand] = val;
            return val;
        }
    });
});
},{}],42:[function(require,module,exports){
var DomUtils = module.exports;
[
    require(47),
    require(48),
    require(45),
    require(46),
    require(44),
    require(43)
].forEach(function (ext) {
    Object.keys(ext).forEach(function (key) {
        DomUtils[key] = ext[key].bind(DomUtils);
    });
});
},{"43":43,"44":44,"45":45,"46":46,"47":47,"48":48}],43:[function(require,module,exports){
exports.removeSubsets = function (nodes) {
    var idx = nodes.length, node, ancestor, replace;
    while (--idx > -1) {
        node = ancestor = nodes[idx];
        nodes[idx] = null;
        replace = true;
        while (ancestor) {
            if (nodes.indexOf(ancestor) > -1) {
                replace = false;
                nodes.splice(idx, 1);
                break;
            }
            ancestor = ancestor.parent;
        }
        if (replace) {
            nodes[idx] = node;
        }
    }
    return nodes;
};
var POSITION = {
    DISCONNECTED: 1,
    PRECEDING: 2,
    FOLLOWING: 4,
    CONTAINS: 8,
    CONTAINED_BY: 16
};
var comparePos = exports.compareDocumentPosition = function (nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    var current, sharedParent, siblings, aSibling, bSibling, idx;
    if (nodeA === nodeB) {
        return 0;
    }
    current = nodeA;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = nodeB;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    idx = 0;
    while (aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return POSITION.DISCONNECTED;
    }
    sharedParent = aParents[idx - 1];
    siblings = sharedParent.children;
    aSibling = aParents[idx];
    bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return POSITION.FOLLOWING | POSITION.CONTAINED_BY;
        }
        return POSITION.FOLLOWING;
    } else {
        if (sharedParent === nodeA) {
            return POSITION.PRECEDING | POSITION.CONTAINS;
        }
        return POSITION.PRECEDING;
    }
};
exports.uniqueSort = function (nodes) {
    var idx = nodes.length, node, position;
    nodes = nodes.slice();
    while (--idx > -1) {
        node = nodes[idx];
        position = nodes.indexOf(node);
        if (position > -1 && position < idx) {
            nodes.splice(idx, 1);
        }
    }
    nodes.sort(function (a, b) {
        var relative = comparePos(a, b);
        if (relative & POSITION.PRECEDING) {
            return -1;
        } else if (relative & POSITION.FOLLOWING) {
            return 1;
        }
        return 0;
    });
    return nodes;
};
},{}],44:[function(require,module,exports){
var ElementType = require(38);
var isTag = exports.isTag = ElementType.isTag;
exports.testElement = function (options, element) {
    for (var key in options) {
        if (!options.hasOwnProperty(key));
        else if (key === 'tag_name') {
            if (!isTag(element) || !options.tag_name(element.name)) {
                return false;
            }
        } else if (key === 'tag_type') {
            if (!options.tag_type(element.type))
                return false;
        } else if (key === 'tag_contains') {
            if (isTag(element) || !options.tag_contains(element.data)) {
                return false;
            }
        } else if (!element.attribs || !options[key](element.attribs[key])) {
            return false;
        }
    }
    return true;
};
var Checks = {
    tag_name: function (name) {
        if (typeof name === 'function') {
            return function (elem) {
                return isTag(elem) && name(elem.name);
            };
        } else if (name === '*') {
            return isTag;
        } else {
            return function (elem) {
                return isTag(elem) && elem.name === name;
            };
        }
    },
    tag_type: function (type) {
        if (typeof type === 'function') {
            return function (elem) {
                return type(elem.type);
            };
        } else {
            return function (elem) {
                return elem.type === type;
            };
        }
    },
    tag_contains: function (data) {
        if (typeof data === 'function') {
            return function (elem) {
                return !isTag(elem) && data(elem.data);
            };
        } else {
            return function (elem) {
                return !isTag(elem) && elem.data === data;
            };
        }
    }
};
function getAttribCheck(attrib, value) {
    if (typeof value === 'function') {
        return function (elem) {
            return elem.attribs && value(elem.attribs[attrib]);
        };
    } else {
        return function (elem) {
            return elem.attribs && elem.attribs[attrib] === value;
        };
    }
}
function combineFuncs(a, b) {
    return function (elem) {
        return a(elem) || b(elem);
    };
}
exports.getElements = function (options, element, recurse, limit) {
    var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return key in Checks ? Checks[key](value) : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? [] : this.filter(funcs.reduce(combineFuncs), element, recurse, limit);
};
exports.getElementById = function (id, element, recurse) {
    if (!Array.isArray(element))
        element = [element];
    return this.findOne(getAttribCheck('id', id), element, recurse !== false);
};
exports.getElementsByTagName = function (name, element, recurse, limit) {
    return this.filter(Checks.tag_name(name), element, recurse, limit);
};
exports.getElementsByTagType = function (type, element, recurse, limit) {
    return this.filter(Checks.tag_type(type), element, recurse, limit);
};
},{"38":38}],45:[function(require,module,exports){
exports.removeElement = function (elem) {
    if (elem.prev)
        elem.prev.next = elem.next;
    if (elem.next)
        elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
    }
};
exports.replaceElement = function (elem, replacement) {
    var prev = replacement.prev = elem.prev;
    if (prev) {
        prev.next = replacement;
    }
    var next = replacement.next = elem.next;
    if (next) {
        next.prev = replacement;
    }
    var parent = replacement.parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
    }
};
exports.appendChild = function (elem, child) {
    child.parent = elem;
    if (elem.children.push(child) !== 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
        child.next = null;
    }
};
exports.append = function (elem, next) {
    var parent = elem.parent, currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    } else if (parent) {
        parent.children.push(next);
    }
};
exports.prepend = function (elem, prev) {
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.lastIndexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
};
},{}],46:[function(require,module,exports){
var isTag = require(38).isTag;
module.exports = {
    filter: filter,
    find: find,
    findOneChild: findOneChild,
    findOne: findOne,
    existsOne: existsOne,
    findAll: findAll
};
function filter(test, element, recurse, limit) {
    if (!Array.isArray(element))
        element = [element];
    if (typeof limit !== 'number' || !isFinite(limit)) {
        limit = Infinity;
    }
    return find(test, element, recurse !== false, limit);
}
function find(test, elems, recurse, limit) {
    var result = [], childs;
    for (var i = 0, j = elems.length; i < j; i++) {
        if (test(elems[i])) {
            result.push(elems[i]);
            if (--limit <= 0)
                break;
        }
        childs = elems[i].children;
        if (recurse && childs && childs.length > 0) {
            childs = find(test, childs, recurse, limit);
            result = result.concat(childs);
            limit -= childs.length;
            if (limit <= 0)
                break;
        }
    }
    return result;
}
function findOneChild(test, elems) {
    for (var i = 0, l = elems.length; i < l; i++) {
        if (test(elems[i]))
            return elems[i];
    }
    return null;
}
function findOne(test, elems) {
    var elem = null;
    for (var i = 0, l = elems.length; i < l && !elem; i++) {
        if (!isTag(elems[i])) {
            continue;
        } else if (test(elems[i])) {
            elem = elems[i];
        } else if (elems[i].children.length > 0) {
            elem = findOne(test, elems[i].children);
        }
    }
    return elem;
}
function existsOne(test, elems) {
    for (var i = 0, l = elems.length; i < l; i++) {
        if (isTag(elems[i]) && (test(elems[i]) || elems[i].children.length > 0 && existsOne(test, elems[i].children))) {
            return true;
        }
    }
    return false;
}
function findAll(test, elems) {
    var result = [];
    for (var i = 0, j = elems.length; i < j; i++) {
        if (!isTag(elems[i]))
            continue;
        if (test(elems[i]))
            result.push(elems[i]);
        if (elems[i].children.length > 0) {
            result = result.concat(findAll(test, elems[i].children));
        }
    }
    return result;
}
},{"38":38}],47:[function(require,module,exports){
var ElementType = require(38), getOuterHTML = require(36), isTag = ElementType.isTag;
module.exports = {
    getInnerHTML: getInnerHTML,
    getOuterHTML: getOuterHTML,
    getText: getText
};
function getInnerHTML(elem, opts) {
    return elem.children ? elem.children.map(function (elem) {
        return getOuterHTML(elem, opts);
    }).join('') : '';
}
function getText(elem) {
    if (Array.isArray(elem))
        return elem.map(getText).join('');
    if (isTag(elem) || elem.type === ElementType.CDATA)
        return getText(elem.children);
    if (elem.type === ElementType.Text)
        return elem.data;
    return '';
}
},{"36":36,"38":38}],48:[function(require,module,exports){
var getChildren = exports.getChildren = function (elem) {
    return elem.children;
};
var getParent = exports.getParent = function (elem) {
    return elem.parent;
};
exports.getSiblings = function (elem) {
    var parent = getParent(elem);
    return parent ? getChildren(parent) : [elem];
};
exports.getAttributeValue = function (elem, name) {
    return elem.attribs && elem.attribs[name];
};
exports.hasAttrib = function (elem, name) {
    return !!elem.attribs && hasOwnProperty.call(elem.attribs, name);
};
exports.getName = function (elem) {
    return elem.name;
};
},{}],49:[function(require,module,exports){
'use strict';
var stream = require(263);
function DuplexWrapper(options, writable, readable) {
    if (typeof readable === 'undefined') {
        readable = writable;
        writable = options;
        options = null;
    }
    stream.Duplex.call(this, options);
    if (typeof readable.read !== 'function') {
        readable = new stream.Readable(options).wrap(readable);
    }
    this._writable = writable;
    this._readable = readable;
    this._waiting = false;
    var self = this;
    writable.once('finish', function () {
        self.end();
    });
    this.once('finish', function () {
        writable.end();
    });
    readable.on('readable', function () {
        if (self._waiting) {
            self._waiting = false;
            self._read();
        }
    });
    readable.once('end', function () {
        self.push(null);
    });
    if (!options || typeof options.bubbleErrors === 'undefined' || options.bubbleErrors) {
        writable.on('error', function (err) {
            self.emit('error', err);
        });
        readable.on('error', function (err) {
            self.emit('error', err);
        });
    }
}
DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, { constructor: { value: DuplexWrapper } });
DuplexWrapper.prototype._write = function _write(input, encoding, done) {
    this._writable.write(input, encoding, done);
};
DuplexWrapper.prototype._read = function _read() {
    var buf;
    var reads = 0;
    while ((buf = this._readable.read()) !== null) {
        this.push(buf);
        reads++;
    }
    if (reads === 0) {
        this._waiting = true;
    }
};
module.exports = function duplex2(options, writable, readable) {
    return new DuplexWrapper(options, writable, readable);
};
module.exports.DuplexWrapper = DuplexWrapper;
},{"263":263}],50:[function(require,module,exports){
var encode = require(53), decode = require(51);
exports.decode = function (data, level) {
    return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
};
exports.decodeStrict = function (data, level) {
    return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
};
exports.encode = function (data, level) {
    return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
};
exports.encodeXML = encode.XML;
exports.encodeHTML4 = exports.encodeHTML5 = exports.encodeHTML = encode.HTML;
exports.decodeXML = exports.decodeXMLStrict = decode.XML;
exports.decodeHTML4 = exports.decodeHTML5 = exports.decodeHTML = decode.HTML;
exports.decodeHTML4Strict = exports.decodeHTML5Strict = exports.decodeHTMLStrict = decode.HTMLStrict;
exports.escape = encode.escape;
},{"51":51,"53":53}],51:[function(require,module,exports){
var entityMap = require(55), legacyMap = require(56), xmlMap = require(57), decodeCodePoint = require(52);
var decodeXMLStrict = getStrictDecoder(xmlMap), decodeHTMLStrict = getStrictDecoder(entityMap);
function getStrictDecoder(map) {
    var keys = Object.keys(map).join('|'), replace = getReplacer(map);
    keys += '|#[xX][\\da-fA-F]+|#\\d+';
    var re = new RegExp('&(?:' + keys + ');', 'g');
    return function (str) {
        return String(str).replace(re, replace);
    };
}
var decodeHTML = function () {
    var legacy = Object.keys(legacyMap).sort(sorter);
    var keys = Object.keys(entityMap).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ';?';
            j++;
        } else {
            keys[i] += ';';
        }
    }
    var re = new RegExp('&(?:' + keys.join('|') + '|#[xX][\\da-fA-F]+;?|#\\d+;?)', 'g'), replace = getReplacer(entityMap);
    function replacer(str) {
        if (str.substr(-1) !== ';')
            str += ';';
        return replace(str);
    }
    return function (str) {
        return String(str).replace(re, replacer);
    };
}();
function sorter(a, b) {
    return a < b ? 1 : -1;
}
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === '#') {
            if (str.charAt(2) === 'X' || str.charAt(2) === 'x') {
                return decodeCodePoint(parseInt(str.substr(3), 16));
            }
            return decodeCodePoint(parseInt(str.substr(2), 10));
        }
        return map[str.slice(1, -1)];
    };
}
module.exports = {
    XML: decodeXMLStrict,
    HTML: decodeHTML,
    HTMLStrict: decodeHTMLStrict
};
},{"52":52,"55":55,"56":56,"57":57}],52:[function(require,module,exports){
var decodeMap = require(54);
module.exports = decodeCodePoint;
function decodeCodePoint(codePoint) {
    if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return '\uFFFD';
    }
    if (codePoint in decodeMap) {
        codePoint = decodeMap[codePoint];
    }
    var output = '';
    if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
}
},{"54":54}],53:[function(require,module,exports){
var inverseXML = getInverseObj(require(57)), xmlReplacer = getInverseReplacer(inverseXML);
exports.XML = getInverse(inverseXML, xmlReplacer);
var inverseHTML = getInverseObj(require(55)), htmlReplacer = getInverseReplacer(inverseHTML);
exports.HTML = getInverse(inverseHTML, htmlReplacer);
function getInverseObj(obj) {
    return Object.keys(obj).sort().reduce(function (inverse, name) {
        inverse[obj[name]] = '&' + name + ';';
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [], multiple = [];
    Object.keys(inverse).forEach(function (k) {
        if (k.length === 1) {
            single.push('\\' + k);
        } else {
            multiple.push(k);
        }
    });
    multiple.unshift('[' + single.join('') + ']');
    return new RegExp(multiple.join('|'), 'g');
}
var re_nonASCII = /[^\0-\x7F]/g, re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
function singleCharReplacer(c) {
    return '&#x' + c.charCodeAt(0).toString(16).toUpperCase() + ';';
}
function astralReplacer(c) {
    var high = c.charCodeAt(0);
    var low = c.charCodeAt(1);
    var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
    return '&#x' + codePoint.toString(16).toUpperCase() + ';';
}
function getInverse(inverse, re) {
    function func(name) {
        return inverse[name];
    }
    return function (data) {
        return data.replace(re, func).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer);
    };
}
var re_xmlChars = getInverseReplacer(inverseXML);
function escapeXML(data) {
    return data.replace(re_xmlChars, singleCharReplacer).replace(re_astralSymbols, astralReplacer).replace(re_nonASCII, singleCharReplacer);
}
exports.escape = escapeXML;
},{"55":55,"57":57}],54:[function(require,module,exports){
module.exports={"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}
},{}],55:[function(require,module,exports){
module.exports={"Aacute":"\u00C1","aacute":"\u00E1","Abreve":"\u0102","abreve":"\u0103","ac":"\u223E","acd":"\u223F","acE":"\u223E\u0333","Acirc":"\u00C2","acirc":"\u00E2","acute":"\u00B4","Acy":"\u0410","acy":"\u0430","AElig":"\u00C6","aelig":"\u00E6","af":"\u2061","Afr":"\uD835\uDD04","afr":"\uD835\uDD1E","Agrave":"\u00C0","agrave":"\u00E0","alefsym":"\u2135","aleph":"\u2135","Alpha":"\u0391","alpha":"\u03B1","Amacr":"\u0100","amacr":"\u0101","amalg":"\u2A3F","amp":"&","AMP":"&","andand":"\u2A55","And":"\u2A53","and":"\u2227","andd":"\u2A5C","andslope":"\u2A58","andv":"\u2A5A","ang":"\u2220","ange":"\u29A4","angle":"\u2220","angmsdaa":"\u29A8","angmsdab":"\u29A9","angmsdac":"\u29AA","angmsdad":"\u29AB","angmsdae":"\u29AC","angmsdaf":"\u29AD","angmsdag":"\u29AE","angmsdah":"\u29AF","angmsd":"\u2221","angrt":"\u221F","angrtvb":"\u22BE","angrtvbd":"\u299D","angsph":"\u2222","angst":"\u00C5","angzarr":"\u237C","Aogon":"\u0104","aogon":"\u0105","Aopf":"\uD835\uDD38","aopf":"\uD835\uDD52","apacir":"\u2A6F","ap":"\u2248","apE":"\u2A70","ape":"\u224A","apid":"\u224B","apos":"'","ApplyFunction":"\u2061","approx":"\u2248","approxeq":"\u224A","Aring":"\u00C5","aring":"\u00E5","Ascr":"\uD835\uDC9C","ascr":"\uD835\uDCB6","Assign":"\u2254","ast":"*","asymp":"\u2248","asympeq":"\u224D","Atilde":"\u00C3","atilde":"\u00E3","Auml":"\u00C4","auml":"\u00E4","awconint":"\u2233","awint":"\u2A11","backcong":"\u224C","backepsilon":"\u03F6","backprime":"\u2035","backsim":"\u223D","backsimeq":"\u22CD","Backslash":"\u2216","Barv":"\u2AE7","barvee":"\u22BD","barwed":"\u2305","Barwed":"\u2306","barwedge":"\u2305","bbrk":"\u23B5","bbrktbrk":"\u23B6","bcong":"\u224C","Bcy":"\u0411","bcy":"\u0431","bdquo":"\u201E","becaus":"\u2235","because":"\u2235","Because":"\u2235","bemptyv":"\u29B0","bepsi":"\u03F6","bernou":"\u212C","Bernoullis":"\u212C","Beta":"\u0392","beta":"\u03B2","beth":"\u2136","between":"\u226C","Bfr":"\uD835\uDD05","bfr":"\uD835\uDD1F","bigcap":"\u22C2","bigcirc":"\u25EF","bigcup":"\u22C3","bigodot":"\u2A00","bigoplus":"\u2A01","bigotimes":"\u2A02","bigsqcup":"\u2A06","bigstar":"\u2605","bigtriangledown":"\u25BD","bigtriangleup":"\u25B3","biguplus":"\u2A04","bigvee":"\u22C1","bigwedge":"\u22C0","bkarow":"\u290D","blacklozenge":"\u29EB","blacksquare":"\u25AA","blacktriangle":"\u25B4","blacktriangledown":"\u25BE","blacktriangleleft":"\u25C2","blacktriangleright":"\u25B8","blank":"\u2423","blk12":"\u2592","blk14":"\u2591","blk34":"\u2593","block":"\u2588","bne":"=\u20E5","bnequiv":"\u2261\u20E5","bNot":"\u2AED","bnot":"\u2310","Bopf":"\uD835\uDD39","bopf":"\uD835\uDD53","bot":"\u22A5","bottom":"\u22A5","bowtie":"\u22C8","boxbox":"\u29C9","boxdl":"\u2510","boxdL":"\u2555","boxDl":"\u2556","boxDL":"\u2557","boxdr":"\u250C","boxdR":"\u2552","boxDr":"\u2553","boxDR":"\u2554","boxh":"\u2500","boxH":"\u2550","boxhd":"\u252C","boxHd":"\u2564","boxhD":"\u2565","boxHD":"\u2566","boxhu":"\u2534","boxHu":"\u2567","boxhU":"\u2568","boxHU":"\u2569","boxminus":"\u229F","boxplus":"\u229E","boxtimes":"\u22A0","boxul":"\u2518","boxuL":"\u255B","boxUl":"\u255C","boxUL":"\u255D","boxur":"\u2514","boxuR":"\u2558","boxUr":"\u2559","boxUR":"\u255A","boxv":"\u2502","boxV":"\u2551","boxvh":"\u253C","boxvH":"\u256A","boxVh":"\u256B","boxVH":"\u256C","boxvl":"\u2524","boxvL":"\u2561","boxVl":"\u2562","boxVL":"\u2563","boxvr":"\u251C","boxvR":"\u255E","boxVr":"\u255F","boxVR":"\u2560","bprime":"\u2035","breve":"\u02D8","Breve":"\u02D8","brvbar":"\u00A6","bscr":"\uD835\uDCB7","Bscr":"\u212C","bsemi":"\u204F","bsim":"\u223D","bsime":"\u22CD","bsolb":"\u29C5","bsol":"\\","bsolhsub":"\u27C8","bull":"\u2022","bullet":"\u2022","bump":"\u224E","bumpE":"\u2AAE","bumpe":"\u224F","Bumpeq":"\u224E","bumpeq":"\u224F","Cacute":"\u0106","cacute":"\u0107","capand":"\u2A44","capbrcup":"\u2A49","capcap":"\u2A4B","cap":"\u2229","Cap":"\u22D2","capcup":"\u2A47","capdot":"\u2A40","CapitalDifferentialD":"\u2145","caps":"\u2229\uFE00","caret":"\u2041","caron":"\u02C7","Cayleys":"\u212D","ccaps":"\u2A4D","Ccaron":"\u010C","ccaron":"\u010D","Ccedil":"\u00C7","ccedil":"\u00E7","Ccirc":"\u0108","ccirc":"\u0109","Cconint":"\u2230","ccups":"\u2A4C","ccupssm":"\u2A50","Cdot":"\u010A","cdot":"\u010B","cedil":"\u00B8","Cedilla":"\u00B8","cemptyv":"\u29B2","cent":"\u00A2","centerdot":"\u00B7","CenterDot":"\u00B7","cfr":"\uD835\uDD20","Cfr":"\u212D","CHcy":"\u0427","chcy":"\u0447","check":"\u2713","checkmark":"\u2713","Chi":"\u03A7","chi":"\u03C7","circ":"\u02C6","circeq":"\u2257","circlearrowleft":"\u21BA","circlearrowright":"\u21BB","circledast":"\u229B","circledcirc":"\u229A","circleddash":"\u229D","CircleDot":"\u2299","circledR":"\u00AE","circledS":"\u24C8","CircleMinus":"\u2296","CirclePlus":"\u2295","CircleTimes":"\u2297","cir":"\u25CB","cirE":"\u29C3","cire":"\u2257","cirfnint":"\u2A10","cirmid":"\u2AEF","cirscir":"\u29C2","ClockwiseContourIntegral":"\u2232","CloseCurlyDoubleQuote":"\u201D","CloseCurlyQuote":"\u2019","clubs":"\u2663","clubsuit":"\u2663","colon":":","Colon":"\u2237","Colone":"\u2A74","colone":"\u2254","coloneq":"\u2254","comma":",","commat":"@","comp":"\u2201","compfn":"\u2218","complement":"\u2201","complexes":"\u2102","cong":"\u2245","congdot":"\u2A6D","Congruent":"\u2261","conint":"\u222E","Conint":"\u222F","ContourIntegral":"\u222E","copf":"\uD835\uDD54","Copf":"\u2102","coprod":"\u2210","Coproduct":"\u2210","copy":"\u00A9","COPY":"\u00A9","copysr":"\u2117","CounterClockwiseContourIntegral":"\u2233","crarr":"\u21B5","cross":"\u2717","Cross":"\u2A2F","Cscr":"\uD835\uDC9E","cscr":"\uD835\uDCB8","csub":"\u2ACF","csube":"\u2AD1","csup":"\u2AD0","csupe":"\u2AD2","ctdot":"\u22EF","cudarrl":"\u2938","cudarrr":"\u2935","cuepr":"\u22DE","cuesc":"\u22DF","cularr":"\u21B6","cularrp":"\u293D","cupbrcap":"\u2A48","cupcap":"\u2A46","CupCap":"\u224D","cup":"\u222A","Cup":"\u22D3","cupcup":"\u2A4A","cupdot":"\u228D","cupor":"\u2A45","cups":"\u222A\uFE00","curarr":"\u21B7","curarrm":"\u293C","curlyeqprec":"\u22DE","curlyeqsucc":"\u22DF","curlyvee":"\u22CE","curlywedge":"\u22CF","curren":"\u00A4","curvearrowleft":"\u21B6","curvearrowright":"\u21B7","cuvee":"\u22CE","cuwed":"\u22CF","cwconint":"\u2232","cwint":"\u2231","cylcty":"\u232D","dagger":"\u2020","Dagger":"\u2021","daleth":"\u2138","darr":"\u2193","Darr":"\u21A1","dArr":"\u21D3","dash":"\u2010","Dashv":"\u2AE4","dashv":"\u22A3","dbkarow":"\u290F","dblac":"\u02DD","Dcaron":"\u010E","dcaron":"\u010F","Dcy":"\u0414","dcy":"\u0434","ddagger":"\u2021","ddarr":"\u21CA","DD":"\u2145","dd":"\u2146","DDotrahd":"\u2911","ddotseq":"\u2A77","deg":"\u00B0","Del":"\u2207","Delta":"\u0394","delta":"\u03B4","demptyv":"\u29B1","dfisht":"\u297F","Dfr":"\uD835\uDD07","dfr":"\uD835\uDD21","dHar":"\u2965","dharl":"\u21C3","dharr":"\u21C2","DiacriticalAcute":"\u00B4","DiacriticalDot":"\u02D9","DiacriticalDoubleAcute":"\u02DD","DiacriticalGrave":"`","DiacriticalTilde":"\u02DC","diam":"\u22C4","diamond":"\u22C4","Diamond":"\u22C4","diamondsuit":"\u2666","diams":"\u2666","die":"\u00A8","DifferentialD":"\u2146","digamma":"\u03DD","disin":"\u22F2","div":"\u00F7","divide":"\u00F7","divideontimes":"\u22C7","divonx":"\u22C7","DJcy":"\u0402","djcy":"\u0452","dlcorn":"\u231E","dlcrop":"\u230D","dollar":"$","Dopf":"\uD835\uDD3B","dopf":"\uD835\uDD55","Dot":"\u00A8","dot":"\u02D9","DotDot":"\u20DC","doteq":"\u2250","doteqdot":"\u2251","DotEqual":"\u2250","dotminus":"\u2238","dotplus":"\u2214","dotsquare":"\u22A1","doublebarwedge":"\u2306","DoubleContourIntegral":"\u222F","DoubleDot":"\u00A8","DoubleDownArrow":"\u21D3","DoubleLeftArrow":"\u21D0","DoubleLeftRightArrow":"\u21D4","DoubleLeftTee":"\u2AE4","DoubleLongLeftArrow":"\u27F8","DoubleLongLeftRightArrow":"\u27FA","DoubleLongRightArrow":"\u27F9","DoubleRightArrow":"\u21D2","DoubleRightTee":"\u22A8","DoubleUpArrow":"\u21D1","DoubleUpDownArrow":"\u21D5","DoubleVerticalBar":"\u2225","DownArrowBar":"\u2913","downarrow":"\u2193","DownArrow":"\u2193","Downarrow":"\u21D3","DownArrowUpArrow":"\u21F5","DownBreve":"\u0311","downdownarrows":"\u21CA","downharpoonleft":"\u21C3","downharpoonright":"\u21C2","DownLeftRightVector":"\u2950","DownLeftTeeVector":"\u295E","DownLeftVectorBar":"\u2956","DownLeftVector":"\u21BD","DownRightTeeVector":"\u295F","DownRightVectorBar":"\u2957","DownRightVector":"\u21C1","DownTeeArrow":"\u21A7","DownTee":"\u22A4","drbkarow":"\u2910","drcorn":"\u231F","drcrop":"\u230C","Dscr":"\uD835\uDC9F","dscr":"\uD835\uDCB9","DScy":"\u0405","dscy":"\u0455","dsol":"\u29F6","Dstrok":"\u0110","dstrok":"\u0111","dtdot":"\u22F1","dtri":"\u25BF","dtrif":"\u25BE","duarr":"\u21F5","duhar":"\u296F","dwangle":"\u29A6","DZcy":"\u040F","dzcy":"\u045F","dzigrarr":"\u27FF","Eacute":"\u00C9","eacute":"\u00E9","easter":"\u2A6E","Ecaron":"\u011A","ecaron":"\u011B","Ecirc":"\u00CA","ecirc":"\u00EA","ecir":"\u2256","ecolon":"\u2255","Ecy":"\u042D","ecy":"\u044D","eDDot":"\u2A77","Edot":"\u0116","edot":"\u0117","eDot":"\u2251","ee":"\u2147","efDot":"\u2252","Efr":"\uD835\uDD08","efr":"\uD835\uDD22","eg":"\u2A9A","Egrave":"\u00C8","egrave":"\u00E8","egs":"\u2A96","egsdot":"\u2A98","el":"\u2A99","Element":"\u2208","elinters":"\u23E7","ell":"\u2113","els":"\u2A95","elsdot":"\u2A97","Emacr":"\u0112","emacr":"\u0113","empty":"\u2205","emptyset":"\u2205","EmptySmallSquare":"\u25FB","emptyv":"\u2205","EmptyVerySmallSquare":"\u25AB","emsp13":"\u2004","emsp14":"\u2005","emsp":"\u2003","ENG":"\u014A","eng":"\u014B","ensp":"\u2002","Eogon":"\u0118","eogon":"\u0119","Eopf":"\uD835\uDD3C","eopf":"\uD835\uDD56","epar":"\u22D5","eparsl":"\u29E3","eplus":"\u2A71","epsi":"\u03B5","Epsilon":"\u0395","epsilon":"\u03B5","epsiv":"\u03F5","eqcirc":"\u2256","eqcolon":"\u2255","eqsim":"\u2242","eqslantgtr":"\u2A96","eqslantless":"\u2A95","Equal":"\u2A75","equals":"=","EqualTilde":"\u2242","equest":"\u225F","Equilibrium":"\u21CC","equiv":"\u2261","equivDD":"\u2A78","eqvparsl":"\u29E5","erarr":"\u2971","erDot":"\u2253","escr":"\u212F","Escr":"\u2130","esdot":"\u2250","Esim":"\u2A73","esim":"\u2242","Eta":"\u0397","eta":"\u03B7","ETH":"\u00D0","eth":"\u00F0","Euml":"\u00CB","euml":"\u00EB","euro":"\u20AC","excl":"!","exist":"\u2203","Exists":"\u2203","expectation":"\u2130","exponentiale":"\u2147","ExponentialE":"\u2147","fallingdotseq":"\u2252","Fcy":"\u0424","fcy":"\u0444","female":"\u2640","ffilig":"\uFB03","fflig":"\uFB00","ffllig":"\uFB04","Ffr":"\uD835\uDD09","ffr":"\uD835\uDD23","filig":"\uFB01","FilledSmallSquare":"\u25FC","FilledVerySmallSquare":"\u25AA","fjlig":"fj","flat":"\u266D","fllig":"\uFB02","fltns":"\u25B1","fnof":"\u0192","Fopf":"\uD835\uDD3D","fopf":"\uD835\uDD57","forall":"\u2200","ForAll":"\u2200","fork":"\u22D4","forkv":"\u2AD9","Fouriertrf":"\u2131","fpartint":"\u2A0D","frac12":"\u00BD","frac13":"\u2153","frac14":"\u00BC","frac15":"\u2155","frac16":"\u2159","frac18":"\u215B","frac23":"\u2154","frac25":"\u2156","frac34":"\u00BE","frac35":"\u2157","frac38":"\u215C","frac45":"\u2158","frac56":"\u215A","frac58":"\u215D","frac78":"\u215E","frasl":"\u2044","frown":"\u2322","fscr":"\uD835\uDCBB","Fscr":"\u2131","gacute":"\u01F5","Gamma":"\u0393","gamma":"\u03B3","Gammad":"\u03DC","gammad":"\u03DD","gap":"\u2A86","Gbreve":"\u011E","gbreve":"\u011F","Gcedil":"\u0122","Gcirc":"\u011C","gcirc":"\u011D","Gcy":"\u0413","gcy":"\u0433","Gdot":"\u0120","gdot":"\u0121","ge":"\u2265","gE":"\u2267","gEl":"\u2A8C","gel":"\u22DB","geq":"\u2265","geqq":"\u2267","geqslant":"\u2A7E","gescc":"\u2AA9","ges":"\u2A7E","gesdot":"\u2A80","gesdoto":"\u2A82","gesdotol":"\u2A84","gesl":"\u22DB\uFE00","gesles":"\u2A94","Gfr":"\uD835\uDD0A","gfr":"\uD835\uDD24","gg":"\u226B","Gg":"\u22D9","ggg":"\u22D9","gimel":"\u2137","GJcy":"\u0403","gjcy":"\u0453","gla":"\u2AA5","gl":"\u2277","glE":"\u2A92","glj":"\u2AA4","gnap":"\u2A8A","gnapprox":"\u2A8A","gne":"\u2A88","gnE":"\u2269","gneq":"\u2A88","gneqq":"\u2269","gnsim":"\u22E7","Gopf":"\uD835\uDD3E","gopf":"\uD835\uDD58","grave":"`","GreaterEqual":"\u2265","GreaterEqualLess":"\u22DB","GreaterFullEqual":"\u2267","GreaterGreater":"\u2AA2","GreaterLess":"\u2277","GreaterSlantEqual":"\u2A7E","GreaterTilde":"\u2273","Gscr":"\uD835\uDCA2","gscr":"\u210A","gsim":"\u2273","gsime":"\u2A8E","gsiml":"\u2A90","gtcc":"\u2AA7","gtcir":"\u2A7A","gt":">","GT":">","Gt":"\u226B","gtdot":"\u22D7","gtlPar":"\u2995","gtquest":"\u2A7C","gtrapprox":"\u2A86","gtrarr":"\u2978","gtrdot":"\u22D7","gtreqless":"\u22DB","gtreqqless":"\u2A8C","gtrless":"\u2277","gtrsim":"\u2273","gvertneqq":"\u2269\uFE00","gvnE":"\u2269\uFE00","Hacek":"\u02C7","hairsp":"\u200A","half":"\u00BD","hamilt":"\u210B","HARDcy":"\u042A","hardcy":"\u044A","harrcir":"\u2948","harr":"\u2194","hArr":"\u21D4","harrw":"\u21AD","Hat":"^","hbar":"\u210F","Hcirc":"\u0124","hcirc":"\u0125","hearts":"\u2665","heartsuit":"\u2665","hellip":"\u2026","hercon":"\u22B9","hfr":"\uD835\uDD25","Hfr":"\u210C","HilbertSpace":"\u210B","hksearow":"\u2925","hkswarow":"\u2926","hoarr":"\u21FF","homtht":"\u223B","hookleftarrow":"\u21A9","hookrightarrow":"\u21AA","hopf":"\uD835\uDD59","Hopf":"\u210D","horbar":"\u2015","HorizontalLine":"\u2500","hscr":"\uD835\uDCBD","Hscr":"\u210B","hslash":"\u210F","Hstrok":"\u0126","hstrok":"\u0127","HumpDownHump":"\u224E","HumpEqual":"\u224F","hybull":"\u2043","hyphen":"\u2010","Iacute":"\u00CD","iacute":"\u00ED","ic":"\u2063","Icirc":"\u00CE","icirc":"\u00EE","Icy":"\u0418","icy":"\u0438","Idot":"\u0130","IEcy":"\u0415","iecy":"\u0435","iexcl":"\u00A1","iff":"\u21D4","ifr":"\uD835\uDD26","Ifr":"\u2111","Igrave":"\u00CC","igrave":"\u00EC","ii":"\u2148","iiiint":"\u2A0C","iiint":"\u222D","iinfin":"\u29DC","iiota":"\u2129","IJlig":"\u0132","ijlig":"\u0133","Imacr":"\u012A","imacr":"\u012B","image":"\u2111","ImaginaryI":"\u2148","imagline":"\u2110","imagpart":"\u2111","imath":"\u0131","Im":"\u2111","imof":"\u22B7","imped":"\u01B5","Implies":"\u21D2","incare":"\u2105","in":"\u2208","infin":"\u221E","infintie":"\u29DD","inodot":"\u0131","intcal":"\u22BA","int":"\u222B","Int":"\u222C","integers":"\u2124","Integral":"\u222B","intercal":"\u22BA","Intersection":"\u22C2","intlarhk":"\u2A17","intprod":"\u2A3C","InvisibleComma":"\u2063","InvisibleTimes":"\u2062","IOcy":"\u0401","iocy":"\u0451","Iogon":"\u012E","iogon":"\u012F","Iopf":"\uD835\uDD40","iopf":"\uD835\uDD5A","Iota":"\u0399","iota":"\u03B9","iprod":"\u2A3C","iquest":"\u00BF","iscr":"\uD835\uDCBE","Iscr":"\u2110","isin":"\u2208","isindot":"\u22F5","isinE":"\u22F9","isins":"\u22F4","isinsv":"\u22F3","isinv":"\u2208","it":"\u2062","Itilde":"\u0128","itilde":"\u0129","Iukcy":"\u0406","iukcy":"\u0456","Iuml":"\u00CF","iuml":"\u00EF","Jcirc":"\u0134","jcirc":"\u0135","Jcy":"\u0419","jcy":"\u0439","Jfr":"\uD835\uDD0D","jfr":"\uD835\uDD27","jmath":"\u0237","Jopf":"\uD835\uDD41","jopf":"\uD835\uDD5B","Jscr":"\uD835\uDCA5","jscr":"\uD835\uDCBF","Jsercy":"\u0408","jsercy":"\u0458","Jukcy":"\u0404","jukcy":"\u0454","Kappa":"\u039A","kappa":"\u03BA","kappav":"\u03F0","Kcedil":"\u0136","kcedil":"\u0137","Kcy":"\u041A","kcy":"\u043A","Kfr":"\uD835\uDD0E","kfr":"\uD835\uDD28","kgreen":"\u0138","KHcy":"\u0425","khcy":"\u0445","KJcy":"\u040C","kjcy":"\u045C","Kopf":"\uD835\uDD42","kopf":"\uD835\uDD5C","Kscr":"\uD835\uDCA6","kscr":"\uD835\uDCC0","lAarr":"\u21DA","Lacute":"\u0139","lacute":"\u013A","laemptyv":"\u29B4","lagran":"\u2112","Lambda":"\u039B","lambda":"\u03BB","lang":"\u27E8","Lang":"\u27EA","langd":"\u2991","langle":"\u27E8","lap":"\u2A85","Laplacetrf":"\u2112","laquo":"\u00AB","larrb":"\u21E4","larrbfs":"\u291F","larr":"\u2190","Larr":"\u219E","lArr":"\u21D0","larrfs":"\u291D","larrhk":"\u21A9","larrlp":"\u21AB","larrpl":"\u2939","larrsim":"\u2973","larrtl":"\u21A2","latail":"\u2919","lAtail":"\u291B","lat":"\u2AAB","late":"\u2AAD","lates":"\u2AAD\uFE00","lbarr":"\u290C","lBarr":"\u290E","lbbrk":"\u2772","lbrace":"{","lbrack":"[","lbrke":"\u298B","lbrksld":"\u298F","lbrkslu":"\u298D","Lcaron":"\u013D","lcaron":"\u013E","Lcedil":"\u013B","lcedil":"\u013C","lceil":"\u2308","lcub":"{","Lcy":"\u041B","lcy":"\u043B","ldca":"\u2936","ldquo":"\u201C","ldquor":"\u201E","ldrdhar":"\u2967","ldrushar":"\u294B","ldsh":"\u21B2","le":"\u2264","lE":"\u2266","LeftAngleBracket":"\u27E8","LeftArrowBar":"\u21E4","leftarrow":"\u2190","LeftArrow":"\u2190","Leftarrow":"\u21D0","LeftArrowRightArrow":"\u21C6","leftarrowtail":"\u21A2","LeftCeiling":"\u2308","LeftDoubleBracket":"\u27E6","LeftDownTeeVector":"\u2961","LeftDownVectorBar":"\u2959","LeftDownVector":"\u21C3","LeftFloor":"\u230A","leftharpoondown":"\u21BD","leftharpoonup":"\u21BC","leftleftarrows":"\u21C7","leftrightarrow":"\u2194","LeftRightArrow":"\u2194","Leftrightarrow":"\u21D4","leftrightarrows":"\u21C6","leftrightharpoons":"\u21CB","leftrightsquigarrow":"\u21AD","LeftRightVector":"\u294E","LeftTeeArrow":"\u21A4","LeftTee":"\u22A3","LeftTeeVector":"\u295A","leftthreetimes":"\u22CB","LeftTriangleBar":"\u29CF","LeftTriangle":"\u22B2","LeftTriangleEqual":"\u22B4","LeftUpDownVector":"\u2951","LeftUpTeeVector":"\u2960","LeftUpVectorBar":"\u2958","LeftUpVector":"\u21BF","LeftVectorBar":"\u2952","LeftVector":"\u21BC","lEg":"\u2A8B","leg":"\u22DA","leq":"\u2264","leqq":"\u2266","leqslant":"\u2A7D","lescc":"\u2AA8","les":"\u2A7D","lesdot":"\u2A7F","lesdoto":"\u2A81","lesdotor":"\u2A83","lesg":"\u22DA\uFE00","lesges":"\u2A93","lessapprox":"\u2A85","lessdot":"\u22D6","lesseqgtr":"\u22DA","lesseqqgtr":"\u2A8B","LessEqualGreater":"\u22DA","LessFullEqual":"\u2266","LessGreater":"\u2276","lessgtr":"\u2276","LessLess":"\u2AA1","lesssim":"\u2272","LessSlantEqual":"\u2A7D","LessTilde":"\u2272","lfisht":"\u297C","lfloor":"\u230A","Lfr":"\uD835\uDD0F","lfr":"\uD835\uDD29","lg":"\u2276","lgE":"\u2A91","lHar":"\u2962","lhard":"\u21BD","lharu":"\u21BC","lharul":"\u296A","lhblk":"\u2584","LJcy":"\u0409","ljcy":"\u0459","llarr":"\u21C7","ll":"\u226A","Ll":"\u22D8","llcorner":"\u231E","Lleftarrow":"\u21DA","llhard":"\u296B","lltri":"\u25FA","Lmidot":"\u013F","lmidot":"\u0140","lmoustache":"\u23B0","lmoust":"\u23B0","lnap":"\u2A89","lnapprox":"\u2A89","lne":"\u2A87","lnE":"\u2268","lneq":"\u2A87","lneqq":"\u2268","lnsim":"\u22E6","loang":"\u27EC","loarr":"\u21FD","lobrk":"\u27E6","longleftarrow":"\u27F5","LongLeftArrow":"\u27F5","Longleftarrow":"\u27F8","longleftrightarrow":"\u27F7","LongLeftRightArrow":"\u27F7","Longleftrightarrow":"\u27FA","longmapsto":"\u27FC","longrightarrow":"\u27F6","LongRightArrow":"\u27F6","Longrightarrow":"\u27F9","looparrowleft":"\u21AB","looparrowright":"\u21AC","lopar":"\u2985","Lopf":"\uD835\uDD43","lopf":"\uD835\uDD5D","loplus":"\u2A2D","lotimes":"\u2A34","lowast":"\u2217","lowbar":"_","LowerLeftArrow":"\u2199","LowerRightArrow":"\u2198","loz":"\u25CA","lozenge":"\u25CA","lozf":"\u29EB","lpar":"(","lparlt":"\u2993","lrarr":"\u21C6","lrcorner":"\u231F","lrhar":"\u21CB","lrhard":"\u296D","lrm":"\u200E","lrtri":"\u22BF","lsaquo":"\u2039","lscr":"\uD835\uDCC1","Lscr":"\u2112","lsh":"\u21B0","Lsh":"\u21B0","lsim":"\u2272","lsime":"\u2A8D","lsimg":"\u2A8F","lsqb":"[","lsquo":"\u2018","lsquor":"\u201A","Lstrok":"\u0141","lstrok":"\u0142","ltcc":"\u2AA6","ltcir":"\u2A79","lt":"<","LT":"<","Lt":"\u226A","ltdot":"\u22D6","lthree":"\u22CB","ltimes":"\u22C9","ltlarr":"\u2976","ltquest":"\u2A7B","ltri":"\u25C3","ltrie":"\u22B4","ltrif":"\u25C2","ltrPar":"\u2996","lurdshar":"\u294A","luruhar":"\u2966","lvertneqq":"\u2268\uFE00","lvnE":"\u2268\uFE00","macr":"\u00AF","male":"\u2642","malt":"\u2720","maltese":"\u2720","Map":"\u2905","map":"\u21A6","mapsto":"\u21A6","mapstodown":"\u21A7","mapstoleft":"\u21A4","mapstoup":"\u21A5","marker":"\u25AE","mcomma":"\u2A29","Mcy":"\u041C","mcy":"\u043C","mdash":"\u2014","mDDot":"\u223A","measuredangle":"\u2221","MediumSpace":"\u205F","Mellintrf":"\u2133","Mfr":"\uD835\uDD10","mfr":"\uD835\uDD2A","mho":"\u2127","micro":"\u00B5","midast":"*","midcir":"\u2AF0","mid":"\u2223","middot":"\u00B7","minusb":"\u229F","minus":"\u2212","minusd":"\u2238","minusdu":"\u2A2A","MinusPlus":"\u2213","mlcp":"\u2ADB","mldr":"\u2026","mnplus":"\u2213","models":"\u22A7","Mopf":"\uD835\uDD44","mopf":"\uD835\uDD5E","mp":"\u2213","mscr":"\uD835\uDCC2","Mscr":"\u2133","mstpos":"\u223E","Mu":"\u039C","mu":"\u03BC","multimap":"\u22B8","mumap":"\u22B8","nabla":"\u2207","Nacute":"\u0143","nacute":"\u0144","nang":"\u2220\u20D2","nap":"\u2249","napE":"\u2A70\u0338","napid":"\u224B\u0338","napos":"\u0149","napprox":"\u2249","natural":"\u266E","naturals":"\u2115","natur":"\u266E","nbsp":"\u00A0","nbump":"\u224E\u0338","nbumpe":"\u224F\u0338","ncap":"\u2A43","Ncaron":"\u0147","ncaron":"\u0148","Ncedil":"\u0145","ncedil":"\u0146","ncong":"\u2247","ncongdot":"\u2A6D\u0338","ncup":"\u2A42","Ncy":"\u041D","ncy":"\u043D","ndash":"\u2013","nearhk":"\u2924","nearr":"\u2197","neArr":"\u21D7","nearrow":"\u2197","ne":"\u2260","nedot":"\u2250\u0338","NegativeMediumSpace":"\u200B","NegativeThickSpace":"\u200B","NegativeThinSpace":"\u200B","NegativeVeryThinSpace":"\u200B","nequiv":"\u2262","nesear":"\u2928","nesim":"\u2242\u0338","NestedGreaterGreater":"\u226B","NestedLessLess":"\u226A","NewLine":"\n","nexist":"\u2204","nexists":"\u2204","Nfr":"\uD835\uDD11","nfr":"\uD835\uDD2B","ngE":"\u2267\u0338","nge":"\u2271","ngeq":"\u2271","ngeqq":"\u2267\u0338","ngeqslant":"\u2A7E\u0338","nges":"\u2A7E\u0338","nGg":"\u22D9\u0338","ngsim":"\u2275","nGt":"\u226B\u20D2","ngt":"\u226F","ngtr":"\u226F","nGtv":"\u226B\u0338","nharr":"\u21AE","nhArr":"\u21CE","nhpar":"\u2AF2","ni":"\u220B","nis":"\u22FC","nisd":"\u22FA","niv":"\u220B","NJcy":"\u040A","njcy":"\u045A","nlarr":"\u219A","nlArr":"\u21CD","nldr":"\u2025","nlE":"\u2266\u0338","nle":"\u2270","nleftarrow":"\u219A","nLeftarrow":"\u21CD","nleftrightarrow":"\u21AE","nLeftrightarrow":"\u21CE","nleq":"\u2270","nleqq":"\u2266\u0338","nleqslant":"\u2A7D\u0338","nles":"\u2A7D\u0338","nless":"\u226E","nLl":"\u22D8\u0338","nlsim":"\u2274","nLt":"\u226A\u20D2","nlt":"\u226E","nltri":"\u22EA","nltrie":"\u22EC","nLtv":"\u226A\u0338","nmid":"\u2224","NoBreak":"\u2060","NonBreakingSpace":"\u00A0","nopf":"\uD835\uDD5F","Nopf":"\u2115","Not":"\u2AEC","not":"\u00AC","NotCongruent":"\u2262","NotCupCap":"\u226D","NotDoubleVerticalBar":"\u2226","NotElement":"\u2209","NotEqual":"\u2260","NotEqualTilde":"\u2242\u0338","NotExists":"\u2204","NotGreater":"\u226F","NotGreaterEqual":"\u2271","NotGreaterFullEqual":"\u2267\u0338","NotGreaterGreater":"\u226B\u0338","NotGreaterLess":"\u2279","NotGreaterSlantEqual":"\u2A7E\u0338","NotGreaterTilde":"\u2275","NotHumpDownHump":"\u224E\u0338","NotHumpEqual":"\u224F\u0338","notin":"\u2209","notindot":"\u22F5\u0338","notinE":"\u22F9\u0338","notinva":"\u2209","notinvb":"\u22F7","notinvc":"\u22F6","NotLeftTriangleBar":"\u29CF\u0338","NotLeftTriangle":"\u22EA","NotLeftTriangleEqual":"\u22EC","NotLess":"\u226E","NotLessEqual":"\u2270","NotLessGreater":"\u2278","NotLessLess":"\u226A\u0338","NotLessSlantEqual":"\u2A7D\u0338","NotLessTilde":"\u2274","NotNestedGreaterGreater":"\u2AA2\u0338","NotNestedLessLess":"\u2AA1\u0338","notni":"\u220C","notniva":"\u220C","notnivb":"\u22FE","notnivc":"\u22FD","NotPrecedes":"\u2280","NotPrecedesEqual":"\u2AAF\u0338","NotPrecedesSlantEqual":"\u22E0","NotReverseElement":"\u220C","NotRightTriangleBar":"\u29D0\u0338","NotRightTriangle":"\u22EB","NotRightTriangleEqual":"\u22ED","NotSquareSubset":"\u228F\u0338","NotSquareSubsetEqual":"\u22E2","NotSquareSuperset":"\u2290\u0338","NotSquareSupersetEqual":"\u22E3","NotSubset":"\u2282\u20D2","NotSubsetEqual":"\u2288","NotSucceeds":"\u2281","NotSucceedsEqual":"\u2AB0\u0338","NotSucceedsSlantEqual":"\u22E1","NotSucceedsTilde":"\u227F\u0338","NotSuperset":"\u2283\u20D2","NotSupersetEqual":"\u2289","NotTilde":"\u2241","NotTildeEqual":"\u2244","NotTildeFullEqual":"\u2247","NotTildeTilde":"\u2249","NotVerticalBar":"\u2224","nparallel":"\u2226","npar":"\u2226","nparsl":"\u2AFD\u20E5","npart":"\u2202\u0338","npolint":"\u2A14","npr":"\u2280","nprcue":"\u22E0","nprec":"\u2280","npreceq":"\u2AAF\u0338","npre":"\u2AAF\u0338","nrarrc":"\u2933\u0338","nrarr":"\u219B","nrArr":"\u21CF","nrarrw":"\u219D\u0338","nrightarrow":"\u219B","nRightarrow":"\u21CF","nrtri":"\u22EB","nrtrie":"\u22ED","nsc":"\u2281","nsccue":"\u22E1","nsce":"\u2AB0\u0338","Nscr":"\uD835\uDCA9","nscr":"\uD835\uDCC3","nshortmid":"\u2224","nshortparallel":"\u2226","nsim":"\u2241","nsime":"\u2244","nsimeq":"\u2244","nsmid":"\u2224","nspar":"\u2226","nsqsube":"\u22E2","nsqsupe":"\u22E3","nsub":"\u2284","nsubE":"\u2AC5\u0338","nsube":"\u2288","nsubset":"\u2282\u20D2","nsubseteq":"\u2288","nsubseteqq":"\u2AC5\u0338","nsucc":"\u2281","nsucceq":"\u2AB0\u0338","nsup":"\u2285","nsupE":"\u2AC6\u0338","nsupe":"\u2289","nsupset":"\u2283\u20D2","nsupseteq":"\u2289","nsupseteqq":"\u2AC6\u0338","ntgl":"\u2279","Ntilde":"\u00D1","ntilde":"\u00F1","ntlg":"\u2278","ntriangleleft":"\u22EA","ntrianglelefteq":"\u22EC","ntriangleright":"\u22EB","ntrianglerighteq":"\u22ED","Nu":"\u039D","nu":"\u03BD","num":"#","numero":"\u2116","numsp":"\u2007","nvap":"\u224D\u20D2","nvdash":"\u22AC","nvDash":"\u22AD","nVdash":"\u22AE","nVDash":"\u22AF","nvge":"\u2265\u20D2","nvgt":">\u20D2","nvHarr":"\u2904","nvinfin":"\u29DE","nvlArr":"\u2902","nvle":"\u2264\u20D2","nvlt":"<\u20D2","nvltrie":"\u22B4\u20D2","nvrArr":"\u2903","nvrtrie":"\u22B5\u20D2","nvsim":"\u223C\u20D2","nwarhk":"\u2923","nwarr":"\u2196","nwArr":"\u21D6","nwarrow":"\u2196","nwnear":"\u2927","Oacute":"\u00D3","oacute":"\u00F3","oast":"\u229B","Ocirc":"\u00D4","ocirc":"\u00F4","ocir":"\u229A","Ocy":"\u041E","ocy":"\u043E","odash":"\u229D","Odblac":"\u0150","odblac":"\u0151","odiv":"\u2A38","odot":"\u2299","odsold":"\u29BC","OElig":"\u0152","oelig":"\u0153","ofcir":"\u29BF","Ofr":"\uD835\uDD12","ofr":"\uD835\uDD2C","ogon":"\u02DB","Ograve":"\u00D2","ograve":"\u00F2","ogt":"\u29C1","ohbar":"\u29B5","ohm":"\u03A9","oint":"\u222E","olarr":"\u21BA","olcir":"\u29BE","olcross":"\u29BB","oline":"\u203E","olt":"\u29C0","Omacr":"\u014C","omacr":"\u014D","Omega":"\u03A9","omega":"\u03C9","Omicron":"\u039F","omicron":"\u03BF","omid":"\u29B6","ominus":"\u2296","Oopf":"\uD835\uDD46","oopf":"\uD835\uDD60","opar":"\u29B7","OpenCurlyDoubleQuote":"\u201C","OpenCurlyQuote":"\u2018","operp":"\u29B9","oplus":"\u2295","orarr":"\u21BB","Or":"\u2A54","or":"\u2228","ord":"\u2A5D","order":"\u2134","orderof":"\u2134","ordf":"\u00AA","ordm":"\u00BA","origof":"\u22B6","oror":"\u2A56","orslope":"\u2A57","orv":"\u2A5B","oS":"\u24C8","Oscr":"\uD835\uDCAA","oscr":"\u2134","Oslash":"\u00D8","oslash":"\u00F8","osol":"\u2298","Otilde":"\u00D5","otilde":"\u00F5","otimesas":"\u2A36","Otimes":"\u2A37","otimes":"\u2297","Ouml":"\u00D6","ouml":"\u00F6","ovbar":"\u233D","OverBar":"\u203E","OverBrace":"\u23DE","OverBracket":"\u23B4","OverParenthesis":"\u23DC","para":"\u00B6","parallel":"\u2225","par":"\u2225","parsim":"\u2AF3","parsl":"\u2AFD","part":"\u2202","PartialD":"\u2202","Pcy":"\u041F","pcy":"\u043F","percnt":"%","period":".","permil":"\u2030","perp":"\u22A5","pertenk":"\u2031","Pfr":"\uD835\uDD13","pfr":"\uD835\uDD2D","Phi":"\u03A6","phi":"\u03C6","phiv":"\u03D5","phmmat":"\u2133","phone":"\u260E","Pi":"\u03A0","pi":"\u03C0","pitchfork":"\u22D4","piv":"\u03D6","planck":"\u210F","planckh":"\u210E","plankv":"\u210F","plusacir":"\u2A23","plusb":"\u229E","pluscir":"\u2A22","plus":"+","plusdo":"\u2214","plusdu":"\u2A25","pluse":"\u2A72","PlusMinus":"\u00B1","plusmn":"\u00B1","plussim":"\u2A26","plustwo":"\u2A27","pm":"\u00B1","Poincareplane":"\u210C","pointint":"\u2A15","popf":"\uD835\uDD61","Popf":"\u2119","pound":"\u00A3","prap":"\u2AB7","Pr":"\u2ABB","pr":"\u227A","prcue":"\u227C","precapprox":"\u2AB7","prec":"\u227A","preccurlyeq":"\u227C","Precedes":"\u227A","PrecedesEqual":"\u2AAF","PrecedesSlantEqual":"\u227C","PrecedesTilde":"\u227E","preceq":"\u2AAF","precnapprox":"\u2AB9","precneqq":"\u2AB5","precnsim":"\u22E8","pre":"\u2AAF","prE":"\u2AB3","precsim":"\u227E","prime":"\u2032","Prime":"\u2033","primes":"\u2119","prnap":"\u2AB9","prnE":"\u2AB5","prnsim":"\u22E8","prod":"\u220F","Product":"\u220F","profalar":"\u232E","profline":"\u2312","profsurf":"\u2313","prop":"\u221D","Proportional":"\u221D","Proportion":"\u2237","propto":"\u221D","prsim":"\u227E","prurel":"\u22B0","Pscr":"\uD835\uDCAB","pscr":"\uD835\uDCC5","Psi":"\u03A8","psi":"\u03C8","puncsp":"\u2008","Qfr":"\uD835\uDD14","qfr":"\uD835\uDD2E","qint":"\u2A0C","qopf":"\uD835\uDD62","Qopf":"\u211A","qprime":"\u2057","Qscr":"\uD835\uDCAC","qscr":"\uD835\uDCC6","quaternions":"\u210D","quatint":"\u2A16","quest":"?","questeq":"\u225F","quot":"\"","QUOT":"\"","rAarr":"\u21DB","race":"\u223D\u0331","Racute":"\u0154","racute":"\u0155","radic":"\u221A","raemptyv":"\u29B3","rang":"\u27E9","Rang":"\u27EB","rangd":"\u2992","range":"\u29A5","rangle":"\u27E9","raquo":"\u00BB","rarrap":"\u2975","rarrb":"\u21E5","rarrbfs":"\u2920","rarrc":"\u2933","rarr":"\u2192","Rarr":"\u21A0","rArr":"\u21D2","rarrfs":"\u291E","rarrhk":"\u21AA","rarrlp":"\u21AC","rarrpl":"\u2945","rarrsim":"\u2974","Rarrtl":"\u2916","rarrtl":"\u21A3","rarrw":"\u219D","ratail":"\u291A","rAtail":"\u291C","ratio":"\u2236","rationals":"\u211A","rbarr":"\u290D","rBarr":"\u290F","RBarr":"\u2910","rbbrk":"\u2773","rbrace":"}","rbrack":"]","rbrke":"\u298C","rbrksld":"\u298E","rbrkslu":"\u2990","Rcaron":"\u0158","rcaron":"\u0159","Rcedil":"\u0156","rcedil":"\u0157","rceil":"\u2309","rcub":"}","Rcy":"\u0420","rcy":"\u0440","rdca":"\u2937","rdldhar":"\u2969","rdquo":"\u201D","rdquor":"\u201D","rdsh":"\u21B3","real":"\u211C","realine":"\u211B","realpart":"\u211C","reals":"\u211D","Re":"\u211C","rect":"\u25AD","reg":"\u00AE","REG":"\u00AE","ReverseElement":"\u220B","ReverseEquilibrium":"\u21CB","ReverseUpEquilibrium":"\u296F","rfisht":"\u297D","rfloor":"\u230B","rfr":"\uD835\uDD2F","Rfr":"\u211C","rHar":"\u2964","rhard":"\u21C1","rharu":"\u21C0","rharul":"\u296C","Rho":"\u03A1","rho":"\u03C1","rhov":"\u03F1","RightAngleBracket":"\u27E9","RightArrowBar":"\u21E5","rightarrow":"\u2192","RightArrow":"\u2192","Rightarrow":"\u21D2","RightArrowLeftArrow":"\u21C4","rightarrowtail":"\u21A3","RightCeiling":"\u2309","RightDoubleBracket":"\u27E7","RightDownTeeVector":"\u295D","RightDownVectorBar":"\u2955","RightDownVector":"\u21C2","RightFloor":"\u230B","rightharpoondown":"\u21C1","rightharpoonup":"\u21C0","rightleftarrows":"\u21C4","rightleftharpoons":"\u21CC","rightrightarrows":"\u21C9","rightsquigarrow":"\u219D","RightTeeArrow":"\u21A6","RightTee":"\u22A2","RightTeeVector":"\u295B","rightthreetimes":"\u22CC","RightTriangleBar":"\u29D0","RightTriangle":"\u22B3","RightTriangleEqual":"\u22B5","RightUpDownVector":"\u294F","RightUpTeeVector":"\u295C","RightUpVectorBar":"\u2954","RightUpVector":"\u21BE","RightVectorBar":"\u2953","RightVector":"\u21C0","ring":"\u02DA","risingdotseq":"\u2253","rlarr":"\u21C4","rlhar":"\u21CC","rlm":"\u200F","rmoustache":"\u23B1","rmoust":"\u23B1","rnmid":"\u2AEE","roang":"\u27ED","roarr":"\u21FE","robrk":"\u27E7","ropar":"\u2986","ropf":"\uD835\uDD63","Ropf":"\u211D","roplus":"\u2A2E","rotimes":"\u2A35","RoundImplies":"\u2970","rpar":")","rpargt":"\u2994","rppolint":"\u2A12","rrarr":"\u21C9","Rrightarrow":"\u21DB","rsaquo":"\u203A","rscr":"\uD835\uDCC7","Rscr":"\u211B","rsh":"\u21B1","Rsh":"\u21B1","rsqb":"]","rsquo":"\u2019","rsquor":"\u2019","rthree":"\u22CC","rtimes":"\u22CA","rtri":"\u25B9","rtrie":"\u22B5","rtrif":"\u25B8","rtriltri":"\u29CE","RuleDelayed":"\u29F4","ruluhar":"\u2968","rx":"\u211E","Sacute":"\u015A","sacute":"\u015B","sbquo":"\u201A","scap":"\u2AB8","Scaron":"\u0160","scaron":"\u0161","Sc":"\u2ABC","sc":"\u227B","sccue":"\u227D","sce":"\u2AB0","scE":"\u2AB4","Scedil":"\u015E","scedil":"\u015F","Scirc":"\u015C","scirc":"\u015D","scnap":"\u2ABA","scnE":"\u2AB6","scnsim":"\u22E9","scpolint":"\u2A13","scsim":"\u227F","Scy":"\u0421","scy":"\u0441","sdotb":"\u22A1","sdot":"\u22C5","sdote":"\u2A66","searhk":"\u2925","searr":"\u2198","seArr":"\u21D8","searrow":"\u2198","sect":"\u00A7","semi":";","seswar":"\u2929","setminus":"\u2216","setmn":"\u2216","sext":"\u2736","Sfr":"\uD835\uDD16","sfr":"\uD835\uDD30","sfrown":"\u2322","sharp":"\u266F","SHCHcy":"\u0429","shchcy":"\u0449","SHcy":"\u0428","shcy":"\u0448","ShortDownArrow":"\u2193","ShortLeftArrow":"\u2190","shortmid":"\u2223","shortparallel":"\u2225","ShortRightArrow":"\u2192","ShortUpArrow":"\u2191","shy":"\u00AD","Sigma":"\u03A3","sigma":"\u03C3","sigmaf":"\u03C2","sigmav":"\u03C2","sim":"\u223C","simdot":"\u2A6A","sime":"\u2243","simeq":"\u2243","simg":"\u2A9E","simgE":"\u2AA0","siml":"\u2A9D","simlE":"\u2A9F","simne":"\u2246","simplus":"\u2A24","simrarr":"\u2972","slarr":"\u2190","SmallCircle":"\u2218","smallsetminus":"\u2216","smashp":"\u2A33","smeparsl":"\u29E4","smid":"\u2223","smile":"\u2323","smt":"\u2AAA","smte":"\u2AAC","smtes":"\u2AAC\uFE00","SOFTcy":"\u042C","softcy":"\u044C","solbar":"\u233F","solb":"\u29C4","sol":"/","Sopf":"\uD835\uDD4A","sopf":"\uD835\uDD64","spades":"\u2660","spadesuit":"\u2660","spar":"\u2225","sqcap":"\u2293","sqcaps":"\u2293\uFE00","sqcup":"\u2294","sqcups":"\u2294\uFE00","Sqrt":"\u221A","sqsub":"\u228F","sqsube":"\u2291","sqsubset":"\u228F","sqsubseteq":"\u2291","sqsup":"\u2290","sqsupe":"\u2292","sqsupset":"\u2290","sqsupseteq":"\u2292","square":"\u25A1","Square":"\u25A1","SquareIntersection":"\u2293","SquareSubset":"\u228F","SquareSubsetEqual":"\u2291","SquareSuperset":"\u2290","SquareSupersetEqual":"\u2292","SquareUnion":"\u2294","squarf":"\u25AA","squ":"\u25A1","squf":"\u25AA","srarr":"\u2192","Sscr":"\uD835\uDCAE","sscr":"\uD835\uDCC8","ssetmn":"\u2216","ssmile":"\u2323","sstarf":"\u22C6","Star":"\u22C6","star":"\u2606","starf":"\u2605","straightepsilon":"\u03F5","straightphi":"\u03D5","strns":"\u00AF","sub":"\u2282","Sub":"\u22D0","subdot":"\u2ABD","subE":"\u2AC5","sube":"\u2286","subedot":"\u2AC3","submult":"\u2AC1","subnE":"\u2ACB","subne":"\u228A","subplus":"\u2ABF","subrarr":"\u2979","subset":"\u2282","Subset":"\u22D0","subseteq":"\u2286","subseteqq":"\u2AC5","SubsetEqual":"\u2286","subsetneq":"\u228A","subsetneqq":"\u2ACB","subsim":"\u2AC7","subsub":"\u2AD5","subsup":"\u2AD3","succapprox":"\u2AB8","succ":"\u227B","succcurlyeq":"\u227D","Succeeds":"\u227B","SucceedsEqual":"\u2AB0","SucceedsSlantEqual":"\u227D","SucceedsTilde":"\u227F","succeq":"\u2AB0","succnapprox":"\u2ABA","succneqq":"\u2AB6","succnsim":"\u22E9","succsim":"\u227F","SuchThat":"\u220B","sum":"\u2211","Sum":"\u2211","sung":"\u266A","sup1":"\u00B9","sup2":"\u00B2","sup3":"\u00B3","sup":"\u2283","Sup":"\u22D1","supdot":"\u2ABE","supdsub":"\u2AD8","supE":"\u2AC6","supe":"\u2287","supedot":"\u2AC4","Superset":"\u2283","SupersetEqual":"\u2287","suphsol":"\u27C9","suphsub":"\u2AD7","suplarr":"\u297B","supmult":"\u2AC2","supnE":"\u2ACC","supne":"\u228B","supplus":"\u2AC0","supset":"\u2283","Supset":"\u22D1","supseteq":"\u2287","supseteqq":"\u2AC6","supsetneq":"\u228B","supsetneqq":"\u2ACC","supsim":"\u2AC8","supsub":"\u2AD4","supsup":"\u2AD6","swarhk":"\u2926","swarr":"\u2199","swArr":"\u21D9","swarrow":"\u2199","swnwar":"\u292A","szlig":"\u00DF","Tab":"\t","target":"\u2316","Tau":"\u03A4","tau":"\u03C4","tbrk":"\u23B4","Tcaron":"\u0164","tcaron":"\u0165","Tcedil":"\u0162","tcedil":"\u0163","Tcy":"\u0422","tcy":"\u0442","tdot":"\u20DB","telrec":"\u2315","Tfr":"\uD835\uDD17","tfr":"\uD835\uDD31","there4":"\u2234","therefore":"\u2234","Therefore":"\u2234","Theta":"\u0398","theta":"\u03B8","thetasym":"\u03D1","thetav":"\u03D1","thickapprox":"\u2248","thicksim":"\u223C","ThickSpace":"\u205F\u200A","ThinSpace":"\u2009","thinsp":"\u2009","thkap":"\u2248","thksim":"\u223C","THORN":"\u00DE","thorn":"\u00FE","tilde":"\u02DC","Tilde":"\u223C","TildeEqual":"\u2243","TildeFullEqual":"\u2245","TildeTilde":"\u2248","timesbar":"\u2A31","timesb":"\u22A0","times":"\u00D7","timesd":"\u2A30","tint":"\u222D","toea":"\u2928","topbot":"\u2336","topcir":"\u2AF1","top":"\u22A4","Topf":"\uD835\uDD4B","topf":"\uD835\uDD65","topfork":"\u2ADA","tosa":"\u2929","tprime":"\u2034","trade":"\u2122","TRADE":"\u2122","triangle":"\u25B5","triangledown":"\u25BF","triangleleft":"\u25C3","trianglelefteq":"\u22B4","triangleq":"\u225C","triangleright":"\u25B9","trianglerighteq":"\u22B5","tridot":"\u25EC","trie":"\u225C","triminus":"\u2A3A","TripleDot":"\u20DB","triplus":"\u2A39","trisb":"\u29CD","tritime":"\u2A3B","trpezium":"\u23E2","Tscr":"\uD835\uDCAF","tscr":"\uD835\uDCC9","TScy":"\u0426","tscy":"\u0446","TSHcy":"\u040B","tshcy":"\u045B","Tstrok":"\u0166","tstrok":"\u0167","twixt":"\u226C","twoheadleftarrow":"\u219E","twoheadrightarrow":"\u21A0","Uacute":"\u00DA","uacute":"\u00FA","uarr":"\u2191","Uarr":"\u219F","uArr":"\u21D1","Uarrocir":"\u2949","Ubrcy":"\u040E","ubrcy":"\u045E","Ubreve":"\u016C","ubreve":"\u016D","Ucirc":"\u00DB","ucirc":"\u00FB","Ucy":"\u0423","ucy":"\u0443","udarr":"\u21C5","Udblac":"\u0170","udblac":"\u0171","udhar":"\u296E","ufisht":"\u297E","Ufr":"\uD835\uDD18","ufr":"\uD835\uDD32","Ugrave":"\u00D9","ugrave":"\u00F9","uHar":"\u2963","uharl":"\u21BF","uharr":"\u21BE","uhblk":"\u2580","ulcorn":"\u231C","ulcorner":"\u231C","ulcrop":"\u230F","ultri":"\u25F8","Umacr":"\u016A","umacr":"\u016B","uml":"\u00A8","UnderBar":"_","UnderBrace":"\u23DF","UnderBracket":"\u23B5","UnderParenthesis":"\u23DD","Union":"\u22C3","UnionPlus":"\u228E","Uogon":"\u0172","uogon":"\u0173","Uopf":"\uD835\uDD4C","uopf":"\uD835\uDD66","UpArrowBar":"\u2912","uparrow":"\u2191","UpArrow":"\u2191","Uparrow":"\u21D1","UpArrowDownArrow":"\u21C5","updownarrow":"\u2195","UpDownArrow":"\u2195","Updownarrow":"\u21D5","UpEquilibrium":"\u296E","upharpoonleft":"\u21BF","upharpoonright":"\u21BE","uplus":"\u228E","UpperLeftArrow":"\u2196","UpperRightArrow":"\u2197","upsi":"\u03C5","Upsi":"\u03D2","upsih":"\u03D2","Upsilon":"\u03A5","upsilon":"\u03C5","UpTeeArrow":"\u21A5","UpTee":"\u22A5","upuparrows":"\u21C8","urcorn":"\u231D","urcorner":"\u231D","urcrop":"\u230E","Uring":"\u016E","uring":"\u016F","urtri":"\u25F9","Uscr":"\uD835\uDCB0","uscr":"\uD835\uDCCA","utdot":"\u22F0","Utilde":"\u0168","utilde":"\u0169","utri":"\u25B5","utrif":"\u25B4","uuarr":"\u21C8","Uuml":"\u00DC","uuml":"\u00FC","uwangle":"\u29A7","vangrt":"\u299C","varepsilon":"\u03F5","varkappa":"\u03F0","varnothing":"\u2205","varphi":"\u03D5","varpi":"\u03D6","varpropto":"\u221D","varr":"\u2195","vArr":"\u21D5","varrho":"\u03F1","varsigma":"\u03C2","varsubsetneq":"\u228A\uFE00","varsubsetneqq":"\u2ACB\uFE00","varsupsetneq":"\u228B\uFE00","varsupsetneqq":"\u2ACC\uFE00","vartheta":"\u03D1","vartriangleleft":"\u22B2","vartriangleright":"\u22B3","vBar":"\u2AE8","Vbar":"\u2AEB","vBarv":"\u2AE9","Vcy":"\u0412","vcy":"\u0432","vdash":"\u22A2","vDash":"\u22A8","Vdash":"\u22A9","VDash":"\u22AB","Vdashl":"\u2AE6","veebar":"\u22BB","vee":"\u2228","Vee":"\u22C1","veeeq":"\u225A","vellip":"\u22EE","verbar":"|","Verbar":"\u2016","vert":"|","Vert":"\u2016","VerticalBar":"\u2223","VerticalLine":"|","VerticalSeparator":"\u2758","VerticalTilde":"\u2240","VeryThinSpace":"\u200A","Vfr":"\uD835\uDD19","vfr":"\uD835\uDD33","vltri":"\u22B2","vnsub":"\u2282\u20D2","vnsup":"\u2283\u20D2","Vopf":"\uD835\uDD4D","vopf":"\uD835\uDD67","vprop":"\u221D","vrtri":"\u22B3","Vscr":"\uD835\uDCB1","vscr":"\uD835\uDCCB","vsubnE":"\u2ACB\uFE00","vsubne":"\u228A\uFE00","vsupnE":"\u2ACC\uFE00","vsupne":"\u228B\uFE00","Vvdash":"\u22AA","vzigzag":"\u299A","Wcirc":"\u0174","wcirc":"\u0175","wedbar":"\u2A5F","wedge":"\u2227","Wedge":"\u22C0","wedgeq":"\u2259","weierp":"\u2118","Wfr":"\uD835\uDD1A","wfr":"\uD835\uDD34","Wopf":"\uD835\uDD4E","wopf":"\uD835\uDD68","wp":"\u2118","wr":"\u2240","wreath":"\u2240","Wscr":"\uD835\uDCB2","wscr":"\uD835\uDCCC","xcap":"\u22C2","xcirc":"\u25EF","xcup":"\u22C3","xdtri":"\u25BD","Xfr":"\uD835\uDD1B","xfr":"\uD835\uDD35","xharr":"\u27F7","xhArr":"\u27FA","Xi":"\u039E","xi":"\u03BE","xlarr":"\u27F5","xlArr":"\u27F8","xmap":"\u27FC","xnis":"\u22FB","xodot":"\u2A00","Xopf":"\uD835\uDD4F","xopf":"\uD835\uDD69","xoplus":"\u2A01","xotime":"\u2A02","xrarr":"\u27F6","xrArr":"\u27F9","Xscr":"\uD835\uDCB3","xscr":"\uD835\uDCCD","xsqcup":"\u2A06","xuplus":"\u2A04","xutri":"\u25B3","xvee":"\u22C1","xwedge":"\u22C0","Yacute":"\u00DD","yacute":"\u00FD","YAcy":"\u042F","yacy":"\u044F","Ycirc":"\u0176","ycirc":"\u0177","Ycy":"\u042B","ycy":"\u044B","yen":"\u00A5","Yfr":"\uD835\uDD1C","yfr":"\uD835\uDD36","YIcy":"\u0407","yicy":"\u0457","Yopf":"\uD835\uDD50","yopf":"\uD835\uDD6A","Yscr":"\uD835\uDCB4","yscr":"\uD835\uDCCE","YUcy":"\u042E","yucy":"\u044E","yuml":"\u00FF","Yuml":"\u0178","Zacute":"\u0179","zacute":"\u017A","Zcaron":"\u017D","zcaron":"\u017E","Zcy":"\u0417","zcy":"\u0437","Zdot":"\u017B","zdot":"\u017C","zeetrf":"\u2128","ZeroWidthSpace":"\u200B","Zeta":"\u0396","zeta":"\u03B6","zfr":"\uD835\uDD37","Zfr":"\u2128","ZHcy":"\u0416","zhcy":"\u0436","zigrarr":"\u21DD","zopf":"\uD835\uDD6B","Zopf":"\u2124","Zscr":"\uD835\uDCB5","zscr":"\uD835\uDCCF","zwj":"\u200D","zwnj":"\u200C"}
},{}],56:[function(require,module,exports){
module.exports={"Aacute":"\u00C1","aacute":"\u00E1","Acirc":"\u00C2","acirc":"\u00E2","acute":"\u00B4","AElig":"\u00C6","aelig":"\u00E6","Agrave":"\u00C0","agrave":"\u00E0","amp":"&","AMP":"&","Aring":"\u00C5","aring":"\u00E5","Atilde":"\u00C3","atilde":"\u00E3","Auml":"\u00C4","auml":"\u00E4","brvbar":"\u00A6","Ccedil":"\u00C7","ccedil":"\u00E7","cedil":"\u00B8","cent":"\u00A2","copy":"\u00A9","COPY":"\u00A9","curren":"\u00A4","deg":"\u00B0","divide":"\u00F7","Eacute":"\u00C9","eacute":"\u00E9","Ecirc":"\u00CA","ecirc":"\u00EA","Egrave":"\u00C8","egrave":"\u00E8","ETH":"\u00D0","eth":"\u00F0","Euml":"\u00CB","euml":"\u00EB","frac12":"\u00BD","frac14":"\u00BC","frac34":"\u00BE","gt":">","GT":">","Iacute":"\u00CD","iacute":"\u00ED","Icirc":"\u00CE","icirc":"\u00EE","iexcl":"\u00A1","Igrave":"\u00CC","igrave":"\u00EC","iquest":"\u00BF","Iuml":"\u00CF","iuml":"\u00EF","laquo":"\u00AB","lt":"<","LT":"<","macr":"\u00AF","micro":"\u00B5","middot":"\u00B7","nbsp":"\u00A0","not":"\u00AC","Ntilde":"\u00D1","ntilde":"\u00F1","Oacute":"\u00D3","oacute":"\u00F3","Ocirc":"\u00D4","ocirc":"\u00F4","Ograve":"\u00D2","ograve":"\u00F2","ordf":"\u00AA","ordm":"\u00BA","Oslash":"\u00D8","oslash":"\u00F8","Otilde":"\u00D5","otilde":"\u00F5","Ouml":"\u00D6","ouml":"\u00F6","para":"\u00B6","plusmn":"\u00B1","pound":"\u00A3","quot":"\"","QUOT":"\"","raquo":"\u00BB","reg":"\u00AE","REG":"\u00AE","sect":"\u00A7","shy":"\u00AD","sup1":"\u00B9","sup2":"\u00B2","sup3":"\u00B3","szlig":"\u00DF","THORN":"\u00DE","thorn":"\u00FE","times":"\u00D7","Uacute":"\u00DA","uacute":"\u00FA","Ucirc":"\u00DB","ucirc":"\u00FB","Ugrave":"\u00D9","ugrave":"\u00F9","uml":"\u00A8","Uuml":"\u00DC","uuml":"\u00FC","Yacute":"\u00DD","yacute":"\u00FD","yen":"\u00A5","yuml":"\u00FF"}
},{}],57:[function(require,module,exports){
module.exports={"amp":"&","apos":"'","gt":">","lt":"<","quot":"\""}

},{}],58:[function(require,module,exports){
function EventEmitter() {
    this._events = this._events || {};
    this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;
EventEmitter.defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function (n) {
    if (!isNumber(n) || n < 0 || isNaN(n))
        throw TypeError('n must be a positive number');
    this._maxListeners = n;
    return this;
};
EventEmitter.prototype.emit = function (type) {
    var er, handler, len, args, i, listeners;
    if (!this._events)
        this._events = {};
    if (type === 'error') {
        if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
            er = arguments[1];
            if (er instanceof Error) {
                throw er;
            } else {
                var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
                err.context = er;
                throw err;
            }
        }
    }
    handler = this._events[type];
    if (isUndefined(handler))
        return false;
    if (isFunction(handler)) {
        switch (arguments.length) {
        case 1:
            handler.call(this);
            break;
        case 2:
            handler.call(this, arguments[1]);
            break;
        case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
        default:
            args = Array.prototype.slice.call(arguments, 1);
            handler.apply(this, args);
        }
    } else if (isObject(handler)) {
        args = Array.prototype.slice.call(arguments, 1);
        listeners = handler.slice();
        len = listeners.length;
        for (i = 0; i < len; i++)
            listeners[i].apply(this, args);
    }
    return true;
};
EventEmitter.prototype.addListener = function (type, listener) {
    var m;
    if (!isFunction(listener))
        throw TypeError('listener must be a function');
    if (!this._events)
        this._events = {};
    if (this._events.newListener)
        this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);
    if (!this._events[type])
        this._events[type] = listener;
    else if (isObject(this._events[type]))
        this._events[type].push(listener);
    else
        this._events[type] = [
            this._events[type],
            listener
        ];
    if (isObject(this._events[type]) && !this._events[type].warned) {
        if (!isUndefined(this._maxListeners)) {
            m = this._maxListeners;
        } else {
            m = EventEmitter.defaultMaxListeners;
        }
        if (m && m > 0 && this._events[type].length > m) {
            this._events[type].warned = true;
            console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
            if (typeof console.trace === 'function') {
                console.trace();
            }
        }
    }
    return this;
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.once = function (type, listener) {
    if (!isFunction(listener))
        throw TypeError('listener must be a function');
    var fired = false;
    function g() {
        this.removeListener(type, g);
        if (!fired) {
            fired = true;
            listener.apply(this, arguments);
        }
    }
    g.listener = listener;
    this.on(type, g);
    return this;
};
EventEmitter.prototype.removeListener = function (type, listener) {
    var list, position, length, i;
    if (!isFunction(listener))
        throw TypeError('listener must be a function');
    if (!this._events || !this._events[type])
        return this;
    list = this._events[type];
    length = list.length;
    position = -1;
    if (list === listener || isFunction(list.listener) && list.listener === listener) {
        delete this._events[type];
        if (this._events.removeListener)
            this.emit('removeListener', type, listener);
    } else if (isObject(list)) {
        for (i = length; i-- > 0;) {
            if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                position = i;
                break;
            }
        }
        if (position < 0)
            return this;
        if (list.length === 1) {
            list.length = 0;
            delete this._events[type];
        } else {
            list.splice(position, 1);
        }
        if (this._events.removeListener)
            this.emit('removeListener', type, listener);
    }
    return this;
};
EventEmitter.prototype.removeAllListeners = function (type) {
    var key, listeners;
    if (!this._events)
        return this;
    if (!this._events.removeListener) {
        if (arguments.length === 0)
            this._events = {};
        else if (this._events[type])
            delete this._events[type];
        return this;
    }
    if (arguments.length === 0) {
        for (key in this._events) {
            if (key === 'removeListener')
                continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = {};
        return this;
    }
    listeners = this._events[type];
    if (isFunction(listeners)) {
        this.removeListener(type, listeners);
    } else if (listeners) {
        while (listeners.length)
            this.removeListener(type, listeners[listeners.length - 1]);
    }
    delete this._events[type];
    return this;
};
EventEmitter.prototype.listeners = function (type) {
    var ret;
    if (!this._events || !this._events[type])
        ret = [];
    else if (isFunction(this._events[type]))
        ret = [this._events[type]];
    else
        ret = this._events[type].slice();
    return ret;
};
EventEmitter.prototype.listenerCount = function (type) {
    if (this._events) {
        var evlistener = this._events[type];
        if (isFunction(evlistener))
            return 1;
        else if (evlistener)
            return evlistener.length;
    }
    return 0;
};
EventEmitter.listenerCount = function (emitter, type) {
    return emitter.listenerCount(type);
};
function isFunction(arg) {
    return typeof arg === 'function';
}
function isNumber(arg) {
    return typeof arg === 'number';
}
function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}
function isUndefined(arg) {
    return arg === void 0;
}
},{}],59:[function(require,module,exports){
var from2 = require(60);
var toBuffer = require(272);
module.exports = function (file, options) {
    options = options || {};
    var offset = options.offset || 0;
    var chunkSize = options.chunkSize || 1024 * 1024;
    var fileReader = new FileReader(file);
    var from = from2(function (size, cb) {
        if (offset >= file.size)
            return cb(null, null);
        fileReader.onloadend = function loaded(event) {
            var data = event.target.result;
            if (data instanceof ArrayBuffer)
                data = toBuffer(new Uint8Array(event.target.result));
            cb(null, data);
        };
        var end = offset + chunkSize;
        var slice = file.slice(offset, end);
        fileReader.readAsArrayBuffer(slice);
        offset = end;
    });
    from.name = file.name;
    from.size = file.size;
    from.type = file.type;
    from.lastModifiedDate = file.lastModifiedDate;
    fileReader.onerror = function (err) {
        from.destroy(err);
    };
    return from;
};
},{"272":272,"60":60}],60:[function(require,module,exports){
(function (process){
var Readable = require(263).Readable;
var inherits = require(73);
module.exports = from2;
from2.ctor = ctor;
from2.obj = obj;
var Proto = ctor();
function toFunction(list) {
    list = list.slice();
    return function (_, cb) {
        var err = null;
        var item = list.length ? list.shift() : null;
        if (item instanceof Error) {
            err = item;
            item = null;
        }
        cb(err, item);
    };
}
function from2(opts, read) {
    if (typeof opts !== 'object' || Array.isArray(opts)) {
        read = opts;
        opts = {};
    }
    var rs = new Proto(opts);
    rs._from = Array.isArray(read) ? toFunction(read) : read || noop;
    return rs;
}
function ctor(opts, read) {
    if (typeof opts === 'function') {
        read = opts;
        opts = {};
    }
    opts = defaults(opts);
    inherits(Class, Readable);
    function Class(override) {
        if (!(this instanceof Class))
            return new Class(override);
        this._reading = false;
        this._callback = check;
        this.destroyed = false;
        Readable.call(this, override || opts);
        var self = this;
        var hwm = this._readableState.highWaterMark;
        function check(err, data) {
            if (self.destroyed)
                return;
            if (err)
                return self.destroy(err);
            if (data === null)
                return self.push(null);
            self._reading = false;
            if (self.push(data))
                self._read(hwm);
        }
    }
    Class.prototype._from = read || noop;
    Class.prototype._read = function (size) {
        if (this._reading || this.destroyed)
            return;
        this._reading = true;
        this._from(size, this._callback);
    };
    Class.prototype.destroy = function (err) {
        if (this.destroyed)
            return;
        this.destroyed = true;
        var self = this;
        process.nextTick(function () {
            if (err)
                self.emit('error', err);
            self.emit('close');
        });
    };
    return Class;
}
function obj(opts, read) {
    if (typeof opts === 'function' || Array.isArray(opts)) {
        read = opts;
        opts = {};
    }
    opts = defaults(opts);
    opts.objectMode = true;
    opts.highWaterMark = 16;
    return from2(opts, read);
}
function noop() {
}
function defaults(opts) {
    opts = opts || {};
    return opts;
}
}).call(this,require(251))
},{"251":251,"263":263,"73":73}],61:[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};
var minDoc = require(5);
var doccy;
if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];
    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}
module.exports = doccy;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"5":5}],62:[function(require,module,exports){
(function (global){
var win;
if (typeof window !== 'undefined') {
    win = window;
} else if (typeof global !== 'undefined') {
    win = global;
} else if (typeof self !== 'undefined') {
    win = self;
} else {
    win = {};
}
module.exports = win;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],63:[function(require,module,exports){
(function (exports) {
    function xassert(test) {
        if (!test) {
            throw new Error('assert');
        }
    }
    var GLP_DEBUG = false, DBL_MAX = Number.MAX_VALUE, DBL_MIN = Number.MIN_VALUE, DBL_DIG = 16, INT_MAX = 2147483647, DBL_EPSILON = 2.220446049250313e-16, CHAR_BIT = 1;
    var M_MAX = 100000000, N_MAX = 100000000, NNZ_MAX = 500000000;
    var XEOF = -1;
    function xerror(message) {
        throw new Error(message);
    }
    var xprintf = function (data) {
    };
    exports['glp_get_print_func'] = function () {
        return xprintf;
    };
    exports['glp_set_print_func'] = function (value) {
        xprintf = value;
    };
    function xcopyObj(dest, src) {
        for (var prop in src) {
            dest[prop] = src[prop];
        }
    }
    function xcopyArr(dest, destFrom, src, srcFrom, count) {
        for (; count > 0; destFrom++, srcFrom++, count--) {
            dest[destFrom] = src[srcFrom];
        }
    }
    function xfillArr(dest, destFrom, value, count) {
        for (; count > 0; destFrom++, count--) {
            dest[destFrom] = value;
        }
    }
    function xfillObjArr(dest, destFrom, count) {
        for (; count > 0; destFrom++, count--) {
            dest[destFrom] = {};
        }
    }
    function xtime() {
        var d = new Date();
        return d.getTime();
    }
    function xdifftime(to, from) {
        return (to - from) / 1000;
    }
    function xqsort(base, idx, num, compar) {
        var tmp = new Array(num);
        xcopyArr(tmp, 0, base, idx, num);
        tmp.sort(compar);
        xcopyArr(base, idx, tmp, 0, num);
    }
    var global_env = {};
    function get_env_ptr() {
        return global_env;
    }
    var glp_version = exports['glp_version'] = function () {
        return GLP_MAJOR_VERSION + '.' + GLP_MINOR_VERSION;
    };
    function isspace(c) {
        return ' \t\n\x0B\f\r'.indexOf(c) >= 0;
    }
    function iscntrl(c) {
        var code = typeof c == 'string' ? c.charCodeAt(0) : -1;
        return code >= 0 && code <= 31 || code == 127;
    }
    function isalpha(c) {
        var code = typeof c == 'string' ? c.charCodeAt(0) : -1;
        return code >= 65 && code <= 90 || code >= 97 && code <= 122;
    }
    function isalnum(c) {
        var code = typeof c == 'string' ? c.charCodeAt(0) : -1;
        return code >= 65 && code <= 90 || code >= 97 && code <= 122 || code >= 48 && code <= 57;
    }
    function isdigit(c) {
        var code = typeof c == 'string' ? c.charCodeAt(0) : -1;
        return code >= 48 && code <= 57;
    }
    function strchr(str, c) {
        return str.indexOf(c);
    }
    function tolower(c) {
        return c.toLowerCase();
    }
    function sprintf() {
        var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
        var a = arguments, i = 0, format = a[i++];
        var pad = function (str, len, chr, leftJustify) {
            if (!chr) {
                chr = ' ';
            }
            var padding = str.length >= len ? '' : Array(1 + len - str.length >>> 0).join(chr);
            return leftJustify ? str + padding : padding + str;
        };
        var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
            var diff = minWidth - value.length;
            if (diff > 0) {
                if (leftJustify || !zeroPad) {
                    value = pad(value, minWidth, customPadChar, leftJustify);
                } else {
                    value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
                }
            }
            return value;
        };
        var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
            var number = value >>> 0;
            prefix = prefix && number && {
                '2': '0b',
                '8': '0',
                '16': '0x'
            }[base] || '';
            value = prefix + pad(number.toString(base), precision || 0, '0', false);
            return justify(value, prefix, leftJustify, minWidth, zeroPad);
        };
        var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
            if (precision != null) {
                value = value.slice(0, precision);
            }
            return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
        };
        var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
            var number;
            var prefix;
            var method;
            var textTransform;
            var value;
            if (substring == '%%') {
                return '%';
            }
            var leftJustify = false, positivePrefix = '', zeroPad = false, prefixBaseX = false, customPadChar = ' ';
            var flagsl = flags.length;
            for (var j = 0; flags && j < flagsl; j++) {
                switch (flags.charAt(j)) {
                case ' ':
                    positivePrefix = ' ';
                    break;
                case '+':
                    positivePrefix = '+';
                    break;
                case '-':
                    leftJustify = true;
                    break;
                case '\'':
                    customPadChar = flags.charAt(j + 1);
                    break;
                case '0':
                    zeroPad = true;
                    break;
                case '#':
                    prefixBaseX = true;
                    break;
                }
            }
            if (!minWidth) {
                minWidth = 0;
            } else if (minWidth == '*') {
                minWidth = +a[i++];
            } else if (minWidth.charAt(0) == '*') {
                minWidth = +a[minWidth.slice(1, -1)];
            } else {
                minWidth = +minWidth;
            }
            if (minWidth < 0) {
                minWidth = -minWidth;
                leftJustify = true;
            }
            if (!isFinite(minWidth)) {
                throw new Error('sprintf: (minimum-)width must be finite');
            }
            if (!precision) {
                precision = 'fFeE'.indexOf(type) > -1 ? 6 : type == 'd' ? 0 : undefined;
            } else if (precision == '*') {
                precision = +a[i++];
            } else if (precision.charAt(0) == '*') {
                precision = +a[precision.slice(1, -1)];
            } else {
                precision = +precision;
            }
            value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];
            switch (type) {
            case 's':
                return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
            case 'c':
                return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
            case 'b':
                return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'o':
                return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'x':
                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'X':
                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();
            case 'u':
                return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'i':
            case 'd':
                number = +value || 0;
                number = Math.round(number - number % 1);
                prefix = number < 0 ? '-' : positivePrefix;
                value = prefix + pad(String(Math.abs(number)), precision, '0', false);
                return justify(value, prefix, leftJustify, minWidth, zeroPad);
            case 'e':
            case 'E':
            case 'f':
            case 'F':
            case 'g':
            case 'G':
                number = +value;
                prefix = number < 0 ? '-' : positivePrefix;
                method = [
                    'toExponential',
                    'toFixed',
                    'toPrecision'
                ]['efg'.indexOf(type.toLowerCase())];
                textTransform = [
                    'toString',
                    'toUpperCase'
                ]['eEfFgG'.indexOf(type) % 2];
                value = prefix + Math.abs(number)[method](precision);
                return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
            default:
                return substring;
            }
        };
        return format.replace(regex, doFormat);
    }
    var GLP_PROB_MAGIC = 3621377730;
    function create_prob(lp) {
        lp.magic = GLP_PROB_MAGIC;
        lp.parms = null;
        lp.tree = null;
        lp.name = null;
        lp.obj = null;
        lp.dir = GLP_MIN;
        lp.c0 = 0;
        lp.m_max = 100;
        lp.n_max = 200;
        lp.m = lp.n = 0;
        lp.nnz = 0;
        lp.row = new Array(1 + lp.m_max);
        lp.col = new Array(1 + lp.n_max);
        lp.r_tree = {};
        lp.c_tree = {};
        lp.valid = 0;
        lp.head = new Int32Array(1 + lp.m_max);
        lp.bfcp = null;
        lp.bfd = null;
        lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;
        lp.obj_val = 0;
        lp.it_cnt = 0;
        lp.some = 0;
        lp.ipt_stat = GLP_UNDEF;
        lp.ipt_obj = 0;
        lp.mip_stat = GLP_UNDEF;
        lp.mip_obj = 0;
    }
    var glp_create_prob = exports['glp_create_prob'] = function () {
        var lp = {};
        create_prob(lp);
        return lp;
    };
    var glp_set_prob_name = exports['glp_set_prob_name'] = function (lp, name) {
        var tree = lp.tree;
        if (tree != null && tree.reason != 0)
            xerror('glp_set_prob_name: operation not allowed');
        lp.name = name;
    };
    var glp_set_obj_name = exports['glp_set_obj_name'] = function (lp, name) {
        var tree = lp.tree;
        if (tree != null && tree.reason != 0)
            xerror('glp_set_obj_name: operation not allowed');
        lp.obj = name;
    };
    var glp_set_obj_dir = exports['glp_set_obj_dir'] = function (lp, dir) {
        var tree = lp.tree;
        if (tree != null && tree.reason != 0)
            xerror('glp_set_obj_dir: operation not allowed');
        if (!(dir == GLP_MIN || dir == GLP_MAX))
            xerror('glp_set_obj_dir: dir = ' + dir + '; invalid direction flag');
        lp.dir = dir;
    };
    var glp_add_rows = exports['glp_add_rows'] = function (lp, nrs) {
        var tree = lp.tree;
        var row;
        if (nrs < 1)
            xerror('glp_add_rows: nrs = ' + nrs + '; invalid number of rows');
        if (nrs > M_MAX - lp.m)
            xerror('glp_add_rows: nrs = ' + nrs + '; too many rows');
        var m_new = lp.m + nrs;
        if (lp.m_max < m_new) {
            while (lp.m_max < m_new) {
                lp.m_max += lp.m_max;
                xassert(lp.m_max > 0);
            }
            lp.row.length = 1 + lp.m_max;
            lp.head = new Int32Array(1 + lp.m_max);
        }
        for (var i = lp.m + 1; i <= m_new; i++) {
            lp.row[i] = row = {};
            row.i = i;
            row.name = null;
            row.node = null;
            row.level = 0;
            row.origin = 0;
            row.klass = 0;
            if (tree != null) {
                switch (tree.reason) {
                case 0:
                    break;
                case GLP_IROWGEN:
                    xassert(tree.curr != null);
                    row.level = tree.curr.level;
                    row.origin = GLP_RF_LAZY;
                    break;
                case GLP_ICUTGEN:
                    xassert(tree.curr != null);
                    row.level = tree.curr.level;
                    row.origin = GLP_RF_CUT;
                    break;
                default:
                    xassert(tree != tree);
                }
            }
            row.type = GLP_FR;
            row.lb = row.ub = 0;
            row.ptr = null;
            row.rii = 1;
            row.stat = GLP_BS;
            row.bind = 0;
            row.prim = row.dual = 0;
            row.pval = row.dval = 0;
            row.mipx = 0;
        }
        lp.m = m_new;
        lp.valid = 0;
        if (tree != null && tree.reason != 0)
            tree.reopt = 1;
        return m_new - nrs + 1;
    };
    var glp_add_cols = exports['glp_add_cols'] = function (lp, ncs) {
        var tree = lp.tree;
        var col;
        if (tree != null && tree.reason != 0)
            xerror('glp_add_cols: operation not allowed');
        if (ncs < 1)
            xerror('glp_add_cols: ncs = ' + ncs + '; invalid number of columns');
        if (ncs > N_MAX - lp.n)
            xerror('glp_add_cols: ncs = ' + ncs + '; too many columns');
        var n_new = lp.n + ncs;
        if (lp.n_max < n_new) {
            while (lp.n_max < n_new) {
                lp.n_max += lp.n_max;
                xassert(lp.n_max > 0);
            }
            lp.col.length = 1 + lp.n_max;
        }
        for (var j = lp.n + 1; j <= n_new; j++) {
            lp.col[j] = col = {};
            col.j = j;
            col.name = null;
            col.node = null;
            col.kind = GLP_CV;
            col.type = GLP_FX;
            col.lb = col.ub = 0;
            col.coef = 0;
            col.ptr = null;
            col.sjj = 1;
            col.stat = GLP_NS;
            col.bind = 0;
            col.prim = col.dual = 0;
            col.pval = col.dval = 0;
            col.mipx = 0;
        }
        lp.n = n_new;
        return n_new - ncs + 1;
    };
    var glp_set_row_name = exports['glp_set_row_name'] = function (lp, i, name) {
        var tree = lp.tree;
        if (!(1 <= i && i <= lp.m))
            xerror('glp_set_row_name: i = ' + i + '; row number out of range');
        var row = lp.row[i];
        if (tree != null && tree.reason != 0) {
            xassert(tree.curr != null);
            xassert(row.level == tree.curr.level);
        }
        if (row.name != null) {
            delete lp.r_tree[row.name];
            row.name = null;
        }
        if (name != null) {
            row.name = name;
            lp.r_tree[row.name] = row;
        }
    };
    var glp_set_col_name = exports['glp_set_col_name'] = function (lp, j, name) {
        var tree = lp.tree;
        if (tree != null && tree.reason != 0)
            xerror('glp_set_col_name: operation not allowed');
        if (!(1 <= j && j <= lp.n))
            xerror('glp_set_col_name: j = ' + j + '; column number out of range');
        var col = lp.col[j];
        if (col.name != null) {
            delete lp.c_tree[col.name];
            col.name = null;
        }
        if (name != null) {
            col.name = name;
            lp.c_tree[col.name] = col;
        }
    };
    var glp_set_row_bnds = exports['glp_set_row_bnds'] = function (lp, i, type, lb, ub) {
        if (!(1 <= i && i <= lp.m))
            xerror('glp_set_row_bnds: i = ' + i + '; row number out of range');
        var row = lp.row[i];
        row.type = type;
        switch (type) {
        case GLP_FR:
            row.lb = row.ub = 0;
            if (row.stat != GLP_BS)
                row.stat = GLP_NF;
            break;
        case GLP_LO:
            row.lb = lb;
            row.ub = 0;
            if (row.stat != GLP_BS)
                row.stat = GLP_NL;
            break;
        case GLP_UP:
            row.lb = 0;
            row.ub = ub;
            if (row.stat != GLP_BS)
                row.stat = GLP_NU;
            break;
        case GLP_DB:
            row.lb = lb;
            row.ub = ub;
            if (!(row.stat == GLP_BS || row.stat == GLP_NL || row.stat == GLP_NU))
                row.stat = Math.abs(lb) <= Math.abs(ub) ? GLP_NL : GLP_NU;
            break;
        case GLP_FX:
            row.lb = row.ub = lb;
            if (row.stat != GLP_BS)
                row.stat = GLP_NS;
            break;
        default:
            xerror('glp_set_row_bnds: i = ' + i + '; type = ' + type + '; invalid row type');
        }
    };
    var glp_set_col_bnds = exports['glp_set_col_bnds'] = function (lp, j, type, lb, ub) {
        if (!(1 <= j && j <= lp.n))
            xerror('glp_set_col_bnds: j = ' + j + '; column number out of range');
        var col = lp.col[j];
        col.type = type;
        switch (type) {
        case GLP_FR:
            col.lb = col.ub = 0;
            if (col.stat != GLP_BS)
                col.stat = GLP_NF;
            break;
        case GLP_LO:
            col.lb = lb;
            col.ub = 0;
            if (col.stat != GLP_BS)
                col.stat = GLP_NL;
            break;
        case GLP_UP:
            col.lb = 0;
            col.ub = ub;
            if (col.stat != GLP_BS)
                col.stat = GLP_NU;
            break;
        case GLP_DB:
            col.lb = lb;
            col.ub = ub;
            if (!(col.stat == GLP_BS || col.stat == GLP_NL || col.stat == GLP_NU))
                col.stat = Math.abs(lb) <= Math.abs(ub) ? GLP_NL : GLP_NU;
            break;
        case GLP_FX:
            col.lb = col.ub = lb;
            if (col.stat != GLP_BS)
                col.stat = GLP_NS;
            break;
        default:
            xerror('glp_set_col_bnds: j = ' + j + '; type = ' + type + '; invalid column type');
        }
    };
    var glp_set_obj_coef = exports['glp_set_obj_coef'] = function (lp, j, coef) {
        var tree = lp.tree;
        if (tree != null && tree.reason != 0)
            xerror('glp_set_obj_coef: operation not allowed');
        if (!(0 <= j && j <= lp.n))
            xerror('glp_set_obj_coef: j = ' + j + '; column number out of range');
        if (j == 0)
            lp.c0 = coef;
        else
            lp.col[j].coef = coef;
    };
    var glp_set_mat_row = exports['glp_set_mat_row'] = function (lp, i, len, ind, val) {
        var tree = lp.tree;
        var col, aij, next, j, k;
        if (!(1 <= i && i <= lp.m))
            xerror('glp_set_mat_row: i = ' + i + '; row number out of range');
        var row = lp.row[i];
        if (tree != null && tree.reason != 0) {
            xassert(tree.curr != null);
            xassert(row.level == tree.curr.level);
        }
        while (row.ptr != null) {
            aij = row.ptr;
            row.ptr = aij.r_next;
            col = aij.col;
            if (aij.c_prev == null)
                col.ptr = aij.c_next;
            else
                aij.c_prev.c_next = aij.c_next;
            if (aij.c_next != null)
                aij.c_next.c_prev = aij.c_prev;
            lp.nnz--;
            if (col.stat == GLP_BS)
                lp.valid = 0;
        }
        if (!(0 <= len && len <= lp.n))
            xerror('glp_set_mat_row: i = ' + i + '; len = ' + len + '; invalid row length ');
        if (len > NNZ_MAX - lp.nnz)
            xerror('glp_set_mat_row: i = ' + i + '; len = ' + len + '; too many constraint coefficients');
        for (k = 1; k <= len; k++) {
            j = ind[k];
            if (!(1 <= j && j <= lp.n))
                xerror('glp_set_mat_row: i = ' + i + '; ind[' + k + '] = ' + j + '; column index out of range');
            col = lp.col[j];
            if (col.ptr != null && col.ptr.row.i == i)
                xerror('glp_set_mat_row: i = ' + i + '; ind[' + k + '] = ' + j + '; duplicate column indices not allowed');
            aij = {};
            lp.nnz++;
            aij.row = row;
            aij.col = col;
            aij.val = val[k];
            aij.r_prev = null;
            aij.r_next = row.ptr;
            aij.c_prev = null;
            aij.c_next = col.ptr;
            if (aij.r_next != null)
                aij.r_next.r_prev = aij;
            if (aij.c_next != null)
                aij.c_next.c_prev = aij;
            row.ptr = col.ptr = aij;
            if (col.stat == GLP_BS && aij.val != 0)
                lp.valid = 0;
        }
        for (aij = row.ptr; aij != null; aij = next) {
            next = aij.r_next;
            if (aij.val == 0) {
                if (aij.r_prev == null)
                    row.ptr = next;
                else
                    aij.r_prev.r_next = next;
                if (next != null)
                    next.r_prev = aij.r_prev;
                xassert(aij.c_prev == null);
                aij.col.ptr = aij.c_next;
                if (aij.c_next != null)
                    aij.c_next.c_prev = null;
                lp.nnz--;
            }
        }
    };
    var glp_set_mat_col = exports['glp_set_mat_col'] = function (lp, j, len, ind, val) {
        var tree = lp.tree;
        var row, aij, next;
        var i, k;
        if (tree != null && tree.reason != 0)
            xerror('glp_set_mat_col: operation not allowed');
        if (!(1 <= j && j <= lp.n))
            xerror('glp_set_mat_col: j = ' + j + '; column number out of range');
        var col = lp.col[j];
        while (col.ptr != null) {
            aij = col.ptr;
            col.ptr = aij.c_next;
            row = aij.row;
            if (aij.r_prev == null)
                row.ptr = aij.r_next;
            else
                aij.r_prev.r_next = aij.r_next;
            if (aij.r_next != null)
                aij.r_next.r_prev = aij.r_prev;
            lp.nnz--;
        }
        if (!(0 <= len && len <= lp.m))
            xerror('glp_set_mat_col: j = ' + j + '; len = ' + len + '; invalid column length');
        if (len > NNZ_MAX - lp.nnz)
            xerror('glp_set_mat_col: j = ' + j + '; len = ' + len + '; too many constraint coefficients');
        for (k = 1; k <= len; k++) {
            i = ind[k];
            if (!(1 <= i && i <= lp.m))
                xerror('glp_set_mat_col: j = ' + j + '; ind[' + k + '] = ' + i + '; row index out of range');
            row = lp.row[i];
            if (row.ptr != null && row.ptr.col.j == j)
                xerror('glp_set_mat_col: j = ' + j + '; ind[' + k + '] = ' + i + '; duplicate row indices not allowed');
            aij = {};
            lp.nnz++;
            aij.row = row;
            aij.col = col;
            aij.val = val[k];
            aij.r_prev = null;
            aij.r_next = row.ptr;
            aij.c_prev = null;
            aij.c_next = col.ptr;
            if (aij.r_next != null)
                aij.r_next.r_prev = aij;
            if (aij.c_next != null)
                aij.c_next.c_prev = aij;
            row.ptr = col.ptr = aij;
        }
        for (aij = col.ptr; aij != null; aij = next) {
            next = aij.c_next;
            if (aij.val == 0) {
                xassert(aij.r_prev == null);
                aij.row.ptr = aij.r_next;
                if (aij.r_next != null)
                    aij.r_next.r_prev = null;
                if (aij.c_prev == null)
                    col.ptr = next;
                else
                    aij.c_prev.c_next = next;
                if (next != null)
                    next.c_prev = aij.c_prev;
                lp.nnz--;
            }
        }
        if (col.stat == GLP_BS)
            lp.valid = 0;
    };
    var glp_load_matrix = exports['glp_load_matrix'] = function (lp, ne, ia, ja, ar) {
        var tree = lp.tree;
        var row, col, aij, next;
        var i, j, k;
        if (tree != null && tree.reason != 0)
            xerror('glp_load_matrix: operation not allowed');
        for (i = 1; i <= lp.m; i++) {
            row = lp.row[i];
            while (row.ptr != null) {
                aij = row.ptr;
                row.ptr = aij.r_next;
                lp.nnz--;
            }
        }
        xassert(lp.nnz == 0);
        for (j = 1; j <= lp.n; j++)
            lp.col[j].ptr = null;
        if (ne < 0)
            xerror('glp_load_matrix: ne = ' + ne + '; invalid number of constraint coefficients');
        if (ne > NNZ_MAX)
            xerror('glp_load_matrix: ne = ' + ne + '; too many constraint coefficients');
        for (k = 1; k <= ne; k++) {
            i = ia[k];
            j = ja[k];
            if (!(1 <= i && i <= lp.m))
                xerror('glp_load_matrix: ia[' + k + '] = ' + i + '; row index out of range');
            row = lp.row[i];
            if (!(1 <= j && j <= lp.n))
                xerror('glp_load_matrix: ja[' + k + '] = ' + j + '; column index out of range');
            col = lp.col[j];
            aij = {};
            lp.nnz++;
            aij.row = row;
            aij.col = col;
            aij.val = ar[k];
            aij.r_prev = null;
            aij.r_next = row.ptr;
            if (aij.r_next != null)
                aij.r_next.r_prev = aij;
            row.ptr = aij;
        }
        xassert(lp.nnz == ne);
        for (i = 1; i <= lp.m; i++) {
            for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next) {
                col = aij.col;
                if (col.ptr != null && col.ptr.row.i == i) {
                    for (k = 1; k <= ne; k++)
                        if (ia[k] == i && ja[k] == col.j)
                            break;
                    xerror('glp_load_mat: ia[' + k + '] = ' + i + '; ja[' + k + '] = ' + col.j + '; duplicate indices not allowed');
                }
                aij.c_prev = null;
                aij.c_next = col.ptr;
                if (aij.c_next != null)
                    aij.c_next.c_prev = aij;
                col.ptr = aij;
            }
        }
        for (i = 1; i <= lp.m; i++) {
            row = lp.row[i];
            for (aij = row.ptr; aij != null; aij = next) {
                next = aij.r_next;
                if (aij.val == 0) {
                    if (aij.r_prev == null)
                        row.ptr = next;
                    else
                        aij.r_prev.r_next = next;
                    if (next != null)
                        next.r_prev = aij.r_prev;
                    if (aij.c_prev == null)
                        aij.col.ptr = aij.c_next;
                    else
                        aij.c_prev.c_next = aij.c_next;
                    if (aij.c_next != null)
                        aij.c_next.c_prev = aij.c_prev;
                    lp.nnz--;
                }
            }
        }
        lp.valid = 0;
    };
    var glp_check_dup = exports['glp_check_dup'] = function (m, n, ne, ia, ja) {
        var i, j, k, ptr, next, ret;
        var flag;
        if (m < 0)
            xerror('glp_check_dup: m = %d; invalid parameter');
        if (n < 0)
            xerror('glp_check_dup: n = %d; invalid parameter');
        if (ne < 0)
            xerror('glp_check_dup: ne = %d; invalid parameter');
        if (ne > 0 && ia == null)
            xerror('glp_check_dup: ia = ' + ia + '; invalid parameter');
        if (ne > 0 && ja == null)
            xerror('glp_check_dup: ja = ' + ja + '; invalid parameter');
        for (k = 1; k <= ne; k++) {
            i = ia[k];
            j = ja[k];
            if (!(1 <= i && i <= m && 1 <= j && j <= n)) {
                ret = -k;
                return ret;
            }
        }
        if (m == 0 || n == 0) {
            ret = 0;
            return ret;
        }
        ptr = new Int32Array(1 + m);
        next = new Int32Array(1 + ne);
        flag = new Int8Array(1 + n);
        for (k = 1; k <= ne; k++) {
            i = ia[k];
            next[k] = ptr[i];
            ptr[i] = k;
        }
        for (i = 1; i <= m; i++) {
            for (k = ptr[i]; k != 0; k = next[k]) {
                j = ja[k];
                if (flag[j]) {
                    for (k = 1; k <= ne; k++)
                        if (ia[k] == i && ja[k] == j)
                            break;
                    xassert(k <= ne);
                    for (k++; k <= ne; k++)
                        if (ia[k] == i && ja[k] == j)
                            break;
                    xassert(k <= ne);
                    ret = +k;
                    return ret;
                }
                flag[j] = 1;
            }
            for (k = ptr[i]; k != 0; k = next[k])
                flag[ja[k]] = 0;
        }
        ret = 0;
        return ret;
    };
    var glp_sort_matrix = exports['glp_sort_matrix'] = function (P) {
        var aij;
        var i, j;
        if (P == null || P.magic != GLP_PROB_MAGIC)
            xerror('glp_sort_matrix: P = ' + P + '; invalid problem object');
        for (i = P.m; i >= 1; i--)
            P.row[i].ptr = null;
        for (j = P.n; j >= 1; j--) {
            for (aij = P.col[j].ptr; aij != null; aij = aij.c_next) {
                i = aij.row.i;
                aij.r_prev = null;
                aij.r_next = P.row[i].ptr;
                if (aij.r_next != null)
                    aij.r_next.r_prev = aij;
                P.row[i].ptr = aij;
            }
        }
        for (j = P.n; j >= 1; j--)
            P.col[j].ptr = null;
        for (i = P.m; i >= 1; i--) {
            for (aij = P.row[i].ptr; aij != null; aij = aij.r_next) {
                j = aij.col.j;
                aij.c_prev = null;
                aij.c_next = P.col[j].ptr;
                if (aij.c_next != null)
                    aij.c_next.c_prev = aij;
                P.col[j].ptr = aij;
            }
        }
    };
    var glp_del_rows = exports['glp_del_rows'] = function (lp, nrs, num) {
        var tree = lp.tree;
        var row;
        var i, k, m_new;
        if (!(1 <= nrs && nrs <= lp.m))
            xerror('glp_del_rows: nrs = ' + nrs + '; invalid number of rows');
        for (k = 1; k <= nrs; k++) {
            i = num[k];
            if (!(1 <= i && i <= lp.m))
                xerror('glp_del_rows: num[' + k + '] = ' + i + '; row number out of range');
            row = lp.row[i];
            if (tree != null && tree.reason != 0) {
                if (!(tree.reason == GLP_IROWGEN || tree.reason == GLP_ICUTGEN))
                    xerror('glp_del_rows: operation not allowed');
                xassert(tree.curr != null);
                if (row.level != tree.curr.level)
                    xerror('glp_del_rows: num[' + k + '] = ' + i + '; invalid attempt to delete row created not in current subproblem');
                if (row.stat != GLP_BS)
                    xerror('glp_del_rows: num[' + k + '] = ' + i + '; invalid attempt to delete active row (constraint)');
                tree.reinv = 1;
            }
            if (row.i == 0)
                xerror('glp_del_rows: num[' + k + '] = ' + i + '; duplicate row numbers not allowed');
            glp_set_row_name(lp, i, null);
            xassert(row.node == null);
            glp_set_mat_row(lp, i, 0, null, null);
            xassert(row.ptr == null);
            row.i = 0;
        }
        m_new = 0;
        for (i = 1; i <= lp.m; i++) {
            row = lp.row[i];
            if (row.i != 0) {
                row.i = ++m_new;
                lp.row[row.i] = row;
            }
        }
        lp.m = m_new;
        lp.valid = 0;
    };
    var glp_del_cols = exports['glp_del_cols'] = function (lp, ncs, num) {
        var tree = lp.tree;
        var col;
        var j, k, n_new;
        if (tree != null && tree.reason != 0)
            xerror('glp_del_cols: operation not allowed');
        if (!(1 <= ncs && ncs <= lp.n))
            xerror('glp_del_cols: ncs = ' + ncs + '; invalid number of columns');
        for (k = 1; k <= ncs; k++) {
            j = num[k];
            if (!(1 <= j && j <= lp.n))
                xerror('glp_del_cols: num[' + k + '] = ' + j + '; column number out of range');
            col = lp.col[j];
            if (col.j == 0)
                xerror('glp_del_cols: num[' + k + '] = ' + j + '; duplicate column numbers not allowed');
            glp_set_col_name(lp, j, null);
            xassert(col.node == null);
            glp_set_mat_col(lp, j, 0, null, null);
            xassert(col.ptr == null);
            col.j = 0;
            if (col.stat == GLP_BS)
                lp.valid = 0;
        }
        n_new = 0;
        for (j = 1; j <= lp.n; j++) {
            col = lp.col[j];
            if (col.j != 0) {
                col.j = ++n_new;
                lp.col[col.j] = col;
            }
        }
        lp.n = n_new;
        if (lp.valid) {
            var m = lp.m;
            var head = lp.head;
            for (j = 1; j <= n_new; j++) {
                k = lp.col[j].bind;
                if (k != 0) {
                    xassert(1 <= k && k <= m);
                    head[k] = m + j;
                }
            }
        }
    };
    var glp_copy_prob = exports['glp_copy_prob'] = function (dest, prob, names) {
        var tree = dest.tree;
        var bfcp = {};
        var i, j, len, ind;
        var val;
        if (tree != null && tree.reason != 0)
            xerror('glp_copy_prob: operation not allowed');
        if (dest == prob)
            xerror('glp_copy_prob: copying problem object to itself not allowed');
        if (!(names == GLP_ON || names == GLP_OFF))
            xerror('glp_copy_prob: names = ' + names + '; invalid parameter');
        glp_erase_prob(dest);
        if (names && prob.name != null)
            glp_set_prob_name(dest, prob.name);
        if (names && prob.obj != null)
            glp_set_obj_name(dest, prob.obj);
        dest.dir = prob.dir;
        dest.c0 = prob.c0;
        if (prob.m > 0)
            glp_add_rows(dest, prob.m);
        if (prob.n > 0)
            glp_add_cols(dest, prob.n);
        glp_get_bfcp(prob, bfcp);
        glp_set_bfcp(dest, bfcp);
        dest.pbs_stat = prob.pbs_stat;
        dest.dbs_stat = prob.dbs_stat;
        dest.obj_val = prob.obj_val;
        dest.some = prob.some;
        dest.ipt_stat = prob.ipt_stat;
        dest.ipt_obj = prob.ipt_obj;
        dest.mip_stat = prob.mip_stat;
        dest.mip_obj = prob.mip_obj;
        var to, from;
        for (i = 1; i <= prob.m; i++) {
            to = dest.row[i];
            from = prob.row[i];
            if (names && from.name != null)
                glp_set_row_name(dest, i, from.name);
            to.type = from.type;
            to.lb = from.lb;
            to.ub = from.ub;
            to.rii = from.rii;
            to.stat = from.stat;
            to.prim = from.prim;
            to.dual = from.dual;
            to.pval = from.pval;
            to.dval = from.dval;
            to.mipx = from.mipx;
        }
        ind = new Int32Array(1 + prob.m);
        val = new Float64Array(1 + prob.m);
        for (j = 1; j <= prob.n; j++) {
            to = dest.col[j];
            from = prob.col[j];
            if (names && from.name != null)
                glp_set_col_name(dest, j, from.name);
            to.kind = from.kind;
            to.type = from.type;
            to.lb = from.lb;
            to.ub = from.ub;
            to.coef = from.coef;
            len = glp_get_mat_col(prob, j, ind, val);
            glp_set_mat_col(dest, j, len, ind, val);
            to.sjj = from.sjj;
            to.stat = from.stat;
            to.prim = from.prim;
            to.dual = from.dual;
            to.pval = from.pval;
            to.dval = from.dval;
            to.mipx = from.mipx;
        }
    };
    var glp_erase_prob = exports['glp_erase_prob'] = function (lp) {
        var tree = lp.tree;
        if (tree != null && tree.reason != 0)
            xerror('glp_erase_prob: operation not allowed');
        delete_prob(lp);
        create_prob(lp);
    };
    function delete_prob(lp) {
        lp.magic = 1061109567;
        lp.parms = null;
        xassert(lp.tree == null);
        lp.row = null;
        lp.col = null;
        lp.r_tree = null;
        lp.c_tree = null;
        lp.head = null;
        lp.bfcp = null;
        lp.bfd = null;
    }
    var glp_get_prob_name = exports['glp_get_prob_name'] = function (lp) {
        return lp.name;
    };
    var glp_get_obj_name = exports['glp_get_obj_name'] = function (lp) {
        return lp.obj;
    };
    var glp_get_obj_dir = exports['glp_get_obj_dir'] = function (lp) {
        return lp.dir;
    };
    var glp_get_num_rows = exports['glp_get_num_rows'] = function (lp) {
        return lp.m;
    };
    var glp_get_num_cols = exports['glp_get_num_cols'] = function (lp) {
        return lp.n;
    };
    var glp_get_row_name = exports['glp_get_row_name'] = function (lp, i) {
        if (!(1 <= i && i <= lp.m))
            xerror('glp_get_row_name: i = ' + i + '; row number out of range');
        return lp.row[i].name;
    };
    var glp_get_col_name = exports['glp_get_col_name'] = function (lp, j) {
        if (!(1 <= j && j <= lp.n))
            xerror('glp_get_col_name: j = ' + j + '; column number out of range');
        return lp.col[j].name;
    };
    var glp_get_row_type = exports['glp_get_row_type'] = function (lp, i) {
        if (!(1 <= i && i <= lp.m))
            xerror('glp_get_row_type: i = ' + i + '; row number out of range');
        return lp.row[i].type;
    };
    var glp_get_row_lb = exports['glp_get_row_lb'] = function (lp, i) {
        var lb;
        if (!(1 <= i && i <= lp.m))
            xerror('glp_get_row_lb: i = ' + i + '; row number out of range');
        switch (lp.row[i].type) {
        case GLP_FR:
        case GLP_UP:
            lb = -DBL_MAX;
            break;
        case GLP_LO:
        case GLP_DB:
        case GLP_FX:
            lb = lp.row[i].lb;
            break;
        default:
            xassert(lp != lp);
        }
        return lb;
    };
    var glp_get_row_ub = exports['glp_get_row_ub'] = function (lp, i) {
        var ub;
        if (!(1 <= i && i <= lp.m))
            xerror('glp_get_row_ub: i = ' + i + '; row number out of range');
        switch (lp.row[i].type) {
        case GLP_FR:
        case GLP_LO:
            ub = +DBL_MAX;
            break;
        case GLP_UP:
        case GLP_DB:
        case GLP_FX:
            ub = lp.row[i].ub;
            break;
        default:
            xassert(lp != lp);
        }
        return ub;
    };
    var glp_get_col_type = exports['glp_get_col_type'] = function (lp, j) {
        if (!(1 <= j && j <= lp.n))
            xerror('glp_get_col_type: j = ' + j + '; column number out of range');
        return lp.col[j].type;
    };
    var glp_get_col_lb = exports['glp_get_col_lb'] = function (lp, j) {
        var lb;
        if (!(1 <= j && j <= lp.n))
            xerror('glp_get_col_lb: j = ' + j + '; column number out of range');
        switch (lp.col[j].type) {
        case GLP_FR:
        case GLP_UP:
            lb = -DBL_MAX;
            break;
        case GLP_LO:
        case GLP_DB:
        case GLP_FX:
            lb = lp.col[j].lb;
            break;
        default:
            xassert(lp != lp);
        }
        return lb;
    };
    var glp_get_col_ub = exports['glp_get_col_ub'] = function (lp, j) {
        var ub;
        if (!(1 <= j && j <= lp.n))
            xerror('glp_get_col_ub: j = ' + j + '; column number out of range');
        switch (lp.col[j].type) {
        case GLP_FR:
        case GLP_LO:
            ub = +DBL_MAX;
            break;
        case GLP_UP:
        case GLP_DB:
        case GLP_FX:
            ub = lp.col[j].ub;
            break;
        default:
            xassert(lp != lp);
        }
        return ub;
    };
    var glp_get_obj_coef = exports['glp_get_obj_coef'] = function (lp, j) {
        if (!(0 <= j && j <= lp.n))
            xerror('glp_get_obj_coef: j = ' + j + '; column number out of range');
        return j == 0 ? lp.c0 : lp.col[j].coef;
    };
    var glp_get_num_nz = exports['glp_get_num_nz'] = function (lp) {
        return lp.nnz;
    };
    var glp_get_mat_row = exports['glp_get_mat_row'] = function (lp, i, ind, val) {
        var aij;
        var len;
        if (!(1 <= i && i <= lp.m))
            xerror('glp_get_mat_row: i = ' + i + '; row number out of range');
        len = 0;
        for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next) {
            len++;
            if (ind != null)
                ind[len] = aij.col.j;
            if (val != null)
                val[len] = aij.val;
        }
        xassert(len <= lp.n);
        return len;
    };
    var glp_get_mat_col = exports['glp_get_mat_col'] = function (lp, j, ind, val) {
        var aij;
        var len;
        if (!(1 <= j && j <= lp.n))
            xerror('glp_get_mat_col: j = ' + j + '; column number out of range');
        len = 0;
        for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next) {
            len++;
            if (ind != null)
                ind[len] = aij.row.i;
            if (val != null)
                val[len] = aij.val;
        }
        xassert(len <= lp.m);
        return len;
    };
    var glp_create_index = exports['glp_create_index'] = function (lp) {
        var row;
        var col;
        var i, j;
        if (lp.r_tree == null) {
            lp.r_tree = {};
            for (i = 1; i <= lp.m; i++) {
                row = lp.row[i];
                if (row.name != null) {
                    lp.r_tree[row.name] = row;
                }
            }
        }
        if (lp.c_tree == null) {
            lp.c_tree = {};
            for (j = 1; j <= lp.n; j++) {
                col = lp.col[j];
                if (col.name != null) {
                    lp.c_tree[col.name] = col;
                }
            }
        }
    };
    var glp_find_row = exports['glp_find_row'] = function (lp, name) {
        var i = 0;
        if (lp.r_tree == null)
            xerror('glp_find_row: row name index does not exist');
        var row = lp.r_tree[name];
        if (row)
            i = row.i;
        return i;
    };
    var glp_find_col = exports['glp_find_col'] = function (lp, name) {
        var j = 0;
        if (lp.c_tree == null)
            xerror('glp_find_col: column name index does not exist');
        var col = lp.c_tree[name];
        if (col)
            j = col.j;
        return j;
    };
    var glp_delete_index = exports['glp_delete_index'] = function (lp) {
        lp.r_tree = null;
        lp.r_tree = null;
    };
    var glp_set_rii = exports['glp_set_rii'] = function (lp, i, rii) {
        if (!(1 <= i && i <= lp.m))
            xerror('glp_set_rii: i = ' + i + '; row number out of range');
        if (rii <= 0)
            xerror('glp_set_rii: i = ' + i + '; rii = ' + rii + '; invalid scale factor');
        if (lp.valid && lp.row[i].rii != rii) {
            for (var aij = lp.row[i].ptr; aij != null; aij = aij.r_next) {
                if (aij.col.stat == GLP_BS) {
                    lp.valid = 0;
                    break;
                }
            }
        }
        lp.row[i].rii = rii;
    };
    var glp_set_sjj = exports['glp_set_sjj'] = function (lp, j, sjj) {
        if (!(1 <= j && j <= lp.n))
            xerror('glp_set_sjj: j = ' + j + '; column number out of range');
        if (sjj <= 0)
            xerror('glp_set_sjj: j = ' + j + '; sjj = ' + sjj + '; invalid scale factor');
        if (lp.valid && lp.col[j].sjj != sjj && lp.col[j].stat == GLP_BS) {
            lp.valid = 0;
        }
        lp.col[j].sjj = sjj;
    };
    var glp_get_rii = exports['glp_get_rii'] = function (lp, i) {
        if (!(1 <= i && i <= lp.m))
            xerror('glp_get_rii: i = ' + i + '; row number out of range');
        return lp.row[i].rii;
    };
    var glp_get_sjj = exports['glp_get_sjj'] = function (lp, j) {
        if (!(1 <= j && j <= lp.n))
            xerror('glp_get_sjj: j = ' + j + '; column number out of range');
        return lp.col[j].sjj;
    };
    var glp_unscale_prob = exports['glp_unscale_prob'] = function (lp) {
        var m = glp_get_num_rows(lp);
        var n = glp_get_num_cols(lp);
        var i, j;
        for (i = 1; i <= m; i++)
            glp_set_rii(lp, i, 1);
        for (j = 1; j <= n; j++)
            glp_set_sjj(lp, j, 1);
    };
    var glp_set_row_stat = exports['glp_set_row_stat'] = function (lp, i, stat) {
        var row;
        if (!(1 <= i && i <= lp.m))
            xerror('glp_set_row_stat: i = ' + i + '; row number out of range');
        if (!(stat == GLP_BS || stat == GLP_NL || stat == GLP_NU || stat == GLP_NF || stat == GLP_NS))
            xerror('glp_set_row_stat: i = ' + i + '; stat = ' + stat + '; invalid status');
        row = lp.row[i];
        if (stat != GLP_BS) {
            switch (row.type) {
            case GLP_FR:
                stat = GLP_NF;
                break;
            case GLP_LO:
                stat = GLP_NL;
                break;
            case GLP_UP:
                stat = GLP_NU;
                break;
            case GLP_DB:
                if (stat != GLP_NU)
                    stat = GLP_NL;
                break;
            case GLP_FX:
                stat = GLP_NS;
                break;
            default:
                xassert(row != row);
            }
        }
        if (row.stat == GLP_BS && stat != GLP_BS || row.stat != GLP_BS && stat == GLP_BS) {
            lp.valid = 0;
        }
        row.stat = stat;
    };
    var glp_set_col_stat = exports['glp_set_col_stat'] = function (lp, j, stat) {
        var col;
        if (!(1 <= j && j <= lp.n))
            xerror('glp_set_col_stat: j = ' + j + '; column number out of range');
        if (!(stat == GLP_BS || stat == GLP_NL || stat == GLP_NU || stat == GLP_NF || stat == GLP_NS))
            xerror('glp_set_col_stat: j = ' + j + '; stat = ' + stat + '; invalid status');
        col = lp.col[j];
        if (stat != GLP_BS) {
            switch (col.type) {
            case GLP_FR:
                stat = GLP_NF;
                break;
            case GLP_LO:
                stat = GLP_NL;
                break;
            case GLP_UP:
                stat = GLP_NU;
                break;
            case GLP_DB:
                if (stat != GLP_NU)
                    stat = GLP_NL;
                break;
            case GLP_FX:
                stat = GLP_NS;
                break;
            default:
                xassert(col != col);
            }
        }
        if (col.stat == GLP_BS && stat != GLP_BS || col.stat != GLP_BS && stat == GLP_BS) {
            lp.valid = 0;
        }
        col.stat = stat;
    };
    var glp_std_basis = exports['glp_std_basis'] = function (lp) {
        var i, j;
        for (i = 1; i <= lp.m; i++)
            glp_set_row_stat(lp, i, GLP_BS);
        for (j = 1; j <= lp.n; j++) {
            var col = lp.col[j];
            if (col.type == GLP_DB && Math.abs(col.lb) > Math.abs(col.ub))
                glp_set_col_stat(lp, j, GLP_NU);
            else
                glp_set_col_stat(lp, j, GLP_NL);
        }
    };
    var glp_simplex = exports['glp_simplex'] = function (P, parm) {
        function solve_lp(P, parm) {
            var ret;
            if (!glp_bf_exists(P)) {
                ret = glp_factorize(P);
                if (ret == 0) {
                } else if (ret == GLP_EBADB) {
                    if (parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('glp_simplex: initial basis is invalid');
                } else if (ret == GLP_ESING) {
                    if (parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('glp_simplex: initial basis is singular');
                } else if (ret == GLP_ECOND) {
                    if (parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('glp_simplex: initial basis is ill-conditioned');
                } else
                    xassert(ret != ret);
                if (ret != 0)
                    return ret;
            }
            if (parm.meth == GLP_PRIMAL)
                ret = spx_primal(P, parm);
            else if (parm.meth == GLP_DUALP) {
                ret = spx_dual(P, parm);
                if (ret == GLP_EFAIL && P.valid)
                    ret = spx_primal(P, parm);
            } else if (parm.meth == GLP_DUAL)
                ret = spx_dual(P, parm);
            else
                xassert(parm != parm);
            return ret;
        }
        function preprocess_and_solve_lp(P, parm) {
            var npp;
            var lp = null;
            var bfcp = {};
            var ret;
            function post() {
                npp_postprocess(npp, lp);
                lp = null;
                npp_unload_sol(npp, P);
                ret = 0;
                return ret;
            }
            if (parm.msg_lev >= GLP_MSG_ALL)
                xprintf('Preprocessing...');
            npp = npp_create_wksp();
            npp_load_prob(npp, P, GLP_OFF, GLP_SOL, GLP_OFF);
            ret = npp_simplex(npp, parm);
            if (ret == 0) {
            } else if (ret == GLP_ENOPFS) {
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION');
            } else if (ret == GLP_ENODFS) {
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('PROBLEM HAS NO DUAL FEASIBLE SOLUTION');
            } else
                xassert(ret != ret);
            if (ret != 0)
                return ret;
            lp = glp_create_prob();
            npp_build_prob(npp, lp);
            if (lp.m == 0 && lp.n == 0) {
                lp.pbs_stat = lp.dbs_stat = GLP_FEAS;
                lp.obj_val = lp.c0;
                if (parm.msg_lev >= GLP_MSG_ON && parm.out_dly == 0) {
                    xprintf(P.it_cnt + ': obj = ' + lp.obj_val + '  infeas = 0.0');
                }
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('OPTIMAL SOLUTION FOUND BY LP PREPROCESSOR');
                return post();
            }
            if (parm.msg_lev >= GLP_MSG_ALL) {
                xprintf(lp.m + ' row' + (lp.m == 1 ? '' : 's') + ', ' + lp.n + ' column' + (lp.n == 1 ? '' : 's') + ', ' + lp.nnz + ' non-zero' + (lp.nnz == 1 ? '' : 's') + '');
            }
            glp_get_bfcp(P, bfcp);
            glp_set_bfcp(lp, bfcp);
            {
                var env = get_env_ptr();
                var term_out = env.term_out;
                if (!term_out || parm.msg_lev < GLP_MSG_ALL)
                    env.term_out = GLP_OFF;
                else
                    env.term_out = GLP_ON;
                glp_scale_prob(lp, GLP_SF_AUTO);
                env.term_out = term_out;
            }
            {
                env = get_env_ptr();
                term_out = env.term_out;
                if (!term_out || parm.msg_lev < GLP_MSG_ALL)
                    env.term_out = GLP_OFF;
                else
                    env.term_out = GLP_ON;
                glp_adv_basis(lp, 0);
                env.term_out = term_out;
            }
            lp.it_cnt = P.it_cnt;
            ret = solve_lp(lp, parm);
            P.it_cnt = lp.it_cnt;
            if (!(ret == 0 && lp.pbs_stat == GLP_FEAS && lp.dbs_stat == GLP_FEAS)) {
                if (parm.msg_lev >= GLP_MSG_ERR)
                    xprintf('glp_simplex: unable to recover undefined or non-optimal solution');
                if (ret == 0) {
                    if (lp.pbs_stat == GLP_NOFEAS)
                        ret = GLP_ENOPFS;
                    else if (lp.dbs_stat == GLP_NOFEAS)
                        ret = GLP_ENODFS;
                    else
                        xassert(lp != lp);
                }
                return ret;
            }
            return post();
        }
        function trivial_lp(P, parm) {
            var row, col;
            var i, j;
            var p_infeas, d_infeas, zeta;
            P.valid = 0;
            P.pbs_stat = P.dbs_stat = GLP_FEAS;
            P.obj_val = P.c0;
            P.some = 0;
            p_infeas = d_infeas = 0;
            for (i = 1; i <= P.m; i++) {
                row = P.row[i];
                row.stat = GLP_BS;
                row.prim = row.dual = 0;
                if (row.type == GLP_LO || row.type == GLP_DB || row.type == GLP_FX) {
                    if (row.lb > +parm.tol_bnd) {
                        P.pbs_stat = GLP_NOFEAS;
                        if (P.some == 0 && parm.meth != GLP_PRIMAL)
                            P.some = i;
                    }
                    if (p_infeas < +row.lb)
                        p_infeas = +row.lb;
                }
                if (row.type == GLP_UP || row.type == GLP_DB || row.type == GLP_FX) {
                    if (row.ub < -parm.tol_bnd) {
                        P.pbs_stat = GLP_NOFEAS;
                        if (P.some == 0 && parm.meth != GLP_PRIMAL)
                            P.some = i;
                    }
                    if (p_infeas < -row.ub)
                        p_infeas = -row.ub;
                }
            }
            zeta = 1;
            for (j = 1; j <= P.n; j++) {
                col = P.col[j];
                if (zeta < Math.abs(col.coef))
                    zeta = Math.abs(col.coef);
            }
            zeta = (P.dir == GLP_MIN ? +1 : -1) / zeta;
            function lo() {
                col.stat = GLP_NL;
                col.prim = col.lb;
            }
            function up() {
                col.stat = GLP_NU;
                col.prim = col.ub;
            }
            for (j = 1; j <= P.n; j++) {
                col = P.col[j];
                if (col.type == GLP_FR) {
                    col.stat = GLP_NF;
                    col.prim = 0;
                } else if (col.type == GLP_LO)
                    lo();
                else if (col.type == GLP_UP)
                    up();
                else if (col.type == GLP_DB) {
                    if (zeta * col.coef > 0)
                        lo();
                    else if (zeta * col.coef < 0)
                        up();
                    else if (Math.abs(col.lb) <= Math.abs(col.ub))
                        lo();
                    else
                        up();
                } else if (col.type == GLP_FX) {
                    col.stat = GLP_NS;
                    col.prim = col.lb;
                }
                col.dual = col.coef;
                P.obj_val += col.coef * col.prim;
                if (col.type == GLP_FR || col.type == GLP_LO) {
                    if (zeta * col.dual < -parm.tol_dj) {
                        P.dbs_stat = GLP_NOFEAS;
                        if (P.some == 0 && parm.meth == GLP_PRIMAL)
                            P.some = P.m + j;
                    }
                    if (d_infeas < -zeta * col.dual)
                        d_infeas = -zeta * col.dual;
                }
                if (col.type == GLP_FR || col.type == GLP_UP) {
                    if (zeta * col.dual > +parm.tol_dj) {
                        P.dbs_stat = GLP_NOFEAS;
                        if (P.some == 0 && parm.meth == GLP_PRIMAL)
                            P.some = P.m + j;
                    }
                    if (d_infeas < +zeta * col.dual)
                        d_infeas = +zeta * col.dual;
                }
            }
            if (parm.msg_lev >= GLP_MSG_ON && parm.out_dly == 0) {
                xprintf('~' + P.it_cnt + ': obj = ' + P.obj_val + '  infeas = ' + (parm.meth == GLP_PRIMAL ? p_infeas : d_infeas) + '');
            }
            if (parm.msg_lev >= GLP_MSG_ALL && parm.out_dly == 0) {
                if (P.pbs_stat == GLP_FEAS && P.dbs_stat == GLP_FEAS)
                    xprintf('OPTIMAL SOLUTION FOUND');
                else if (P.pbs_stat == GLP_NOFEAS)
                    xprintf('PROBLEM HAS NO FEASIBLE SOLUTION');
                else if (parm.meth == GLP_PRIMAL)
                    xprintf('PROBLEM HAS UNBOUNDED SOLUTION');
                else
                    xprintf('PROBLEM HAS NO DUAL FEASIBLE SOLUTION');
            }
        }
        var i, j, ret;
        if (P == null || P.magic != GLP_PROB_MAGIC)
            xerror('glp_simplex: P = ' + P + '; invalid problem object');
        if (P.tree != null && P.tree.reason != 0)
            xerror('glp_simplex: operation not allowed');
        if (parm == null) {
            parm = new SMCP();
        }
        if (!(parm.msg_lev == GLP_MSG_OFF || parm.msg_lev == GLP_MSG_ERR || parm.msg_lev == GLP_MSG_ON || parm.msg_lev == GLP_MSG_ALL || parm.msg_lev == GLP_MSG_DBG))
            xerror('glp_simplex: msg_lev = ' + parm.msg_lev + '; invalid parameter');
        if (!(parm.meth == GLP_PRIMAL || parm.meth == GLP_DUALP || parm.meth == GLP_DUAL))
            xerror('glp_simplex: meth = ' + parm.meth + '; invalid parameter');
        if (!(parm.pricing == GLP_PT_STD || parm.pricing == GLP_PT_PSE))
            xerror('glp_simplex: pricing = ' + parm.pricing + '; invalid parameter');
        if (!(parm.r_test == GLP_RT_STD || parm.r_test == GLP_RT_HAR))
            xerror('glp_simplex: r_test = ' + parm.r_test + '; invalid parameter');
        if (!(0 < parm.tol_bnd && parm.tol_bnd < 1))
            xerror('glp_simplex: tol_bnd = ' + parm.tol_bnd + '; invalid parameter');
        if (!(0 < parm.tol_dj && parm.tol_dj < 1))
            xerror('glp_simplex: tol_dj = ' + parm.tol_dj + '; invalid parameter');
        if (!(0 < parm.tol_piv && parm.tol_piv < 1))
            xerror('glp_simplex: tol_piv = ' + parm.tol_piv + '; invalid parameter');
        if (parm.it_lim < 0)
            xerror('glp_simplex: it_lim = ' + parm.it_lim + '; invalid parameter');
        if (parm.tm_lim < 0)
            xerror('glp_simplex: tm_lim = ' + parm.tm_lim + '; invalid parameter');
        if (parm.out_frq < 1)
            xerror('glp_simplex: out_frq = ' + parm.out_frq + '; invalid parameter');
        if (parm.out_dly < 0)
            xerror('glp_simplex: out_dly = ' + parm.out_dly + '; invalid parameter');
        if (!(parm.presolve == GLP_ON || parm.presolve == GLP_OFF))
            xerror('glp_simplex: presolve = ' + parm.presolve + '; invalid parameter');
        P.pbs_stat = P.dbs_stat = GLP_UNDEF;
        P.obj_val = 0;
        P.some = 0;
        for (i = 1; i <= P.m; i++) {
            var row = P.row[i];
            if (row.type == GLP_DB && row.lb >= row.ub) {
                if (parm.msg_lev >= GLP_MSG_ERR)
                    xprintf('glp_simplex: row ' + i + ': lb = ' + row.lb + ', ub = ' + row.ub + '; incorrect bounds');
                ret = GLP_EBOUND;
                return ret;
            }
        }
        for (j = 1; j <= P.n; j++) {
            var col = P.col[j];
            if (col.type == GLP_DB && col.lb >= col.ub) {
                if (parm.msg_lev >= GLP_MSG_ERR)
                    xprintf('glp_simplex: column ' + j + ': lb = ' + col.lb + ', ub = ' + col.ub + '; incorrect bounds');
                ret = GLP_EBOUND;
                return ret;
            }
        }
        if (parm.msg_lev >= GLP_MSG_ALL) {
            xprintf('GLPK Simplex Optimizer, v' + glp_version() + '');
            xprintf(P.m + ' row' + (P.m == 1 ? '' : 's') + ', ' + P.n + ' column' + (P.n == 1 ? '' : 's') + ', ' + P.nnz + ' non-zero' + (P.nnz == 1 ? '' : 's') + '');
        }
        if (P.nnz == 0) {
            trivial_lp(P, parm);
            ret = 0;
        } else if (!parm.presolve)
            ret = solve_lp(P, parm);
        else
            ret = preprocess_and_solve_lp(P, parm);
        return ret;
    };
    var SMCP = exports['SMCP'] = function (options) {
        options = options || {};
        this.msg_lev = options['msg_lev'] || GLP_MSG_ALL;
        this.meth = options['meth'] || GLP_PRIMAL;
        this.pricing = options['pricing'] || GLP_PT_PSE;
        this.r_test = options['r_test'] || GLP_RT_HAR;
        this.tol_bnd = options['tol_bnd'] || 1e-7;
        this.tol_dj = options['tol_dj'] || 1e-7;
        this.tol_piv = options['tol_piv'] || 1e-10;
        this.obj_ll = options['obj_ll'] || -DBL_MAX;
        this.obj_ul = options['obj_ul'] || +DBL_MAX;
        this.it_lim = options['it_lim'] || INT_MAX;
        this.tm_lim = options['tm_lim'] || INT_MAX;
        this.out_frq = options['out_frq'] || 500;
        this.out_dly = options['out_dly'] || 0;
        this.presolve = options['presolve'] || GLP_OFF;
    };
    var glp_get_status = exports['glp_get_status'] = function (lp) {
        var status;
        status = glp_get_prim_stat(lp);
        switch (status) {
        case GLP_FEAS:
            switch (glp_get_dual_stat(lp)) {
            case GLP_FEAS:
                status = GLP_OPT;
                break;
            case GLP_NOFEAS:
                status = GLP_UNBND;
                break;
            case GLP_UNDEF:
            case GLP_INFEAS:
                break;
            default:
                xassert(lp != lp);
            }
            break;
        case GLP_UNDEF:
        case GLP_INFEAS:
        case GLP_NOFEAS:
            break;
        default:
            xassert(lp != lp);
        }
        return status;
    };
    var glp_get_prim_stat = exports['glp_get_prim_stat'] = function (lp) {
        return lp.pbs_stat;
    };
    var glp_get_dual_stat = exports['glp_get_dual_stat'] = function (lp) {
        return lp.dbs_stat;
    };
    var glp_get_obj_val = exports['glp_get_obj_val'] = function (lp) {
        return lp.obj_val;
    };
    var glp_get_row_stat = exports['glp_get_row_stat'] = function (lp, i) {
        if (!(1 <= i && i <= lp.m))
            xerror('glp_get_row_stat: i = ' + i + '; row number out of range');
        return lp.row[i].stat;
    };
    var glp_get_row_prim = exports['glp_get_row_prim'] = function (lp, i) {
        if (!(1 <= i && i <= lp.m))
            xerror('glp_get_row_prim: i = ' + i + '; row number out of range');
        return lp.row[i].prim;
    };
    var glp_get_row_dual = exports['glp_get_row_dual'] = function (lp, i) {
        if (!(1 <= i && i <= lp.m))
            xerror('glp_get_row_dual: i = ' + i + '; row number out of range');
        return lp.row[i].dual;
    };
    var glp_get_col_stat = exports['glp_get_col_stat'] = function (lp, j) {
        if (!(1 <= j && j <= lp.n))
            xerror('glp_get_col_stat: j = ' + j + '; column number out of range');
        return lp.col[j].stat;
    };
    var glp_get_col_prim = exports['glp_get_col_prim'] = function (lp, j) {
        if (!(1 <= j && j <= lp.n))
            xerror('glp_get_col_prim: j = ' + j + '; column number out of range');
        return lp.col[j].prim;
    };
    var glp_get_col_dual = exports['glp_get_col_dual'] = function (lp, j) {
        if (!(1 <= j && j <= lp.n))
            xerror('glp_get_col_dual: j = ' + j + '; column number out of range');
        return lp.col[j].dual;
    };
    var glp_get_unbnd_ray = exports['glp_get_unbnd_ray'] = function (lp) {
        var k = lp.some;
        xassert(k >= 0);
        if (k > lp.m + lp.n)
            k = 0;
        return k;
    };
    var glp_set_col_kind = exports['glp_set_col_kind'] = function (mip, j, kind) {
        if (!(1 <= j && j <= mip.n))
            xerror('glp_set_col_kind: j = ' + j + '; column number out of range');
        var col = mip.col[j];
        switch (kind) {
        case GLP_CV:
            col.kind = GLP_CV;
            break;
        case GLP_IV:
            col.kind = GLP_IV;
            break;
        case GLP_BV:
            col.kind = GLP_IV;
            if (!(col.type == GLP_DB && col.lb == 0 && col.ub == 1))
                glp_set_col_bnds(mip, j, GLP_DB, 0, 1);
            break;
        default:
            xerror('glp_set_col_kind: j = ' + j + '; kind = ' + kind + '; invalid column kind');
        }
    };
    var glp_get_col_kind = exports['glp_get_col_kind'] = function (mip, j) {
        if (!(1 <= j && j <= mip.n))
            xerror('glp_get_col_kind: j = ' + j + '; column number out of range');
        var col = mip.col[j];
        var kind = col.kind;
        switch (kind) {
        case GLP_CV:
            break;
        case GLP_IV:
            if (col.type == GLP_DB && col.lb == 0 && col.ub == 1)
                kind = GLP_BV;
            break;
        default:
            xassert(kind != kind);
        }
        return kind;
    };
    var glp_get_num_int = exports['glp_get_num_int'] = function (mip) {
        var col;
        var count = 0;
        for (var j = 1; j <= mip.n; j++) {
            col = mip.col[j];
            if (col.kind == GLP_IV)
                count++;
        }
        return count;
    };
    var glp_get_num_bin = exports['glp_get_num_bin'] = function (mip) {
        var col;
        var count = 0;
        for (var j = 1; j <= mip.n; j++) {
            col = mip.col[j];
            if (col.kind == GLP_IV && col.type == GLP_DB && col.lb == 0 && col.ub == 1)
                count++;
        }
        return count;
    };
    var glp_intopt = exports['glp_intopt'] = function (P, parm) {
        function solve_mip(P, parm) {
            var T;
            var ret;
            if (glp_get_status(P) != GLP_OPT) {
                if (parm.msg_lev >= GLP_MSG_ERR)
                    xprintf('glp_intopt: optimal basis to initial LP relaxation not provided');
                ret = GLP_EROOT;
                return ret;
            }
            if (parm.msg_lev >= GLP_MSG_ALL)
                xprintf('Integer optimization begins...');
            T = ios_create_tree(P, parm);
            ret = ios_driver(T);
            ios_delete_tree(T);
            if (ret == 0) {
                if (P.mip_stat == GLP_FEAS) {
                    if (parm.msg_lev >= GLP_MSG_ALL)
                        xprintf('INTEGER OPTIMAL SOLUTION FOUND');
                    P.mip_stat = GLP_OPT;
                } else {
                    if (parm.msg_lev >= GLP_MSG_ALL)
                        xprintf('PROBLEM HAS NO INTEGER FEASIBLE SOLUTION');
                    P.mip_stat = GLP_NOFEAS;
                }
            } else if (ret == GLP_EMIPGAP) {
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('RELATIVE MIP GAP TOLERANCE REACHED; SEARCH TERMINATED');
            } else if (ret == GLP_ETMLIM) {
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('TIME LIMIT EXCEEDED; SEARCH TERMINATED');
            } else if (ret == GLP_EFAIL) {
                if (parm.msg_lev >= GLP_MSG_ERR)
                    xprintf('glp_intopt: cannot solve current LP relaxation');
            } else if (ret == GLP_ESTOP) {
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('SEARCH TERMINATED BY APPLICATION');
            } else
                xassert(ret != ret);
            return ret;
        }
        function preprocess_and_solve_mip(P, parm) {
            var env = get_env_ptr();
            var term_out = env.term_out;
            var npp;
            var mip = null;
            var bfcp = {};
            var ret;
            function post() {
                npp_postprocess(npp, mip);
                mip = null;
                npp_unload_sol(npp, P);
                return ret;
            }
            if (parm.msg_lev >= GLP_MSG_ALL)
                xprintf('Preprocessing...');
            npp = npp_create_wksp();
            npp_load_prob(npp, P, GLP_OFF, GLP_MIP, GLP_OFF);
            if (!term_out || parm.msg_lev < GLP_MSG_ALL)
                env.term_out = GLP_OFF;
            else
                env.term_out = GLP_ON;
            ret = npp_integer(npp, parm);
            env.term_out = term_out;
            if (ret == 0) {
            } else if (ret == GLP_ENOPFS) {
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION');
            } else if (ret == GLP_ENODFS) {
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('LP RELAXATION HAS NO DUAL FEASIBLE SOLUTION');
            } else
                xassert(ret != ret);
            if (ret != 0)
                return ret;
            mip = glp_create_prob();
            npp_build_prob(npp, mip);
            if (mip.m == 0 && mip.n == 0) {
                mip.mip_stat = GLP_OPT;
                mip.mip_obj = mip.c0;
                if (parm.msg_lev >= GLP_MSG_ALL) {
                    xprintf('Objective value = ' + mip.mip_obj + '');
                    xprintf('INTEGER OPTIMAL SOLUTION FOUND BY MIP PREPROCESSOR');
                }
                return post();
            }
            if (parm.msg_lev >= GLP_MSG_ALL) {
                var ni = glp_get_num_int(mip);
                var nb = glp_get_num_bin(mip);
                var s;
                xprintf(mip.m + ' row' + (mip.m == 1 ? '' : 's') + ', ' + mip.n + ' column' + (mip.n == 1 ? '' : 's') + ', ' + mip.nnz + ' non-zero' + (mip.nnz == 1 ? '' : 's') + '');
                if (nb == 0)
                    s = 'none of';
                else if (ni == 1 && nb == 1)
                    s = '';
                else if (nb == 1)
                    s = 'one of';
                else if (nb == ni)
                    s = 'all of';
                else
                    s = nb + ' of';
                xprintf(ni + ' integer variable' + (ni == 1 ? '' : 's') + ', ' + s + ' which ' + (nb == 1 ? 'is' : 'are') + ' binary');
            }
            glp_get_bfcp(P, bfcp);
            glp_set_bfcp(mip, bfcp);
            if (!term_out || parm.msg_lev < GLP_MSG_ALL)
                env.term_out = GLP_OFF;
            else
                env.term_out = GLP_ON;
            glp_scale_prob(mip, GLP_SF_GM | GLP_SF_EQ | GLP_SF_2N | GLP_SF_SKIP);
            env.term_out = term_out;
            if (!term_out || parm.msg_lev < GLP_MSG_ALL)
                env.term_out = GLP_OFF;
            else
                env.term_out = GLP_ON;
            glp_adv_basis(mip, 0);
            env.term_out = term_out;
            if (parm.msg_lev >= GLP_MSG_ALL)
                xprintf('Solving LP relaxation...');
            var smcp = new SMCP();
            smcp.msg_lev = parm.msg_lev;
            mip.it_cnt = P.it_cnt;
            ret = glp_simplex(mip, smcp);
            P.it_cnt = mip.it_cnt;
            if (ret != 0) {
                if (parm.msg_lev >= GLP_MSG_ERR)
                    xprintf('glp_intopt: cannot solve LP relaxation');
                ret = GLP_EFAIL;
                return ret;
            }
            ret = glp_get_status(mip);
            if (ret == GLP_OPT)
                ret = 0;
            else if (ret == GLP_NOFEAS)
                ret = GLP_ENOPFS;
            else if (ret == GLP_UNBND)
                ret = GLP_ENODFS;
            else
                xassert(ret != ret);
            if (ret != 0)
                return ret;
            mip.it_cnt = P.it_cnt;
            ret = solve_mip(mip, parm);
            P.it_cnt = mip.it_cnt;
            if (!(mip.mip_stat == GLP_OPT || mip.mip_stat == GLP_FEAS)) {
                P.mip_stat = mip.mip_stat;
                return ret;
            }
            return post();
        }
        var i, j, ret, col;
        if (P == null || P.magic != GLP_PROB_MAGIC)
            xerror('glp_intopt: P = ' + P + '; invalid problem object');
        if (P.tree != null)
            xerror('glp_intopt: operation not allowed');
        if (parm == null) {
            parm = new IOCP();
        }
        if (!(parm.msg_lev == GLP_MSG_OFF || parm.msg_lev == GLP_MSG_ERR || parm.msg_lev == GLP_MSG_ON || parm.msg_lev == GLP_MSG_ALL || parm.msg_lev == GLP_MSG_DBG))
            xerror('glp_intopt: msg_lev = ' + parm.msg_lev + '; invalid parameter');
        if (!(parm.br_tech == GLP_BR_FFV || parm.br_tech == GLP_BR_LFV || parm.br_tech == GLP_BR_MFV || parm.br_tech == GLP_BR_DTH || parm.br_tech == GLP_BR_PCH))
            xerror('glp_intopt: br_tech = ' + parm.br_tech + '; invalid parameter');
        if (!(parm.bt_tech == GLP_BT_DFS || parm.bt_tech == GLP_BT_BFS || parm.bt_tech == GLP_BT_BLB || parm.bt_tech == GLP_BT_BPH))
            xerror('glp_intopt: bt_tech = ' + parm.bt_tech + '; invalid parameter');
        if (!(0 < parm.tol_int && parm.tol_int < 1))
            xerror('glp_intopt: tol_int = ' + parm.tol_int + '; invalid parameter');
        if (!(0 < parm.tol_obj && parm.tol_obj < 1))
            xerror('glp_intopt: tol_obj = ' + parm.tol_obj + '; invalid parameter');
        if (parm.tm_lim < 0)
            xerror('glp_intopt: tm_lim = ' + parm.tm_lim + '; invalid parameter');
        if (parm.out_frq < 0)
            xerror('glp_intopt: out_frq = ' + parm.out_frq + '; invalid parameter');
        if (parm.out_dly < 0)
            xerror('glp_intopt: out_dly = ' + parm.out_dly + '; invalid parameter');
        if (!(0 <= parm.cb_size && parm.cb_size <= 256))
            xerror('glp_intopt: cb_size = ' + parm.cb_size + '; invalid parameter');
        if (!(parm.pp_tech == GLP_PP_NONE || parm.pp_tech == GLP_PP_ROOT || parm.pp_tech == GLP_PP_ALL))
            xerror('glp_intopt: pp_tech = ' + parm.pp_tech + '; invalid parameter');
        if (parm.mip_gap < 0)
            xerror('glp_intopt: mip_gap = ' + parm.mip_gap + '; invalid parameter');
        if (!(parm.mir_cuts == GLP_ON || parm.mir_cuts == GLP_OFF))
            xerror('glp_intopt: mir_cuts = ' + parm.mir_cuts + '; invalid parameter');
        if (!(parm.gmi_cuts == GLP_ON || parm.gmi_cuts == GLP_OFF))
            xerror('glp_intopt: gmi_cuts = ' + parm.gmi_cuts + '; invalid parameter');
        if (!(parm.cov_cuts == GLP_ON || parm.cov_cuts == GLP_OFF))
            xerror('glp_intopt: cov_cuts = ' + parm.cov_cuts + '; invalid parameter');
        if (!(parm.clq_cuts == GLP_ON || parm.clq_cuts == GLP_OFF))
            xerror('glp_intopt: clq_cuts = ' + parm.clq_cuts + '; invalid parameter');
        if (!(parm.presolve == GLP_ON || parm.presolve == GLP_OFF))
            xerror('glp_intopt: presolve = ' + parm.presolve + '; invalid parameter');
        if (!(parm.binarize == GLP_ON || parm.binarize == GLP_OFF))
            xerror('glp_intopt: binarize = ' + parm.binarize + '; invalid parameter');
        if (!(parm.fp_heur == GLP_ON || parm.fp_heur == GLP_OFF))
            xerror('glp_intopt: fp_heur = ' + parm.fp_heur + '; invalid parameter');
        P.mip_stat = GLP_UNDEF;
        P.mip_obj = 0;
        for (i = 1; i <= P.m; i++) {
            var row = P.row[i];
            if (row.type == GLP_DB && row.lb >= row.ub) {
                if (parm.msg_lev >= GLP_MSG_ERR)
                    xprintf('glp_intopt: row ' + i + ': lb = ' + row.lb + ', ub = ' + row.ub + '; incorrect bounds');
                ret = GLP_EBOUND;
                return ret;
            }
        }
        for (j = 1; j <= P.n; j++) {
            col = P.col[j];
            if (col.type == GLP_DB && col.lb >= col.ub) {
                if (parm.msg_lev >= GLP_MSG_ERR)
                    xprintf('glp_intopt: column ' + j + ': lb = ' + col.lb + ', ub = ' + col.ub + '; incorrect bounds');
                ret = GLP_EBOUND;
                return ret;
            }
        }
        for (j = 1; j <= P.n; j++) {
            col = P.col[j];
            if (col.kind != GLP_IV)
                continue;
            if (col.type == GLP_LO || col.type == GLP_DB) {
                if (col.lb != Math.floor(col.lb)) {
                    if (parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('glp_intopt: integer column ' + j + ' has non-integer lower bound ' + col.lb + '');
                    ret = GLP_EBOUND;
                    return ret;
                }
            }
            if (col.type == GLP_UP || col.type == GLP_DB) {
                if (col.ub != Math.floor(col.ub)) {
                    if (parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('glp_intopt: integer column ' + j + ' has non-integer upper bound ' + col.ub + '');
                    ret = GLP_EBOUND;
                    return ret;
                }
            }
            if (col.type == GLP_FX) {
                if (col.lb != Math.floor(col.lb)) {
                    if (parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('glp_intopt: integer column ' + j + ' has non-integer fixed value ' + col.lb + '');
                    ret = GLP_EBOUND;
                    return ret;
                }
            }
        }
        if (parm.msg_lev >= GLP_MSG_ALL) {
            var ni = glp_get_num_int(P);
            var nb = glp_get_num_bin(P);
            var s;
            xprintf('GLPK Integer Optimizer, v' + glp_version() + '');
            xprintf(P.m + ' row' + (P.m == 1 ? '' : 's') + ', ' + P.n + ' column' + (P.n == 1 ? '' : 's') + ', ' + P.nnz + ' non-zero' + (P.nnz == 1 ? '' : 's') + '');
            if (nb == 0)
                s = 'none of';
            else if (ni == 1 && nb == 1)
                s = '';
            else if (nb == 1)
                s = 'one of';
            else if (nb == ni)
                s = 'all of';
            else
                s = nb + ' of';
            xprintf(ni + ' integer variable' + (ni == 1 ? '' : 's') + ', ' + s + ' which ' + (nb == 1 ? 'is' : 'are') + ' binary');
        }
        if (!parm.presolve)
            ret = solve_mip(P, parm);
        else
            ret = preprocess_and_solve_mip(P, parm);
        return ret;
    };
    var IOCP = exports['IOCP'] = function (options) {
        options = options || {};
        this.msg_lev = options['msg_lev'] || GLP_MSG_ALL;
        this.br_tech = options['br_tech'] || GLP_BR_DTH;
        this.bt_tech = options['bt_tech'] || GLP_BT_BLB;
        this.tol_int = options['tol_int'] || 0.00001;
        this.tol_obj = options['tol_obj'] || 1e-7;
        this.tm_lim = options['tm_lim'] || INT_MAX;
        this.out_frq = options['out_frq'] || 5000;
        this.out_dly = options['out_dly'] || 10000;
        this.cb_func = options['cb_func'] || null;
        this.cb_info = options['cb_info'] || null;
        this.cb_size = options['cb_size'] || 0;
        this.pp_tech = options['pp_tech'] || GLP_PP_ALL;
        this.mip_gap = options['mip_gap'] || 0;
        this.mir_cuts = options['mir_cuts'] || GLP_OFF;
        this.gmi_cuts = options['gmi_cuts'] || GLP_OFF;
        this.cov_cuts = options['cov_cuts'] || GLP_OFF;
        this.clq_cuts = options['clq_cuts'] || GLP_OFF;
        this.presolve = options['presolve'] || GLP_OFF;
        this.binarize = options['binarize'] || GLP_OFF;
        this.fp_heur = options['fp_heur'] || GLP_OFF;
    };
    var glp_mip_status = exports['glp_mip_status'] = function (mip) {
        return mip.mip_stat;
    };
    var glp_mip_obj_val = exports['glp_mip_obj_val'] = function (mip) {
        return mip.mip_obj;
    };
    var glp_mip_row_val = exports['glp_mip_row_val'] = function (mip, i) {
        if (!(1 <= i && i <= mip.m))
            xerror('glp_mip_row_val: i = ' + i + '; row number out of range');
        return mip.row[i].mipx;
    };
    var glp_mip_col_val = exports['glp_mip_col_val'] = function (mip, j) {
        if (!(1 <= j && j <= mip.n))
            xerror('glp_mip_col_val: j = ' + j + '; column number out of range');
        return mip.col[j].mipx;
    };
    function glp_check_kkt(P, sol, cond, callback) {
        var m = P.m;
        var n = P.n;
        var row, col, aij;
        var i, j, ae_ind, re_ind;
        var e, sp, sn, t, ae_max, re_max;
        if (!(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP))
            xerror('glp_check_kkt: sol = ' + sol + '; invalid solution indicator');
        if (!(cond == GLP_KKT_PE || cond == GLP_KKT_PB || cond == GLP_KKT_DE || cond == GLP_KKT_DB || cond == GLP_KKT_CS))
            xerror('glp_check_kkt: cond = ' + cond + '; invalid condition indicator ');
        ae_max = re_max = 0;
        ae_ind = re_ind = 0;
        if (cond == GLP_KKT_PE) {
            for (i = 1; i <= m; i++) {
                row = P.row[i];
                sp = sn = 0;
                if (sol == GLP_SOL)
                    t = row.prim;
                else if (sol == GLP_IPT)
                    t = row.pval;
                else if (sol == GLP_MIP)
                    t = row.mipx;
                else
                    xassert(sol != sol);
                if (t >= 0)
                    sp += t;
                else
                    sn -= t;
                for (aij = row.ptr; aij != null; aij = aij.r_next) {
                    col = aij.col;
                    if (sol == GLP_SOL)
                        t = -aij.val * col.prim;
                    else if (sol == GLP_IPT)
                        t = -aij.val * col.pval;
                    else if (sol == GLP_MIP)
                        t = -aij.val * col.mipx;
                    else
                        xassert(sol != sol);
                    if (t >= 0)
                        sp += t;
                    else
                        sn -= t;
                }
                e = Math.abs(sp - sn);
                if (ae_max < e) {
                    ae_max = e;
                    ae_ind = i;
                }
                e /= 1 + sp + sn;
                if (re_max < e) {
                    re_max = e;
                    re_ind = i;
                }
            }
        } else if (cond == GLP_KKT_PB) {
            for (i = 1; i <= m; i++) {
                row = P.row[i];
                if (sol == GLP_SOL)
                    t = row.prim;
                else if (sol == GLP_IPT)
                    t = row.pval;
                else if (sol == GLP_MIP)
                    t = row.mipx;
                else
                    xassert(sol != sol);
                if (row.type == GLP_LO || row.type == GLP_DB || row.type == GLP_FX) {
                    if (t < row.lb) {
                        e = row.lb - t;
                        if (ae_max < e) {
                            ae_max = e;
                            ae_ind = i;
                        }
                        e /= 1 + Math.abs(row.lb);
                        if (re_max < e) {
                            re_max = e;
                            re_ind = i;
                        }
                    }
                }
                if (row.type == GLP_UP || row.type == GLP_DB || row.type == GLP_FX) {
                    if (t > row.ub) {
                        e = t - row.ub;
                        if (ae_max < e) {
                            ae_max = e;
                            ae_ind = i;
                        }
                        e /= 1 + Math.abs(row.ub);
                        if (re_max < e) {
                            re_max = e;
                            re_ind = i;
                        }
                    }
                }
            }
            for (j = 1; j <= n; j++) {
                col = P.col[j];
                if (sol == GLP_SOL)
                    t = col.prim;
                else if (sol == GLP_IPT)
                    t = col.pval;
                else if (sol == GLP_MIP)
                    t = col.mipx;
                else
                    xassert(sol != sol);
                if (col.type == GLP_LO || col.type == GLP_DB || col.type == GLP_FX) {
                    if (t < col.lb) {
                        e = col.lb - t;
                        if (ae_max < e) {
                            ae_max = e;
                            ae_ind = m + j;
                        }
                        e /= 1 + Math.abs(col.lb);
                        if (re_max < e) {
                            re_max = e;
                            re_ind = m + j;
                        }
                    }
                }
                if (col.type == GLP_UP || col.type == GLP_DB || col.type == GLP_FX) {
                    if (t > col.ub) {
                        e = t - col.ub;
                        if (ae_max < e) {
                            ae_max = e;
                            ae_ind = m + j;
                        }
                        e /= 1 + Math.abs(col.ub);
                        if (re_max < e) {
                            re_max = e;
                            re_ind = m + j;
                        }
                    }
                }
            }
        } else if (cond == GLP_KKT_DE) {
            for (j = 1; j <= n; j++) {
                col = P.col[j];
                sp = sn = 0;
                if (sol == GLP_SOL)
                    t = col.dual - col.coef;
                else if (sol == GLP_IPT)
                    t = col.dval - col.coef;
                else
                    xassert(sol != sol);
                if (t >= 0)
                    sp += t;
                else
                    sn -= t;
                for (aij = col.ptr; aij != null; aij = aij.c_next) {
                    row = aij.row;
                    if (sol == GLP_SOL)
                        t = aij.val * row.dual;
                    else if (sol == GLP_IPT)
                        t = aij.val * row.dval;
                    else
                        xassert(sol != sol);
                    if (t >= 0)
                        sp += t;
                    else
                        sn -= t;
                }
                e = Math.abs(sp - sn);
                if (ae_max < e) {
                    ae_max = e;
                    ae_ind = m + j;
                }
                e /= 1 + sp + sn;
                if (re_max < e) {
                    re_max = e;
                    re_ind = m + j;
                }
            }
        } else if (cond == GLP_KKT_DB) {
            for (i = 1; i <= m; i++) {
                row = P.row[i];
                if (sol == GLP_SOL)
                    t = row.dual;
                else if (sol == GLP_IPT)
                    t = row.dval;
                else
                    xassert(sol != sol);
                if (P.dir == GLP_MIN)
                    t = +t;
                else if (P.dir == GLP_MAX)
                    t = -t;
                else
                    xassert(P != P);
                if (row.stat == GLP_NF || row.stat == GLP_NL) {
                    if (t < 0) {
                        e = -t;
                        if (ae_max < e) {
                            ae_max = re_max = e;
                            ae_ind = re_ind = i;
                        }
                    }
                }
                if (row.stat == GLP_NF || row.stat == GLP_NU) {
                    if (t > 0) {
                        e = +t;
                        if (ae_max < e) {
                            ae_max = re_max = e;
                            ae_ind = re_ind = i;
                        }
                    }
                }
            }
            for (j = 1; j <= n; j++) {
                col = P.col[j];
                if (sol == GLP_SOL)
                    t = col.dual;
                else if (sol == GLP_IPT)
                    t = col.dval;
                else
                    xassert(sol != sol);
                if (P.dir == GLP_MIN)
                    t = +t;
                else if (P.dir == GLP_MAX)
                    t = -t;
                else
                    xassert(P != P);
                if (col.stat == GLP_NF || col.stat == GLP_NL) {
                    if (t < 0) {
                        e = -t;
                        if (ae_max < e) {
                            ae_max = re_max = e;
                            ae_ind = re_ind = m + j;
                        }
                    }
                }
                if (col.stat == GLP_NF || col.stat == GLP_NU) {
                    if (t > 0) {
                        e = +t;
                        if (ae_max < e) {
                            ae_max = re_max = e;
                            ae_ind = re_ind = m + j;
                        }
                    }
                }
            }
        } else
            xassert(cond != cond);
        callback(ae_max, ae_ind, re_max, re_ind);
    }
    var glp_bf_exists = exports['glp_bf_exists'] = function (lp) {
        return lp.m == 0 || lp.valid;
    };
    var glp_factorize = exports['glp_factorize'] = function (lp) {
        function b_col(lp, j, ind, val) {
            var m = lp.m;
            var aij;
            var k, len;
            xassert(1 <= j && j <= m);
            k = lp.head[j];
            if (k <= m) {
                len = 1;
                ind[1] = k;
                val[1] = 1;
            } else {
                len = 0;
                for (aij = lp.col[k - m].ptr; aij != null; aij = aij.c_next) {
                    len++;
                    ind[len] = aij.row.i;
                    val[len] = -aij.row.rii * aij.val * aij.col.sjj;
                }
            }
            return len;
        }
        var m = lp.m;
        var n = lp.n;
        var row = lp.row;
        var col = lp.col;
        var head = lp.head;
        var j, k, stat, ret;
        lp.valid = 0;
        j = 0;
        for (k = 1; k <= m + n; k++) {
            if (k <= m) {
                stat = row[k].stat;
                row[k].bind = 0;
            } else {
                stat = col[k - m].stat;
                col[k - m].bind = 0;
            }
            if (stat == GLP_BS) {
                j++;
                if (j > m) {
                    ret = GLP_EBADB;
                    return ret;
                }
                head[j] = k;
                if (k <= m)
                    row[k].bind = j;
                else
                    col[k - m].bind = j;
            }
        }
        if (j < m) {
            ret = GLP_EBADB;
            return ret;
        }
        if (m > 0) {
            if (lp.bfd == null) {
                lp.bfd = bfd_create_it();
                copy_bfcp(lp);
            }
            switch (bfd_factorize(lp.bfd, m, lp.head, b_col, lp)) {
            case 0:
                break;
            case BFD_ESING:
                ret = GLP_ESING;
                return ret;
            case BFD_ECOND:
                ret = GLP_ECOND;
                return ret;
            default:
                xassert(lp != lp);
            }
            lp.valid = 1;
        }
        ret = 0;
        return ret;
    };
    var glp_bf_updated = exports['glp_bf_updated'] = function (lp) {
        if (!(lp.m == 0 || lp.valid))
            xerror('glp_bf_update: basis factorization does not exist');
        return lp.m == 0 ? 0 : bfd_get_count(lp.bfd);
    };
    var glp_get_bfcp = exports['glp_get_bfcp'] = function (lp, parm) {
        var bfcp = lp.bfcp;
        if (bfcp == null) {
            parm.type = GLP_BF_FT;
            parm.lu_size = 0;
            parm.piv_tol = 0.1;
            parm.piv_lim = 4;
            parm.suhl = GLP_ON;
            parm.eps_tol = 1e-15;
            parm.max_gro = 10000000000;
            parm.nfs_max = 100;
            parm.upd_tol = 0.000001;
            parm.nrs_max = 100;
            parm.rs_size = 0;
        } else
            xcopyObj(parm, bfcp);
    };
    function copy_bfcp(lp) {
        var parm = {};
        glp_get_bfcp(lp, parm);
        bfd_set_parm(lp.bfd, parm);
    }
    var glp_set_bfcp = exports['glp_set_bfcp'] = function (lp, parm) {
        var bfcp = lp.bfcp;
        if (parm == null) {
            if (bfcp != null)
                lp.bfcp = null;
        } else {
            if (bfcp == null)
                bfcp = lp.bfcp = {};
            xcopyObj(bfcp, parm);
            if (!(bfcp.type == GLP_BF_FT || bfcp.type == GLP_BF_BG || bfcp.type == GLP_BF_GR))
                xerror('glp_set_bfcp: type = ' + bfcp.type + '; invalid parameter');
            if (bfcp.lu_size < 0)
                xerror('glp_set_bfcp: lu_size = ' + bfcp.lu_size + '; invalid parameter');
            if (!(0 < bfcp.piv_tol && bfcp.piv_tol < 1))
                xerror('glp_set_bfcp: piv_tol = ' + bfcp.piv_tol + '; invalid parameter');
            if (bfcp.piv_lim < 1)
                xerror('glp_set_bfcp: piv_lim = ' + bfcp.piv_lim + '; invalid parameter');
            if (!(bfcp.suhl == GLP_ON || bfcp.suhl == GLP_OFF))
                xerror('glp_set_bfcp: suhl = ' + bfcp.suhl + '; invalid parameter');
            if (!(0 <= bfcp.eps_tol && bfcp.eps_tol <= 0.000001))
                xerror('glp_set_bfcp: eps_tol = ' + bfcp.eps_tol + '; invalid parameter');
            if (bfcp.max_gro < 1)
                xerror('glp_set_bfcp: max_gro = ' + bfcp.max_gro + '; invalid parameter');
            if (!(1 <= bfcp.nfs_max && bfcp.nfs_max <= 32767))
                xerror('glp_set_bfcp: nfs_max = ' + bfcp.nfs_max + '; invalid parameter');
            if (!(0 < bfcp.upd_tol && bfcp.upd_tol < 1))
                xerror('glp_set_bfcp: upd_tol = ' + bfcp.upd_tol + '; invalid parameter');
            if (!(1 <= bfcp.nrs_max && bfcp.nrs_max <= 32767))
                xerror('glp_set_bfcp: nrs_max = ' + bfcp.nrs_max + '; invalid parameter');
            if (bfcp.rs_size < 0)
                xerror('glp_set_bfcp: rs_size = ' + bfcp.nrs_max + '; invalid parameter');
            if (bfcp.rs_size == 0)
                bfcp.rs_size = 20 * bfcp.nrs_max;
        }
        if (lp.bfd != null)
            copy_bfcp(lp);
    };
    var glp_get_bhead = exports['glp_get_bhead'] = function (lp, k) {
        if (!(lp.m == 0 || lp.valid))
            xerror('glp_get_bhead: basis factorization does not exist');
        if (!(1 <= k && k <= lp.m))
            xerror('glp_get_bhead: k = ' + k + '; index out of range');
        return lp.head[k];
    };
    var glp_get_row_bind = exports['glp_get_row_bind'] = function (lp, i) {
        if (!(lp.m == 0 || lp.valid))
            xerror('glp_get_row_bind: basis factorization does not exist');
        if (!(1 <= i && i <= lp.m))
            xerror('glp_get_row_bind: i = ' + i + '; row number out of range');
        return lp.row[i].bind;
    };
    var glp_get_col_bind = exports['glp_get_col_bind'] = function (lp, j) {
        if (!(lp.m == 0 || lp.valid))
            xerror('glp_get_col_bind: basis factorization does not exist');
        if (!(1 <= j && j <= lp.n))
            xerror('glp_get_col_bind: j = ' + j + '; column number out of range');
        return lp.col[j].bind;
    };
    var glp_ftran = exports['glp_ftran'] = function (lp, x) {
        var m = lp.m;
        var row = lp.row;
        var col = lp.col;
        var i, k;
        if (!(m == 0 || lp.valid))
            xerror('glp_ftran: basis factorization does not exist');
        for (i = 1; i <= m; i++)
            x[i] *= row[i].rii;
        if (m > 0)
            bfd_ftran(lp.bfd, x);
        for (i = 1; i <= m; i++) {
            k = lp.head[i];
            if (k <= m)
                x[i] /= row[k].rii;
            else
                x[i] *= col[k - m].sjj;
        }
    };
    var glp_btran = exports['glp_btran'] = function (lp, x) {
        var m = lp.m;
        var row = lp.row;
        var col = lp.col;
        var i, k;
        if (!(m == 0 || lp.valid))
            xerror('glp_btran: basis factorization does not exist');
        for (i = 1; i <= m; i++) {
            k = lp.head[i];
            if (k <= m)
                x[i] /= row[k].rii;
            else
                x[i] *= col[k - m].sjj;
        }
        if (m > 0)
            bfd_btran(lp.bfd, x);
        for (i = 1; i <= m; i++)
            x[i] *= row[i].rii;
    };
    var glp_warm_up = exports['glp_warm_up'] = function (P) {
        var row;
        var col;
        var aij;
        var i, j, type, stat, ret;
        var eps, temp, work;
        P.pbs_stat = P.dbs_stat = GLP_UNDEF;
        P.obj_val = 0;
        P.some = 0;
        for (i = 1; i <= P.m; i++) {
            row = P.row[i];
            row.prim = row.dual = 0;
        }
        for (j = 1; j <= P.n; j++) {
            col = P.col[j];
            col.prim = col.dual = 0;
        }
        if (!glp_bf_exists(P)) {
            ret = glp_factorize(P);
            if (ret != 0)
                return ret;
        }
        work = new Float64Array(1 + P.m);
        for (i = 1; i <= P.m; i++) {
            row = P.row[i];
            if (row.stat == GLP_BS)
                continue;
            else if (row.stat == GLP_NL)
                row.prim = row.lb;
            else if (row.stat == GLP_NU)
                row.prim = row.ub;
            else if (row.stat == GLP_NF)
                row.prim = 0;
            else if (row.stat == GLP_NS)
                row.prim = row.lb;
            else
                xassert(row != row);
            work[i] -= row.prim;
        }
        for (j = 1; j <= P.n; j++) {
            col = P.col[j];
            if (col.stat == GLP_BS)
                continue;
            else if (col.stat == GLP_NL)
                col.prim = col.lb;
            else if (col.stat == GLP_NU)
                col.prim = col.ub;
            else if (col.stat == GLP_NF)
                col.prim = 0;
            else if (col.stat == GLP_NS)
                col.prim = col.lb;
            else
                xassert(col != col);
            if (col.prim != 0) {
                for (aij = col.ptr; aij != null; aij = aij.c_next)
                    work[aij.row.i] += aij.val * col.prim;
            }
        }
        glp_ftran(P, work);
        P.pbs_stat = GLP_FEAS;
        for (i = 1; i <= P.m; i++) {
            row = P.row[i];
            if (row.stat != GLP_BS)
                continue;
            row.prim = work[row.bind];
            type = row.type;
            if (type == GLP_LO || type == GLP_DB || type == GLP_FX) {
                eps = 0.000001 + 1e-9 * Math.abs(row.lb);
                if (row.prim < row.lb - eps)
                    P.pbs_stat = GLP_INFEAS;
            }
            if (type == GLP_UP || type == GLP_DB || type == GLP_FX) {
                eps = 0.000001 + 1e-9 * Math.abs(row.ub);
                if (row.prim > row.ub + eps)
                    P.pbs_stat = GLP_INFEAS;
            }
        }
        for (j = 1; j <= P.n; j++) {
            col = P.col[j];
            if (col.stat != GLP_BS)
                continue;
            col.prim = work[col.bind];
            type = col.type;
            if (type == GLP_LO || type == GLP_DB || type == GLP_FX) {
                eps = 0.000001 + 1e-9 * Math.abs(col.lb);
                if (col.prim < col.lb - eps)
                    P.pbs_stat = GLP_INFEAS;
            }
            if (type == GLP_UP || type == GLP_DB || type == GLP_FX) {
                eps = 0.000001 + 1e-9 * Math.abs(col.ub);
                if (col.prim > col.ub + eps)
                    P.pbs_stat = GLP_INFEAS;
            }
        }
        P.obj_val = P.c0;
        for (j = 1; j <= P.n; j++) {
            col = P.col[j];
            P.obj_val += col.coef * col.prim;
        }
        for (i = 1; i <= P.m; i++)
            work[i] = 0;
        for (j = 1; j <= P.n; j++) {
            col = P.col[j];
            if (col.stat == GLP_BS)
                work[col.bind] = col.coef;
        }
        glp_btran(P, work);
        P.dbs_stat = GLP_FEAS;
        for (i = 1; i <= P.m; i++) {
            row = P.row[i];
            if (row.stat == GLP_BS) {
                row.dual = 0;
                continue;
            }
            row.dual = -work[i];
            stat = row.stat;
            temp = P.dir == GLP_MIN ? +row.dual : -row.dual;
            if ((stat == GLP_NF || stat == GLP_NL) && temp < -0.00001 || (stat == GLP_NF || stat == GLP_NU) && temp > +0.00001)
                P.dbs_stat = GLP_INFEAS;
        }
        for (j = 1; j <= P.n; j++) {
            col = P.col[j];
            if (col.stat == GLP_BS) {
                col.dual = 0;
                continue;
            }
            col.dual = col.coef;
            for (aij = col.ptr; aij != null; aij = aij.c_next)
                col.dual += aij.val * work[aij.row.i];
            stat = col.stat;
            temp = P.dir == GLP_MIN ? +col.dual : -col.dual;
            if ((stat == GLP_NF || stat == GLP_NL) && temp < -0.00001 || (stat == GLP_NF || stat == GLP_NU) && temp > +0.00001)
                P.dbs_stat = GLP_INFEAS;
        }
        return 0;
    };
    var glp_eval_tab_row = exports['glp_eval_tab_row'] = function (lp, k, ind, val) {
        var m = lp.m;
        var n = lp.n;
        var i, t, len, lll, iii;
        var alfa, rho, vvv;
        if (!(m == 0 || lp.valid))
            xerror('glp_eval_tab_row: basis factorization does not exist');
        if (!(1 <= k && k <= m + n))
            xerror('glp_eval_tab_row: k = ' + k + '; variable number out of range');
        if (k <= m)
            i = glp_get_row_bind(lp, k);
        else
            i = glp_get_col_bind(lp, k - m);
        if (i == 0)
            xerror('glp_eval_tab_row: k = ' + k + '; variable must be basic');
        xassert(1 <= i && i <= m);
        rho = new Float64Array(1 + m);
        iii = new Int32Array(1 + m);
        vvv = new Float64Array(1 + m);
        rho[i] = 1;
        glp_btran(lp, rho);
        len = 0;
        for (k = 1; k <= m + n; k++) {
            if (k <= m) {
                if (glp_get_row_stat(lp, k) == GLP_BS)
                    continue;
                alfa = -rho[k];
            } else {
                if (glp_get_col_stat(lp, k - m) == GLP_BS)
                    continue;
                lll = glp_get_mat_col(lp, k - m, iii, vvv);
                alfa = 0;
                for (t = 1; t <= lll; t++)
                    alfa += rho[iii[t]] * vvv[t];
            }
            if (alfa != 0) {
                len++;
                ind[len] = k;
                val[len] = alfa;
            }
        }
        xassert(len <= n);
        return len;
    };
    var glp_eval_tab_col = exports['glp_eval_tab_col'] = function (lp, k, ind, val) {
        var m = lp.m;
        var n = lp.n;
        var t, len, stat;
        var col;
        if (!(m == 0 || lp.valid))
            xerror('glp_eval_tab_col: basis factorization does not exist');
        if (!(1 <= k && k <= m + n))
            xerror('glp_eval_tab_col: k = ' + k + '; variable number out of range');
        if (k <= m)
            stat = glp_get_row_stat(lp, k);
        else
            stat = glp_get_col_stat(lp, k - m);
        if (stat == GLP_BS)
            xerror('glp_eval_tab_col: k = ' + k + '; variable must be non-basic');
        col = new Float64Array(1 + m);
        if (k <= m) {
            col[k] = -1;
        } else {
            len = glp_get_mat_col(lp, k - m, ind, val);
            for (t = 1; t <= len; t++)
                col[ind[t]] = val[t];
        }
        glp_ftran(lp, col);
        len = 0;
        for (t = 1; t <= m; t++) {
            if (col[t] != 0) {
                len++;
                ind[len] = glp_get_bhead(lp, t);
                val[len] = col[t];
            }
        }
        return len;
    };
    var glp_transform_row = exports['glp_transform_row'] = function (P, len, ind, val) {
        var i, j, k, m, n, t, lll, iii;
        var alfa, a, aB, rho, vvv;
        if (!glp_bf_exists(P))
            xerror('glp_transform_row: basis factorization does not exist ');
        m = glp_get_num_rows(P);
        n = glp_get_num_cols(P);
        a = new Float64Array(1 + n);
        if (!(0 <= len && len <= n))
            xerror('glp_transform_row: len = ' + len + '; invalid row length');
        for (t = 1; t <= len; t++) {
            j = ind[t];
            if (!(1 <= j && j <= n))
                xerror('glp_transform_row: ind[' + t + '] = ' + j + '; column index out of range');
            if (val[t] == 0)
                xerror('glp_transform_row: val[' + t + '] = 0; zero coefficient not allowed');
            if (a[j] != 0)
                xerror('glp_transform_row: ind[' + t + '] = ' + j + '; duplicate column indices not allowed');
            a[j] = val[t];
        }
        aB = new Float64Array(1 + m);
        for (i = 1; i <= m; i++) {
            k = glp_get_bhead(P, i);
            xassert(1 <= k && k <= m + n);
            aB[i] = k <= m ? 0 : a[k - m];
        }
        rho = aB;
        glp_btran(P, rho);
        len = 0;
        for (i = 1; i <= m; i++) {
            if (glp_get_row_stat(P, i) != GLP_BS) {
                alfa = -rho[i];
                if (alfa != 0) {
                    len++;
                    ind[len] = i;
                    val[len] = alfa;
                }
            }
        }
        iii = new Int32Array(1 + m);
        vvv = new Float64Array(1 + m);
        for (j = 1; j <= n; j++) {
            if (glp_get_col_stat(P, j) != GLP_BS) {
                alfa = a[j];
                lll = glp_get_mat_col(P, j, iii, vvv);
                for (t = 1; t <= lll; t++)
                    alfa += vvv[t] * rho[iii[t]];
                if (alfa != 0) {
                    len++;
                    ind[len] = m + j;
                    val[len] = alfa;
                }
            }
        }
        xassert(len <= n);
        return len;
    };
    var glp_transform_col = exports['glp_transform_col'] = function (P, len, ind, val) {
        var i, m, t;
        var a, alfa;
        if (!glp_bf_exists(P))
            xerror('glp_transform_col: basis factorization does not exist ');
        m = glp_get_num_rows(P);
        a = new Float64Array(1 + m);
        if (!(0 <= len && len <= m))
            xerror('glp_transform_col: len = ' + len + '; invalid column length');
        for (t = 1; t <= len; t++) {
            i = ind[t];
            if (!(1 <= i && i <= m))
                xerror('glp_transform_col: ind[' + t + '] = ' + i + '; row index out of range');
            if (val[t] == 0)
                xerror('glp_transform_col: val[' + t + '] = 0; zero coefficient not allowed');
            if (a[i] != 0)
                xerror('glp_transform_col: ind[' + t + '] = ' + i + '; duplicate row indices not allowed');
            a[i] = val[t];
        }
        alfa = a;
        glp_ftran(P, alfa);
        len = 0;
        for (i = 1; i <= m; i++) {
            if (alfa[i] != 0) {
                len++;
                ind[len] = glp_get_bhead(P, i);
                val[len] = alfa[i];
            }
        }
        return len;
    };
    var glp_prim_rtest = exports['glp_prim_rtest'] = function (P, len, ind, val, dir, eps) {
        var k, m, n, piv, t, type, stat;
        var alfa, big, beta, lb, ub, temp, teta;
        if (glp_get_prim_stat(P) != GLP_FEAS)
            xerror('glp_prim_rtest: basic solution is not primal feasible ');
        if (!(dir == +1 || dir == -1))
            xerror('glp_prim_rtest: dir = ' + dir + '; invalid parameter');
        if (!(0 < eps && eps < 1))
            xerror('glp_prim_rtest: eps = ' + eps + '; invalid parameter');
        m = glp_get_num_rows(P);
        n = glp_get_num_cols(P);
        piv = 0;
        teta = DBL_MAX;
        big = 0;
        for (t = 1; t <= len; t++) {
            k = ind[t];
            if (!(1 <= k && k <= m + n))
                xerror('glp_prim_rtest: ind[' + t + '] = ' + k + '; variable number out of range');
            if (k <= m) {
                type = glp_get_row_type(P, k);
                lb = glp_get_row_lb(P, k);
                ub = glp_get_row_ub(P, k);
                stat = glp_get_row_stat(P, k);
                beta = glp_get_row_prim(P, k);
            } else {
                type = glp_get_col_type(P, k - m);
                lb = glp_get_col_lb(P, k - m);
                ub = glp_get_col_ub(P, k - m);
                stat = glp_get_col_stat(P, k - m);
                beta = glp_get_col_prim(P, k - m);
            }
            if (stat != GLP_BS)
                xerror('glp_prim_rtest: ind[' + t + '] = ' + k + '; non-basic variable not allowed');
            alfa = dir > 0 ? +val[t] : -val[t];
            if (type == GLP_FR) {
                continue;
            } else if (type == GLP_LO) {
                if (alfa > -eps)
                    continue;
                temp = (lb - beta) / alfa;
            } else if (type == GLP_UP) {
                if (alfa < +eps)
                    continue;
                temp = (ub - beta) / alfa;
            } else if (type == GLP_DB) {
                if (alfa < 0) {
                    if (alfa > -eps)
                        continue;
                    temp = (lb - beta) / alfa;
                } else {
                    if (alfa < +eps)
                        continue;
                    temp = (ub - beta) / alfa;
                }
            } else if (type == GLP_FX) {
                if (-eps < alfa && alfa < +eps)
                    continue;
                temp = 0;
            } else
                xassert(type != type);
            if (temp < 0)
                temp = 0;
            if (teta > temp || teta == temp && big < Math.abs(alfa)) {
                piv = t;
                teta = temp;
                big = Math.abs(alfa);
            }
        }
        return piv;
    };
    var glp_dual_rtest = exports['glp_dual_rtest'] = function (P, len, ind, val, dir, eps) {
        var k, m, n, piv, t, stat;
        var alfa, big, cost, obj, temp, teta;
        if (glp_get_dual_stat(P) != GLP_FEAS)
            xerror('glp_dual_rtest: basic solution is not dual feasible');
        if (!(dir == +1 || dir == -1))
            xerror('glp_dual_rtest: dir = ' + dir + '; invalid parameter');
        if (!(0 < eps && eps < 1))
            xerror('glp_dual_rtest: eps = ' + eps + '; invalid parameter');
        m = glp_get_num_rows(P);
        n = glp_get_num_cols(P);
        obj = glp_get_obj_dir(P) == GLP_MIN ? +1 : -1;
        piv = 0;
        teta = DBL_MAX;
        big = 0;
        for (t = 1; t <= len; t++) {
            k = ind[t];
            if (!(1 <= k && k <= m + n))
                xerror('glp_dual_rtest: ind[' + t + '] = ' + k + '; variable number out of range');
            if (k <= m) {
                stat = glp_get_row_stat(P, k);
                cost = glp_get_row_dual(P, k);
            } else {
                stat = glp_get_col_stat(P, k - m);
                cost = glp_get_col_dual(P, k - m);
            }
            if (stat == GLP_BS)
                xerror('glp_dual_rtest: ind[' + t + '] = ' + k + '; basic variable not allowed');
            alfa = dir > 0 ? +val[t] : -val[t];
            if (stat == GLP_NL) {
                if (alfa < +eps)
                    continue;
                temp = obj * cost / alfa;
            } else if (stat == GLP_NU) {
                if (alfa > -eps)
                    continue;
                temp = obj * cost / alfa;
            } else if (stat == GLP_NF) {
                if (-eps < alfa && alfa < +eps)
                    continue;
                temp = 0;
            } else if (stat == GLP_NS) {
                continue;
            } else
                xassert(stat != stat);
            if (temp < 0)
                temp = 0;
            if (teta > temp || teta == temp && big < Math.abs(alfa)) {
                piv = t;
                teta = temp;
                big = Math.abs(alfa);
            }
        }
        return piv;
    };
    function _glp_analyze_row(P, len, ind, val, type, rhs, eps, callback) {
        var t, k, dir, piv, ret = 0;
        var x, dx, y, dy, dz;
        if (P.pbs_stat == GLP_UNDEF)
            xerror('glp_analyze_row: primal basic solution components are undefined');
        if (P.dbs_stat != GLP_FEAS)
            xerror('glp_analyze_row: basic solution is not dual feasible');
        if (!(0 <= len && len <= P.n))
            xerror('glp_analyze_row: len = ' + len + '; invalid row length');
        y = 0;
        for (t = 1; t <= len; t++) {
            k = ind[t];
            if (!(1 <= k && k <= P.m + P.n))
                xerror('glp_analyze_row: ind[' + t + '] = ' + k + '; row/column index out of range');
            if (k <= P.m) {
                if (P.row[k].stat == GLP_BS)
                    xerror('glp_analyze_row: ind[' + t + '] = ' + k + '; basic auxiliary variable is not allowed');
                x = P.row[k].prim;
            } else {
                if (P.col[k - P.m].stat == GLP_BS)
                    xerror('glp_analyze_row: ind[' + t + '] = ' + k + '; basic structural variable is not allowed');
                x = P.col[k - P.m].prim;
            }
            y += val[t] * x;
        }
        if (type == GLP_LO) {
            if (y >= rhs) {
                ret = 1;
                return ret;
            }
            dir = +1;
        } else if (type == GLP_UP) {
            if (y <= rhs) {
                ret = 1;
                return ret;
            }
            dir = -1;
        } else
            xerror('glp_analyze_row: type = ' + type + '; invalid parameter');
        dy = rhs - y;
        piv = glp_dual_rtest(P, len, ind, val, dir, eps);
        if (piv == 0) {
            ret = 2;
            return ret;
        }
        k = ind[piv];
        xassert(1 <= k && k <= P.m + P.n);
        if (k <= P.m)
            x = P.row[k].prim;
        else
            x = P.col[k - P.m].prim;
        xassert(val[piv] != 0);
        dx = dy / val[piv];
        if (k <= P.m)
            dz = P.row[k].dual * dx;
        else
            dz = P.col[k - P.m].dual * dx;
        callback(piv, x, dx, y, dy, dz);
        return ret;
    }
    var glp_analyze_bound = exports['glp_analyze_bound'] = function (P, k, callback) {
        var row;
        var col;
        var m, n, stat, kase, p, len, piv, ind;
        var x, new_x, ll, uu, xx, delta, val;
        var value1, var1, value2, var2;
        value1 = var1 = value2 = var2 = null;
        function store() {
            if (kase < 0) {
                value1 = new_x;
                var1 = p;
            } else {
                value2 = new_x;
                var2 = p;
            }
        }
        if (P == null || P.magic != GLP_PROB_MAGIC)
            xerror('glp_analyze_bound: P = ' + P + '; invalid problem object');
        m = P.m;
        n = P.n;
        if (!(P.pbs_stat == GLP_FEAS && P.dbs_stat == GLP_FEAS))
            xerror('glp_analyze_bound: optimal basic solution required');
        if (!(m == 0 || P.valid))
            xerror('glp_analyze_bound: basis factorization required');
        if (!(1 <= k && k <= m + n))
            xerror('glp_analyze_bound: k = ' + k + '; variable number out of range');
        if (k <= m) {
            row = P.row[k];
            stat = row.stat;
            x = row.prim;
        } else {
            col = P.col[k - m];
            stat = col.stat;
            x = col.prim;
        }
        if (stat == GLP_BS)
            xerror('glp_analyze_bound: k = ' + k + '; basic variable not allowed ');
        ind = new Int32Array(1 + m);
        val = new Float64Array(1 + m);
        len = glp_eval_tab_col(P, k, ind, val);
        xassert(0 <= len && len <= m);
        for (kase = -1; kase <= +1; kase += 2) {
            piv = glp_prim_rtest(P, len, ind, val, kase, 1e-9);
            if (piv == 0) {
                p = 0;
                new_x = kase < 0 ? -DBL_MAX : +DBL_MAX;
                store();
                continue;
            }
            xassert(1 <= piv && piv <= len);
            p = ind[piv];
            if (p <= m) {
                row = P.row[p];
                ll = glp_get_row_lb(P, row.i);
                uu = glp_get_row_ub(P, row.i);
                stat = row.stat;
                xx = row.prim;
            } else {
                col = P.col[p - m];
                ll = glp_get_col_lb(P, col.j);
                uu = glp_get_col_ub(P, col.j);
                stat = col.stat;
                xx = col.prim;
            }
            xassert(stat == GLP_BS);
            if (kase < 0 && val[piv] > 0 || kase > 0 && val[piv] < 0) {
                xassert(ll != -DBL_MAX);
                delta = ll - xx;
            } else {
                xassert(uu != +DBL_MAX);
                delta = uu - xx;
            }
            xassert(val[piv] != 0);
            new_x = x + delta / val[piv];
            store();
        }
        callback(value1, var1, value2, var2);
    };
    var glp_analyze_coef = exports['glp_analyze_coef'] = function (P, k, callback) {
        var row, col;
        var m, n, type, stat, kase, p, q, dir, clen, cpiv, rlen, rpiv, cind, rind;
        var lb, ub, coef, x, lim_coef, new_x, d, delta, ll, uu, xx, rval, cval;
        var coef1 = null, var1 = null, value1 = null, coef2 = null, var2 = null, value2 = null;
        function store() {
            if (kase < 0) {
                coef1 = lim_coef;
                var1 = q;
                value1 = new_x;
            } else {
                coef2 = lim_coef;
                var2 = q;
                value2 = new_x;
            }
        }
        if (P == null || P.magic != GLP_PROB_MAGIC)
            xerror('glp_analyze_coef: P = ' + P + '; invalid problem object');
        m = P.m;
        n = P.n;
        if (!(P.pbs_stat == GLP_FEAS && P.dbs_stat == GLP_FEAS))
            xerror('glp_analyze_coef: optimal basic solution required');
        if (!(m == 0 || P.valid))
            xerror('glp_analyze_coef: basis factorization required');
        if (!(1 <= k && k <= m + n))
            xerror('glp_analyze_coef: k = ' + k + '; variable number out of range');
        if (k <= m) {
            row = P.row[k];
            type = row.type;
            lb = row.lb;
            ub = row.ub;
            coef = 0;
            stat = row.stat;
            x = row.prim;
        } else {
            col = P.col[k - m];
            type = col.type;
            lb = col.lb;
            ub = col.ub;
            coef = col.coef;
            stat = col.stat;
            x = col.prim;
        }
        if (stat != GLP_BS)
            xerror('glp_analyze_coef: k = ' + k + '; non-basic variable not allowed');
        cind = new Int32Array(1 + m);
        cval = new Float64Array(1 + m);
        rind = new Int32Array(1 + n);
        rval = new Float64Array(1 + n);
        rlen = glp_eval_tab_row(P, k, rind, rval);
        xassert(0 <= rlen && rlen <= n);
        for (kase = -1; kase <= +1; kase += 2) {
            if (P.dir == GLP_MIN)
                dir = -kase;
            else if (P.dir == GLP_MAX)
                dir = +kase;
            else
                xassert(P != P);
            rpiv = glp_dual_rtest(P, rlen, rind, rval, dir, 1e-9);
            if (rpiv == 0) {
                lim_coef = kase < 0 ? -DBL_MAX : +DBL_MAX;
                q = 0;
                new_x = x;
                store();
                continue;
            }
            xassert(1 <= rpiv && rpiv <= rlen);
            q = rind[rpiv];
            xassert(1 <= q && q <= m + n);
            if (q <= m) {
                row = P.row[q];
                stat = row.stat;
                d = row.dual;
            } else {
                col = P.col[q - m];
                stat = col.stat;
                d = col.dual;
            }
            xassert(rval[rpiv] != 0);
            delta = -d / rval[rpiv];
            lim_coef = coef + delta;
            if (kase < 0 && rval[rpiv] > 0 || kase > 0 && rval[rpiv] < 0) {
                dir = +1;
            } else {
                dir = -1;
            }
            if (P.dir == GLP_MAX)
                dir = -dir;
            if (dir > 0)
                xassert(stat == GLP_NL || stat == GLP_NF);
            else
                xassert(stat == GLP_NU || stat == GLP_NF);
            clen = glp_eval_tab_col(P, q, cind, cval);
            if (k <= m) {
                row = P.row[k];
                row.type = GLP_FR;
                row.lb = row.ub = 0;
            } else {
                col = P.col[k - m];
                col.type = GLP_FR;
                col.lb = col.ub = 0;
            }
            cpiv = glp_prim_rtest(P, clen, cind, cval, dir, 1e-9);
            if (k <= m) {
                row = P.row[k];
                row.type = type;
                row.lb = lb;
                row.ub = ub;
            } else {
                col = P.col[k - m];
                col.type = type;
                col.lb = lb;
                col.ub = ub;
            }
            if (cpiv == 0) {
                if (dir < 0 && rval[rpiv] > 0 || dir > 0 && rval[rpiv] < 0) {
                    new_x = -DBL_MAX;
                } else {
                    new_x = +DBL_MAX;
                }
                store();
                continue;
            }
            xassert(1 <= cpiv && cpiv <= clen);
            p = cind[cpiv];
            xassert(1 <= p && p <= m + n);
            xassert(p != k);
            if (p <= m) {
                row = P.row[p];
                xassert(row.stat == GLP_BS);
                ll = glp_get_row_lb(P, row.i);
                uu = glp_get_row_ub(P, row.i);
                xx = row.prim;
            } else {
                col = P.col[p - m];
                xassert(col.stat == GLP_BS);
                ll = glp_get_col_lb(P, col.j);
                uu = glp_get_col_ub(P, col.j);
                xx = col.prim;
            }
            if (dir < 0 && cval[cpiv] > 0 || dir > 0 && cval[cpiv] < 0) {
                xassert(ll != -DBL_MAX);
                delta = ll - xx;
            } else {
                xassert(uu != +DBL_MAX);
                delta = uu - xx;
            }
            xassert(cval[cpiv] != 0);
            new_x = x + rval[rpiv] / cval[cpiv] * delta;
            store();
        }
        callback(coef1, var1, value1, coef2, var2, value2);
    };
    var glp_ios_reason = exports['glp_ios_reason'] = function (tree) {
        return tree.reason;
    };
    var glp_ios_get_prob = exports['glp_ios_get_prob'] = function (tree) {
        return tree.mip;
    };
    function glp_ios_tree_size(tree, callback) {
        callback(tree.a_cnt, tree.n_cnt, tree.t_cnt);
    }
    function glp_ios_curr_node(tree) {
        var node = tree.curr;
        return node == null ? 0 : node.p;
    }
    function glp_ios_next_node(tree, p) {
        function doError() {
            xerror('glp_ios_next_node: p = ' + p + '; invalid subproblem reference number');
        }
        var node;
        if (p == 0) {
            node = tree.head;
        } else {
            if (!(1 <= p && p <= tree.nslots))
                doError();
            node = tree.slot[p].node;
            if (node == null)
                doError();
            if (node.count != 0)
                xerror('glp_ios_next_node: p = ' + p + '; subproblem not in the active list');
            node = node.next;
        }
        return node == null ? 0 : node.p;
    }
    function glp_ios_prev_node(tree, p) {
        var node;
        function doError() {
            xerror('glp_ios_prev_node: p = ' + p + '; invalid subproblem reference number');
        }
        if (p == 0) {
            node = tree.tail;
        } else {
            if (!(1 <= p && p <= tree.nslots))
                doError();
            node = tree.slot[p].node;
            if (node == null)
                doError();
            if (node.count != 0)
                xerror('glp_ios_prev_node: p = ' + p + '; subproblem not in the active list');
            node = node.prev;
        }
        return node == null ? 0 : node.p;
    }
    function glp_ios_up_node(tree, p) {
        var node;
        function doError() {
            xerror('glp_ios_up_node: p = ' + p + '; invalid subproblem reference number');
        }
        if (!(1 <= p && p <= tree.nslots))
            doError();
        node = tree.slot[p].node;
        if (node == null)
            doError();
        node = node.up;
        return node == null ? 0 : node.p;
    }
    function glp_ios_node_level(tree, p) {
        var node;
        function doError() {
            xerror('glp_ios_node_level: p = ' + p + '; invalid subproblem reference number');
        }
        if (!(1 <= p && p <= tree.nslots))
            doError();
        node = tree.slot[p].node;
        if (node == null)
            doError();
        return node.level;
    }
    function glp_ios_node_bound(tree, p) {
        var node;
        function doError() {
            xerror('glp_ios_node_bound: p = ' + p + '; invalid subproblem reference number');
        }
        if (!(1 <= p && p <= tree.nslots))
            doError();
        node = tree.slot[p].node;
        if (node == null)
            doError();
        return node.bound;
    }
    function glp_ios_best_node(tree) {
        return ios_best_node(tree);
    }
    function glp_ios_mip_gap(tree) {
        return ios_relative_gap(tree);
    }
    function glp_ios_node_data(tree, p) {
        var node;
        function doError() {
            xerror('glp_ios_node_level: p = ' + p + '; invalid subproblem reference number');
        }
        if (!(1 <= p && p <= tree.nslots))
            doError();
        node = tree.slot[p].node;
        if (node == null)
            doError();
        return node.data;
    }
    function glp_ios_row_attr(tree, i, attr) {
        var row;
        if (!(1 <= i && i <= tree.mip.m))
            xerror('glp_ios_row_attr: i = ' + i + '; row number out of range');
        row = tree.mip.row[i];
        attr.level = row.level;
        attr.origin = row.origin;
        attr.klass = row.klass;
    }
    function glp_ios_pool_size(tree) {
        if (tree.reason != GLP_ICUTGEN)
            xerror('glp_ios_pool_size: operation not allowed');
        xassert(tree.local != null);
        return tree.local.size;
    }
    function glp_ios_add_row(tree, name, klass, flags, len, ind, val, type, rhs) {
        var num;
        if (tree.reason != GLP_ICUTGEN)
            xerror('glp_ios_add_row: operation not allowed');
        xassert(tree.local != null);
        num = ios_add_row(tree, tree.local, name, klass, flags, len, ind, val, type, rhs);
        return num;
    }
    function glp_ios_del_row(tree, i) {
        if (tree.reason != GLP_ICUTGEN)
            xerror('glp_ios_del_row: operation not allowed');
        ios_del_row(tree.local, i);
    }
    function glp_ios_clear_pool(tree) {
        if (tree.reason != GLP_ICUTGEN)
            xerror('glp_ios_clear_pool: operation not allowed');
        ios_clear_pool(tree.local);
    }
    function glp_ios_can_branch(tree, j) {
        if (!(1 <= j && j <= tree.mip.n))
            xerror('glp_ios_can_branch: j = ' + j + '; column number out of range');
        return tree.non_int[j];
    }
    function glp_ios_branch_upon(tree, j, sel) {
        if (!(1 <= j && j <= tree.mip.n))
            xerror('glp_ios_branch_upon: j = ' + j + '; column number out of range');
        if (!(sel == GLP_DN_BRNCH || sel == GLP_UP_BRNCH || sel == GLP_NO_BRNCH))
            xerror('glp_ios_branch_upon: sel = ' + sel + ': invalid branch selection flag');
        if (!tree.non_int[j])
            xerror('glp_ios_branch_upon: j = ' + j + '; variable cannot be used to branch upon');
        if (tree.br_var != 0)
            xerror('glp_ios_branch_upon: branching variable already chosen');
        tree.br_var = j;
        tree.br_sel = sel;
    }
    function glp_ios_select_node(tree, p) {
        var node;
        function doError() {
            xerror('glp_ios_select_node: p = ' + p + '; invalid subproblem reference number');
        }
        if (!(1 <= p && p <= tree.nslots))
            doError();
        node = tree.slot[p].node;
        if (node == null)
            doError();
        if (node.count != 0)
            xerror('glp_ios_select_node: p = ' + p + '; subproblem not in the active list');
        if (tree.next_p != 0)
            xerror('glp_ios_select_node: subproblem already selected');
        tree.next_p = p;
    }
    function glp_ios_heur_sol(tree, x) {
        var mip = tree.mip;
        var m = tree.orig_m;
        var n = tree.n;
        var i, j;
        var obj;
        xassert(mip.m >= m);
        xassert(mip.n == n);
        obj = mip.c0;
        for (j = 1; j <= n; j++) {
            var col = mip.col[j];
            if (col.kind == GLP_IV) {
                if (x[j] != Math.floor(x[j]))
                    return 1;
            }
            obj += col.coef * x[j];
        }
        if (mip.mip_stat == GLP_FEAS) {
            switch (mip.dir) {
            case GLP_MIN:
                if (obj >= tree.mip.mip_obj)
                    return 1;
                break;
            case GLP_MAX:
                if (obj <= tree.mip.mip_obj)
                    return 1;
                break;
            default:
                xassert(mip != mip);
            }
        }
        if (tree.parm.msg_lev >= GLP_MSG_ON)
            xprintf('Solution found by heuristic: ' + obj + '');
        mip.mip_stat = GLP_FEAS;
        mip.mip_obj = obj;
        for (j = 1; j <= n; j++)
            mip.col[j].mipx = x[j];
        for (i = 1; i <= m; i++) {
            var row = mip.row[i];
            var aij;
            row.mipx = 0;
            for (aij = row.ptr; aij != null; aij = aij.r_next)
                row.mipx += aij.val * aij.col.mipx;
        }
        return 0;
    }
    function glp_ios_terminate(tree) {
        if (tree.parm.msg_lev >= GLP_MSG_DBG)
            xprintf('The search is prematurely terminated due to application request');
        tree.stop = 1;
    }
    var glp_mpl_alloc_wksp = exports['glp_mpl_alloc_wksp'] = function () {
        return mpl_initialize();
    };
    var _glp_mpl_init_rand = exports['_glp_mpl_init_rand'] = function (tran, seed) {
        if (tran.phase != 0)
            xerror('glp_mpl_init_rand: invalid call sequence\n');
        rng_init_rand(tran.rand, seed);
    };
    var glp_mpl_read_model = exports['glp_mpl_read_model'] = function (tran, name, callback, skip) {
        var ret;
        if (tran.phase != 0)
            xerror('glp_mpl_read_model: invalid call sequence');
        ret = mpl_read_model(tran, name, callback, skip);
        if (ret == 1 || ret == 2)
            ret = 0;
        else if (ret == 4)
            ret = 1;
        else
            xassert(ret != ret);
        return ret;
    };
    var glp_mpl_read_model_from_string = exports['glp_mpl_read_model_from_string'] = function (tran, name, str, skip) {
        var pos = 0;
        return glp_mpl_read_model(tran, name, function () {
            if (pos < str.length) {
                return str[pos++];
            } else
                return -1;
        }, skip);
    };
    var glp_mpl_read_data = exports['glp_mpl_read_data'] = function (tran, name, callback) {
        var ret;
        if (!(tran.phase == 1 || tran.phase == 2))
            xerror('glp_mpl_read_data: invalid call sequence');
        ret = mpl_read_data(tran, name, callback);
        if (ret == 2)
            ret = 0;
        else if (ret == 4)
            ret = 1;
        else
            xassert(ret != ret);
        return ret;
    };
    var glp_mpl_read_data_from_string = exports['glp_mpl_read_data_from_string'] = function (tran, name, str) {
        var pos = 0;
        return glp_mpl_read_data(tran, name, function () {
            if (pos < str.length) {
                return str[pos++];
            } else
                return -1;
        });
    };
    var glp_mpl_generate = exports['glp_mpl_generate'] = function (tran, name, callback, tablecb) {
        var ret;
        if (!(tran.phase == 1 || tran.phase == 2))
            xerror('glp_mpl_generate: invalid call sequence\n');
        ret = mpl_generate(tran, name, callback, tablecb);
        if (ret == 3)
            ret = 0;
        else if (ret == 4)
            ret = 1;
        return ret;
    };
    var glp_mpl_build_prob = exports['glp_mpl_build_prob'] = function (tran, prob) {
        var m, n, i, j, t, kind, type, len, ind;
        var lb, ub, val;
        if (tran.phase != 3)
            xerror('glp_mpl_build_prob: invalid call sequence\n');
        glp_erase_prob(prob);
        glp_set_prob_name(prob, mpl_get_prob_name(tran));
        m = mpl_get_num_rows(tran);
        if (m > 0)
            glp_add_rows(prob, m);
        for (i = 1; i <= m; i++) {
            glp_set_row_name(prob, i, mpl_get_row_name(tran, i));
            type = mpl_get_row_bnds(tran, i, function (l, u) {
                lb = l;
                ub = u;
            });
            switch (type) {
            case MPL_FR:
                type = GLP_FR;
                break;
            case MPL_LO:
                type = GLP_LO;
                break;
            case MPL_UP:
                type = GLP_UP;
                break;
            case MPL_DB:
                type = GLP_DB;
                break;
            case MPL_FX:
                type = GLP_FX;
                break;
            default:
                xassert(type != type);
            }
            if (type == GLP_DB && Math.abs(lb - ub) < 1e-9 * (1 + Math.abs(lb))) {
                type = GLP_FX;
                if (Math.abs(lb) <= Math.abs(ub))
                    ub = lb;
                else
                    lb = ub;
            }
            glp_set_row_bnds(prob, i, type, lb, ub);
            if (mpl_get_row_c0(tran, i) != 0)
                xprintf('glp_mpl_build_prob: row ' + mpl_get_row_name(tran, i) + '; constant term ' + mpl_get_row_c0(tran, i) + ' ignored');
        }
        n = mpl_get_num_cols(tran);
        if (n > 0)
            glp_add_cols(prob, n);
        for (j = 1; j <= n; j++) {
            glp_set_col_name(prob, j, mpl_get_col_name(tran, j));
            kind = mpl_get_col_kind(tran, j);
            switch (kind) {
            case MPL_NUM:
                break;
            case MPL_INT:
            case MPL_BIN:
                glp_set_col_kind(prob, j, GLP_IV);
                break;
            default:
                xassert(kind != kind);
            }
            type = mpl_get_col_bnds(tran, j, function (l, u) {
                lb = l;
                ub = u;
            });
            switch (type) {
            case MPL_FR:
                type = GLP_FR;
                break;
            case MPL_LO:
                type = GLP_LO;
                break;
            case MPL_UP:
                type = GLP_UP;
                break;
            case MPL_DB:
                type = GLP_DB;
                break;
            case MPL_FX:
                type = GLP_FX;
                break;
            default:
                xassert(type != type);
            }
            if (kind == MPL_BIN) {
                if (type == GLP_FR || type == GLP_UP || lb < 0)
                    lb = 0;
                if (type == GLP_FR || type == GLP_LO || ub > 1)
                    ub = 1;
                type = GLP_DB;
            }
            if (type == GLP_DB && Math.abs(lb - ub) < 1e-9 * (1 + Math.abs(lb))) {
                type = GLP_FX;
                if (Math.abs(lb) <= Math.abs(ub))
                    ub = lb;
                else
                    lb = ub;
            }
            glp_set_col_bnds(prob, j, type, lb, ub);
        }
        ind = new Int32Array(1 + n);
        val = new Float64Array(1 + n);
        for (i = 1; i <= m; i++) {
            len = mpl_get_mat_row(tran, i, ind, val);
            glp_set_mat_row(prob, i, len, ind, val);
        }
        for (i = 1; i <= m; i++) {
            kind = mpl_get_row_kind(tran, i);
            if (kind == MPL_MIN || kind == MPL_MAX) {
                glp_set_obj_name(prob, mpl_get_row_name(tran, i));
                glp_set_obj_dir(prob, kind == MPL_MIN ? GLP_MIN : GLP_MAX);
                glp_set_obj_coef(prob, 0, mpl_get_row_c0(tran, i));
                len = mpl_get_mat_row(tran, i, ind, val);
                for (t = 1; t <= len; t++)
                    glp_set_obj_coef(prob, ind[t], val[t]);
                break;
            }
        }
    };
    var glp_mpl_postsolve = exports['glp_mpl_postsolve'] = function (tran, prob, sol) {
        var i, j, m, n, stat, ret;
        var prim, dual;
        if (!(tran.phase == 3 && !tran.flag_p))
            xerror('glp_mpl_postsolve: invalid call sequence');
        if (!(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP))
            xerror('glp_mpl_postsolve: sol = ' + sol + '; invalid parameter');
        m = mpl_get_num_rows(tran);
        n = mpl_get_num_cols(tran);
        if (!(m == glp_get_num_rows(prob) && n == glp_get_num_cols(prob)))
            xerror('glp_mpl_postsolve: wrong problem object\n');
        if (!mpl_has_solve_stmt(tran))
            return 0;
        for (i = 1; i <= m; i++) {
            if (sol == GLP_SOL) {
                stat = glp_get_row_stat(prob, i);
                prim = glp_get_row_prim(prob, i);
                dual = glp_get_row_dual(prob, i);
            } else if (sol == GLP_IPT) {
                stat = 0;
                prim = glp_ipt_row_prim(prob, i);
                dual = glp_ipt_row_dual(prob, i);
            } else if (sol == GLP_MIP) {
                stat = 0;
                prim = glp_mip_row_val(prob, i);
                dual = 0;
            } else
                xassert(sol != sol);
            if (Math.abs(prim) < 1e-9)
                prim = 0;
            if (Math.abs(dual) < 1e-9)
                dual = 0;
            mpl_put_row_soln(tran, i, stat, prim, dual);
        }
        for (j = 1; j <= n; j++) {
            if (sol == GLP_SOL) {
                stat = glp_get_col_stat(prob, j);
                prim = glp_get_col_prim(prob, j);
                dual = glp_get_col_dual(prob, j);
            } else if (sol == GLP_IPT) {
                stat = 0;
                prim = glp_ipt_col_prim(prob, j);
                dual = glp_ipt_col_dual(prob, j);
            } else if (sol == GLP_MIP) {
                stat = 0;
                prim = glp_mip_col_val(prob, j);
                dual = 0;
            } else
                xassert(sol != sol);
            if (Math.abs(prim) < 1e-9)
                prim = 0;
            if (Math.abs(dual) < 1e-9)
                dual = 0;
            mpl_put_col_soln(tran, j, stat, prim, dual);
        }
        ret = mpl_postsolve(tran);
        if (ret == 3)
            ret = 0;
        else if (ret == 4)
            ret = 1;
        return ret;
    };
    function avl_create_tree(fcmp, info) {
        var tree = {};
        tree.root = null;
        tree.fcmp = fcmp;
        tree.info = info;
        tree.size = 0;
        tree.height = 0;
        return tree;
    }
    function avl_strcmp(info, key1, key2) {
        if (key1 == key2)
            return 0;
        else if (key1 > key2)
            return 1;
        else
            return -1;
    }
    function avl_insert_node(tree, key) {
        var p, q, r, flag;
        p = null;
        q = tree.root;
        while (q != null) {
            p = q;
            if (tree.fcmp(tree.info, key, p.key) <= 0) {
                flag = 0;
                q = p.left;
                p.rank++;
            } else {
                flag = 1;
                q = p.right;
            }
        }
        r = {};
        r.key = key;
        r.type = 0;
        r.link = null;
        r.rank = 1;
        r.up = p;
        r.flag = p == null ? 0 : flag;
        r.bal = 0;
        r.left = null;
        r.right = null;
        tree.size++;
        if (p == null)
            tree.root = r;
        else if (flag == 0)
            p.left = r;
        else
            p.right = r;
        while (p != null) {
            if (flag == 0) {
                if (p.bal > 0) {
                    p.bal = 0;
                    break;
                }
                if (p.bal < 0) {
                    rotate_subtree(tree, p);
                    break;
                }
                p.bal = -1;
                flag = p.flag;
                p = p.up;
            } else {
                if (p.bal < 0) {
                    p.bal = 0;
                    break;
                }
                if (p.bal > 0) {
                    rotate_subtree(tree, p);
                    break;
                }
                p.bal = +1;
                flag = p.flag;
                p = p.up;
            }
        }
        if (p == null)
            tree.height++;
        return r;
    }
    function avl_set_node_type(node, type) {
        node.type = type;
    }
    function avl_set_node_link(node, link) {
        node.link = link;
    }
    function avl_find_node(tree, key) {
        var p, c;
        p = tree.root;
        while (p != null) {
            c = tree.fcmp(tree.info, key, p.key);
            if (c == 0)
                break;
            p = c < 0 ? p.left : p.right;
        }
        return p;
    }
    function avl_get_node_type(node) {
        return node.type;
    }
    function avl_get_node_link(node) {
        return node.link;
    }
    function find_next_node(tree, node) {
        var p, q;
        if (tree.root == null)
            return null;
        p = node;
        q = p == null ? tree.root : p.right;
        if (q == null) {
            for (;;) {
                q = p.up;
                if (q == null)
                    break;
                if (p.flag == 0)
                    break;
                p = q;
            }
        } else {
            for (;;) {
                p = q.left;
                if (p == null)
                    break;
                q = p;
            }
        }
        return q;
    }
    function avl_delete_node(tree, node) {
        var f, p, q, r, s, x, y, flag;
        p = node;
        if (p.left != null && p.right != null) {
            f = p.up;
            q = p.left;
            r = find_next_node(tree, p);
            s = r.right;
            if (p.right == r) {
                if (f == null)
                    tree.root = r;
                else if (p.flag == 0)
                    f.left = r;
                else
                    f.right = r;
                r.rank = p.rank;
                r.up = f;
                r.flag = p.flag;
                r.bal = p.bal;
                r.left = q;
                r.right = p;
                q.up = r;
                p.rank = 1;
                p.up = r;
                p.flag = 1;
                p.bal = s == null ? 0 : +1;
                p.left = null;
                p.right = s;
                if (s != null)
                    s.up = p;
            } else {
                x = p.right;
                y = r.up;
                if (f == null)
                    tree.root = r;
                else if (p.flag == 0)
                    f.left = r;
                else
                    f.right = r;
                r.rank = p.rank;
                r.up = f;
                r.flag = p.flag;
                r.bal = p.bal;
                r.left = q;
                r.right = x;
                q.up = r;
                x.up = r;
                y.left = p;
                p.rank = 1;
                p.up = y;
                p.flag = 0;
                p.bal = s == null ? 0 : +1;
                p.left = null;
                p.right = s;
                if (s != null)
                    s.up = p;
            }
        }
        q = p;
        f = q.up;
        while (f != null) {
            if (q.flag == 0)
                f.rank--;
            q = f;
            f = q.up;
        }
        f = p.up;
        flag = p.flag;
        q = p.left != null ? p.left : p.right;
        if (f == null)
            tree.root = q;
        else if (flag == 0)
            f.left = q;
        else
            f.right = q;
        if (q != null) {
            q.up = f;
            q.flag = flag;
        }
        tree.size--;
        while (f != null) {
            if (flag == 0) {
                if (f.bal == 0) {
                    f.bal = +1;
                    break;
                }
                if (f.bal < 0)
                    f.bal = 0;
                else {
                    f = rotate_subtree(tree, f);
                    if (f.bal < 0)
                        break;
                }
                flag = f.flag;
                f = f.up;
            } else {
                if (f.bal == 0) {
                    f.bal = -1;
                    break;
                }
                if (f.bal > 0)
                    f.bal = 0;
                else {
                    f = rotate_subtree(tree, f);
                    if (f.bal > 0)
                        break;
                }
                flag = f.flag;
                f = f.up;
            }
        }
        if (f == null)
            tree.height--;
    }
    function rotate_subtree(tree, node) {
        var f, p, q, r, x, y;
        xassert(node != null);
        p = node;
        if (p.bal < 0) {
            f = p.up;
            q = p.left;
            r = q.right;
            if (q.bal <= 0) {
                if (f == null)
                    tree.root = q;
                else if (p.flag == 0)
                    f.left = q;
                else
                    f.right = q;
                p.rank -= q.rank;
                q.up = f;
                q.flag = p.flag;
                q.bal++;
                q.right = p;
                p.up = q;
                p.flag = 1;
                p.bal = -q.bal;
                p.left = r;
                if (r != null) {
                    r.up = p;
                    r.flag = 0;
                }
                node = q;
            } else {
                x = r.left;
                y = r.right;
                if (f == null)
                    tree.root = r;
                else if (p.flag == 0)
                    f.left = r;
                else
                    f.right = r;
                p.rank -= q.rank + r.rank;
                r.rank += q.rank;
                p.bal = r.bal >= 0 ? 0 : +1;
                q.bal = r.bal <= 0 ? 0 : -1;
                r.up = f;
                r.flag = p.flag;
                r.bal = 0;
                r.left = q;
                r.right = p;
                p.up = r;
                p.flag = 1;
                p.left = y;
                q.up = r;
                q.flag = 0;
                q.right = x;
                if (x != null) {
                    x.up = q;
                    x.flag = 1;
                }
                if (y != null) {
                    y.up = p;
                    y.flag = 0;
                }
                node = r;
            }
        } else {
            f = p.up;
            q = p.right;
            r = q.left;
            if (q.bal >= 0) {
                if (f == null)
                    tree.root = q;
                else if (p.flag == 0)
                    f.left = q;
                else
                    f.right = q;
                q.rank += p.rank;
                q.up = f;
                q.flag = p.flag;
                q.bal--;
                q.left = p;
                p.up = q;
                p.flag = 0;
                p.bal = -q.bal;
                p.right = r;
                if (r != null) {
                    r.up = p;
                    r.flag = 1;
                }
                node = q;
            } else {
                x = r.left;
                y = r.right;
                if (f == null)
                    tree.root = r;
                else if (p.flag == 0)
                    f.left = r;
                else
                    f.right = r;
                q.rank -= r.rank;
                r.rank += p.rank;
                p.bal = r.bal <= 0 ? 0 : -1;
                q.bal = r.bal >= 0 ? 0 : +1;
                r.up = f;
                r.flag = p.flag;
                r.bal = 0;
                r.left = p;
                r.right = q;
                p.up = r;
                p.flag = 0;
                p.right = x;
                q.up = r;
                q.flag = 1;
                q.left = y;
                if (x != null) {
                    x.up = p;
                    x.flag = 1;
                }
                if (y != null) {
                    y.up = q;
                    y.flag = 0;
                }
                node = r;
            }
        }
        return node;
    }
    var BFD_ESING = 1, BFD_ECOND = 2, BFD_ECHECK = 3, BFD_ELIMIT = 4, BFD_EROOM = 5;
    function bfd_create_it() {
        var bfd = {};
        bfd.valid = 0;
        bfd.type = GLP_BF_FT;
        bfd.fhv = null;
        bfd.lpf = null;
        bfd.lu_size = 0;
        bfd.piv_tol = 0.1;
        bfd.piv_lim = 4;
        bfd.suhl = 1;
        bfd.eps_tol = 1e-15;
        bfd.max_gro = 10000000000;
        bfd.nfs_max = 100;
        bfd.upd_tol = 0.000001;
        bfd.nrs_max = 100;
        bfd.rs_size = 1000;
        bfd.upd_lim = -1;
        bfd.upd_cnt = 0;
        return bfd;
    }
    function bfd_set_parm(bfd, parm) {
        xassert(bfd != null);
        bfd.type = parm.type;
        bfd.lu_size = parm.lu_size;
        bfd.piv_tol = parm.piv_tol;
        bfd.piv_lim = parm.piv_lim;
        bfd.suhl = parm.suhl;
        bfd.eps_tol = parm.eps_tol;
        bfd.max_gro = parm.max_gro;
        bfd.nfs_max = parm.nfs_max;
        bfd.upd_tol = parm.upd_tol;
        bfd.nrs_max = parm.nrs_max;
        bfd.rs_size = parm.rs_size;
    }
    function bfd_factorize(bfd, m, bh, col, info) {
        var luf;
        var nov, ret;
        xassert(bfd != null);
        xassert(1 <= m && m <= M_MAX);
        bfd.valid = 0;
        nov = 0;
        switch (bfd.type) {
        case GLP_BF_FT:
            bfd.lpf = null;
            if (bfd.fhv == null) {
                bfd.fhv = fhv_create_it();
                nov = 1;
            }
            break;
        case GLP_BF_BG:
        case GLP_BF_GR:
            bfd.fhv = null;
            if (bfd.lpf == null) {
                bfd.lpf = lpf_create_it();
                nov = 1;
            }
            break;
        default:
            xassert(bfd != bfd);
        }
        if (bfd.fhv != null)
            luf = bfd.fhv.luf;
        else if (bfd.lpf != null)
            luf = bfd.lpf.luf;
        else
            xassert(bfd != bfd);
        if (nov)
            luf.new_sva = bfd.lu_size;
        luf.piv_tol = bfd.piv_tol;
        luf.piv_lim = bfd.piv_lim;
        luf.suhl = bfd.suhl;
        luf.eps_tol = bfd.eps_tol;
        luf.max_gro = bfd.max_gro;
        if (bfd.fhv != null) {
            if (nov)
                bfd.fhv.hh_max = bfd.nfs_max;
            bfd.fhv.upd_tol = bfd.upd_tol;
        }
        if (bfd.lpf != null) {
            if (nov)
                bfd.lpf.n_max = bfd.nrs_max;
            if (nov)
                bfd.lpf.v_size = bfd.rs_size;
        }
        if (bfd.fhv != null) {
            switch (fhv_factorize(bfd.fhv, m, col, info)) {
            case 0:
                break;
            case FHV_ESING:
                ret = BFD_ESING;
                return ret;
            case FHV_ECOND:
                ret = BFD_ECOND;
                return ret;
            default:
                xassert(bfd != bfd);
            }
        } else if (bfd.lpf != null) {
            switch (lpf_factorize(bfd.lpf, m, bh, col, info)) {
            case 0:
                switch (bfd.type) {
                case GLP_BF_BG:
                    bfd.lpf.scf.t_opt = SCF_TBG;
                    break;
                case GLP_BF_GR:
                    bfd.lpf.scf.t_opt = SCF_TGR;
                    break;
                default:
                    xassert(bfd != bfd);
                }
                break;
            case LPF_ESING:
                ret = BFD_ESING;
                return ret;
            case LPF_ECOND:
                ret = BFD_ECOND;
                return ret;
            default:
                xassert(bfd != bfd);
            }
        } else
            xassert(bfd != bfd);
        bfd.valid = 1;
        bfd.upd_cnt = 0;
        ret = 0;
        return ret;
    }
    function bfd_ftran(bfd, x) {
        xassert(bfd != null);
        xassert(bfd.valid);
        if (bfd.fhv != null)
            fhv_ftran(bfd.fhv, x);
        else if (bfd.lpf != null)
            lpf_ftran(bfd.lpf, x);
        else
            xassert(bfd != bfd);
    }
    function bfd_btran(bfd, x) {
        xassert(bfd != null);
        xassert(bfd.valid);
        if (bfd.fhv != null)
            fhv_btran(bfd.fhv, x);
        else if (bfd.lpf != null)
            lpf_btran(bfd.lpf, x);
        else
            xassert(bfd != bfd);
    }
    function bfd_update_it(bfd, j, bh, len, ind, idx, val) {
        var ret;
        xassert(bfd != null);
        xassert(bfd.valid);
        if (bfd.fhv != null) {
            switch (fhv_update_it(bfd.fhv, j, len, ind, idx, val)) {
            case 0:
                break;
            case FHV_ESING:
                bfd.valid = 0;
                ret = BFD_ESING;
                return ret;
            case FHV_ECHECK:
                bfd.valid = 0;
                ret = BFD_ECHECK;
                return ret;
            case FHV_ELIMIT:
                bfd.valid = 0;
                ret = BFD_ELIMIT;
                return ret;
            case FHV_EROOM:
                bfd.valid = 0;
                ret = BFD_EROOM;
                return ret;
            default:
                xassert(bfd != bfd);
            }
        } else if (bfd.lpf != null) {
            switch (lpf_update_it(bfd.lpf, j, bh, len, ind, idx, val)) {
            case 0:
                break;
            case LPF_ESING:
                bfd.valid = 0;
                ret = BFD_ESING;
                return ret;
            case LPF_ELIMIT:
                bfd.valid = 0;
                ret = BFD_ELIMIT;
                return ret;
            default:
                xassert(bfd != bfd);
            }
        } else
            xassert(bfd != bfd);
        bfd.upd_cnt++;
        ret = 0;
        return ret;
    }
    function bfd_get_count(bfd) {
        xassert(bfd != null);
        xassert(bfd.valid);
        return bfd.upd_cnt;
    }
    function check_parm(func, parm) {
        xassert(func != null);
        xassert(parm != null);
    }
    var CHAR_SET = '!"#$%&()/,.;?@_`\'{}|~';
    var glp_read_lp = exports['glp_read_lp'] = function (P, parm, callback) {
        var T_EOF = 0, T_MINIMIZE = 1, T_MAXIMIZE = 2, T_SUBJECT_TO = 3, T_BOUNDS = 4, T_GENERAL = 5, T_INTEGER = 6, T_BINARY = 7, T_END = 8, T_NAME = 9, T_NUMBER = 10, T_PLUS = 11, T_MINUS = 12, T_COLON = 13, T_LE = 14, T_GE = 15, T_EQ = 16;
        function error(csa, fmt) {
            throw new Error(csa.count + ': ' + fmt);
        }
        function warning(csa, fmt) {
            xprintf(csa.count + ': warning: ' + fmt);
        }
        function read_char(csa) {
            var c;
            xassert(csa.c != XEOF);
            if (csa.c == '\n')
                csa.count++;
            c = csa.callback();
            if (c < 0) {
                if (csa.c == '\n') {
                    csa.count--;
                    c = XEOF;
                } else {
                    warning(csa, 'missing final end of line');
                    c = '\n';
                }
            } else if (c == '\n') {
            } else if (isspace(c))
                c = ' ';
            else if (iscntrl(c))
                error(csa, 'invalid control character ' + c.charCodeAt(0));
            csa.c = c;
        }
        function add_char(csa) {
            csa.image += csa.c;
            read_char(csa);
        }
        function the_same(s1, s2) {
            return s1.toLowerCase() == s2.toLowerCase() ? 1 : 0;
        }
        function scan_token(csa) {
            var flag;
            csa.token = -1;
            csa.image = '';
            csa.value = 0;
            function name() {
                csa.token = T_NAME;
                while (isalnum(csa.c) || strchr(CHAR_SET, csa.c) >= 0)
                    add_char(csa);
                if (flag) {
                    if (the_same(csa.image, 'minimize'))
                        csa.token = T_MINIMIZE;
                    else if (the_same(csa.image, 'minimum'))
                        csa.token = T_MINIMIZE;
                    else if (the_same(csa.image, 'min'))
                        csa.token = T_MINIMIZE;
                    else if (the_same(csa.image, 'maximize'))
                        csa.token = T_MAXIMIZE;
                    else if (the_same(csa.image, 'maximum'))
                        csa.token = T_MAXIMIZE;
                    else if (the_same(csa.image, 'max'))
                        csa.token = T_MAXIMIZE;
                    else if (the_same(csa.image, 'subject')) {
                        if (csa.c == ' ') {
                            read_char(csa);
                            if (tolower(csa.c) == 't') {
                                csa.token = T_SUBJECT_TO;
                                csa.image += ' ';
                                add_char(csa);
                                if (tolower(csa.c) != 'o')
                                    error(csa, 'keyword `subject to\' incomplete');
                                add_char(csa);
                                if (isalpha(csa.c))
                                    error(csa, 'keyword `' + csa.image + csa.c + '...\' not recognized');
                            }
                        }
                    } else if (the_same(csa.image, 'such')) {
                        if (csa.c == ' ') {
                            read_char(csa);
                            if (tolower(csa.c) == 't') {
                                csa.token = T_SUBJECT_TO;
                                csa.image += ' ';
                                add_char(csa);
                                if (tolower(csa.c) != 'h')
                                    error(csa, 'keyword `such that\' incomplete');
                                add_char(csa);
                                if (tolower(csa.c) != 'a')
                                    error(csa, 'keyword `such that\' incomplete');
                                add_char(csa);
                                if (tolower(csa.c) != 't')
                                    error(csa, 'keyword `such that\' incomplete');
                                add_char(csa);
                                if (isalpha(csa.c))
                                    error(csa, 'keyword `' + csa.image + csa.c + '...\' not recognized');
                            }
                        }
                    } else if (the_same(csa.image, 'st'))
                        csa.token = T_SUBJECT_TO;
                    else if (the_same(csa.image, 's.t.'))
                        csa.token = T_SUBJECT_TO;
                    else if (the_same(csa.image, 'st.'))
                        csa.token = T_SUBJECT_TO;
                    else if (the_same(csa.image, 'bounds'))
                        csa.token = T_BOUNDS;
                    else if (the_same(csa.image, 'bound'))
                        csa.token = T_BOUNDS;
                    else if (the_same(csa.image, 'general'))
                        csa.token = T_GENERAL;
                    else if (the_same(csa.image, 'generals'))
                        csa.token = T_GENERAL;
                    else if (the_same(csa.image, 'gen'))
                        csa.token = T_GENERAL;
                    else if (the_same(csa.image, 'integer'))
                        csa.token = T_INTEGER;
                    else if (the_same(csa.image, 'integers'))
                        csa.token = T_INTEGER;
                    else if (the_same(csa.image, 'int'))
                        csa.token = T_INTEGER;
                    else if (the_same(csa.image, 'binary'))
                        csa.token = T_BINARY;
                    else if (the_same(csa.image, 'binaries'))
                        csa.token = T_BINARY;
                    else if (the_same(csa.image, 'bin'))
                        csa.token = T_BINARY;
                    else if (the_same(csa.image, 'end'))
                        csa.token = T_END;
                }
            }
            while (true) {
                flag = 0;
                while (csa.c == ' ')
                    read_char(csa);
                if (csa.c == XEOF)
                    csa.token = T_EOF;
                else if (csa.c == '\n') {
                    read_char(csa);
                    if (isalpha(csa.c)) {
                        flag = 1;
                        name();
                    } else
                        continue;
                } else if (csa.c == '\\') {
                    while (csa.c != '\n')
                        read_char(csa);
                    continue;
                } else if (isalpha(csa.c) || csa.c != '.' && strchr(CHAR_SET, csa.c) >= 0) {
                    name();
                } else if (isdigit(csa.c) || csa.c == '.') {
                    csa.token = T_NUMBER;
                    while (isdigit(csa.c))
                        add_char(csa);
                    if (csa.c == '.') {
                        add_char(csa);
                        if (csa.image.length == 1 && !isdigit(csa.c))
                            error(csa, 'invalid use of decimal point');
                        while (isdigit(csa.c))
                            add_char(csa);
                    }
                    if (csa.c == 'e' || csa.c == 'E') {
                        add_char(csa);
                        if (csa.c == '+' || csa.c == '-')
                            add_char(csa);
                        if (!isdigit(csa.c))
                            error(csa, 'numeric constant `' + csa.image + '\' incomplete');
                        while (isdigit(csa.c))
                            add_char(csa);
                    }
                    csa.value = Number(csa.image);
                    if (csa.value == Number.NaN)
                        error(csa, 'numeric constant `' + csa.image + '\' out of range');
                } else if (csa.c == '+') {
                    csa.token = T_PLUS;
                    add_char(csa);
                } else if (csa.c == '-') {
                    csa.token = T_MINUS;
                    add_char(csa);
                } else if (csa.c == ':') {
                    csa.token = T_COLON;
                    add_char(csa);
                } else if (csa.c == '<') {
                    csa.token = T_LE;
                    add_char(csa);
                    if (csa.c == '=')
                        add_char(csa);
                } else if (csa.c == '>') {
                    csa.token = T_GE;
                    add_char(csa);
                    if (csa.c == '=')
                        add_char(csa);
                } else if (csa.c == '=') {
                    csa.token = T_EQ;
                    add_char(csa);
                    if (csa.c == '<') {
                        csa.token = T_LE;
                        add_char(csa);
                    } else if (csa.c == '>') {
                        csa.token = T_GE;
                        add_char(csa);
                    }
                } else
                    error(csa, 'character `' + csa.c + '\' not recognized');
                break;
            }
            while (csa.c == ' ')
                read_char(csa);
        }
        function find_col(csa, name) {
            var j = glp_find_col(csa.P, name);
            if (j == 0) {
                j = glp_add_cols(csa.P, 1);
                glp_set_col_name(csa.P, j, name);
                if (csa.n_max < j) {
                    var n_max = csa.n_max;
                    var ind = csa.ind;
                    var val = csa.val;
                    var flag = csa.flag;
                    var lb = csa.lb;
                    var ub = csa.ub;
                    csa.n_max += csa.n_max;
                    csa.ind = new Int32Array(1 + csa.n_max);
                    xcopyArr(csa.ind, 1, ind, 1, n_max);
                    csa.val = new Float64Array(1 + csa.n_max);
                    xcopyArr(csa.val, 1, val, 1, n_max);
                    csa.flag = new Int8Array(1 + csa.n_max);
                    xfillArr(csa.flag, 1, 0, csa.n_max);
                    xcopyArr(csa.flag, 1, flag, 1, n_max);
                    csa.lb = new Float64Array(1 + csa.n_max);
                    xcopyArr(csa.lb, 1, lb, 1, n_max);
                    csa.ub = new Float64Array(1 + csa.n_max);
                    xcopyArr(csa.ub, 1, ub, 1, n_max);
                }
                csa.lb[j] = +DBL_MAX;
                csa.ub[j] = -DBL_MAX;
            }
            return j;
        }
        function parse_linear_form(csa) {
            var j, k, len = 0, newlen;
            var s, coef;
            while (true) {
                if (csa.token == T_PLUS) {
                    s = +1;
                    scan_token(csa);
                } else if (csa.token == T_MINUS) {
                    s = -1;
                    scan_token(csa);
                } else
                    s = +1;
                if (csa.token == T_NUMBER) {
                    coef = csa.value;
                    scan_token(csa);
                } else
                    coef = 1;
                if (csa.token != T_NAME)
                    error(csa, 'missing variable name');
                j = find_col(csa, csa.image);
                if (csa.flag[j])
                    error(csa, 'multiple use of variable `' + csa.image + '\' not allowed');
                len++;
                csa.ind[len] = j;
                csa.val[len] = s * coef;
                csa.flag[j] = 1;
                scan_token(csa);
                if (csa.token == T_PLUS || csa.token == T_MINUS)
                    continue;
                for (k = 1; k <= len; k++)
                    csa.flag[csa.ind[k]] = 0;
                newlen = 0;
                for (k = 1; k <= len; k++) {
                    if (csa.val[k] != 0) {
                        newlen++;
                        csa.ind[newlen] = csa.ind[k];
                        csa.val[newlen] = csa.val[k];
                    }
                }
                break;
            }
            return newlen;
        }
        function parse_objective(csa) {
            var k, len;
            if (csa.token == T_MINIMIZE)
                glp_set_obj_dir(csa.P, GLP_MIN);
            else if (csa.token == T_MAXIMIZE)
                glp_set_obj_dir(csa.P, GLP_MAX);
            else
                xassert(csa != csa);
            scan_token(csa);
            if (csa.token == T_NAME && csa.c == ':') {
                glp_set_obj_name(csa.P, csa.image);
                scan_token(csa);
                xassert(csa.token == T_COLON);
                scan_token(csa);
            } else {
                glp_set_obj_name(csa.P, 'obj');
            }
            len = parse_linear_form(csa);
            for (k = 1; k <= len; k++)
                glp_set_obj_coef(csa.P, csa.ind[k], csa.val[k]);
        }
        function parse_constraints(csa) {
            var i, len, type;
            var s;
            xassert(csa.token == T_SUBJECT_TO);
            scan_token(csa);
            while (true) {
                i = glp_add_rows(csa.P, 1);
                if (csa.token == T_NAME && csa.c == ':') {
                    if (glp_find_row(csa.P, csa.image) != 0)
                        error(csa, 'constraint `' + csa.image + '\' multiply defined');
                    glp_set_row_name(csa.P, i, csa.image);
                    scan_token(csa);
                    xassert(csa.token == T_COLON);
                    scan_token(csa);
                } else {
                    glp_set_row_name(csa.P, i, 'r.' + csa.count);
                }
                len = parse_linear_form(csa);
                glp_set_mat_row(csa.P, i, len, csa.ind, csa.val);
                if (csa.token == T_LE) {
                    type = GLP_UP;
                    scan_token(csa);
                } else if (csa.token == T_GE) {
                    type = GLP_LO;
                    scan_token(csa);
                } else if (csa.token == T_EQ) {
                    type = GLP_FX;
                    scan_token(csa);
                } else
                    error(csa, 'missing constraint sense');
                if (csa.token == T_PLUS) {
                    s = +1;
                    scan_token(csa);
                } else if (csa.token == T_MINUS) {
                    s = -1;
                    scan_token(csa);
                } else
                    s = +1;
                if (csa.token != T_NUMBER)
                    error(csa, 'missing right-hand side');
                glp_set_row_bnds(csa.P, i, type, s * csa.value, s * csa.value);
                if (!(csa.c == '\n' || csa.c == XEOF))
                    error(csa, 'invalid symbol(s) beyond right-hand side');
                scan_token(csa);
                if (csa.token == T_PLUS || csa.token == T_MINUS || csa.token == T_NUMBER || csa.token == T_NAME)
                    continue;
                break;
            }
        }
        function set_lower_bound(csa, j, lb) {
            if (csa.lb[j] != +DBL_MAX) {
                warning(csa, 'lower bound of variable `' + glp_get_col_name(csa.P, j) + '\' redefined');
            }
            csa.lb[j] = lb;
        }
        function set_upper_bound(csa, j, ub) {
            if (csa.ub[j] != -DBL_MAX) {
                warning(csa, 'upper bound of variable `' + glp_get_col_name(csa.P, j) + '\' redefined');
            }
            csa.ub[j] = ub;
        }
        function parse_bounds(csa) {
            var j, lb_flag;
            var lb, s;
            xassert(csa.token == T_BOUNDS);
            scan_token(csa);
            while (true) {
                if (!(csa.token == T_PLUS || csa.token == T_MINUS || csa.token == T_NUMBER || csa.token == T_NAME))
                    return;
                if (csa.token == T_PLUS || csa.token == T_MINUS) {
                    lb_flag = 1;
                    s = csa.token == T_PLUS ? +1 : -1;
                    scan_token(csa);
                    if (csa.token == T_NUMBER) {
                        lb = s * csa.value;
                        scan_token(csa);
                    } else if (the_same(csa.image, 'infinity') || the_same(csa.image, 'inf')) {
                        if (s > 0)
                            error(csa, 'invalid use of `+inf\' as lower bound');
                        lb = -DBL_MAX;
                        scan_token(csa);
                    } else
                        error(csa, 'missing lower bound');
                } else if (csa.token == T_NUMBER) {
                    lb_flag = 1;
                    lb = csa.value;
                    scan_token(csa);
                } else {
                    lb_flag = 0;
                }
                if (lb_flag) {
                    if (csa.token != T_LE)
                        error(csa, 'missing `<\', `<=\', or `=<\' after lower bound');
                    scan_token(csa);
                }
                if (csa.token != T_NAME)
                    error(csa, 'missing variable name');
                j = find_col(csa, csa.image);
                if (lb_flag)
                    set_lower_bound(csa, j, lb);
                scan_token(csa);
                if (csa.token == T_LE) {
                    scan_token(csa);
                    if (csa.token == T_PLUS || csa.token == T_MINUS) {
                        s = csa.token == T_PLUS ? +1 : -1;
                        scan_token(csa);
                        if (csa.token == T_NUMBER) {
                            set_upper_bound(csa, j, s * csa.value);
                            scan_token(csa);
                        } else if (the_same(csa.image, 'infinity') || the_same(csa.image, 'inf')) {
                            if (s < 0)
                                error(csa, 'invalid use of `-inf\' as upper bound');
                            set_upper_bound(csa, j, +DBL_MAX);
                            scan_token(csa);
                        } else
                            error(csa, 'missing upper bound');
                    } else if (csa.token == T_NUMBER) {
                        set_upper_bound(csa, j, csa.value);
                        scan_token(csa);
                    } else
                        error(csa, 'missing upper bound');
                } else if (csa.token == T_GE) {
                    if (lb_flag) {
                        error(csa, 'invalid bound definition');
                    }
                    scan_token(csa);
                    if (csa.token == T_PLUS || csa.token == T_MINUS) {
                        s = csa.token == T_PLUS ? +1 : -1;
                        scan_token(csa);
                        if (csa.token == T_NUMBER) {
                            set_lower_bound(csa, j, s * csa.value);
                            scan_token(csa);
                        } else if (the_same(csa.image, 'infinity') || the_same(csa.image, 'inf') == 0) {
                            if (s > 0)
                                error(csa, 'invalid use of `+inf\' as lower bound');
                            set_lower_bound(csa, j, -DBL_MAX);
                            scan_token(csa);
                        } else
                            error(csa, 'missing lower bound');
                    } else if (csa.token == T_NUMBER) {
                        set_lower_bound(csa, j, csa.value);
                        scan_token(csa);
                    } else
                        error(csa, 'missing lower bound');
                } else if (csa.token == T_EQ) {
                    if (lb_flag) {
                        error(csa, 'invalid bound definition');
                    }
                    scan_token(csa);
                    if (csa.token == T_PLUS || csa.token == T_MINUS) {
                        s = csa.token == T_PLUS ? +1 : -1;
                        scan_token(csa);
                        if (csa.token == T_NUMBER) {
                            set_lower_bound(csa, j, s * csa.value);
                            set_upper_bound(csa, j, s * csa.value);
                            scan_token(csa);
                        } else
                            error(csa, 'missing fixed value');
                    } else if (csa.token == T_NUMBER) {
                        set_lower_bound(csa, j, csa.value);
                        set_upper_bound(csa, j, csa.value);
                        scan_token(csa);
                    } else
                        error(csa, 'missing fixed value');
                } else if (the_same(csa.image, 'free')) {
                    if (lb_flag) {
                        error(csa, 'invalid bound definition');
                    }
                    set_lower_bound(csa, j, -DBL_MAX);
                    set_upper_bound(csa, j, +DBL_MAX);
                    scan_token(csa);
                } else if (!lb_flag) {
                    error(csa, 'invalid bound definition');
                }
            }
        }
        function parse_integer(csa) {
            var j, binary;
            if (csa.token == T_GENERAL) {
                binary = 0;
                scan_token(csa);
            } else if (csa.token == T_INTEGER) {
                binary = 0;
                scan_token(csa);
            } else if (csa.token == T_BINARY) {
                binary = 1;
                scan_token(csa);
            } else
                xassert(csa != csa);
            while (csa.token == T_NAME) {
                j = find_col(csa, csa.image);
                glp_set_col_kind(csa.P, j, GLP_IV);
                if (binary) {
                    set_lower_bound(csa, j, 0);
                    set_upper_bound(csa, j, 1);
                }
                scan_token(csa);
            }
        }
        var csa = {};
        var ret;
        xprintf('Reading problem data');
        if (parm == null) {
            parm = {};
        }
        check_parm('glp_read_lp', parm);
        csa.P = P;
        csa.parm = parm;
        csa.callback = callback;
        csa.count = 0;
        csa.c = '\n';
        csa.token = T_EOF;
        csa.image = '';
        csa.value = 0;
        csa.n_max = 100;
        csa.ind = new Int32Array(1 + csa.n_max);
        csa.val = new Float64Array(1 + csa.n_max);
        csa.flag = new Int8Array(1 + csa.n_max);
        xfillArr(csa.flag, 1, 0, csa.n_max);
        csa.lb = new Float64Array(1 + csa.n_max);
        csa.ub = new Float64Array(1 + csa.n_max);
        glp_erase_prob(P);
        glp_create_index(P);
        scan_token(csa);
        if (!(csa.token == T_MINIMIZE || csa.token == T_MAXIMIZE))
            error(csa, '`minimize\' or `maximize\' keyword missing');
        parse_objective(csa);
        if (csa.token != T_SUBJECT_TO)
            error(csa, 'constraints section missing');
        parse_constraints(csa);
        if (csa.token == T_BOUNDS)
            parse_bounds(csa);
        while (csa.token == T_GENERAL || csa.token == T_INTEGER || csa.token == T_BINARY)
            parse_integer(csa);
        if (csa.token == T_END)
            scan_token(csa);
        else if (csa.token == T_EOF)
            warning(csa, 'keyword `end\' missing');
        else
            error(csa, 'symbol ' + csa.image + ' in wrong position');
        if (csa.token != T_EOF)
            error(csa, 'extra symbol(s) detected beyond `end\'');
        {
            var j, type;
            var lb, ub;
            for (j = 1; j <= P.n; j++) {
                lb = csa.lb[j];
                ub = csa.ub[j];
                if (lb == +DBL_MAX)
                    lb = 0;
                if (ub == -DBL_MAX)
                    ub = +DBL_MAX;
                if (lb == -DBL_MAX && ub == +DBL_MAX)
                    type = GLP_FR;
                else if (ub == +DBL_MAX)
                    type = GLP_LO;
                else if (lb == -DBL_MAX)
                    type = GLP_UP;
                else if (lb != ub)
                    type = GLP_DB;
                else
                    type = GLP_FX;
                glp_set_col_bnds(csa.P, j, type, lb, ub);
            }
        }
        xprintf(P.m + ' row' + (P.m == 1 ? '' : 's') + ', ' + P.n + ' column' + (P.n == 1 ? '' : 's') + ', ' + P.nnz + ' non-zero' + (P.nnz == 1 ? '' : 's'));
        if (glp_get_num_int(P) > 0) {
            var ni = glp_get_num_int(P);
            var nb = glp_get_num_bin(P);
            if (ni == 1) {
                if (nb == 0)
                    xprintf('One variable is integer');
                else
                    xprintf('One variable is binary');
            } else {
                var line = ni + ' integer variables, ';
                if (nb == 0)
                    line += 'none';
                else if (nb == 1)
                    line += 'one';
                else if (nb == ni)
                    line += 'all';
                else
                    line += nb;
                xprintf(line + ' of which ' + (nb == 1 ? 'is' : 'are') + ' binary');
            }
        }
        xprintf(csa.count + ' lines were read');
        glp_delete_index(P);
        glp_sort_matrix(P);
        ret = 0;
        function done() {
            if (ret != 0)
                glp_erase_prob(P);
            return ret;
        }
        return done();
    };
    var glp_write_lp = exports['glp_write_lp'] = function (P, parm, callback) {
        function check_name(name) {
            if (name[0] == '.')
                return 1;
            if (isdigit(name[0]))
                return 1;
            for (var i = 0; i < name.length; i++) {
                if (!isalnum(name[i]) && strchr(CHAR_SET, name[i]) < 0)
                    return 1;
            }
            return 0;
        }
        function adjust_name(name) {
            for (var i = 0; i < name.length; i++) {
                if (name[i] == ' ')
                    name[i] = '_';
                else if (name[i] == '-')
                    name[i] = '~';
                else if (name[i] == '[')
                    name[i] = '(';
                else if (name[i] == ']')
                    name[i] = ')';
            }
        }
        function row_name(csa, i) {
            var name;
            if (i == 0)
                name = glp_get_obj_name(csa.P);
            else
                name = glp_get_row_name(csa.P, i);
            if (name == null)
                return fake();
            adjust_name(name);
            if (check_name(name))
                return fake();
            return name;
            function fake() {
                if (i == 0)
                    return 'obj';
                else
                    return 'r_' + i;
            }
        }
        function col_name(csa, j) {
            var name = glp_get_col_name(csa.P, j);
            if (name == null)
                return fake();
            adjust_name(name);
            if (check_name(name))
                return fake();
            return name;
            function fake() {
                return 'x_' + j;
            }
        }
        var csa = {};
        var row;
        var col;
        var aij;
        var i, j, len, flag, count, ret;
        var line, term, name;
        xprintf('Writing problem data');
        if (parm == null) {
            parm = {};
        }
        check_parm('glp_write_lp', parm);
        csa.P = P;
        csa.parm = parm;
        count = 0;
        callback('\\* Problem: ' + (P.name == null ? 'Unknown' : P.name) + ' *\\');
        count++;
        callback('');
        count++;
        if (!(P.m > 0 && P.n > 0)) {
            xprintf('Warning: problem has no rows/columns');
            callback('\\* WARNING: PROBLEM HAS NO ROWS/COLUMNS *\\');
            count++;
            callback('');
            count++;
            return skip();
        }
        if (P.dir == GLP_MIN) {
            callback('Minimize');
            count++;
        } else if (P.dir == GLP_MAX) {
            callback('Maximize');
            count++;
        } else
            xassert(P != P);
        name = row_name(csa, 0);
        line = ' ' + name + ':';
        len = 0;
        for (j = 1; j <= P.n; j++) {
            col = P.col[j];
            if (col.coef != 0 || col.ptr == null) {
                len++;
                name = col_name(csa, j);
                if (col.coef == 0)
                    term = ' + 0 ' + name;
                else if (col.coef == +1)
                    term = ' + ' + name;
                else if (col.coef == -1)
                    term = ' - ' + name;
                else if (col.coef > 0)
                    term = ' + ' + col.coef + ' ' + name;
                else
                    term = ' - ' + -col.coef + ' ' + name;
                if (line.length + term.length > 72) {
                    callback(line);
                    line = '';
                    count++;
                }
                line += term;
            }
        }
        if (len == 0) {
            term = ' 0 ' + col_name(csa, 1);
            line += term;
        }
        callback(line);
        count++;
        if (P.c0 != 0) {
            callback('\\* constant term = ' + P.c0 + ' *\\');
            count++;
        }
        callback('');
        count++;
        callback('Subject To');
        count++;
        for (i = 1; i <= P.m; i++) {
            row = P.row[i];
            if (row.type == GLP_FR)
                continue;
            name = row_name(csa, i);
            line = ' ' + name + ':';
            for (aij = row.ptr; aij != null; aij = aij.r_next) {
                name = col_name(csa, aij.col.j);
                if (aij.val == +1)
                    term = ' + ' + name;
                else if (aij.val == -1)
                    term = ' - ' + name;
                else if (aij.val > 0)
                    term = ' + ' + aij.val + ' ' + name;
                else
                    term = ' - ' + -aij.val + ' ' + name;
                if (line.length + term.length > 72) {
                    callback(line);
                    line = '';
                    count++;
                }
                line += term;
            }
            if (row.type == GLP_DB) {
                term = ' - ~r_' + i;
                if (line.length + term.length > 72) {
                    callback(line);
                    line = '';
                    count++;
                }
                line += term;
            } else if (row.ptr == null) {
                term = ' 0 ' + col_name(csa, 1);
                line += term;
            }
            if (row.type == GLP_LO)
                term = ' >= ' + row.lb;
            else if (row.type == GLP_UP)
                term = ' <= ' + row.ub;
            else if (row.type == GLP_DB || row.type == GLP_FX)
                term = ' = ' + row.lb;
            else
                xassert(row != row);
            if (line.length + term.length > 72) {
                callback(line);
                line = '';
                count++;
            }
            line += term;
            callback(line);
            count++;
        }
        callback('');
        count++;
        flag = 0;
        for (i = 1; i <= P.m; i++) {
            row = P.row[i];
            if (row.type != GLP_DB)
                continue;
            if (!flag) {
                callback('Bounds');
                flag = 1;
                count++;
            }
            callback(' 0 <= ~r_' + i + ' <= ' + (row.ub - row.lb));
            count++;
        }
        for (j = 1; j <= P.n; j++) {
            col = P.col[j];
            if (col.type == GLP_LO && col.lb == 0)
                continue;
            if (!flag) {
                callback('Bounds');
                flag = 1;
                count++;
            }
            name = col_name(csa, j);
            if (col.type == GLP_FR) {
                callback(' ' + name + ' free');
                count++;
            } else if (col.type == GLP_LO) {
                callback(' ' + name + ' >= ' + col.lb);
                count++;
            } else if (col.type == GLP_UP) {
                callback(' -Inf <= ' + name + ' <= ' + col.ub);
                count++;
            } else if (col.type == GLP_DB) {
                callback(' ' + col.lb + ' <= ' + name + ' <= ' + col.ub);
                count++;
            } else if (col.type == GLP_FX) {
                callback(' ' + name + ' = ' + col.lb);
                count++;
            } else
                xassert(col != col);
        }
        if (flag)
            callback('');
        count++;
        flag = 0;
        for (j = 1; j <= P.n; j++) {
            col = P.col[j];
            if (col.kind == GLP_CV)
                continue;
            xassert(col.kind == GLP_IV);
            if (!flag) {
                callback('Generals');
                flag = 1;
                count++;
            }
            callback(' ' + col_name(csa, j));
            count++;
        }
        if (flag) {
            callback('');
            count++;
        }
        function skip() {
            callback('End');
            count++;
            xprintf(count + ' lines were written');
            return 0;
        }
        return skip();
    };
    var glp_read_lp_from_string = exports['glp_read_lp_from_string'] = function (P, parm, str) {
        var pos = 0;
        return glp_read_lp(P, parm, function () {
            if (pos < str.length) {
                return str[pos++];
            } else
                return -1;
        });
    };
    var FHV_ESING = 1, FHV_ECOND = 2, FHV_ECHECK = 3, FHV_ELIMIT = 4, FHV_EROOM = 5;
    function fhv_create_it() {
        var fhv;
        fhv = {};
        fhv.m_max = fhv.m = 0;
        fhv.valid = 0;
        fhv.luf = luf_create_it();
        fhv.hh_max = 50;
        fhv.hh_nfs = 0;
        fhv.hh_ind = fhv.hh_ptr = fhv.hh_len = null;
        fhv.p0_row = fhv.p0_col = null;
        fhv.cc_ind = null;
        fhv.cc_val = null;
        fhv.upd_tol = 0.000001;
        fhv.nnz_h = 0;
        return fhv;
    }
    function fhv_factorize(fhv, m, col, info) {
        var ret;
        if (m < 1)
            xerror('fhv_factorize: m = ' + m + '; invalid parameter');
        if (m > M_MAX)
            xerror('fhv_factorize: m = ' + m + '; matrix too big');
        fhv.m = m;
        fhv.valid = 0;
        if (fhv.hh_ind == null)
            fhv.hh_ind = new Int32Array(1 + fhv.hh_max);
        if (fhv.hh_ptr == null)
            fhv.hh_ptr = new Int32Array(1 + fhv.hh_max);
        if (fhv.hh_len == null)
            fhv.hh_len = new Int32Array(1 + fhv.hh_max);
        if (fhv.m_max < m) {
            fhv.m_max = m + 100;
            fhv.p0_row = new Int32Array(1 + fhv.m_max);
            fhv.p0_col = new Int32Array(1 + fhv.m_max);
            fhv.cc_ind = new Int32Array(1 + fhv.m_max);
            fhv.cc_val = new Float64Array(1 + fhv.m_max);
        }
        switch (luf_factorize(fhv.luf, m, col, info)) {
        case 0:
            break;
        case LUF_ESING:
            ret = FHV_ESING;
            return ret;
        case LUF_ECOND:
            ret = FHV_ECOND;
            return ret;
        default:
            xassert(fhv != fhv);
        }
        fhv.valid = 1;
        fhv.hh_nfs = 0;
        xcopyArr(fhv.p0_row, 1, fhv.luf.pp_row, 1, m);
        xcopyArr(fhv.p0_col, 1, fhv.luf.pp_col, 1, m);
        fhv.nnz_h = 0;
        ret = 0;
        return ret;
    }
    function fhv_h_solve(fhv, tr, x) {
        var nfs = fhv.hh_nfs;
        var hh_ind = fhv.hh_ind;
        var hh_ptr = fhv.hh_ptr;
        var hh_len = fhv.hh_len;
        var sv_ind = fhv.luf.sv_ind;
        var sv_val = fhv.luf.sv_val;
        var i, k, beg, end, ptr;
        var temp;
        if (!fhv.valid)
            xerror('fhv_h_solve: the factorization is not valid');
        if (!tr) {
            for (k = 1; k <= nfs; k++) {
                i = hh_ind[k];
                temp = x[i];
                beg = hh_ptr[k];
                end = beg + hh_len[k] - 1;
                for (ptr = beg; ptr <= end; ptr++)
                    temp -= sv_val[ptr] * x[sv_ind[ptr]];
                x[i] = temp;
            }
        } else {
            for (k = nfs; k >= 1; k--) {
                i = hh_ind[k];
                temp = x[i];
                if (temp == 0)
                    continue;
                beg = hh_ptr[k];
                end = beg + hh_len[k] - 1;
                for (ptr = beg; ptr <= end; ptr++)
                    x[sv_ind[ptr]] -= sv_val[ptr] * temp;
            }
        }
    }
    function fhv_ftran(fhv, x) {
        var pp_row = fhv.luf.pp_row;
        var pp_col = fhv.luf.pp_col;
        var p0_row = fhv.p0_row;
        var p0_col = fhv.p0_col;
        if (!fhv.valid)
            xerror('fhv_ftran: the factorization is not valid');
        fhv.luf.pp_row = p0_row;
        fhv.luf.pp_col = p0_col;
        luf_f_solve(fhv.luf, 0, x);
        fhv.luf.pp_row = pp_row;
        fhv.luf.pp_col = pp_col;
        fhv_h_solve(fhv, 0, x);
        luf_v_solve(fhv.luf, 0, x);
    }
    function fhv_btran(fhv, x) {
        var pp_row = fhv.luf.pp_row;
        var pp_col = fhv.luf.pp_col;
        var p0_row = fhv.p0_row;
        var p0_col = fhv.p0_col;
        if (!fhv.valid)
            xerror('fhv_btran: the factorization is not valid');
        luf_v_solve(fhv.luf, 1, x);
        fhv_h_solve(fhv, 1, x);
        fhv.luf.pp_row = p0_row;
        fhv.luf.pp_col = p0_col;
        luf_f_solve(fhv.luf, 1, x);
        fhv.luf.pp_row = pp_row;
        fhv.luf.pp_col = pp_col;
    }
    function fhv_update_it(fhv, j, len, ind, idx, val) {
        var m = fhv.m;
        var luf = fhv.luf;
        var vr_ptr = luf.vr_ptr;
        var vr_len = luf.vr_len;
        var vr_cap = luf.vr_cap;
        var vr_piv = luf.vr_piv;
        var vc_ptr = luf.vc_ptr;
        var vc_len = luf.vc_len;
        var vc_cap = luf.vc_cap;
        var pp_row = luf.pp_row;
        var pp_col = luf.pp_col;
        var qq_row = luf.qq_row;
        var qq_col = luf.qq_col;
        var sv_ind = luf.sv_ind;
        var sv_val = luf.sv_val;
        var work = luf.work;
        var eps_tol = luf.eps_tol;
        var hh_ind = fhv.hh_ind;
        var hh_ptr = fhv.hh_ptr;
        var hh_len = fhv.hh_len;
        var p0_row = fhv.p0_row;
        var p0_col = fhv.p0_col;
        var cc_ind = fhv.cc_ind;
        var cc_val = fhv.cc_val;
        var upd_tol = fhv.upd_tol;
        var i, i_beg, i_end, i_ptr, j_beg, j_end, j_ptr, k, k1, k2, p, q, p_beg, p_end, p_ptr, ptr, ret;
        var f, temp;
        if (!fhv.valid)
            xerror('fhv_update_it: the factorization is not valid');
        if (!(1 <= j && j <= m))
            xerror('fhv_update_it: j = ' + j + '; column number out of range');
        if (fhv.hh_nfs == fhv.hh_max) {
            fhv.valid = 0;
            ret = FHV_ELIMIT;
            return ret;
        }
        for (i = 1; i <= m; i++)
            cc_val[i] = 0;
        for (k = 1; k <= len; k++) {
            i = ind[idx + k];
            if (!(1 <= i && i <= m))
                xerror('fhv_update_it: ind[' + k + '] = ' + i + '; row number out of range');
            if (cc_val[i] != 0)
                xerror('fhv_update_it: ind[' + k + '] = ' + i + '; duplicate row index not allowed');
            if (val[k] == 0)
                xerror('fhv_update_it: val[' + k + '] = ' + val[k] + '; zero element not allowed');
            cc_val[i] = val[k];
        }
        fhv.luf.pp_row = p0_row;
        fhv.luf.pp_col = p0_col;
        luf_f_solve(fhv.luf, 0, cc_val);
        fhv.luf.pp_row = pp_row;
        fhv.luf.pp_col = pp_col;
        fhv_h_solve(fhv, 0, cc_val);
        len = 0;
        for (i = 1; i <= m; i++) {
            temp = cc_val[i];
            if (temp == 0 || Math.abs(temp) < eps_tol)
                continue;
            len++;
            cc_ind[len] = i;
            cc_val[len] = temp;
        }
        j_beg = vc_ptr[j];
        j_end = j_beg + vc_len[j] - 1;
        for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++) {
            i = sv_ind[j_ptr];
            i_beg = vr_ptr[i];
            i_end = i_beg + vr_len[i] - 1;
            for (i_ptr = i_beg; sv_ind[i_ptr] != j; i_ptr++) {
            }
            xassert(i_ptr <= i_end);
            sv_ind[i_ptr] = sv_ind[i_end];
            sv_val[i_ptr] = sv_val[i_end];
            vr_len[i]--;
        }
        luf.nnz_v -= vc_len[j];
        vc_len[j] = 0;
        k1 = qq_row[j];
        k2 = 0;
        for (ptr = 1; ptr <= len; ptr++) {
            i = cc_ind[ptr];
            if (vr_len[i] + 1 > vr_cap[i]) {
                if (luf_enlarge_row(luf, i, vr_len[i] + 10)) {
                    fhv.valid = 0;
                    luf.new_sva = luf.sv_size + luf.sv_size;
                    xassert(luf.new_sva > luf.sv_size);
                    ret = FHV_EROOM;
                    return ret;
                }
            }
            i_ptr = vr_ptr[i] + vr_len[i];
            sv_ind[i_ptr] = j;
            sv_val[i_ptr] = cc_val[ptr];
            vr_len[i]++;
            if (k2 < pp_col[i])
                k2 = pp_col[i];
        }
        if (vc_cap[j] < len) {
            if (luf_enlarge_col(luf, j, len)) {
                fhv.valid = 0;
                luf.new_sva = luf.sv_size + luf.sv_size;
                xassert(luf.new_sva > luf.sv_size);
                ret = FHV_EROOM;
                return ret;
            }
        }
        j_ptr = vc_ptr[j];
        xcopyArr(sv_ind, j_ptr, cc_ind, 1, len);
        xcopyArr(sv_val, j_ptr, cc_val, 1, len);
        vc_len[j] = len;
        luf.nnz_v += len;
        if (k1 > k2) {
            fhv.valid = 0;
            ret = FHV_ESING;
            return ret;
        }
        i = pp_row[k1];
        j = qq_col[k1];
        for (k = k1; k < k2; k++) {
            pp_row[k] = pp_row[k + 1];
            pp_col[pp_row[k]] = k;
            qq_col[k] = qq_col[k + 1];
            qq_row[qq_col[k]] = k;
        }
        pp_row[k2] = i;
        pp_col[i] = k2;
        qq_col[k2] = j;
        qq_row[j] = k2;
        for (j = 1; j <= m; j++)
            work[j] = 0;
        i_beg = vr_ptr[i];
        i_end = i_beg + vr_len[i] - 1;
        for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++) {
            j = sv_ind[i_ptr];
            work[j] = sv_val[i_ptr];
            j_beg = vc_ptr[j];
            j_end = j_beg + vc_len[j] - 1;
            for (j_ptr = j_beg; sv_ind[j_ptr] != i; j_ptr++) {
            }
            xassert(j_ptr <= j_end);
            sv_ind[j_ptr] = sv_ind[j_end];
            sv_val[j_ptr] = sv_val[j_end];
            vc_len[j]--;
        }
        luf.nnz_v -= vr_len[i];
        vr_len[i] = 0;
        fhv.hh_nfs++;
        hh_ind[fhv.hh_nfs] = i;
        hh_len[fhv.hh_nfs] = 0;
        if (luf.sv_end - luf.sv_beg < k2 - k1) {
            luf_defrag_sva(luf);
            if (luf.sv_end - luf.sv_beg < k2 - k1) {
                fhv.valid = luf.valid = 0;
                luf.new_sva = luf.sv_size + luf.sv_size;
                xassert(luf.new_sva > luf.sv_size);
                ret = FHV_EROOM;
                return ret;
            }
        }
        for (k = k1; k < k2; k++) {
            p = pp_row[k];
            q = qq_col[k];
            if (work[q] == 0)
                continue;
            f = work[q] / vr_piv[p];
            p_beg = vr_ptr[p];
            p_end = p_beg + vr_len[p] - 1;
            for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)
                work[sv_ind[p_ptr]] -= f * sv_val[p_ptr];
            luf.sv_end--;
            sv_ind[luf.sv_end] = p;
            sv_val[luf.sv_end] = f;
            hh_len[fhv.hh_nfs]++;
        }
        if (hh_len[fhv.hh_nfs] == 0)
            fhv.hh_nfs--;
        else {
            hh_ptr[fhv.hh_nfs] = luf.sv_end;
            fhv.nnz_h += hh_len[fhv.hh_nfs];
        }
        vr_piv[i] = work[qq_col[k2]];
        len = 0;
        for (k = k2 + 1; k <= m; k++) {
            j = qq_col[k];
            temp = work[j];
            if (Math.abs(temp) < eps_tol)
                continue;
            if (vc_len[j] + 1 > vc_cap[j]) {
                if (luf_enlarge_col(luf, j, vc_len[j] + 10)) {
                    fhv.valid = 0;
                    luf.new_sva = luf.sv_size + luf.sv_size;
                    xassert(luf.new_sva > luf.sv_size);
                    ret = FHV_EROOM;
                    return ret;
                }
            }
            j_ptr = vc_ptr[j] + vc_len[j];
            sv_ind[j_ptr] = i;
            sv_val[j_ptr] = temp;
            vc_len[j]++;
            len++;
            cc_ind[len] = j;
            cc_val[len] = temp;
        }
        if (vr_cap[i] < len) {
            if (luf_enlarge_row(luf, i, len)) {
                fhv.valid = 0;
                luf.new_sva = luf.sv_size + luf.sv_size;
                xassert(luf.new_sva > luf.sv_size);
                ret = FHV_EROOM;
                return ret;
            }
        }
        i_ptr = vr_ptr[i];
        xcopyArr(sv_ind, i_ptr, cc_ind, 1, len);
        xcopyArr(sv_val, i_ptr, cc_val, 1, len);
        vr_len[i] = len;
        luf.nnz_v += len;
        temp = 0;
        i = pp_row[k2];
        i_beg = vr_ptr[i];
        i_end = i_beg + vr_len[i] - 1;
        for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)
            if (temp < Math.abs(sv_val[i_ptr]))
                temp = Math.abs(sv_val[i_ptr]);
        j = qq_col[k2];
        j_beg = vc_ptr[j];
        j_end = j_beg + vc_len[j] - 1;
        for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)
            if (temp < Math.abs(sv_val[j_ptr]))
                temp = Math.abs(sv_val[j_ptr]);
        if (Math.abs(vr_piv[i]) < upd_tol * temp) {
            fhv.valid = 0;
            ret = FHV_ECHECK;
            return ret;
        }
        ret = 0;
        return ret;
    }
    function glp_adv_basis(lp, flags) {
        function triang(m, n, info, mat, rn, cn) {
            var ndx;
            var rs_len;
            var rs_head;
            var rs_prev;
            var rs_next;
            var cs_head;
            var cs_prev;
            var cs_next;
            var i, j, ii, jj, k1, k2, len, t, size = 0;
            var head, rn_inv, cn_inv;
            if (!(m > 0 && n > 0))
                xerror('triang: m = ' + m + '; n = ' + n + '; invalid dimension');
            ndx = new Int32Array(1 + (m >= n ? m : n));
            rs_len = new Int32Array(1 + m);
            rs_head = new Int32Array(1 + n);
            rs_prev = new Int32Array(1 + m);
            rs_next = new Int32Array(1 + m);
            cs_prev = new Int32Array(1 + n);
            cs_next = new Int32Array(1 + n);
            head = rs_len;
            for (j = 1; j <= n; j++) {
                len = mat(info, -j, ndx);
                xassert(0 <= len && len <= m);
                cs_prev[j] = head[len];
                head[len] = j;
            }
            cs_head = 0;
            for (len = 0; len <= m; len++) {
                for (j = head[len]; j != 0; j = cs_prev[j]) {
                    cs_next[j] = cs_head;
                    cs_head = j;
                }
            }
            jj = 0;
            for (j = cs_head; j != 0; j = cs_next[j]) {
                cs_prev[j] = jj;
                jj = j;
            }
            for (i = 1; i <= m; i++) {
                rs_len[i] = len = mat(info, +i, ndx);
                xassert(0 <= len && len <= n);
                rs_prev[i] = 0;
                rs_next[i] = rs_head[len];
                if (rs_next[i] != 0)
                    rs_prev[rs_next[i]] = i;
                rs_head[len] = i;
            }
            for (i = 1; i <= m; i++)
                rn[i] = 0;
            for (j = 1; j <= n; j++)
                cn[j] = 0;
            k1 = 1;
            k2 = n;
            while (k1 <= k2) {
                i = rs_head[1];
                if (i != 0) {
                    xassert(rs_len[i] == 1);
                    j = 0;
                    t = mat(info, +i, ndx);
                    xassert(0 <= t && t <= n);
                    for (; t >= 1; t--) {
                        jj = ndx[t];
                        xassert(1 <= jj && jj <= n);
                        if (cn[jj] == 0) {
                            xassert(j == 0);
                            j = jj;
                        }
                    }
                    xassert(j != 0);
                    rn[i] = cn[j] = k1;
                    k1++;
                    size++;
                } else {
                    j = cs_head;
                    xassert(j != 0);
                    cn[j] = k2;
                    k2--;
                }
                if (cs_prev[j] == 0)
                    cs_head = cs_next[j];
                else
                    cs_next[cs_prev[j]] = cs_next[j];
                if (cs_next[j] != 0)
                    cs_prev[cs_next[j]] = cs_prev[j];
                t = mat(info, -j, ndx);
                xassert(0 <= t && t <= m);
                for (; t >= 1; t--) {
                    i = ndx[t];
                    xassert(1 <= i && i <= m);
                    len = rs_len[i];
                    xassert(len >= 1);
                    if (rs_prev[i] == 0)
                        rs_head[len] = rs_next[i];
                    else
                        rs_next[rs_prev[i]] = rs_next[i];
                    if (rs_next[i] != 0)
                        rs_prev[rs_next[i]] = rs_prev[i];
                    rs_len[i] = --len;
                    rs_prev[i] = 0;
                    rs_next[i] = rs_head[len];
                    if (rs_next[i] != 0)
                        rs_prev[rs_next[i]] = i;
                    rs_head[len] = i;
                }
            }
            for (i = 1; i <= m; i++)
                if (rn[i] == 0)
                    rn[i] = k1++;
            for (j = 1; j <= n; j++)
                xassert(cn[j] != 0);
            rn_inv = rs_len;
            for (ii = 1; ii <= m; ii++)
                rn_inv[ii] = 0;
            for (i = 1; i <= m; i++) {
                ii = rn[i];
                xassert(1 <= ii && ii <= m);
                xassert(rn_inv[ii] == 0);
                rn_inv[ii] = i;
            }
            cn_inv = rs_head;
            for (jj = 1; jj <= n; jj++)
                cn_inv[jj] = 0;
            for (j = 1; j <= n; j++) {
                jj = cn[j];
                xassert(1 <= jj && jj <= n);
                xassert(cn_inv[jj] == 0);
                cn_inv[jj] = j;
            }
            for (ii = 1; ii <= size; ii++) {
                var diag = 0;
                i = rn_inv[ii];
                t = mat(info, +i, ndx);
                xassert(0 <= t && t <= n);
                for (; t >= 1; t--) {
                    j = ndx[t];
                    xassert(1 <= j && j <= n);
                    jj = cn[j];
                    if (jj <= size)
                        xassert(jj <= ii);
                    if (jj == ii) {
                        xassert(!diag);
                        diag = 1;
                    }
                }
                xassert(diag);
            }
            return size;
        }
        function mat(lp, k, ndx) {
            var m = lpx_get_num_rows(lp);
            var n = lpx_get_num_cols(lp);
            var i, j, lll, len = 0;
            if (k > 0) {
                i = +k;
                xassert(1 <= i && i <= m);
                lll = lpx_get_mat_row(lp, i, ndx, null);
                for (k = 1; k <= lll; k++) {
                    lpx_get_col_bnds(lp, ndx[k], function (typx) {
                        if (typx != LPX_FX)
                            ndx[++len] = m + ndx[k];
                    });
                }
                lpx_get_row_bnds(lp, i, function (typx) {
                    if (typx != LPX_FX)
                        ndx[++len] = i;
                });
            } else {
                j = -k;
                xassert(1 <= j && j <= m + n);
                function doit(typx) {
                    if (typx != LPX_FX) {
                        if (j <= m) {
                            ndx[++len] = j;
                        } else {
                            len = lpx_get_mat_col(lp, j - m, ndx, null);
                        }
                    }
                }
                if (j <= m)
                    lpx_get_row_bnds(lp, j, doit);
                else
                    lpx_get_col_bnds(lp, j - m, doit);
            }
            return len;
        }
        function adv_basis(lp) {
            var m = lpx_get_num_rows(lp);
            var n = lpx_get_num_cols(lp);
            var i, j, jj, k, size;
            var rn, cn, rn_inv, cn_inv;
            var tagx = new Int32Array(1 + m + n);
            xprintf('Constructing initial basis...');
            if (m == 0 || n == 0) {
                glp_std_basis(lp);
                return;
            }
            rn = new Int32Array(1 + m);
            cn = new Int32Array(1 + m + n);
            size = triang(m, m + n, lp, mat, rn, cn);
            if (lpx_get_int_parm(lp, LPX_K_MSGLEV) >= 3)
                xprintf('Size of triangular part = ' + size + '');
            rn_inv = new Int32Array(1 + m);
            cn_inv = new Int32Array(1 + m + n);
            for (i = 1; i <= m; i++)
                rn_inv[rn[i]] = i;
            for (j = 1; j <= m + n; j++)
                cn_inv[cn[j]] = j;
            for (k = 1; k <= m + n; k++)
                tagx[k] = -1;
            for (jj = 1; jj <= size; jj++) {
                j = cn_inv[jj];
                tagx[j] = LPX_BS;
            }
            for (jj = size + 1; jj <= m; jj++) {
                i = rn_inv[jj];
                xassert(1 <= i && i <= m);
                xassert(cn[i] > size);
                tagx[i] = LPX_BS;
            }
            for (k = 1; k <= m + n; k++) {
                if (tagx[k] != LPX_BS) {
                    function doit(typx, lb, ub) {
                        switch (typx) {
                        case LPX_FR:
                            tagx[k] = LPX_NF;
                            break;
                        case LPX_LO:
                            tagx[k] = LPX_NL;
                            break;
                        case LPX_UP:
                            tagx[k] = LPX_NU;
                            break;
                        case LPX_DB:
                            tagx[k] = Math.abs(lb) <= Math.abs(ub) ? LPX_NL : LPX_NU;
                            break;
                        case LPX_FX:
                            tagx[k] = LPX_NS;
                            break;
                        default:
                            xassert(typx != typx);
                        }
                    }
                    if (k <= m)
                        lpx_get_row_bnds(lp, k, doit);
                    else
                        lpx_get_col_bnds(lp, k - m, doit);
                }
            }
            for (k = 1; k <= m + n; k++) {
                if (k <= m)
                    lpx_set_row_stat(lp, k, tagx[k]);
                else
                    lpx_set_col_stat(lp, k - m, tagx[k]);
            }
        }
        if (flags != 0)
            xerror('glp_adv_basis: flags = ' + flags + '; invalid flags');
        if (lp.m == 0 || lp.n == 0)
            glp_std_basis(lp);
        else
            adv_basis(lp);
    }
    function cpx_basis(lp) {
        var C, C2, C3, C4;
        var m, n, i, j, jk, k, l, ll, t, n2, n3, n4, type, len, I, r, ind;
        var alpha, gamma, cmax, temp, v, val;
        xprintf('Constructing initial basis...');
        m = glp_get_num_rows(lp);
        n = glp_get_num_cols(lp);
        C = new Array(1 + n);
        I = new Int32Array(1 + m);
        r = new Int32Array(1 + m);
        v = new Float64Array(1 + m);
        ind = new Int32Array(1 + m);
        val = new Float64Array(1 + m);
        for (i = 1; i <= m; i++) {
            if (glp_get_row_type(lp, i) != GLP_DB)
                glp_set_row_stat(lp, i, GLP_NS);
            else if (Math.abs(glp_get_row_lb(lp, i)) <= Math.abs(glp_get_row_ub(lp, i)))
                glp_set_row_stat(lp, i, GLP_NL);
            else
                glp_set_row_stat(lp, i, GLP_NU);
        }
        for (j = 1; j <= n; j++) {
            if (glp_get_col_type(lp, j) != GLP_DB)
                glp_set_col_stat(lp, j, GLP_NS);
            else if (Math.abs(glp_get_col_lb(lp, j)) <= Math.abs(glp_get_col_ub(lp, j)))
                glp_set_col_stat(lp, j, GLP_NL);
            else
                glp_set_col_stat(lp, j, GLP_NU);
        }
        n2 = 0;
        C2 = 0;
        for (j = 1; j <= n; j++) {
            type = glp_get_col_type(lp, j);
            if (type == GLP_FR) {
                n2++;
                C[C2 + n2].j = j;
                C[C2 + n2].q = 0;
            }
        }
        n3 = 0;
        C3 = C2 + n2;
        for (j = 1; j <= n; j++) {
            type = glp_get_col_type(lp, j);
            if (type == GLP_LO) {
                n3++;
                C[C3 + n3].j = j;
                C[C3 + n3].q = +glp_get_col_lb(lp, j);
            } else if (type == GLP_UP) {
                n3++;
                C[C3 + n3].j = j;
                C[C3 + n3].q = -glp_get_col_ub(lp, j);
            }
        }
        n4 = 0;
        C4 = C3 + n3;
        for (j = 1; j <= n; j++) {
            type = glp_get_col_type(lp, j);
            if (type == GLP_DB) {
                n4++;
                C[C4 + n4].j = j;
                C[C4 + n4].q = glp_get_col_lb(lp, j) - glp_get_col_ub(lp, j);
            }
        }
        gamma = 0;
        for (j = 1; j <= n; j++) {
            temp = Math.abs(glp_get_obj_coef(lp, j));
            if (gamma < temp)
                gamma = temp;
        }
        cmax = gamma == 0 ? 1 : 1000 * gamma;
        switch (glp_get_obj_dir(lp)) {
        case GLP_MIN:
            temp = +1;
            break;
        case GLP_MAX:
            temp = -1;
            break;
        default:
            xassert(lp != lp);
        }
        for (k = 1; k <= n2 + n3 + n4; k++) {
            j = C[k].j;
            C[k].q += temp * glp_get_obj_coef(lp, j) / cmax;
        }
        function fcmp(col1, col2) {
            if (col1.q < col2.q)
                return -1;
            if (col1.q > col2.q)
                return +1;
            return 0;
        }
        xqsort(C, C2 + 1 + n2, fcmp);
        for (k = 1; k < n2; k++)
            xassert(C[C2 + k].q <= C[C2 + k + 1].q);
        xqsort(C, C3 + 1 + n3, fcmp);
        for (k = 1; k < n3; k++)
            xassert(C[C3 + k].q <= C[C3 + k + 1].q);
        xqsort(C, C4 + 1 + n4, fcmp);
        for (k = 1; k < n4; k++)
            xassert(C[C4 + k].q <= C[C4 + k + 1].q);
        for (i = 1; i <= m; i++) {
            type = glp_get_row_type(lp, i);
            if (type != GLP_FX) {
                glp_set_row_stat(lp, i, GLP_BS);
                I[i] = 1;
                r[i] = 1;
            }
            v[i] = +DBL_MAX;
        }
        function get_column(lp, j, ind, val) {
            var k;
            var len = glp_get_mat_col(lp, j, ind, val);
            var big = 0;
            for (k = 1; k <= len; k++)
                if (big < Math.abs(val[k]))
                    big = Math.abs(val[k]);
            if (big == 0)
                big = 1;
            for (k = 1; k <= len; k++)
                val[k] /= big;
            return len;
        }
        for (k = 1; k <= n2 + n3 + n4; k++) {
            jk = C[k].j;
            len = get_column(lp, jk, ind, val);
            alpha = 0;
            ll = 0;
            for (t = 1; t <= len; t++) {
                l = ind[t];
                if (r[l] == 0 && alpha < Math.abs(val[t])) {
                    alpha = Math.abs(val[t]);
                    ll = l;
                }
            }
            if (alpha >= 0.99) {
                glp_set_col_stat(lp, jk, GLP_BS);
                I[ll] = 1;
                v[ll] = alpha;
                for (t = 1; t <= len; t++) {
                    l = ind[t];
                    if (val[t] != 0)
                        r[l]++;
                }
                continue;
            }
            for (t = 1; t <= len; t++) {
                l = ind[t];
                if (Math.abs(val[t]) > 0.01 * v[l])
                    break;
            }
            if (t <= len)
                continue;
            alpha = 0;
            ll = 0;
            for (t = 1; t <= len; t++) {
                l = ind[t];
                if (I[l] == 0 && alpha < Math.abs(val[t])) {
                    alpha = Math.abs(val[t]);
                    ll = l;
                }
            }
            if (alpha == 0)
                continue;
            glp_set_col_stat(lp, jk, GLP_BS);
            I[ll] = 1;
            v[ll] = alpha;
            for (t = 1; t <= len; t++) {
                l = ind[t];
                if (val[t] != 0)
                    r[l]++;
            }
        }
        for (i = 1; i <= m; i++)
            if (I[i] == 0)
                glp_set_row_stat(lp, i, GLP_BS);
    }
    function glp_cpx_basis(lp) {
        if (lp.m == 0 || lp.n == 0)
            glp_std_basis(lp);
        else
            cpx_basis(lp);
    }
    function new_node(tree, parent) {
        var p = get_slot(tree);
        var node = {};
        tree.slot[p].node = node;
        node.p = p;
        node.up = parent;
        node.level = parent == null ? 0 : parent.level + 1;
        node.count = 0;
        node.b_ptr = null;
        node.s_ptr = null;
        node.r_ptr = null;
        node.solved = 0;
        node.lp_obj = parent == null ? tree.mip.dir == GLP_MIN ? -DBL_MAX : +DBL_MAX : parent.lp_obj;
        node.bound = parent == null ? tree.mip.dir == GLP_MIN ? -DBL_MAX : +DBL_MAX : parent.bound;
        node.br_var = 0;
        node.br_val = 0;
        node.ii_cnt = 0;
        node.ii_sum = 0;
        node.changed = 0;
        if (tree.parm.cb_size == 0)
            node.data = null;
        else {
            node.data = {};
        }
        node.temp = null;
        node.prev = tree.tail;
        node.next = null;
        if (tree.head == null)
            tree.head = node;
        else
            tree.tail.next = node;
        tree.tail = node;
        tree.a_cnt++;
        tree.n_cnt++;
        tree.t_cnt++;
        if (parent == null)
            xassert(p == 1);
        else
            parent.count++;
        return node;
    }
    function get_slot(tree) {
        var p;
        if (tree.avail == 0) {
            var nslots = tree.nslots;
            var save = tree.slot;
            if (nslots == 0)
                tree.nslots = 20;
            else {
                tree.nslots = nslots + nslots;
                xassert(tree.nslots > nslots);
            }
            tree.slot = new Array(1 + tree.nslots);
            xfillObjArr(tree.slot, 0, 1 + tree.nslots);
            if (save != null) {
                xcopyArr(tree.slot, 1, save, 1, nslots);
            }
            for (p = tree.nslots; p > nslots; p--) {
                tree.slot[p].node = null;
                tree.slot[p].next = tree.avail;
                tree.avail = p;
            }
        }
        p = tree.avail;
        tree.avail = tree.slot[p].next;
        xassert(tree.slot[p].node == null);
        tree.slot[p].next = 0;
        return p;
    }
    function ios_create_tree(mip, parm) {
        var m = mip.m;
        var n = mip.n;
        var tree;
        var i, j;
        xassert(mip.tree == null);
        mip.tree = tree = {};
        tree.n = n;
        tree.orig_m = m;
        tree.orig_type = new Int8Array(1 + m + n);
        tree.orig_lb = new Float64Array(1 + m + n);
        tree.orig_ub = new Float64Array(1 + m + n);
        tree.orig_stat = new Int8Array(1 + m + n);
        tree.orig_prim = new Float64Array(1 + m + n);
        tree.orig_dual = new Float64Array(1 + m + n);
        for (i = 1; i <= m; i++) {
            var row = mip.row[i];
            tree.orig_type[i] = row.type;
            tree.orig_lb[i] = row.lb;
            tree.orig_ub[i] = row.ub;
            tree.orig_stat[i] = row.stat;
            tree.orig_prim[i] = row.prim;
            tree.orig_dual[i] = row.dual;
        }
        for (j = 1; j <= n; j++) {
            var col = mip.col[j];
            tree.orig_type[m + j] = col.type;
            tree.orig_lb[m + j] = col.lb;
            tree.orig_ub[m + j] = col.ub;
            tree.orig_stat[m + j] = col.stat;
            tree.orig_prim[m + j] = col.prim;
            tree.orig_dual[m + j] = col.dual;
        }
        tree.orig_obj = mip.obj_val;
        tree.nslots = 0;
        tree.avail = 0;
        tree.slot = null;
        tree.head = tree.tail = null;
        tree.a_cnt = tree.n_cnt = tree.t_cnt = 0;
        tree.root_m = 0;
        tree.root_type = null;
        tree.root_lb = tree.root_ub = null;
        tree.root_stat = null;
        tree.curr = null;
        tree.mip = mip;
        tree.non_int = new Int8Array(1 + n);
        tree.pred_m = tree.pred_max = 0;
        tree.pred_type = null;
        tree.pred_lb = tree.pred_ub = null;
        tree.pred_stat = null;
        tree.local = ios_create_pool(tree);
        tree.mir_gen = null;
        tree.clq_gen = null;
        tree.pcost = null;
        tree.iwrk = new Int32Array(1 + n);
        tree.dwrk = new Float64Array(1 + n);
        tree.parm = parm;
        tree.tm_beg = xtime();
        tree.tm_lag = 0;
        tree.sol_cnt = 0;
        tree.reason = 0;
        tree.reopt = 0;
        tree.reinv = 0;
        tree.br_var = 0;
        tree.br_sel = 0;
        tree.child = 0;
        tree.next_p = 0;
        tree.stop = 0;
        new_node(tree, null);
        return tree;
    }
    function ios_revive_node(tree, p) {
        var mip = tree.mip;
        var node, root;
        var b, r, s, a;
        xassert(1 <= p && p <= tree.nslots);
        node = tree.slot[p].node;
        xassert(node != null);
        xassert(node.count == 0);
        xassert(tree.curr == null);
        tree.curr = node;
        root = tree.slot[1].node;
        xassert(root != null);
        if (node == root)
            return;
        xassert(mip.m == tree.root_m);
        node.temp = null;
        for (; node != null; node = node.up) {
            if (node.up == null)
                xassert(node == root);
            else
                node.up.temp = node;
        }
        for (node = root; node != null; node = node.temp) {
            var m = mip.m;
            var n = mip.n;
            if (node.temp == null) {
                var i, j;
                tree.pred_m = m;
                if (tree.pred_max < m + n) {
                    var new_size = m + n + 100;
                    tree.pred_max = new_size;
                    tree.pred_type = new Int8Array(1 + new_size);
                    tree.pred_lb = new Float64Array(1 + new_size);
                    tree.pred_ub = new Float64Array(1 + new_size);
                    tree.pred_stat = new Int8Array(1 + new_size);
                }
                for (i = 1; i <= m; i++) {
                    var row = mip.row[i];
                    tree.pred_type[i] = row.type;
                    tree.pred_lb[i] = row.lb;
                    tree.pred_ub[i] = row.ub;
                    tree.pred_stat[i] = row.stat;
                }
                for (j = 1; j <= n; j++) {
                    var col = mip.col[j];
                    tree.pred_type[mip.m + j] = col.type;
                    tree.pred_lb[mip.m + j] = col.lb;
                    tree.pred_ub[mip.m + j] = col.ub;
                    tree.pred_stat[mip.m + j] = col.stat;
                }
            }
            {
                for (b = node.b_ptr; b != null; b = b.next) {
                    if (b.k <= m)
                        glp_set_row_bnds(mip, b.k, b.type, b.lb, b.ub);
                    else
                        glp_set_col_bnds(mip, b.k - m, b.type, b.lb, b.ub);
                }
            }
            {
                for (s = node.s_ptr; s != null; s = s.next) {
                    if (s.k <= m)
                        glp_set_row_stat(mip, s.k, s.stat);
                    else
                        glp_set_col_stat(mip, s.k - m, s.stat);
                }
            }
            if (node.r_ptr != null) {
                var len, ind;
                var val;
                ind = new Int32Array(1 + n);
                val = new Float64Array(1 + n);
                for (r = node.r_ptr; r != null; r = r.next) {
                    i = glp_add_rows(mip, 1);
                    glp_set_row_name(mip, i, r.name);
                    xassert(mip.row[i].level == 0);
                    mip.row[i].level = node.level;
                    mip.row[i].origin = r.origin;
                    mip.row[i].klass = r.klass;
                    glp_set_row_bnds(mip, i, r.type, r.lb, r.ub);
                    len = 0;
                    for (a = r.ptr; a != null; a = a.next) {
                        len++;
                        ind[len] = a.j;
                        val[len] = a.val;
                    }
                    glp_set_mat_row(mip, i, len, ind, val);
                    glp_set_rii(mip, i, r.rii);
                    glp_set_row_stat(mip, i, r.stat);
                }
            }
        }
        node = tree.curr;
        while (node.b_ptr != null) {
            b = node.b_ptr;
            node.b_ptr = b.next;
        }
        while (node.s_ptr != null) {
            s = node.s_ptr;
            node.s_ptr = s.next;
        }
        while (node.r_ptr != null) {
            r = node.r_ptr;
            node.r_ptr = r.next;
            xassert(r.name == null);
            while (r.ptr != null) {
                a = r.ptr;
                r.ptr = a.next;
            }
        }
    }
    function ios_freeze_node(tree) {
        var mip = tree.mip;
        var m = mip.m;
        var n = mip.n;
        var node = tree.curr;
        xassert(node != null);
        var k, i, row, col;
        if (node.up == null) {
            xassert(node.p == 1);
            xassert(tree.root_m == 0);
            xassert(tree.root_type == null);
            xassert(tree.root_lb == null);
            xassert(tree.root_ub == null);
            xassert(tree.root_stat == null);
            tree.root_m = m;
            tree.root_type = new Int8Array(1 + m + n);
            tree.root_lb = new Float64Array(1 + m + n);
            tree.root_ub = new Float64Array(1 + m + n);
            tree.root_stat = new Int8Array(1 + m + n);
            for (k = 1; k <= m + n; k++) {
                if (k <= m) {
                    row = mip.row[k];
                    tree.root_type[k] = row.type;
                    tree.root_lb[k] = row.lb;
                    tree.root_ub[k] = row.ub;
                    tree.root_stat[k] = row.stat;
                } else {
                    col = mip.col[k - m];
                    tree.root_type[k] = col.type;
                    tree.root_lb[k] = col.lb;
                    tree.root_ub[k] = col.ub;
                    tree.root_stat[k] = col.stat;
                }
            }
        } else {
            var root_m = tree.root_m;
            var pred_m = tree.pred_m;
            var j;
            xassert(pred_m <= m);
            xassert(node.b_ptr == null);
            xassert(node.s_ptr == null);
            for (k = 1; k <= pred_m + n; k++) {
                var pred_type, pred_stat, type, stat;
                var pred_lb, pred_ub, lb, ub;
                pred_type = tree.pred_type[k];
                pred_lb = tree.pred_lb[k];
                pred_ub = tree.pred_ub[k];
                pred_stat = tree.pred_stat[k];
                if (k <= pred_m) {
                    row = mip.row[k];
                    type = row.type;
                    lb = row.lb;
                    ub = row.ub;
                    stat = row.stat;
                } else {
                    col = mip.col[k - pred_m];
                    type = col.type;
                    lb = col.lb;
                    ub = col.ub;
                    stat = col.stat;
                }
                if (!(pred_type == type && pred_lb == lb && pred_ub == ub)) {
                    var b = {};
                    b.k = k;
                    b.type = type;
                    b.lb = lb;
                    b.ub = ub;
                    b.next = node.b_ptr;
                    node.b_ptr = b;
                }
                if (pred_stat != stat) {
                    var s = {};
                    s.k = k;
                    s.stat = stat;
                    s.next = node.s_ptr;
                    node.s_ptr = s;
                }
            }
            xassert(node.r_ptr == null);
            if (pred_m < m) {
                var len, ind;
                var val;
                ind = new Int32Array(1 + n);
                val = new Float64Array(1 + n);
                for (i = m; i > pred_m; i--) {
                    row = mip.row[i];
                    var r = {};
                    var name = glp_get_row_name(mip, i);
                    if (name == null)
                        r.name = null;
                    else {
                        r.name = name;
                    }
                    r.type = row.type;
                    r.lb = row.lb;
                    r.ub = row.ub;
                    r.ptr = null;
                    len = glp_get_mat_row(mip, i, ind, val);
                    for (k = 1; k <= len; k++) {
                        var a = {};
                        a.j = ind[k];
                        a.val = val[k];
                        a.next = r.ptr;
                        r.ptr = a;
                    }
                    r.rii = row.rii;
                    r.stat = row.stat;
                    r.next = node.r_ptr;
                    node.r_ptr = r;
                }
            }
            if (m != root_m) {
                var nrs = m - root_m;
                xassert(nrs > 0);
                var num = new Int32Array(1 + nrs);
                for (i = 1; i <= nrs; i++)
                    num[i] = root_m + i;
                glp_del_rows(mip, nrs, num);
            }
            m = mip.m;
            xassert(m == root_m);
            for (i = 1; i <= m; i++) {
                glp_set_row_bnds(mip, i, tree.root_type[i], tree.root_lb[i], tree.root_ub[i]);
                glp_set_row_stat(mip, i, tree.root_stat[i]);
            }
            for (j = 1; j <= n; j++) {
                glp_set_col_bnds(mip, j, tree.root_type[m + j], tree.root_lb[m + j], tree.root_ub[m + j]);
                glp_set_col_stat(mip, j, tree.root_stat[m + j]);
            }
        }
        tree.curr = null;
    }
    function ios_clone_node(tree, p, nnn, ref) {
        var node, k;
        xassert(1 <= p && p <= tree.nslots);
        node = tree.slot[p].node;
        xassert(node != null);
        xassert(node.count == 0);
        xassert(tree.curr != node);
        if (node.prev == null)
            tree.head = node.next;
        else
            node.prev.next = node.next;
        if (node.next == null)
            tree.tail = node.prev;
        else
            node.next.prev = node.prev;
        node.prev = node.next = null;
        tree.a_cnt--;
        xassert(nnn > 0);
        for (k = 1; k <= nnn; k++)
            ref[k] = new_node(tree, node).p;
    }
    function ios_delete_node(tree, p) {
        var node, temp;
        xassert(1 <= p && p <= tree.nslots);
        node = tree.slot[p].node;
        xassert(node != null);
        xassert(node.count == 0);
        xassert(tree.curr != node);
        if (node.prev == null)
            tree.head = node.next;
        else
            node.prev.next = node.next;
        if (node.next == null)
            tree.tail = node.prev;
        else
            node.next.prev = node.prev;
        node.prev = node.next = null;
        tree.a_cnt--;
        while (true) {
            {
                var b;
                while (node.b_ptr != null) {
                    b = node.b_ptr;
                    node.b_ptr = b.next;
                }
            }
            {
                var s;
                while (node.s_ptr != null) {
                    s = node.s_ptr;
                    node.s_ptr = s.next;
                }
            }
            while (node.r_ptr != null) {
                var r;
                r = node.r_ptr;
                r.name = null;
                while (r.ptr != null) {
                    var a;
                    a = r.ptr;
                    r.ptr = a.next;
                }
                node.r_ptr = r.next;
            }
            if (tree.parm.cb_size == 0)
                xassert(node.data == null);
            p = node.p;
            xassert(tree.slot[p].node == node);
            tree.slot[p].node = null;
            tree.slot[p].next = tree.avail;
            tree.avail = p;
            temp = node.up;
            tree.n_cnt--;
            node = temp;
            if (node != null) {
                xassert(node.count > 0);
                node.count--;
                if (node.count == 0)
                    continue;
            }
            break;
        }
    }
    function ios_delete_tree(tree) {
        var mip = tree.mip;
        var i, j;
        var m = mip.m;
        var n = mip.n;
        xassert(mip.tree == tree);
        if (m != tree.orig_m) {
            var nrs, num;
            nrs = m - tree.orig_m;
            xassert(nrs > 0);
            num = new Int32Array(1 + nrs);
            for (i = 1; i <= nrs; i++)
                num[i] = tree.orig_m + i;
            glp_del_rows(mip, nrs, num);
        }
        m = tree.orig_m;
        xassert(m == tree.orig_m);
        xassert(n == tree.n);
        for (i = 1; i <= m; i++) {
            glp_set_row_bnds(mip, i, tree.orig_type[i], tree.orig_lb[i], tree.orig_ub[i]);
            glp_set_row_stat(mip, i, tree.orig_stat[i]);
            mip.row[i].prim = tree.orig_prim[i];
            mip.row[i].dual = tree.orig_dual[i];
        }
        for (j = 1; j <= n; j++) {
            glp_set_col_bnds(mip, j, tree.orig_type[m + j], tree.orig_lb[m + j], tree.orig_ub[m + j]);
            glp_set_col_stat(mip, j, tree.orig_stat[m + j]);
            mip.col[j].prim = tree.orig_prim[m + j];
            mip.col[j].dual = tree.orig_dual[m + j];
        }
        mip.pbs_stat = mip.dbs_stat = GLP_FEAS;
        mip.obj_val = tree.orig_obj;
        xassert(tree.local != null);
        ios_delete_pool(tree.local);
        xassert(tree.mir_gen == null);
        xassert(tree.clq_gen == null);
        mip.tree = null;
    }
    function ios_eval_degrad(tree, j, callback) {
        var mip = tree.mip;
        var m = mip.m;
        var n = mip.n;
        var len, kase, k, t, stat;
        var alfa, beta, gamma, delta, dz;
        var ind = tree.iwrk;
        var val = tree.dwrk;
        var dn, up;
        xassert(glp_get_status(mip) == GLP_OPT);
        xassert(glp_bf_exists(mip));
        xassert(1 <= j && j <= n);
        beta = mip.col[j].prim;
        len = lpx_eval_tab_row(mip, m + j, ind, val);
        for (kase = -1; kase <= +1; kase += 2) {
            k = lpx_dual_ratio_test(mip, len, ind, val, kase, 1e-9);
            if (k == 0) {
                if (mip.dir == GLP_MIN) {
                    if (kase < 0)
                        dn = +DBL_MAX;
                    else
                        up = +DBL_MAX;
                } else if (mip.dir == GLP_MAX) {
                    if (kase < 0)
                        dn = -DBL_MAX;
                    else
                        up = -DBL_MAX;
                } else
                    xassert(mip != mip);
                continue;
            }
            xassert(1 <= k && k <= m + n);
            for (t = 1; t <= len; t++)
                if (ind[t] == k)
                    break;
            xassert(1 <= t && t <= len);
            alfa = val[t];
            if (k <= m) {
                stat = mip.row[k].stat;
                gamma = mip.row[k].dual;
            } else {
                stat = mip.col[k - m].stat;
                gamma = mip.col[k - m].dual;
            }
            xassert(stat == GLP_NL || stat == GLP_NU || stat == GLP_NF);
            if (mip.dir == GLP_MIN) {
                if (stat == GLP_NL && gamma < 0 || stat == GLP_NU && gamma > 0 || stat == GLP_NF)
                    gamma = 0;
            } else if (mip.dir == GLP_MAX) {
                if (stat == GLP_NL && gamma > 0 || stat == GLP_NU && gamma < 0 || stat == GLP_NF)
                    gamma = 0;
            } else
                xassert(mip != mip);
            delta = (kase < 0 ? Math.floor(beta) : Math.ceil(beta)) - beta;
            delta /= alfa;
            dz = gamma * delta;
            if (mip.dir == GLP_MIN)
                xassert(dz >= 0);
            else if (mip.dir == GLP_MAX)
                xassert(dz <= 0);
            else
                xassert(mip != mip);
            if (kase < 0)
                dn = mip.obj_val + dz;
            else
                up = mip.obj_val + dz;
        }
        callback(dn, up);
    }
    function ios_round_bound(tree, bound) {
        var mip = tree.mip;
        var n = mip.n;
        var d, j, nn;
        var c = tree.iwrk;
        var s, h;
        nn = 0;
        s = mip.c0;
        d = 0;
        for (j = 1; j <= n; j++) {
            var col = mip.col[j];
            if (col.coef == 0)
                continue;
            if (col.type == GLP_FX) {
                s += col.coef * col.prim;
            } else {
                if (col.kind != GLP_IV)
                    return bound;
                if (col.coef != Math.floor(col.coef))
                    return bound;
                if (Math.abs(col.coef) <= INT_MAX)
                    c[++nn] = Math.abs(col.coef) | 0;
                else
                    d = 1;
            }
        }
        if (d == 0) {
            if (nn == 0)
                return bound;
            d = gcdn(nn, c);
        }
        xassert(d > 0);
        if (mip.dir == GLP_MIN) {
            if (bound != +DBL_MAX) {
                h = (bound - s) / d;
                if (h >= Math.floor(h) + 0.001) {
                    h = Math.ceil(h);
                    bound = d * h + s;
                }
            }
        } else if (mip.dir == GLP_MAX) {
            if (bound != -DBL_MAX) {
                h = (bound - s) / d;
                if (h <= Math.ceil(h) - 0.001) {
                    h = Math.floor(h);
                    bound = d * h + s;
                }
            }
        } else
            xassert(mip != mip);
        return bound;
    }
    function ios_is_hopeful(tree, bound) {
        var mip = tree.mip;
        var ret = 1;
        var eps;
        if (mip.mip_stat == GLP_FEAS) {
            eps = tree.parm.tol_obj * (1 + Math.abs(mip.mip_obj));
            switch (mip.dir) {
            case GLP_MIN:
                if (bound >= mip.mip_obj - eps)
                    ret = 0;
                break;
            case GLP_MAX:
                if (bound <= mip.mip_obj + eps)
                    ret = 0;
                break;
            default:
                xassert(mip != mip);
            }
        } else {
            switch (mip.dir) {
            case GLP_MIN:
                if (bound == +DBL_MAX)
                    ret = 0;
                break;
            case GLP_MAX:
                if (bound == -DBL_MAX)
                    ret = 0;
                break;
            default:
                xassert(mip != mip);
            }
        }
        return ret;
    }
    function ios_best_node(tree) {
        var node, best = null;
        switch (tree.mip.dir) {
        case GLP_MIN:
            for (node = tree.head; node != null; node = node.next)
                if (best == null || best.bound > node.bound)
                    best = node;
            break;
        case GLP_MAX:
            for (node = tree.head; node != null; node = node.next)
                if (best == null || best.bound < node.bound)
                    best = node;
            break;
        default:
            xassert(tree != tree);
        }
        return best == null ? 0 : best.p;
    }
    var ios_relative_gap = exports['glp_ios_relative_gap'] = function (tree) {
        var mip = tree.mip;
        var p;
        var best_mip, best_bnd, gap;
        if (mip.mip_stat == GLP_FEAS) {
            best_mip = mip.mip_obj;
            p = ios_best_node(tree);
            if (p == 0) {
                gap = 0;
            } else {
                best_bnd = tree.slot[p].node.bound;
                gap = Math.abs(best_mip - best_bnd) / (Math.abs(best_mip) + DBL_EPSILON);
            }
        } else {
            gap = DBL_MAX;
        }
        return gap;
    };
    function ios_solve_node(tree) {
        var mip = tree.mip;
        var ret;
        xassert(tree.curr != null);
        var parm = new SMCP();
        switch (tree.parm.msg_lev) {
        case GLP_MSG_OFF:
            parm.msg_lev = GLP_MSG_OFF;
            break;
        case GLP_MSG_ERR:
            parm.msg_lev = GLP_MSG_ERR;
            break;
        case GLP_MSG_ON:
        case GLP_MSG_ALL:
            parm.msg_lev = GLP_MSG_ON;
            break;
        case GLP_MSG_DBG:
            parm.msg_lev = GLP_MSG_ALL;
            break;
        default:
            xassert(tree != tree);
        }
        parm.meth = GLP_DUALP;
        if (tree.parm.msg_lev < GLP_MSG_DBG)
            parm.out_dly = tree.parm.out_dly;
        else
            parm.out_dly = 0;
        if (mip.mip_stat == GLP_FEAS) {
            switch (tree.mip.dir) {
            case GLP_MIN:
                parm.obj_ul = mip.mip_obj;
                break;
            case GLP_MAX:
                parm.obj_ll = mip.mip_obj;
                break;
            default:
                xassert(mip != mip);
            }
        }
        ret = glp_simplex(mip, parm);
        tree.curr.solved++;
        return ret;
    }
    function ios_create_pool(tree) {
        xassert(tree == tree);
        var pool = {};
        pool.size = 0;
        pool.head = pool.tail = null;
        pool.ord = 0;
        pool.curr = null;
        return pool;
    }
    function ios_add_row(tree, pool, name, klass, flags, len, ind, val, type, rhs) {
        var cut, aij, k;
        xassert(pool != null);
        cut = {};
        if (name == null || name[0] == '\0')
            cut.name = null;
        else {
            cut.name = name;
        }
        if (!(0 <= klass && klass <= 255))
            xerror('glp_ios_add_row: klass = ' + klass + '; invalid cut class');
        cut.klass = klass;
        if (flags != 0)
            xerror('glp_ios_add_row: flags = ' + flags + '; invalid cut flags');
        cut.ptr = null;
        if (!(0 <= len && len <= tree.n))
            xerror('glp_ios_add_row: len = ' + len + '; invalid cut length');
        for (k = 1; k <= len; k++) {
            aij = {};
            if (!(1 <= ind[k] && ind[k] <= tree.n))
                xerror('glp_ios_add_row: ind[' + k + '] = ' + ind[k] + '; column index out of range');
            aij.j = ind[k];
            aij.val = val[k];
            aij.next = cut.ptr;
            cut.ptr = aij;
        }
        if (!(type == GLP_LO || type == GLP_UP || type == GLP_FX))
            xerror('glp_ios_add_row: type = ' + type + '; invalid cut type');
        cut.type = type;
        cut.rhs = rhs;
        cut.prev = pool.tail;
        cut.next = null;
        if (cut.prev == null)
            pool.head = cut;
        else
            cut.prev.next = cut;
        pool.tail = cut;
        pool.size++;
        return pool.size;
    }
    function ios_find_row(pool, i) {
        xassert(pool != null);
        xassert(1 <= i && i <= pool.size);
        if (pool.ord == 0) {
            xassert(pool.curr == null);
            pool.ord = 1;
            pool.curr = pool.head;
        }
        xassert(pool.curr != null);
        if (i < pool.ord) {
            if (i < pool.ord - i) {
                pool.ord = 1;
                pool.curr = pool.head;
                while (pool.ord != i) {
                    pool.ord++;
                    xassert(pool.curr != null);
                    pool.curr = pool.curr.next;
                }
            } else {
                while (pool.ord != i) {
                    pool.ord--;
                    xassert(pool.curr != null);
                    pool.curr = pool.curr.prev;
                }
            }
        } else if (i > pool.ord) {
            if (i - pool.ord < pool.size - i) {
                while (pool.ord != i) {
                    pool.ord++;
                    xassert(pool.curr != null);
                    pool.curr = pool.curr.next;
                }
            } else {
                pool.ord = pool.size;
                pool.curr = pool.tail;
                while (pool.ord != i) {
                    pool.ord--;
                    xassert(pool.curr != null);
                    pool.curr = pool.curr.prev;
                }
            }
        }
        xassert(pool.ord == i);
        xassert(pool.curr != null);
        return pool.curr;
    }
    function ios_del_row(pool, i) {
        var cut, aij;
        xassert(pool != null);
        if (!(1 <= i && i <= pool.size))
            xerror('glp_ios_del_row: i = ' + i + '; cut number out of range');
        cut = ios_find_row(pool, i);
        xassert(pool.curr == cut);
        if (cut.next != null)
            pool.curr = cut.next;
        else if (cut.prev != null) {
            pool.ord--;
            pool.curr = cut.prev;
        } else {
            pool.ord = 0;
            pool.curr = null;
        }
        if (cut.prev == null) {
            xassert(pool.head == cut);
            pool.head = cut.next;
        } else {
            xassert(cut.prev.next == cut);
            cut.prev.next = cut.next;
        }
        if (cut.next == null) {
            xassert(pool.tail == cut);
            pool.tail = cut.prev;
        } else {
            xassert(cut.next.prev == cut);
            cut.next.prev = cut.prev;
        }
        while (cut.ptr != null) {
            aij = cut.ptr;
            cut.ptr = aij.next;
        }
        pool.size--;
    }
    function ios_clear_pool(pool) {
        xassert(pool != null);
        while (pool.head != null) {
            var cut = pool.head;
            pool.head = cut.next;
            while (cut.ptr != null) {
                var aij = cut.ptr;
                cut.ptr = aij.next;
            }
        }
        pool.size = 0;
        pool.head = pool.tail = null;
        pool.ord = 0;
        pool.curr = null;
    }
    function ios_delete_pool(pool) {
        xassert(pool != null);
        ios_clear_pool(pool);
    }
    function ios_preprocess_node(tree, max_pass) {
        function prepare_row_info(n, a, l, u, f) {
            var j, j_min, j_max;
            var f_min, f_max;
            xassert(n >= 0);
            f_min = 0;
            j_min = 0;
            for (j = 1; j <= n; j++) {
                if (a[j] > 0) {
                    if (l[j] == -DBL_MAX) {
                        if (j_min == 0)
                            j_min = j;
                        else {
                            f_min = -DBL_MAX;
                            j_min = 0;
                            break;
                        }
                    } else
                        f_min += a[j] * l[j];
                } else if (a[j] < 0) {
                    if (u[j] == +DBL_MAX) {
                        if (j_min == 0)
                            j_min = j;
                        else {
                            f_min = -DBL_MAX;
                            j_min = 0;
                            break;
                        }
                    } else
                        f_min += a[j] * u[j];
                } else
                    xassert(a != a);
            }
            f.f_min = f_min;
            f.j_min = j_min;
            f_max = 0;
            j_max = 0;
            for (j = 1; j <= n; j++) {
                if (a[j] > 0) {
                    if (u[j] == +DBL_MAX) {
                        if (j_max == 0)
                            j_max = j;
                        else {
                            f_max = +DBL_MAX;
                            j_max = 0;
                            break;
                        }
                    } else
                        f_max += a[j] * u[j];
                } else if (a[j] < 0) {
                    if (l[j] == -DBL_MAX) {
                        if (j_max == 0)
                            j_max = j;
                        else {
                            f_max = +DBL_MAX;
                            j_max = 0;
                            break;
                        }
                    } else
                        f_max += a[j] * l[j];
                } else
                    xassert(a != a);
            }
            f.f_max = f_max;
            f.j_max = j_max;
        }
        function row_implied_bounds(f, callback) {
            callback(f.j_min == 0 ? f.f_min : -DBL_MAX, f.j_max == 0 ? f.f_max : +DBL_MAX);
        }
        function col_implied_bounds(f, n, a, L, U, l, u, k, callback) {
            var ilb, iub, ll, uu;
            xassert(n >= 0);
            xassert(1 <= k && k <= n);
            if (L == -DBL_MAX || f.f_max == +DBL_MAX)
                ilb = -DBL_MAX;
            else if (f.j_max == 0) {
                if (a[k] > 0) {
                    xassert(u[k] != +DBL_MAX);
                    ilb = L - (f.f_max - a[k] * u[k]);
                } else if (a[k] < 0) {
                    xassert(l[k] != -DBL_MAX);
                    ilb = L - (f.f_max - a[k] * l[k]);
                } else
                    xassert(a != a);
            } else if (f.j_max == k)
                ilb = L - f.f_max;
            else
                ilb = -DBL_MAX;
            if (U == +DBL_MAX || f.f_min == -DBL_MAX)
                iub = +DBL_MAX;
            else if (f.j_min == 0) {
                if (a[k] > 0) {
                    xassert(l[k] != -DBL_MAX);
                    iub = U - (f.f_min - a[k] * l[k]);
                } else if (a[k] < 0) {
                    xassert(u[k] != +DBL_MAX);
                    iub = U - (f.f_min - a[k] * u[k]);
                } else
                    xassert(a != a);
            } else if (f.j_min == k)
                iub = U - f.f_min;
            else
                iub = +DBL_MAX;
            if (Math.abs(a[k]) < 0.000001) {
                ll = -DBL_MAX;
                uu = +DBL_MAX;
            } else if (a[k] > 0) {
                ll = ilb == -DBL_MAX ? -DBL_MAX : ilb / a[k];
                uu = iub == +DBL_MAX ? +DBL_MAX : iub / a[k];
            } else if (a[k] < 0) {
                ll = iub == +DBL_MAX ? -DBL_MAX : iub / a[k];
                uu = ilb == -DBL_MAX ? +DBL_MAX : ilb / a[k];
            } else
                xassert(a != a);
            callback(ll, uu);
        }
        function check_row_bounds(f, L_, Lx, U_, Ux) {
            var eps, ret = 0;
            var L = L_[Lx], U = U_[Ux], LL = null, UU = null;
            row_implied_bounds(f, function (a, b) {
                LL = a;
                UU = b;
            });
            if (L != -DBL_MAX) {
                eps = 0.001 * (1 + Math.abs(L));
                if (UU < L - eps) {
                    ret = 1;
                    return ret;
                }
            }
            if (U != +DBL_MAX) {
                eps = 0.001 * (1 + Math.abs(U));
                if (LL > U + eps) {
                    ret = 1;
                    return ret;
                }
            }
            if (L != -DBL_MAX) {
                eps = 1e-12 * (1 + Math.abs(L));
                if (LL > L - eps) {
                    L_[Lx] = -DBL_MAX;
                }
            }
            if (U != +DBL_MAX) {
                eps = 1e-12 * (1 + Math.abs(U));
                if (UU < U + eps) {
                    U_[Ux] = +DBL_MAX;
                }
            }
            return ret;
        }
        function check_col_bounds(f, n, a, L, U, l, u, flag, j, callback) {
            var eps, ret = 0;
            var lj, uj, ll = null, uu = null;
            xassert(n >= 0);
            xassert(1 <= j && j <= n);
            lj = l[j];
            uj = u[j];
            col_implied_bounds(f, n, a, L, U, l, u, j, function (a, b) {
                ll = a;
                uu = b;
            });
            if (flag) {
                if (ll != -DBL_MAX)
                    ll = ll - Math.floor(ll) < 0.001 ? Math.floor(ll) : Math.ceil(ll);
                if (uu != +DBL_MAX)
                    uu = Math.ceil(uu) - uu < 0.001 ? Math.ceil(uu) : Math.floor(uu);
            }
            if (lj != -DBL_MAX) {
                eps = 0.001 * (1 + Math.abs(lj));
                if (uu < lj - eps) {
                    ret = 1;
                    return ret;
                }
            }
            if (uj != +DBL_MAX) {
                eps = 0.001 * (1 + Math.abs(uj));
                if (ll > uj + eps) {
                    ret = 1;
                    return ret;
                }
            }
            if (ll != -DBL_MAX) {
                eps = 0.001 * (1 + Math.abs(ll));
                if (lj < ll - eps) {
                    lj = ll;
                }
            }
            if (uu != +DBL_MAX) {
                eps = 0.001 * (1 + Math.abs(uu));
                if (uj > uu + eps) {
                    uj = uu;
                }
            }
            if (!(lj == -DBL_MAX || uj == +DBL_MAX)) {
                var t1 = Math.abs(lj), t2 = Math.abs(uj);
                eps = 1e-10 * (1 + (t1 <= t2 ? t1 : t2));
                if (lj > uj - eps) {
                    if (lj == l[j])
                        uj = lj;
                    else if (uj == u[j])
                        lj = uj;
                    else if (t1 <= t2)
                        uj = lj;
                    else
                        lj = uj;
                }
            }
            callback(lj, uj);
            return ret;
        }
        function check_efficiency(flag, l, u, ll, uu) {
            var r, eff = 0;
            if (l < ll) {
                if (flag || l == -DBL_MAX)
                    eff++;
                else {
                    if (u == +DBL_MAX)
                        r = 1 + Math.abs(l);
                    else
                        r = 1 + (u - l);
                    if (ll - l >= 0.25 * r)
                        eff++;
                }
            }
            if (u > uu) {
                if (flag || u == +DBL_MAX)
                    eff++;
                else {
                    if (l == -DBL_MAX)
                        r = 1 + Math.abs(u);
                    else
                        r = 1 + (u - l);
                    if (u - uu >= 0.25 * r)
                        eff++;
                }
            }
            return eff;
        }
        function basic_preprocessing(mip, L, U, l, u, nrs, num, max_pass) {
            var m = mip.m;
            var n = mip.n;
            var f = {};
            var i, j, k, len, size, ret = 0;
            var ind, list, mark, pass;
            var val, lb, ub;
            var aij, col;
            xassert(0 <= nrs && nrs <= m + 1);
            xassert(max_pass > 0);
            ind = new Int32Array(1 + n);
            list = new Int32Array(1 + m + 1);
            mark = new Int32Array(1 + m + 1);
            pass = new Int32Array(1 + m + 1);
            val = new Float64Array(1 + n);
            lb = new Float64Array(1 + n);
            ub = new Float64Array(1 + n);
            size = 0;
            for (k = 1; k <= nrs; k++) {
                i = num[k];
                xassert(0 <= i && i <= m);
                xassert(!mark[i]);
                list[++size] = i;
                mark[i] = 1;
            }
            xassert(size == nrs);
            while (size > 0) {
                i = list[size--];
                mark[i] = 0;
                pass[i]++;
                if (L[i] == -DBL_MAX && U[i] == +DBL_MAX)
                    continue;
                len = 0;
                if (i == 0) {
                    for (j = 1; j <= n; j++) {
                        col = mip.col[j];
                        if (col.coef != 0) {
                            len++;
                            ind[len] = j;
                            val[len] = col.coef;
                        }
                    }
                } else {
                    var row = mip.row[i];
                    for (aij = row.ptr; aij != null; aij = aij.r_next) {
                        len++;
                        ind[len] = aij.col.j;
                        val[len] = aij.val;
                    }
                }
                for (k = 1; k <= len; k++) {
                    j = ind[k];
                    lb[k] = l[j];
                    ub[k] = u[j];
                }
                prepare_row_info(len, val, lb, ub, f);
                if (check_row_bounds(f, L, i, U, i)) {
                    ret = 1;
                    return ret;
                }
                if (L[i] == -DBL_MAX && U[i] == +DBL_MAX)
                    continue;
                for (k = 1; k <= len; k++) {
                    var flag, eff;
                    var ll = null, uu = null;
                    j = ind[k];
                    col = mip.col[j];
                    flag = col.kind != GLP_CV;
                    if (check_col_bounds(f, len, val, L[i], U[i], lb, ub, flag, k, function (a, b) {
                            ll = a;
                            uu = b;
                        })) {
                        ret = 1;
                        return ret;
                    }
                    eff = check_efficiency(flag, l[j], u[j], ll, uu);
                    l[j] = ll;
                    u[j] = uu;
                    if (eff > 0) {
                        for (aij = col.ptr; aij != null; aij = aij.c_next) {
                            var ii = aij.row.i;
                            if (pass[ii] >= max_pass)
                                continue;
                            if (L[ii] == -DBL_MAX && U[ii] == +DBL_MAX)
                                continue;
                            if (mark[ii] == 0) {
                                xassert(size <= m);
                                list[++size] = ii;
                                mark[ii] = 1;
                            }
                        }
                    }
                }
            }
            return ret;
        }
        var mip = tree.mip;
        var m = mip.m;
        var n = mip.n;
        var i, j, nrs, num, ret = 0;
        var L, U, l, u;
        xassert(tree.curr != null);
        L = new Float64Array(1 + m);
        U = new Float64Array(1 + m);
        switch (mip.mip_stat) {
        case GLP_UNDEF:
            L[0] = -DBL_MAX;
            U[0] = +DBL_MAX;
            break;
        case GLP_FEAS:
            switch (mip.dir) {
            case GLP_MIN:
                L[0] = -DBL_MAX;
                U[0] = mip.mip_obj - mip.c0;
                break;
            case GLP_MAX:
                L[0] = mip.mip_obj - mip.c0;
                U[0] = +DBL_MAX;
                break;
            default:
                xassert(mip != mip);
            }
            break;
        default:
            xassert(mip != mip);
        }
        for (i = 1; i <= m; i++) {
            L[i] = glp_get_row_lb(mip, i);
            U[i] = glp_get_row_ub(mip, i);
        }
        l = new Float64Array(1 + n);
        u = new Float64Array(1 + n);
        for (j = 1; j <= n; j++) {
            l[j] = glp_get_col_lb(mip, j);
            u[j] = glp_get_col_ub(mip, j);
        }
        nrs = m + 1;
        num = new Int32Array(1 + nrs);
        for (i = 1; i <= nrs; i++)
            num[i] = i - 1;
        if (basic_preprocessing(mip, L, U, l, u, nrs, num, max_pass)) {
            ret = 1;
            return ret;
        }
        for (i = 1; i <= m; i++) {
            if (glp_get_row_stat(mip, i) == GLP_BS) {
                if (L[i] == -DBL_MAX && U[i] == +DBL_MAX)
                    glp_set_row_bnds(mip, i, GLP_FR, 0, 0);
                else if (U[i] == +DBL_MAX)
                    glp_set_row_bnds(mip, i, GLP_LO, L[i], 0);
                else if (L[i] == -DBL_MAX)
                    glp_set_row_bnds(mip, i, GLP_UP, 0, U[i]);
            }
        }
        for (j = 1; j <= n; j++) {
            var type;
            if (l[j] == -DBL_MAX && u[j] == +DBL_MAX)
                type = GLP_FR;
            else if (u[j] == +DBL_MAX)
                type = GLP_LO;
            else if (l[j] == -DBL_MAX)
                type = GLP_UP;
            else if (l[j] != u[j])
                type = GLP_DB;
            else
                type = GLP_FX;
            glp_set_col_bnds(mip, j, type, l[j], u[j]);
        }
        return ret;
    }
    function ios_driver(T) {
        function show_progress(T, bingo) {
            var p;
            var temp;
            var best_mip, best_bound, rho, rel_gap;
            if (T.mip.mip_stat == GLP_FEAS)
                best_mip = String(T.mip.mip_obj);
            else
                best_mip = 'not found yet';
            p = ios_best_node(T);
            if (p == 0)
                best_bound = 'tree is empty';
            else {
                temp = T.slot[p].node.bound;
                if (temp == -DBL_MAX)
                    best_bound = '-inf';
                else if (temp == +DBL_MAX)
                    best_bound = '+inf';
                else
                    best_bound = temp;
            }
            if (T.mip.dir == GLP_MIN)
                rho = '>=';
            else if (T.mip.dir == GLP_MAX)
                rho = '<=';
            else
                xassert(T != T);
            temp = ios_relative_gap(T);
            if (temp == 0)
                rel_gap = '  0.0%';
            else if (temp < 0.001)
                rel_gap = ' < 0.1%';
            else if (temp <= 9.999) {
                rel_gap = '  ' + Number(100 * temp).toFixed(1) + '%';
            } else
                rel_gap = '';
            xprintf('+' + T.mip.it_cnt + ': ' + (bingo ? '>>>>>' : 'mip =') + ' ' + best_mip + ' ' + rho + ' ' + best_bound + ' ' + rel_gap + ' (' + T.a_cnt + '; ' + (T.t_cnt - T.n_cnt) + ')');
            T.tm_lag = xtime();
        }
        function is_branch_hopeful(T, p) {
            xassert(1 <= p && p <= T.nslots);
            xassert(T.slot[p].node != null);
            return ios_is_hopeful(T, T.slot[p].node.bound);
        }
        function check_integrality(T) {
            var mip = T.mip;
            var j, type, ii_cnt = 0;
            var lb, ub, x, temp1, temp2, ii_sum = 0;
            for (j = 1; j <= mip.n; j++) {
                var col = mip.col[j];
                T.non_int[j] = 0;
                if (col.kind != GLP_IV)
                    continue;
                if (col.stat != GLP_BS)
                    continue;
                type = col.type;
                lb = col.lb;
                ub = col.ub;
                x = col.prim;
                if (type == GLP_LO || type == GLP_DB || type == GLP_FX) {
                    temp1 = lb - T.parm.tol_int;
                    temp2 = lb + T.parm.tol_int;
                    if (temp1 <= x && x <= temp2)
                        continue;
                    if (x < lb)
                        continue;
                }
                if (type == GLP_UP || type == GLP_DB || type == GLP_FX) {
                    temp1 = ub - T.parm.tol_int;
                    temp2 = ub + T.parm.tol_int;
                    if (temp1 <= x && x <= temp2)
                        continue;
                    if (x > ub)
                        continue;
                }
                temp1 = Math.floor(x + 0.5) - T.parm.tol_int;
                temp2 = Math.floor(x + 0.5) + T.parm.tol_int;
                if (temp1 <= x && x <= temp2)
                    continue;
                T.non_int[j] = 1;
                ii_cnt++;
                temp1 = x - Math.floor(x);
                temp2 = Math.ceil(x) - x;
                xassert(temp1 > 0 && temp2 > 0);
                ii_sum += temp1 <= temp2 ? temp1 : temp2;
            }
            xassert(T.curr != null);
            T.curr.ii_cnt = ii_cnt;
            T.curr.ii_sum = ii_sum;
            if (T.parm.msg_lev >= GLP_MSG_DBG) {
                if (ii_cnt == 0)
                    xprintf('There are no fractional columns');
                else if (ii_cnt == 1)
                    xprintf('There is one fractional column, integer infeasibility is ' + ii_sum + '');
                else
                    xprintf('There are ' + ii_cnt + ' fractional columns, integer infeasibility is ' + ii_sum + '');
            }
        }
        function record_solution(T) {
            var mip = T.mip;
            var i, j;
            mip.mip_stat = GLP_FEAS;
            mip.mip_obj = mip.obj_val;
            for (i = 1; i <= mip.m; i++) {
                var row = mip.row[i];
                row.mipx = row.prim;
            }
            for (j = 1; j <= mip.n; j++) {
                var col = mip.col[j];
                if (col.kind == GLP_CV)
                    col.mipx = col.prim;
                else if (col.kind == GLP_IV) {
                    col.mipx = Math.floor(col.prim + 0.5);
                } else
                    xassert(col != col);
            }
            T.sol_cnt++;
        }
        function branch_on(T, j, next) {
            var mip = T.mip;
            var node;
            var m = mip.m;
            var n = mip.n;
            var type, dn_type, up_type, dn_bad, up_bad, p, ret, clone = new Array(1 + 2);
            var lb, ub, beta, new_ub, new_lb, dn_lp = null, up_lp = null, dn_bnd, up_bnd;
            xassert(1 <= j && j <= n);
            type = mip.col[j].type;
            lb = mip.col[j].lb;
            ub = mip.col[j].ub;
            beta = mip.col[j].prim;
            new_ub = Math.floor(beta);
            new_lb = Math.ceil(beta);
            switch (type) {
            case GLP_FR:
                dn_type = GLP_UP;
                up_type = GLP_LO;
                break;
            case GLP_LO:
                xassert(lb <= new_ub);
                dn_type = lb == new_ub ? GLP_FX : GLP_DB;
                xassert(lb + 1 <= new_lb);
                up_type = GLP_LO;
                break;
            case GLP_UP:
                xassert(new_ub <= ub - 1);
                dn_type = GLP_UP;
                xassert(new_lb <= ub);
                up_type = new_lb == ub ? GLP_FX : GLP_DB;
                break;
            case GLP_DB:
                xassert(lb <= new_ub && new_ub <= ub - 1);
                dn_type = lb == new_ub ? GLP_FX : GLP_DB;
                xassert(lb + 1 <= new_lb && new_lb <= ub);
                up_type = new_lb == ub ? GLP_FX : GLP_DB;
                break;
            default:
                xassert(type != type);
            }
            ios_eval_degrad(T, j, function (a, b) {
                dn_lp = a;
                up_lp = b;
            });
            dn_bnd = ios_round_bound(T, dn_lp);
            up_bnd = ios_round_bound(T, up_lp);
            dn_bad = !ios_is_hopeful(T, dn_bnd);
            up_bad = !ios_is_hopeful(T, up_bnd);
            if (dn_bad && up_bad) {
                if (T.parm.msg_lev >= GLP_MSG_DBG)
                    xprintf('Both down- and up-branches are hopeless');
                ret = 2;
                return ret;
            } else if (up_bad) {
                if (T.parm.msg_lev >= GLP_MSG_DBG)
                    xprintf('Up-branch is hopeless');
                glp_set_col_bnds(mip, j, dn_type, lb, new_ub);
                T.curr.lp_obj = dn_lp;
                if (mip.dir == GLP_MIN) {
                    if (T.curr.bound < dn_bnd)
                        T.curr.bound = dn_bnd;
                } else if (mip.dir == GLP_MAX) {
                    if (T.curr.bound > dn_bnd)
                        T.curr.bound = dn_bnd;
                } else
                    xassert(mip != mip);
                ret = 1;
                return ret;
            } else if (dn_bad) {
                if (T.parm.msg_lev >= GLP_MSG_DBG)
                    xprintf('Down-branch is hopeless');
                glp_set_col_bnds(mip, j, up_type, new_lb, ub);
                T.curr.lp_obj = up_lp;
                if (mip.dir == GLP_MIN) {
                    if (T.curr.bound < up_bnd)
                        T.curr.bound = up_bnd;
                } else if (mip.dir == GLP_MAX) {
                    if (T.curr.bound > up_bnd)
                        T.curr.bound = up_bnd;
                } else
                    xassert(mip != mip);
                ret = 1;
                return ret;
            }
            if (T.parm.msg_lev >= GLP_MSG_DBG)
                xprintf('Branching on column ' + j + ', primal value is ' + beta + '');
            xassert(T.curr != null);
            p = T.curr.p;
            T.curr.br_var = j;
            T.curr.br_val = beta;
            ios_freeze_node(T);
            ios_clone_node(T, p, 2, clone);
            if (T.parm.msg_lev >= GLP_MSG_DBG)
                xprintf('Node ' + clone[1] + ' begins down branch, node ' + clone[2] + ' begins up branch ');
            node = T.slot[clone[1]].node;
            xassert(node != null);
            xassert(node.up != null);
            xassert(node.b_ptr == null);
            node.b_ptr = {};
            node.b_ptr.k = m + j;
            node.b_ptr.type = dn_type;
            node.b_ptr.lb = lb;
            node.b_ptr.ub = new_ub;
            node.b_ptr.next = null;
            node.lp_obj = dn_lp;
            if (mip.dir == GLP_MIN) {
                if (node.bound < dn_bnd)
                    node.bound = dn_bnd;
            } else if (mip.dir == GLP_MAX) {
                if (node.bound > dn_bnd)
                    node.bound = dn_bnd;
            } else
                xassert(mip != mip);
            node = T.slot[clone[2]].node;
            xassert(node != null);
            xassert(node.up != null);
            xassert(node.b_ptr == null);
            node.b_ptr = {};
            node.b_ptr.k = m + j;
            node.b_ptr.type = up_type;
            node.b_ptr.lb = new_lb;
            node.b_ptr.ub = ub;
            node.b_ptr.next = null;
            node.lp_obj = up_lp;
            if (mip.dir == GLP_MIN) {
                if (node.bound < up_bnd)
                    node.bound = up_bnd;
            } else if (mip.dir == GLP_MAX) {
                if (node.bound > up_bnd)
                    node.bound = up_bnd;
            } else
                xassert(mip != mip);
            xassert(T.child == 0);
            if (next == GLP_NO_BRNCH)
                T.child = 0;
            else if (next == GLP_DN_BRNCH)
                T.child = clone[1];
            else if (next == GLP_UP_BRNCH)
                T.child = clone[2];
            else
                xassert(next != next);
            ret = 0;
            return ret;
        }
        function fix_by_red_cost(T) {
            var mip = T.mip;
            var j, stat, fixed = 0;
            var obj, lb, ub, dj;
            xassert(T.mip.mip_stat == GLP_FEAS);
            xassert(mip.pbs_stat == GLP_FEAS && mip.dbs_stat == GLP_FEAS);
            obj = mip.obj_val;
            for (j = 1; j <= mip.n; j++) {
                var col = mip.col[j];
                if (col.kind != GLP_IV)
                    continue;
                lb = col.lb;
                ub = col.ub;
                stat = col.stat;
                dj = col.dual;
                switch (mip.dir) {
                case GLP_MIN:
                    if (stat == GLP_NL) {
                        if (dj < 0)
                            dj = 0;
                        if (obj + dj >= mip.mip_obj) {
                            glp_set_col_bnds(mip, j, GLP_FX, lb, lb);
                            fixed++;
                        }
                    } else if (stat == GLP_NU) {
                        if (dj > 0)
                            dj = 0;
                        if (obj - dj >= mip.mip_obj) {
                            glp_set_col_bnds(mip, j, GLP_FX, ub, ub);
                            fixed++;
                        }
                    }
                    break;
                case GLP_MAX:
                    if (stat == GLP_NL) {
                        if (dj > 0)
                            dj = 0;
                        if (obj + dj <= mip.mip_obj) {
                            glp_set_col_bnds(mip, j, GLP_FX, lb, lb);
                            fixed++;
                        }
                    } else if (stat == GLP_NU) {
                        if (dj < 0)
                            dj = 0;
                        if (obj - dj <= mip.mip_obj) {
                            glp_set_col_bnds(mip, j, GLP_FX, ub, ub);
                            fixed++;
                        }
                    }
                    break;
                default:
                    xassert(T != T);
                }
            }
            if (T.parm.msg_lev >= GLP_MSG_DBG) {
                if (fixed == 0) {
                } else if (fixed == 1)
                    xprintf('One column has been fixed by reduced cost');
                else
                    xprintf(fixed + ' columns have been fixed by reduced costs');
            }
            xassert(mip.pbs_stat == GLP_FEAS && mip.dbs_stat == GLP_FEAS);
        }
        function remove_cuts(T) {
            var i, cnt = 0, num = null;
            xassert(T.curr != null);
            for (i = T.orig_m + 1; i <= T.mip.m; i++) {
                if (T.mip.row[i].origin == GLP_RF_CUT && T.mip.row[i].level == T.curr.level && T.mip.row[i].stat == GLP_BS) {
                    if (num == null)
                        num = new Int32Array(1 + T.mip.m);
                    num[++cnt] = i;
                }
            }
            if (cnt > 0) {
                glp_del_rows(T.mip, cnt, num);
                xassert(glp_factorize(T.mip) == 0);
            }
        }
        function display_cut_info(T) {
            var mip = T.mip;
            var i, gmi = 0, mir = 0, cov = 0, clq = 0, app = 0;
            for (i = mip.m; i > 0; i--) {
                var row = mip.row[i];
                if (row.origin == GLP_RF_CUT) {
                    if (row.klass == GLP_RF_GMI)
                        gmi++;
                    else if (row.klass == GLP_RF_MIR)
                        mir++;
                    else if (row.klass == GLP_RF_COV)
                        cov++;
                    else if (row.klass == GLP_RF_CLQ)
                        clq++;
                    else
                        app++;
                }
            }
            xassert(T.curr != null);
            if (gmi + mir + cov + clq + app > 0) {
                xprintf('Cuts on level ' + T.curr.level + ':');
                if (gmi > 0)
                    xprintf(' gmi = ' + gmi + ';');
                if (mir > 0)
                    xprintf(' mir = ' + mir + ';');
                if (cov > 0)
                    xprintf(' cov = ' + cov + ';');
                if (clq > 0)
                    xprintf(' clq = ' + clq + ';');
                if (app > 0)
                    xprintf(' app = ' + app + ';');
                xprintf('');
            }
        }
        function generate_cuts(T) {
            if (!(T.parm.mir_cuts == GLP_ON || T.parm.gmi_cuts == GLP_ON || T.parm.cov_cuts == GLP_ON || T.parm.clq_cuts == GLP_ON))
                return;
            {
                var i, max_cuts, added_cuts;
                max_cuts = T.n;
                if (max_cuts < 1000)
                    max_cuts = 1000;
                added_cuts = 0;
                for (i = T.orig_m + 1; i <= T.mip.m; i++) {
                    if (T.mip.row[i].origin == GLP_RF_CUT)
                        added_cuts++;
                }
                if (added_cuts >= max_cuts)
                    return;
            }
            if (T.parm.gmi_cuts == GLP_ON) {
                if (T.curr.changed < 5)
                    ios_gmi_gen(T);
            }
            if (T.parm.mir_cuts == GLP_ON) {
                xassert(T.mir_gen != null);
                ios_mir_gen(T, T.mir_gen);
            }
            if (T.parm.cov_cuts == GLP_ON) {
                ios_cov_gen(T);
            }
            if (T.parm.clq_cuts == GLP_ON) {
                if (T.clq_gen != null) {
                    if (T.curr.level == 0 && T.curr.changed < 50 || T.curr.level > 0 && T.curr.changed < 5)
                        ios_clq_gen(T, T.clq_gen);
                }
            }
        }
        function cleanup_the_tree(T) {
            var node, next_node;
            var count = 0;
            xassert(T.mip.mip_stat == GLP_FEAS);
            for (node = T.head; node != null; node = next_node) {
                next_node = node.next;
                if (!is_branch_hopeful(T, node.p)) {
                    ios_delete_node(T, node.p);
                    count++;
                }
            }
            if (T.parm.msg_lev >= GLP_MSG_DBG) {
                if (count == 1)
                    xprintf('One hopeless branch has been pruned');
                else if (count > 1)
                    xprintf(count + ' hopeless branches have been pruned');
            }
        }
        var p, curr_p, p_stat, d_stat, ret;
        var pred_p = 0;
        var ttt = T.tm_beg;
        var loop = 0, more = 1, fath = 2, done = 3;
        var label = loop;
        while (true) {
            var go_to = null;
            switch (label) {
            case loop:
                xassert(T.curr == null);
                if (T.head == null) {
                    if (T.parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('Active list is empty!');
                    ret = 0;
                    go_to = done;
                    break;
                }
                xassert(T.next_p == 0);
                if (T.parm.cb_func != null) {
                    xassert(T.reason == 0);
                    T.reason = GLP_ISELECT;
                    T.parm.cb_func(T, T.parm.cb_info);
                    T.reason = 0;
                    if (T.stop) {
                        ret = GLP_ESTOP;
                        go_to = done;
                        break;
                    }
                }
                if (T.next_p != 0) {
                } else if (T.a_cnt == 1) {
                    xassert(T.head.next == null);
                    T.next_p = T.head.p;
                } else if (T.child != 0) {
                    T.next_p = T.child;
                } else {
                    T.next_p = ios_choose_node(T);
                }
                ios_revive_node(T, T.next_p);
                T.next_p = T.child = 0;
                if (T.curr.up != null && T.curr.up.p != pred_p)
                    pred_p = 0;
                p = T.curr.p;
                if (T.parm.msg_lev >= GLP_MSG_DBG) {
                    xprintf('-----------------------------------------------------' + '-------------------');
                    xprintf('Processing node ' + p + ' at level ' + T.curr.level + '');
                }
                if (p == 1) {
                    if (T.parm.gmi_cuts == GLP_ON) {
                        if (T.parm.msg_lev >= GLP_MSG_ALL)
                            xprintf('Gomory\'s cuts enabled');
                    }
                    if (T.parm.mir_cuts == GLP_ON) {
                        if (T.parm.msg_lev >= GLP_MSG_ALL)
                            xprintf('MIR cuts enabled');
                        xassert(T.mir_gen == null);
                        T.mir_gen = ios_mir_init(T);
                    }
                    if (T.parm.cov_cuts == GLP_ON) {
                        if (T.parm.msg_lev >= GLP_MSG_ALL)
                            xprintf('Cover cuts enabled');
                    }
                    if (T.parm.clq_cuts == GLP_ON) {
                        xassert(T.clq_gen == null);
                        if (T.parm.msg_lev >= GLP_MSG_ALL)
                            xprintf('Clique cuts enabled');
                        T.clq_gen = ios_clq_init(T);
                    }
                }
            case more:
                if (T.parm.msg_lev >= GLP_MSG_DBG || T.parm.msg_lev >= GLP_MSG_ON && T.parm.out_frq - 1 <= 1000 * xdifftime(xtime(), T.tm_lag))
                    show_progress(T, 0);
                if (T.parm.msg_lev >= GLP_MSG_ALL && xdifftime(xtime(), ttt) >= 60) {
                    xprintf('Time used: ' + xdifftime(xtime(), T.tm_beg) + ' secs');
                    ttt = xtime();
                }
                if (T.parm.mip_gap > 0 && ios_relative_gap(T) <= T.parm.mip_gap) {
                    if (T.parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('Relative gap tolerance reached; search terminated ');
                    ret = GLP_EMIPGAP;
                    go_to = done;
                    break;
                }
                if (T.parm.tm_lim < INT_MAX && T.parm.tm_lim - 1 <= 1000 * xdifftime(xtime(), T.tm_beg)) {
                    if (T.parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('Time limit exhausted; search terminated');
                    ret = GLP_ETMLIM;
                    go_to = done;
                    break;
                }
                if (T.parm.cb_func != null) {
                    xassert(T.reason == 0);
                    T.reason = GLP_IPREPRO;
                    T.parm.cb_func(T, T.parm.cb_info);
                    T.reason = 0;
                    if (T.stop) {
                        ret = GLP_ESTOP;
                        go_to = done;
                        break;
                    }
                }
                if (T.parm.pp_tech == GLP_PP_NONE) {
                } else if (T.parm.pp_tech == GLP_PP_ROOT) {
                    if (T.curr.level == 0) {
                        if (ios_preprocess_node(T, 100)) {
                            go_to = fath;
                            break;
                        }
                    }
                } else if (T.parm.pp_tech == GLP_PP_ALL) {
                    if (ios_preprocess_node(T, T.curr.level == 0 ? 100 : 10)) {
                        go_to = fath;
                        break;
                    }
                } else
                    xassert(T != T);
                if (!is_branch_hopeful(T, p)) {
                    xprintf('*** not tested yet ***');
                    go_to = fath;
                    break;
                }
                if (T.parm.msg_lev >= GLP_MSG_DBG)
                    xprintf('Solving LP relaxation...');
                ret = ios_solve_node(T);
                if (!(ret == 0 || ret == GLP_EOBJLL || ret == GLP_EOBJUL)) {
                    if (T.parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('ios_driver: unable to solve current LP relaxation; glp_simplex returned ' + ret + '');
                    ret = GLP_EFAIL;
                    go_to = done;
                    break;
                }
                p_stat = T.mip.pbs_stat;
                d_stat = T.mip.dbs_stat;
                if (p_stat == GLP_FEAS && d_stat == GLP_FEAS) {
                    if (T.parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('Found optimal solution to LP relaxation');
                } else if (d_stat == GLP_NOFEAS) {
                    if (T.parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('ios_driver: current LP relaxation has no dual feasible solution');
                    ret = GLP_EFAIL;
                    go_to = done;
                    break;
                } else if (p_stat == GLP_INFEAS && d_stat == GLP_FEAS) {
                    xassert(T.mip.mip_stat == GLP_FEAS);
                    if (T.parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('LP relaxation has no solution better than incumbent objective value');
                    go_to = fath;
                    break;
                } else if (p_stat == GLP_NOFEAS) {
                    if (T.parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('LP relaxation has no feasible solution');
                    go_to = fath;
                    break;
                } else {
                    xassert(T.mip != T.mip);
                }
                xassert(p_stat == GLP_FEAS && d_stat == GLP_FEAS);
                xassert(T.curr != null);
                T.curr.lp_obj = T.mip.obj_val;
                {
                    var bound = T.mip.obj_val;
                    bound = ios_round_bound(T, bound);
                    if (T.mip.dir == GLP_MIN) {
                        if (T.curr.bound < bound)
                            T.curr.bound = bound;
                    } else if (T.mip.dir == GLP_MAX) {
                        if (T.curr.bound > bound)
                            T.curr.bound = bound;
                    } else
                        xassert(T.mip != T.mip);
                    if (T.parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('Local bound is ' + bound + '');
                }
                if (!is_branch_hopeful(T, p)) {
                    if (T.parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('Current branch is hopeless and can be pruned');
                    go_to = fath;
                    break;
                }
                xassert(T.reopt == 0);
                xassert(T.reinv == 0);
                if (T.parm.cb_func != null) {
                    xassert(T.reason == 0);
                    T.reason = GLP_IROWGEN;
                    T.parm.cb_func(T, T.parm.cb_info);
                    T.reason = 0;
                    if (T.stop) {
                        ret = GLP_ESTOP;
                        go_to = done;
                        break;
                    }
                    if (T.reopt) {
                        T.reopt = T.reinv = 0;
                        go_to = more;
                        break;
                    }
                    if (T.reinv) {
                        T.reinv = 0;
                        xassert(glp_factorize(T.mip) == 0);
                    }
                }
                check_integrality(T);
                if (T.curr.ii_cnt == 0) {
                    if (T.parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('New integer feasible solution found');
                    if (T.parm.msg_lev >= GLP_MSG_ALL)
                        display_cut_info(T);
                    record_solution(T);
                    if (T.parm.msg_lev >= GLP_MSG_ON)
                        show_progress(T, 1);
                    if (T.parm.cb_func != null) {
                        xassert(T.reason == 0);
                        T.reason = GLP_IBINGO;
                        T.parm.cb_func(T, T.parm.cb_info);
                        T.reason = 0;
                        if (T.stop) {
                            ret = GLP_ESTOP;
                            go_to = done;
                            break;
                        }
                    }
                    go_to = fath;
                    break;
                }
                if (T.mip.mip_stat == GLP_FEAS)
                    fix_by_red_cost(T);
                if (T.parm.cb_func != null) {
                    xassert(T.reason == 0);
                    T.reason = GLP_IHEUR;
                    T.parm.cb_func(T, T.parm.cb_info);
                    T.reason = 0;
                    if (T.stop) {
                        ret = GLP_ESTOP;
                        go_to = done;
                        break;
                    }
                    if (!is_branch_hopeful(T, p)) {
                        if (T.parm.msg_lev >= GLP_MSG_DBG)
                            xprintf('Current branch became hopeless and can be pruned');
                        go_to = fath;
                        break;
                    }
                }
                if (T.parm.fp_heur) {
                    xassert(T.reason == 0);
                    T.reason = GLP_IHEUR;
                    ios_feas_pump(T);
                    T.reason = 0;
                    if (!is_branch_hopeful(T, p)) {
                        if (T.parm.msg_lev >= GLP_MSG_DBG)
                            xprintf('Current branch became hopeless and can be pruned');
                        go_to = fath;
                        break;
                    }
                }
                xassert(T.local != null);
                xassert(T.local.size == 0);
                if (T.parm.cb_func != null) {
                    xassert(T.reason == 0);
                    T.reason = GLP_ICUTGEN;
                    T.parm.cb_func(T, T.parm.cb_info);
                    T.reason = 0;
                    if (T.stop) {
                        ret = GLP_ESTOP;
                        go_to = done;
                        break;
                    }
                }
                if (T.curr.level == 0 || pred_p == 0) {
                    xassert(T.reason == 0);
                    T.reason = GLP_ICUTGEN;
                    generate_cuts(T);
                    T.reason = 0;
                }
                if (T.local.size > 0) {
                    xassert(T.reason == 0);
                    T.reason = GLP_ICUTGEN;
                    ios_process_cuts(T);
                    T.reason = 0;
                }
                ios_clear_pool(T.local);
                if (T.reopt) {
                    T.reopt = 0;
                    T.curr.changed++;
                    go_to = more;
                    break;
                }
                remove_cuts(T);
                if (T.parm.msg_lev >= GLP_MSG_ALL && T.curr.level == 0)
                    display_cut_info(T);
                if (T.pcost != null)
                    ios_pcost_update(T);
                xassert(T.br_var == 0);
                xassert(T.br_sel == 0);
                if (T.parm.cb_func != null) {
                    xassert(T.reason == 0);
                    xassert(T.br_var == 0);
                    xassert(T.br_sel == 0);
                    T.reason = GLP_IBRANCH;
                    T.parm.cb_func(T, T.parm.cb_info);
                    T.reason = 0;
                    if (T.stop) {
                        ret = GLP_ESTOP;
                        go_to = done;
                        break;
                    }
                }
                if (T.br_var == 0)
                    T.br_var = ios_choose_var(T, function (next) {
                        T.br_sel = next;
                    });
                curr_p = T.curr.p;
                ret = branch_on(T, T.br_var, T.br_sel);
                T.br_var = T.br_sel = 0;
                if (ret == 0) {
                    pred_p = curr_p;
                    go_to = loop;
                    break;
                } else if (ret == 1) {
                    T.curr.solved = T.curr.changed = 0;
                    go_to = more;
                    break;
                } else if (ret == 2) {
                    go_to = fath;
                    break;
                } else
                    xassert(ret != ret);
            case fath:
                if (T.parm.msg_lev >= GLP_MSG_DBG)
                    xprintf('Node ' + p + ' fathomed');
                ios_freeze_node(T);
                ios_delete_node(T, p);
                if (T.mip.mip_stat == GLP_FEAS)
                    cleanup_the_tree(T);
                pred_p = 0;
                go_to = loop;
                break;
            case done:
                if (T.parm.msg_lev >= GLP_MSG_ON)
                    show_progress(T, 0);
                T.mir_gen = null;
                T.clq_gen = null;
                return ret;
            }
            if (go_to == null)
                break;
            label = go_to;
        }
    }
    function ios_create_vec(n) {
        var v;
        xassert(n >= 0);
        v = {};
        v.n = n;
        v.nnz = 0;
        v.pos = new Int32Array(1 + n);
        v.ind = new Int32Array(1 + n);
        v.val = new Float64Array(1 + n);
        return v;
    }
    function ios_check_vec(v) {
        var j, k, nnz;
        xassert(v.n >= 0);
        nnz = 0;
        for (j = v.n; j >= 1; j--) {
            k = v.pos[j];
            xassert(0 <= k && k <= v.nnz);
            if (k != 0) {
                xassert(v.ind[k] == j);
                nnz++;
            }
        }
        xassert(v.nnz == nnz);
    }
    function ios_get_vj(v, j) {
        var k;
        xassert(1 <= j && j <= v.n);
        k = v.pos[j];
        xassert(0 <= k && k <= v.nnz);
        return k == 0 ? 0 : v.val[k];
    }
    function ios_set_vj(v, j, val) {
        xassert(1 <= j && j <= v.n);
        var k = v.pos[j];
        if (val == 0) {
            if (k != 0) {
                v.pos[j] = 0;
                if (k < v.nnz) {
                    v.pos[v.ind[v.nnz]] = k;
                    v.ind[k] = v.ind[v.nnz];
                    v.val[k] = v.val[v.nnz];
                }
                v.nnz--;
            }
        } else {
            if (k == 0) {
                k = ++v.nnz;
                v.pos[j] = k;
                v.ind[k] = j;
            }
            v.val[k] = val;
        }
    }
    function ios_clear_vec(v) {
        for (var k = 1; k <= v.nnz; k++)
            v.pos[v.ind[k]] = 0;
        v.nnz = 0;
    }
    function ios_clean_vec(v, eps) {
        var nnz = 0;
        for (var k = 1; k <= v.nnz; k++) {
            if (Math.abs(v.val[k]) == 0 || Math.abs(v.val[k]) < eps) {
                v.pos[v.ind[k]] = 0;
            } else {
                nnz++;
                v.pos[v.ind[k]] = nnz;
                v.ind[nnz] = v.ind[k];
                v.val[nnz] = v.val[k];
            }
        }
        v.nnz = nnz;
    }
    function ios_copy_vec(x, y) {
        xassert(x != y);
        xassert(x.n == y.n);
        ios_clear_vec(x);
        x.nnz = y.nnz;
        xcopyArr(x.ind, 1, y.ind, 1, x.nnz);
        xcopyArr(x.val, 1, y.val, 1, x.nnz);
        for (var j = 1; j <= x.nnz; j++)
            x.pos[x.ind[j]] = j;
    }
    function ios_linear_comb(x, a, y) {
        var j, xj, yj;
        xassert(x != y);
        xassert(x.n == y.n);
        for (var k = 1; k <= y.nnz; k++) {
            j = y.ind[k];
            xj = ios_get_vj(x, j);
            yj = y.val[k];
            ios_set_vj(x, j, xj + a * yj);
        }
    }
    function ios_gmi_gen(tree) {
        var MAXCUTS = 50;
        function f(x) {
            return x - Math.floor(x);
        }
        function gen_cut(tree, worka, j) {
            var mip = tree.mip;
            var m = mip.m;
            var n = mip.n;
            var ind = worka.ind;
            var val = worka.val;
            var phi = worka.phi;
            var i, k, len, kind, stat;
            var lb, ub, alfa, beta, ksi, phi1, rhs;
            var row, col;
            len = glp_eval_tab_row(mip, m + j, ind, val);
            beta = mip.col[j].prim;
            for (k = 1; k <= m + n; k++)
                phi[k] = 0;
            rhs = f(beta);
            for (j = 1; j <= len; j++) {
                k = ind[j];
                xassert(1 <= k && k <= m + n);
                if (k <= m) {
                    row = mip.row[k];
                    kind = GLP_CV;
                    lb = row.lb;
                    ub = row.ub;
                    stat = row.stat;
                } else {
                    col = mip.col[k - m];
                    kind = col.kind;
                    lb = col.lb;
                    ub = col.ub;
                    stat = col.stat;
                }
                xassert(stat != GLP_BS);
                ksi = val[j];
                if (Math.abs(ksi) > 100000)
                    return;
                if (Math.abs(ksi) < 1e-10)
                    continue;
                switch (stat) {
                case GLP_NF:
                    return;
                case GLP_NL:
                    alfa = -ksi;
                    break;
                case GLP_NU:
                    alfa = +ksi;
                    break;
                case GLP_NS:
                    continue;
                default:
                    xassert(stat != stat);
                }
                switch (kind) {
                case GLP_IV:
                    if (Math.abs(alfa - Math.floor(alfa + 0.5)) < 1e-10) {
                        continue;
                    } else if (f(alfa) <= f(beta))
                        phi1 = f(alfa);
                    else
                        phi1 = f(beta) / (1 - f(beta)) * (1 - f(alfa));
                    break;
                case GLP_CV:
                    if (alfa >= 0)
                        phi1 = +alfa;
                    else
                        phi1 = f(beta) / (1 - f(beta)) * -alfa;
                    break;
                default:
                    xassert(kind != kind);
                }
                switch (stat) {
                case GLP_NL:
                    phi[k] = +phi1;
                    rhs += phi1 * lb;
                    break;
                case GLP_NU:
                    phi[k] = -phi1;
                    rhs -= phi1 * ub;
                    break;
                default:
                    xassert(stat != stat);
                }
            }
            for (i = 1; i <= m; i++) {
                var aij;
                if (Math.abs(phi[i]) < 1e-10)
                    continue;
                row = mip.row[i];
                xassert(row.type != GLP_FX);
                for (aij = row.ptr; aij != null; aij = aij.r_next)
                    phi[m + aij.col.j] += phi[i] * aij.val;
            }
            len = 0;
            for (j = 1; j <= n; j++) {
                if (Math.abs(phi[m + j]) < 1e-10)
                    continue;
                col = mip.col[j];
                if (col.type == GLP_FX) {
                    rhs -= phi[m + j] * col.lb;
                } else {
                    len++;
                    ind[len] = j;
                    val[len] = phi[m + j];
                }
            }
            if (Math.abs(rhs) < 1e-12)
                rhs = 0;
            for (k = 1; k <= len; k++) {
                if (Math.abs(val[k]) < 0.001)
                    return;
                if (Math.abs(val[k]) > 1000)
                    return;
            }
            glp_ios_add_row(tree, null, GLP_RF_GMI, 0, len, ind, val, GLP_LO, rhs);
        }
        var mip = tree.mip;
        var m = mip.m;
        var n = mip.n;
        var var_;
        var k, nv, j, size;
        var worka = {};
        var_ = new Array(1 + n);
        worka.ind = new Int32Array(1 + n);
        worka.val = new Float64Array(1 + n);
        worka.phi = new Float64Array(1 + m + n);
        nv = 0;
        for (j = 1; j <= n; j++) {
            var col = mip.col[j];
            var frac;
            if (col.kind != GLP_IV)
                continue;
            if (col.type == GLP_FX)
                continue;
            if (col.stat != GLP_BS)
                continue;
            frac = f(col.prim);
            if (!(0.05 <= frac && frac <= 0.95))
                continue;
            nv++;
            var_[nv].j = j;
            var_[nv].f = frac;
        }
        xqsort(var_, 1, nv, function (v1, v2) {
            if (v1.f > v2.f)
                return -1;
            if (v1.f < v2.f)
                return +1;
            return 0;
        });
        size = glp_ios_pool_size(tree);
        for (k = 1; k <= nv; k++) {
            if (glp_ios_pool_size(tree) - size >= MAXCUTS)
                break;
            gen_cut(tree, worka, var_[k].j);
        }
    }
    var _MIR_DEBUG = 0;
    var MAXAGGR = 5;
    var MIR_N = 0, MIR_L = 1, MIR_U = 2;
    function ios_mir_init(tree) {
        function set_row_attrib(tree, mir) {
            var mip = tree.mip;
            var m = mir.m;
            var k;
            for (k = 1; k <= m; k++) {
                var row = mip.row[k];
                mir.skip[k] = 0;
                mir.isint[k] = 0;
                switch (row.type) {
                case GLP_FR:
                    mir.lb[k] = -DBL_MAX;
                    mir.ub[k] = +DBL_MAX;
                    break;
                case GLP_LO:
                    mir.lb[k] = row.lb;
                    mir.ub[k] = +DBL_MAX;
                    break;
                case GLP_UP:
                    mir.lb[k] = -DBL_MAX;
                    mir.ub[k] = row.ub;
                    break;
                case GLP_DB:
                    mir.lb[k] = row.lb;
                    mir.ub[k] = row.ub;
                    break;
                case GLP_FX:
                    mir.lb[k] = mir.ub[k] = row.lb;
                    break;
                default:
                    xassert(row != row);
                }
                mir.vlb[k] = mir.vub[k] = 0;
            }
        }
        function set_col_attrib(tree, mir) {
            var mip = tree.mip;
            var m = mir.m;
            var n = mir.n;
            var k;
            for (k = m + 1; k <= m + n; k++) {
                var col = mip.col[k - m];
                switch (col.kind) {
                case GLP_CV:
                    mir.isint[k] = 0;
                    break;
                case GLP_IV:
                    mir.isint[k] = 1;
                    break;
                default:
                    xassert(col != col);
                }
                switch (col.type) {
                case GLP_FR:
                    mir.lb[k] = -DBL_MAX;
                    mir.ub[k] = +DBL_MAX;
                    break;
                case GLP_LO:
                    mir.lb[k] = col.lb;
                    mir.ub[k] = +DBL_MAX;
                    break;
                case GLP_UP:
                    mir.lb[k] = -DBL_MAX;
                    mir.ub[k] = col.ub;
                    break;
                case GLP_DB:
                    mir.lb[k] = col.lb;
                    mir.ub[k] = col.ub;
                    break;
                case GLP_FX:
                    mir.lb[k] = mir.ub[k] = col.lb;
                    break;
                default:
                    xassert(col != col);
                }
                mir.vlb[k] = mir.vub[k] = 0;
            }
        }
        function set_var_bounds(tree, mir) {
            var mip = tree.mip;
            var m = mir.m;
            var aij;
            var i, k1, k2;
            var a1, a2;
            for (i = 1; i <= m; i++) {
                if (!(mir.lb[i] == 0 && mir.ub[i] == +DBL_MAX || mir.lb[i] == -DBL_MAX && mir.ub[i] == 0))
                    continue;
                aij = mip.row[i].ptr;
                if (aij == null)
                    continue;
                k1 = m + aij.col.j;
                a1 = aij.val;
                aij = aij.r_next;
                if (aij == null)
                    continue;
                k2 = m + aij.col.j;
                a2 = aij.val;
                if (aij.r_next != null)
                    continue;
                if (!mir.isint[k1] && mir.isint[k2]) {
                } else if (mir.isint[k1] && !mir.isint[k2]) {
                    k2 = k1;
                    a2 = a1;
                    k1 = m + aij.col.j;
                    a1 = aij.val;
                } else {
                    continue;
                }
                if (mir.lb[k2] == -DBL_MAX || mir.ub[k2] == +DBL_MAX || mir.lb[k2] == mir.ub[k2])
                    continue;
                if (mir.ub[i] == 0) {
                    a1 = -a1;
                    a2 = -a2;
                }
                if (a1 > 0) {
                    if (mir.vlb[k1] == 0) {
                        mir.lb[k1] = -a2 / a1;
                        mir.vlb[k1] = k2;
                        mir.skip[i] = 1;
                    }
                } else {
                    if (mir.vub[k1] == 0) {
                        mir.ub[k1] = -a2 / a1;
                        mir.vub[k1] = k2;
                        mir.skip[i] = 1;
                    }
                }
            }
        }
        function mark_useless_rows(tree, mir) {
            var mip = tree.mip;
            var m = mir.m;
            var aij;
            var i, k, nv;
            for (i = 1; i <= m; i++) {
                if (mir.lb[i] == -DBL_MAX && mir.ub[i] == +DBL_MAX) {
                    mir.skip[i] = 1;
                    continue;
                }
                nv = 0;
                for (aij = mip.row[i].ptr; aij != null; aij = aij.r_next) {
                    k = m + aij.col.j;
                    if (mir.lb[k] == -DBL_MAX && mir.ub[k] == +DBL_MAX) {
                        mir.skip[i] = 1;
                        break;
                    }
                    if (mir.isint[k] && mir.lb[k] == -DBL_MAX || mir.isint[k] && mir.ub[k] == +DBL_MAX) {
                        mir.skip[i] = 1;
                        break;
                    }
                    if (!(mir.vlb[k] == 0 && mir.vub[k] == 0 && mir.lb[k] == mir.ub[k]))
                        nv++;
                }
                if (nv == 0) {
                    mir.skip[i] = 1;
                }
            }
        }
        var mip = tree.mip;
        var m = mip.m;
        var n = mip.n;
        var mir;
        if (_MIR_DEBUG) {
            xprintf('ios_mir_init: warning: debug mode enabled');
        }
        mir = {};
        mir.m = m;
        mir.n = n;
        mir.skip = new Int8Array(1 + m);
        mir.isint = new Int8Array(1 + m + n);
        mir.lb = new Float64Array(1 + m + n);
        mir.vlb = new Int32Array(1 + m + n);
        mir.ub = new Float64Array(1 + m + n);
        mir.vub = new Int32Array(1 + m + n);
        mir.x = new Float64Array(1 + m + n);
        mir.agg_row = new Int32Array(1 + MAXAGGR);
        mir.agg_vec = ios_create_vec(m + n);
        mir.subst = new Int8Array(1 + m + n);
        mir.mod_vec = ios_create_vec(m + n);
        mir.cut_vec = ios_create_vec(m + n);
        set_row_attrib(tree, mir);
        set_col_attrib(tree, mir);
        set_var_bounds(tree, mir);
        mark_useless_rows(tree, mir);
        return mir;
    }
    function ios_mir_gen(tree, mir) {
        var beta, gamma;
        function cmir_sep(n, a, b, u, x, s, alpha) {
            function cmir_cmp(v1, v2) {
                if (v1.v < v2.v)
                    return -1;
                if (v1.v > v2.v)
                    return +1;
                return 0;
            }
            function cmir_ineq(n, a, b, u, cset, delta, alpha) {
                function mir_ineq(n, a, b, alpha) {
                    var j;
                    var f, t;
                    if (Math.abs(b - Math.floor(b + 0.5)) < 0.01)
                        return 1;
                    f = b - Math.floor(b);
                    for (j = 1; j <= n; j++) {
                        t = a[j] - Math.floor(a[j]) - f;
                        if (t <= 0)
                            alpha[j] = Math.floor(a[j]);
                        else
                            alpha[j] = Math.floor(a[j]) + t / (1 - f);
                    }
                    beta = Math.floor(b);
                    gamma = 1 / (1 - f);
                    return 0;
                }
                var j;
                var aa, bb;
                aa = alpha;
                bb = b;
                for (j = 1; j <= n; j++) {
                    aa[j] = a[j] / delta;
                    if (cset[j])
                        aa[j] = -aa[j];
                    bb -= a[j] * u[j];
                }
                bb /= delta;
                if (mir_ineq(n, aa, bb, alpha))
                    return 1;
                for (j = 1; j <= n; j++) {
                    if (cset[j]) {
                        alpha[j] = -alpha[j];
                        beta += alpha[j] * u[j];
                    }
                }
                gamma /= delta;
                return 0;
            }
            var fail, j, k, nv, v;
            var delta, eps, d_try = new Array(1 + 3), r, r_best;
            var cset;
            var vset;
            cset = new Int8Array(1 + n);
            vset = new Array(1 + n);
            for (j = 1; j <= n; j++)
                cset[j] = x[j] >= 0.5 * u[j];
            r_best = delta = 0;
            for (j = 1; j <= n; j++) {
                xassert(a[j] != 0);
                eps = 1e-9 * (1 + Math.abs(u[j]));
                if (x[j] < eps || x[j] > u[j] - eps)
                    continue;
                fail = cmir_ineq(n, a, b, u, cset, Math.abs(a[j]), alpha);
                if (fail)
                    continue;
                r = -beta - gamma * s;
                for (k = 1; k <= n; k++)
                    r += alpha[k] * x[k];
                if (r_best < r) {
                    r_best = r;
                    delta = Math.abs(a[j]);
                }
            }
            if (r_best < 0.001)
                r_best = 0;
            if (r_best == 0)
                return r_best;
            xassert(delta > 0);
            d_try[1] = delta / 2;
            d_try[2] = delta / 4;
            d_try[3] = delta / 8;
            for (j = 1; j <= 3; j++) {
                fail = cmir_ineq(n, a, b, u, cset, d_try[j], alpha);
                if (fail)
                    continue;
                r = -beta - gamma * s;
                for (k = 1; k <= n; k++)
                    r += alpha[k] * x[k];
                if (r_best < r) {
                    r_best = r;
                    delta = d_try[j];
                }
            }
            nv = 0;
            for (j = 1; j <= n; j++) {
                eps = 1e-9 * (1 + Math.abs(u[j]));
                if (x[j] < eps || x[j] > u[j] - eps)
                    continue;
                nv++;
                vset[nv].j = j;
                vset[nv].v = Math.abs(x[j] - 0.5 * u[j]);
            }
            xqsort(vset, 1, nv, cmir_cmp);
            for (v = 1; v <= nv; v++) {
                j = vset[v].j;
                cset[j] = !cset[j];
                fail = cmir_ineq(n, a, b, u, cset, delta, alpha);
                cset[j] = !cset[j];
                if (fail)
                    continue;
                r = -beta - gamma * s;
                for (k = 1; k <= n; k++)
                    r += alpha[k] * x[k];
                if (r_best < r) {
                    r_best = r;
                    cset[j] = !cset[j];
                }
            }
            fail = cmir_ineq(n, a, b, u, cset, delta, alpha);
            xassert(!fail);
            return r_best;
        }
        function get_current_point(tree, mir) {
            var mip = tree.mip;
            var m = mir.m;
            var n = mir.n;
            var k;
            for (k = 1; k <= m; k++)
                mir.x[k] = mip.row[k].prim;
            for (k = m + 1; k <= m + n; k++)
                mir.x[k] = mip.col[k - m].prim;
        }
        function check_current_point(mir) {
            var m = mir.m;
            var n = mir.n;
            var k, kk;
            var lb, ub, eps;
            for (k = 1; k <= m + n; k++) {
                lb = mir.lb[k];
                kk = mir.vlb[k];
                if (kk != 0) {
                    xassert(lb != -DBL_MAX);
                    xassert(!mir.isint[k]);
                    xassert(mir.isint[kk]);
                    lb *= mir.x[kk];
                }
                if (lb != -DBL_MAX) {
                    eps = 0.000001 * (1 + Math.abs(lb));
                    xassert(mir.x[k] >= lb - eps);
                }
                ub = mir.ub[k];
                kk = mir.vub[k];
                if (kk != 0) {
                    xassert(ub != +DBL_MAX);
                    xassert(!mir.isint[k]);
                    xassert(mir.isint[kk]);
                    ub *= mir.x[kk];
                }
                if (ub != +DBL_MAX) {
                    eps = 0.000001 * (1 + Math.abs(ub));
                    xassert(mir.x[k] <= ub + eps);
                }
            }
        }
        function initial_agg_row(tree, mir, i) {
            var mip = tree.mip;
            var m = mir.m;
            var aij;
            xassert(1 <= i && i <= m);
            xassert(!mir.skip[i]);
            mir.skip[i] = 2;
            mir.agg_cnt = 1;
            mir.agg_row[1] = i;
            ios_clear_vec(mir.agg_vec);
            ios_set_vj(mir.agg_vec, i, 1);
            for (aij = mip.row[i].ptr; aij != null; aij = aij.r_next)
                ios_set_vj(mir.agg_vec, m + aij.col.j, -aij.val);
            mir.agg_rhs = 0;
            if (_MIR_DEBUG) {
                ios_check_vec(mir.agg_vec);
            }
        }
        function check_agg_row(mir) {
            var m = mir.m;
            var n = mir.n;
            var j, k;
            var r, big;
            r = 0;
            big = 1;
            for (j = 1; j <= mir.agg_vec.nnz; j++) {
                k = mir.agg_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                r += mir.agg_vec.val[j] * mir.x[k];
                if (big < Math.abs(mir.agg_vec.val[j]))
                    big = Math.abs(mir.agg_vec.val[j]);
            }
            r -= mir.agg_rhs;
            if (big < Math.abs(mir.agg_rhs))
                big = Math.abs(mir.agg_rhs);
            xassert(Math.abs(r) <= 0.000001 * big);
        }
        function subst_fixed_vars(mir) {
            var m = mir.m;
            var n = mir.n;
            var j, k;
            for (j = 1; j <= mir.agg_vec.nnz; j++) {
                k = mir.agg_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (mir.vlb[k] == 0 && mir.vub[k] == 0 && mir.lb[k] == mir.ub[k]) {
                    mir.agg_rhs -= mir.agg_vec.val[j] * mir.lb[k];
                    mir.agg_vec.val[j] = 0;
                }
            }
            ios_clean_vec(mir.agg_vec, DBL_EPSILON);
            if (_MIR_DEBUG) {
                ios_check_vec(mir.agg_vec);
            }
        }
        function bound_subst_heur(mir) {
            var m = mir.m;
            var n = mir.n;
            var j, k, kk;
            var d1, d2;
            for (j = 1; j <= mir.agg_vec.nnz; j++) {
                k = mir.agg_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (mir.isint[k])
                    continue;
                kk = mir.vlb[k];
                if (kk == 0) {
                    if (mir.lb[k] == -DBL_MAX)
                        d1 = DBL_MAX;
                    else
                        d1 = mir.x[k] - mir.lb[k];
                } else {
                    xassert(1 <= kk && kk <= m + n);
                    xassert(mir.isint[kk]);
                    xassert(mir.lb[k] != -DBL_MAX);
                    d1 = mir.x[k] - mir.lb[k] * mir.x[kk];
                }
                kk = mir.vub[k];
                if (kk == 0) {
                    if (mir.vub[k] == +DBL_MAX)
                        d2 = DBL_MAX;
                    else
                        d2 = mir.ub[k] - mir.x[k];
                } else {
                    xassert(1 <= kk && kk <= m + n);
                    xassert(mir.isint[kk]);
                    xassert(mir.ub[k] != +DBL_MAX);
                    d2 = mir.ub[k] * mir.x[kk] - mir.x[k];
                }
                xassert(d1 != DBL_MAX || d2 != DBL_MAX);
                xassert(mir.subst[k] == MIR_N);
                if (d1 <= d2)
                    mir.subst[k] = MIR_L;
                else
                    mir.subst[k] = MIR_U;
            }
        }
        function build_mod_row(mir) {
            var m = mir.m;
            var n = mir.n;
            var j, jj, k, kk;
            ios_copy_vec(mir.mod_vec, mir.agg_vec);
            mir.mod_rhs = mir.agg_rhs;
            if (_MIR_DEBUG) {
                ios_check_vec(mir.mod_vec);
            }
            for (j = mir.mod_vec.nnz; j >= 1; j--) {
                k = mir.mod_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (mir.isint[k])
                    continue;
                if (mir.subst[k] == MIR_L) {
                    xassert(mir.lb[k] != -DBL_MAX);
                    kk = mir.vlb[k];
                    if (kk == 0) {
                        mir.mod_rhs -= mir.mod_vec.val[j] * mir.lb[k];
                    } else {
                        xassert(mir.isint[kk]);
                        jj = mir.mod_vec.pos[kk];
                        if (jj == 0) {
                            ios_set_vj(mir.mod_vec, kk, 1);
                            jj = mir.mod_vec.pos[kk];
                            mir.mod_vec.val[jj] = 0;
                        }
                        mir.mod_vec.val[jj] += mir.mod_vec.val[j] * mir.lb[k];
                    }
                } else if (mir.subst[k] == MIR_U) {
                    xassert(mir.ub[k] != +DBL_MAX);
                    kk = mir.vub[k];
                    if (kk == 0) {
                        mir.mod_rhs -= mir.mod_vec.val[j] * mir.ub[k];
                    } else {
                        xassert(mir.isint[kk]);
                        jj = mir.mod_vec.pos[kk];
                        if (jj == 0) {
                            ios_set_vj(mir.mod_vec, kk, 1);
                            jj = mir.mod_vec.pos[kk];
                            mir.mod_vec.val[jj] = 0;
                        }
                        mir.mod_vec.val[jj] += mir.mod_vec.val[j] * mir.ub[k];
                    }
                    mir.mod_vec.val[j] = -mir.mod_vec.val[j];
                } else
                    xassert(k != k);
            }
            if (_MIR_DEBUG) {
                ios_check_vec(mir.mod_vec);
            }
            for (j = 1; j <= mir.mod_vec.nnz; j++) {
                k = mir.mod_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (!mir.isint[k])
                    continue;
                xassert(mir.subst[k] == MIR_N);
                xassert(mir.vlb[k] == 0 && mir.vub[k] == 0);
                xassert(mir.lb[k] != -DBL_MAX && mir.ub[k] != +DBL_MAX);
                if (Math.abs(mir.lb[k]) <= Math.abs(mir.ub[k])) {
                    mir.subst[k] = MIR_L;
                    mir.mod_rhs -= mir.mod_vec.val[j] * mir.lb[k];
                } else {
                    mir.subst[k] = MIR_U;
                    mir.mod_rhs -= mir.mod_vec.val[j] * mir.ub[k];
                    mir.mod_vec.val[j] = -mir.mod_vec.val[j];
                }
            }
            if (_MIR_DEBUG) {
                ios_check_vec(mir.mod_vec);
            }
        }
        function check_mod_row(mir) {
            var m = mir.m;
            var n = mir.n;
            var j, k, kk;
            var r, big, x;
            r = 0;
            big = 1;
            for (j = 1; j <= mir.mod_vec.nnz; j++) {
                k = mir.mod_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (mir.subst[k] == MIR_L) {
                    xassert(mir.lb[k] != -DBL_MAX);
                    kk = mir.vlb[k];
                    if (kk == 0)
                        x = mir.x[k] - mir.lb[k];
                    else
                        x = mir.x[k] - mir.lb[k] * mir.x[kk];
                } else if (mir.subst[k] == MIR_U) {
                    xassert(mir.ub[k] != +DBL_MAX);
                    kk = mir.vub[k];
                    if (kk == 0)
                        x = mir.ub[k] - mir.x[k];
                    else
                        x = mir.ub[k] * mir.x[kk] - mir.x[k];
                } else
                    xassert(k != k);
                r += mir.mod_vec.val[j] * x;
                if (big < Math.abs(mir.mod_vec.val[j]))
                    big = Math.abs(mir.mod_vec.val[j]);
            }
            r -= mir.mod_rhs;
            if (big < Math.abs(mir.mod_rhs))
                big = Math.abs(mir.mod_rhs);
            xassert(Math.abs(r) <= 0.000001 * big);
        }
        function generate(mir) {
            var m = mir.m;
            var n = mir.n;
            var j, k, kk, nint;
            var s, u, x, alpha, r_best = 0, b, beta = null, gamma = null;
            ios_copy_vec(mir.cut_vec, mir.mod_vec);
            mir.cut_rhs = mir.mod_rhs;
            ios_clean_vec(mir.cut_vec, DBL_EPSILON);
            if (_MIR_DEBUG) {
                ios_check_vec(mir.cut_vec);
            }
            for (j = 1; j <= mir.cut_vec.nnz; j++) {
                k = mir.cut_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (!mir.isint[k] && mir.cut_vec.val[j] > 0)
                    mir.cut_vec.val[j] = 0;
            }
            ios_clean_vec(mir.cut_vec, 0);
            if (_MIR_DEBUG) {
                ios_check_vec(mir.cut_vec);
            }
            nint = 0;
            for (j = 1; j <= mir.cut_vec.nnz; j++) {
                k = mir.cut_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (mir.isint[k]) {
                    var temp;
                    nint++;
                    kk = mir.cut_vec.ind[nint];
                    mir.cut_vec.pos[k] = nint;
                    mir.cut_vec.pos[kk] = j;
                    mir.cut_vec.ind[nint] = k;
                    mir.cut_vec.ind[j] = kk;
                    temp = mir.cut_vec.val[nint];
                    mir.cut_vec.val[nint] = mir.cut_vec.val[j];
                    mir.cut_vec.val[j] = temp;
                }
            }
            if (_MIR_DEBUG) {
                ios_check_vec(mir.cut_vec);
            }
            if (nint == 0)
                return r_best;
            u = new Float64Array(1 + nint);
            x = new Float64Array(1 + nint);
            alpha = new Float64Array(1 + nint);
            for (j = 1; j <= nint; j++) {
                k = mir.cut_vec.ind[j];
                xassert(m + 1 <= k && k <= m + n);
                xassert(mir.isint[k]);
                u[j] = mir.ub[k] - mir.lb[k];
                xassert(u[j] >= 1);
                if (mir.subst[k] == MIR_L)
                    x[j] = mir.x[k] - mir.lb[k];
                else if (mir.subst[k] == MIR_U)
                    x[j] = mir.ub[k] - mir.x[k];
                else
                    xassert(k != k);
                xassert(x[j] >= -0.001);
                if (x[j] < 0)
                    x[j] = 0;
            }
            s = 0;
            for (j = nint + 1; j <= mir.cut_vec.nnz; j++) {
                k = mir.cut_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                xassert(!mir.isint[k]);
                if (mir.subst[k] == MIR_L) {
                    xassert(mir.lb[k] != -DBL_MAX);
                    kk = mir.vlb[k];
                    if (kk == 0)
                        x = mir.x[k] - mir.lb[k];
                    else
                        x = mir.x[k] - mir.lb[k] * mir.x[kk];
                } else if (mir.subst[k] == MIR_U) {
                    xassert(mir.ub[k] != +DBL_MAX);
                    kk = mir.vub[k];
                    if (kk == 0)
                        x = mir.ub[k] - mir.x[k];
                    else
                        x = mir.ub[k] * mir.x[kk] - mir.x[k];
                } else
                    xassert(k != k);
                xassert(x >= -0.001);
                if (x < 0)
                    x = 0;
                s -= mir.cut_vec.val[j] * x;
            }
            xassert(s >= 0);
            b = mir.cut_rhs;
            r_best = cmir_sep(nint, mir.cut_vec.val, b, u, x, s, alpha);
            if (r_best == 0)
                return r_best;
            xassert(r_best > 0);
            for (j = 1; j <= nint; j++)
                mir.cut_vec.val[j] = alpha[j];
            for (j = nint + 1; j <= mir.cut_vec.nnz; j++) {
                k = mir.cut_vec.ind[j];
                if (k <= m + n)
                    mir.cut_vec.val[j] *= gamma;
            }
            mir.cut_rhs = beta;
            if (_MIR_DEBUG) {
                ios_check_vec(mir.cut_vec);
            }
            return r_best;
        }
        function check_raw_cut(mir, r_best) {
            var m = mir.m;
            var n = mir.n;
            var j, k, kk;
            var r, big, x;
            r = 0;
            big = 1;
            for (j = 1; j <= mir.cut_vec.nnz; j++) {
                k = mir.cut_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (mir.subst[k] == MIR_L) {
                    xassert(mir.lb[k] != -DBL_MAX);
                    kk = mir.vlb[k];
                    if (kk == 0)
                        x = mir.x[k] - mir.lb[k];
                    else
                        x = mir.x[k] - mir.lb[k] * mir.x[kk];
                } else if (mir.subst[k] == MIR_U) {
                    xassert(mir.ub[k] != +DBL_MAX);
                    kk = mir.vub[k];
                    if (kk == 0)
                        x = mir.ub[k] - mir.x[k];
                    else
                        x = mir.ub[k] * mir.x[kk] - mir.x[k];
                } else
                    xassert(k != k);
                r += mir.cut_vec.val[j] * x;
                if (big < Math.abs(mir.cut_vec.val[j]))
                    big = Math.abs(mir.cut_vec.val[j]);
            }
            r -= mir.cut_rhs;
            if (big < Math.abs(mir.cut_rhs))
                big = Math.abs(mir.cut_rhs);
            xassert(Math.abs(r - r_best) <= 0.000001 * big);
        }
        function back_subst(mir) {
            var m = mir.m;
            var n = mir.n;
            var j, jj, k, kk;
            for (j = 1; j <= mir.cut_vec.nnz; j++) {
                k = mir.cut_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (!mir.isint[k])
                    continue;
                if (mir.subst[k] == MIR_L) {
                    xassert(mir.lb[k] != -DBL_MAX);
                    xassert(mir.vlb[k] == 0);
                    mir.cut_rhs += mir.cut_vec.val[j] * mir.lb[k];
                } else if (mir.subst[k] == MIR_U) {
                    xassert(mir.ub[k] != +DBL_MAX);
                    xassert(mir.vub[k] == 0);
                    mir.cut_rhs -= mir.cut_vec.val[j] * mir.ub[k];
                    mir.cut_vec.val[j] = -mir.cut_vec.val[j];
                } else
                    xassert(k != k);
            }
            for (j = 1; j <= mir.cut_vec.nnz; j++) {
                k = mir.cut_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (mir.isint[k])
                    continue;
                if (mir.subst[k] == MIR_L) {
                    xassert(mir.lb[k] != -DBL_MAX);
                    kk = mir.vlb[k];
                    if (kk == 0) {
                        mir.cut_rhs += mir.cut_vec.val[j] * mir.lb[k];
                    } else {
                        jj = mir.cut_vec.pos[kk];
                        if (jj == 0) {
                            ios_set_vj(mir.cut_vec, kk, 1);
                            jj = mir.cut_vec.pos[kk];
                            xassert(jj != 0);
                            mir.cut_vec.val[jj] = 0;
                        }
                        mir.cut_vec.val[jj] -= mir.cut_vec.val[j] * mir.lb[k];
                    }
                } else if (mir.subst[k] == MIR_U) {
                    xassert(mir.ub[k] != +DBL_MAX);
                    kk = mir.vub[k];
                    if (kk == 0) {
                        mir.cut_rhs -= mir.cut_vec.val[j] * mir.ub[k];
                    } else {
                        jj = mir.cut_vec.pos[kk];
                        if (jj == 0) {
                            ios_set_vj(mir.cut_vec, kk, 1);
                            jj = mir.cut_vec.pos[kk];
                            xassert(jj != 0);
                            mir.cut_vec.val[jj] = 0;
                        }
                        mir.cut_vec.val[jj] += mir.cut_vec.val[j] * mir.ub[k];
                    }
                    mir.cut_vec.val[j] = -mir.cut_vec.val[j];
                } else
                    xassert(k != k);
            }
            if (_MIR_DEBUG) {
                ios_check_vec(mir.cut_vec);
            }
        }
        function check_cut_row(mir, r_best) {
            var m = mir.m;
            var n = mir.n;
            var j, k;
            var r, big;
            r = 0;
            big = 1;
            for (j = 1; j <= mir.cut_vec.nnz; j++) {
                k = mir.cut_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                r += mir.cut_vec.val[j] * mir.x[k];
                if (big < Math.abs(mir.cut_vec.val[j]))
                    big = Math.abs(mir.cut_vec.val[j]);
            }
            r -= mir.cut_rhs;
            if (big < Math.abs(mir.cut_rhs))
                big = Math.abs(mir.cut_rhs);
            xassert(Math.abs(r - r_best) <= 0.000001 * big);
        }
        function subst_aux_vars(tree, mir) {
            var mip = tree.mip;
            var m = mir.m;
            var n = mir.n;
            var aij;
            var j, k, kk, jj;
            for (j = mir.cut_vec.nnz; j >= 1; j--) {
                k = mir.cut_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (k > m)
                    continue;
                for (aij = mip.row[k].ptr; aij != null; aij = aij.r_next) {
                    kk = m + aij.col.j;
                    jj = mir.cut_vec.pos[kk];
                    if (jj == 0) {
                        ios_set_vj(mir.cut_vec, kk, 1);
                        jj = mir.cut_vec.pos[kk];
                        mir.cut_vec.val[jj] = 0;
                    }
                    mir.cut_vec.val[jj] += mir.cut_vec.val[j] * aij.val;
                }
                mir.cut_vec.val[j] = 0;
            }
            ios_clean_vec(mir.cut_vec, 0);
        }
        function add_cut(tree, mir) {
            var m = mir.m;
            var n = mir.n;
            var j, k, len;
            var ind = new Int32Array(1 + n);
            var val = new Float64Array(1 + n);
            len = 0;
            for (j = mir.cut_vec.nnz; j >= 1; j--) {
                k = mir.cut_vec.ind[j];
                xassert(m + 1 <= k && k <= m + n);
                len++;
                ind[len] = k - m;
                val[len] = mir.cut_vec.val[j];
            }
            glp_ios_add_row(tree, null, GLP_RF_MIR, 0, len, ind, val, GLP_UP, mir.cut_rhs);
        }
        function aggregate_row(tree, mir) {
            var mip = tree.mip;
            var m = mir.m;
            var n = mir.n;
            var aij;
            var v;
            var ii, j, jj, k, kk, kappa = 0, ret = 0;
            var d1, d2, d, d_max = 0;
            for (j = 1; j <= mir.agg_vec.nnz; j++) {
                k = mir.agg_vec.ind[j];
                xassert(1 <= k && k <= m + n);
                if (k <= m)
                    continue;
                if (mir.isint[k])
                    continue;
                if (Math.abs(mir.agg_vec.val[j]) < 0.001)
                    continue;
                kk = mir.vlb[k];
                if (kk == 0) {
                    if (mir.lb[k] == -DBL_MAX)
                        d1 = DBL_MAX;
                    else
                        d1 = mir.x[k] - mir.lb[k];
                } else {
                    xassert(1 <= kk && kk <= m + n);
                    xassert(mir.isint[kk]);
                    xassert(mir.lb[k] != -DBL_MAX);
                    d1 = mir.x[k] - mir.lb[k] * mir.x[kk];
                }
                kk = mir.vub[k];
                if (kk == 0) {
                    if (mir.vub[k] == +DBL_MAX)
                        d2 = DBL_MAX;
                    else
                        d2 = mir.ub[k] - mir.x[k];
                } else {
                    xassert(1 <= kk && kk <= m + n);
                    xassert(mir.isint[kk]);
                    xassert(mir.ub[k] != +DBL_MAX);
                    d2 = mir.ub[k] * mir.x[kk] - mir.x[k];
                }
                xassert(d1 != DBL_MAX || d2 != DBL_MAX);
                d = d1 <= d2 ? d1 : d2;
                xassert(d != DBL_MAX);
                if (d < 0.001)
                    continue;
                if (d_max < d) {
                    d_max = d;
                    kappa = k;
                }
            }
            if (kappa == 0) {
                ret = 1;
                return ret;
            }
            xassert(m + 1 <= kappa && kappa <= m + n);
            xassert(!mir.isint[kappa]);
            for (ii = 1; ii <= m; ii++) {
                if (mir.skip[ii])
                    continue;
                for (aij = mip.row[ii].ptr; aij != null; aij = aij.r_next)
                    if (aij.col.j == kappa - m)
                        break;
                if (aij != null && Math.abs(aij.val) >= 0.001)
                    break;
            }
            if (ii > m) {
                ret = 2;
                return ret;
            }
            mir.agg_cnt++;
            xassert(mir.agg_cnt <= MAXAGGR);
            mir.agg_row[mir.agg_cnt] = ii;
            mir.skip[ii] = 2;
            v = ios_create_vec(m + n);
            ios_set_vj(v, ii, 1);
            for (aij = mip.row[ii].ptr; aij != null; aij = aij.r_next)
                ios_set_vj(v, m + aij.col.j, -aij.val);
            if (_MIR_DEBUG) {
                ios_check_vec(v);
            }
            j = mir.agg_vec.pos[kappa];
            xassert(j != 0);
            jj = v.pos[kappa];
            xassert(jj != 0);
            ios_linear_comb(mir.agg_vec, -mir.agg_vec.val[j] / v.val[jj], v);
            ios_set_vj(mir.agg_vec, kappa, 0);
            if (_MIR_DEBUG) {
                ios_check_vec(mir.agg_vec);
            }
            return ret;
        }
        var mip = tree.mip;
        var m = mir.m;
        var n = mir.n;
        var i, k;
        var r_best;
        xassert(mip.m >= m);
        xassert(mip.n == n);
        get_current_point(tree, mir);
        if (_MIR_DEBUG) {
            check_current_point(mir);
        }
        xfillArr(mir.subst, 1, MIR_N, m + n);
        for (i = 1; i <= m; i++) {
            if (mir.skip[i])
                continue;
            initial_agg_row(tree, mir, i);
            while (true) {
                if (_MIR_DEBUG) {
                    check_agg_row(mir);
                }
                subst_fixed_vars(mir);
                if (_MIR_DEBUG) {
                    check_agg_row(mir);
                    {
                        for (k = 1; k <= m + n; k++)
                            xassert(mir.subst[k] == MIR_N);
                    }
                }
                bound_subst_heur(mir);
                build_mod_row(mir);
                if (_MIR_DEBUG) {
                    check_mod_row(mir);
                }
                r_best = generate(mir);
                if (r_best > 0) {
                    if (_MIR_DEBUG) {
                        check_raw_cut(mir, r_best);
                    }
                    back_subst(mir);
                    if (_MIR_DEBUG) {
                        check_cut_row(mir, r_best);
                    }
                    subst_aux_vars(tree, mir);
                    if (_MIR_DEBUG) {
                        check_cut_row(mir, r_best);
                    }
                    add_cut(tree, mir);
                }
                {
                    for (var j = 1; j <= mir.mod_vec.nnz; j++) {
                        k = mir.mod_vec.ind[j];
                        xassert(1 <= k && k <= m + n);
                        xassert(mir.subst[k] != MIR_N);
                        mir.subst[k] = MIR_N;
                    }
                }
                if (r_best == 0) {
                    if (mir.agg_cnt < MAXAGGR) {
                        if (aggregate_row(tree, mir) == 0)
                            continue;
                    }
                }
                break;
            }
            {
                var ii;
                for (k = 1; k <= mir.agg_cnt; k++) {
                    ii = mir.agg_row[k];
                    xassert(1 <= ii && ii <= m);
                    xassert(mir.skip[ii] == 2);
                    mir.skip[ii] = 0;
                }
            }
        }
    }
    function lpx_cover_cut(lp, len, ind, val, x) {
        var alfa = null, beta = null;
        var MAXTRY = 1000;
        function cover2(n, a, b, u, x, y, cov) {
            var i, j, try_ = 0, ret = 0;
            var eps, temp, rmax = 0.001;
            eps = 0.001 * (1 + Math.abs(b));
            for (i = 1; i <= n; i++)
                for (j = i + 1; j <= n; j++) {
                    try_++;
                    if (try_ > MAXTRY)
                        return ret;
                    if (a[i] + a[j] + y > b + eps) {
                        temp = a[i] + a[j] - b;
                        alfa = 1 / (temp + u);
                        beta = 2 - alfa * temp;
                        temp = x[i] + x[j] + alfa * y - beta;
                        if (rmax < temp) {
                            rmax = temp;
                            cov[1] = i;
                            cov[2] = j;
                            ret = 1;
                        }
                    }
                }
            return ret;
        }
        function cover3(n, a, b, u, x, y, cov) {
            var i, j, k, try_ = 0, ret = 0;
            var eps, temp, rmax = 0.001;
            eps = 0.001 * (1 + Math.abs(b));
            for (i = 1; i <= n; i++)
                for (j = i + 1; j <= n; j++)
                    for (k = j + 1; k <= n; k++) {
                        try_++;
                        if (try_ > MAXTRY)
                            return ret;
                        if (a[i] + a[j] + a[k] + y > b + eps) {
                            temp = a[i] + a[j] + a[k] - b;
                            alfa = 1 / (temp + u);
                            beta = 3 - alfa * temp;
                            temp = x[i] + x[j] + x[k] + alfa * y - beta;
                            if (rmax < temp) {
                                rmax = temp;
                                cov[1] = i;
                                cov[2] = j;
                                cov[3] = k;
                                ret = 1;
                            }
                        }
                    }
            return ret;
        }
        function cover4(n, a, b, u, x, y, cov) {
            var i, j, k, l, try_ = 0, ret = 0;
            var eps, temp, rmax = 0.001;
            eps = 0.001 * (1 + Math.abs(b));
            for (i = 1; i <= n; i++)
                for (j = i + 1; j <= n; j++)
                    for (k = j + 1; k <= n; k++)
                        for (l = k + 1; l <= n; l++) {
                            try_++;
                            if (try_ > MAXTRY)
                                return ret;
                            if (a[i] + a[j] + a[k] + a[l] + y > b + eps) {
                                temp = a[i] + a[j] + a[k] + a[l] - b;
                                alfa = 1 / (temp + u);
                                beta = 4 - alfa * temp;
                                temp = x[i] + x[j] + x[k] + x[l] + alfa * y - beta;
                                if (rmax < temp) {
                                    rmax = temp;
                                    cov[1] = i;
                                    cov[2] = j;
                                    cov[3] = k;
                                    cov[4] = l;
                                    ret = 1;
                                }
                            }
                        }
            return ret;
        }
        function cover(n, a, b, u, x, y, cov) {
            var j;
            xassert(n >= 2);
            for (j = 1; j <= n; j++)
                xassert(a[j] > 0);
            xassert(b > -0.00001);
            xassert(u >= 0);
            for (j = 1; j <= n; j++)
                xassert(0 <= x[j] && x[j] <= 1);
            xassert(0 <= y && y <= u);
            if (cover2(n, a, b, u, x, y, cov))
                return 2;
            if (cover3(n, a, b, u, x, y, cov))
                return 3;
            if (cover4(n, a, b, u, x, y, cov))
                return 4;
            return 0;
        }
        var cov = new Array(1 + 4), j, k, nb, newlen, r;
        var f_min, f_max, u, y;
        newlen = 0;
        for (k = 1; k <= len; k++) {
            j = ind[k];
            if (lpx_get_col_type(lp, j) == LPX_FX)
                val[0] -= val[k] * lpx_get_col_lb(lp, j);
            else {
                newlen++;
                ind[newlen] = ind[k];
                val[newlen] = val[k];
            }
        }
        len = newlen;
        nb = 0;
        for (k = 1; k <= len; k++) {
            j = ind[k];
            if (lpx_get_col_kind(lp, j) == LPX_IV && lpx_get_col_type(lp, j) == LPX_DB && lpx_get_col_lb(lp, j) == 0 && lpx_get_col_ub(lp, j) == 1) {
                var ind_k;
                var val_k;
                nb++;
                ind_k = ind[nb];
                val_k = val[nb];
                ind[nb] = ind[k];
                val[nb] = val[k];
                ind[k] = ind_k;
                val[k] = val_k;
            }
        }
        if (nb < 2)
            return 0;
        f_min = f_max = 0;
        for (k = nb + 1; k <= len; k++) {
            j = ind[k];
            if (lpx_get_col_type(lp, j) != LPX_DB)
                return 0;
            if (val[k] > 0) {
                f_min += val[k] * lpx_get_col_lb(lp, j);
                f_max += val[k] * lpx_get_col_ub(lp, j);
            } else {
                f_min += val[k] * lpx_get_col_ub(lp, j);
                f_max += val[k] * lpx_get_col_lb(lp, j);
            }
        }
        u = f_max - f_min;
        y = 0;
        for (k = nb + 1; k <= len; k++) {
            j = ind[k];
            y += val[k] * lpx_get_col_prim(lp, j);
        }
        y -= f_min;
        if (y < 0)
            y = 0;
        if (y > u)
            y = u;
        val[0] -= f_min;
        for (k = 1; k <= nb; k++) {
            j = ind[k];
            x[k] = lpx_get_col_prim(lp, j);
            if (x[k] < 0)
                x[k] = 0;
            if (x[k] > 1)
                x[k] = 1;
        }
        for (k = 1; k <= nb; k++) {
            if (val[k] < 0) {
                ind[k] = -ind[k];
                val[k] = -val[k];
                val[0] += val[k];
                x[k] = 1 - x[k];
            }
        }
        r = cover(nb, val, val[0], u, x, y, cov);
        if (r == 0)
            return 0;
        xassert(2 <= r && r <= 4);
        ind[0] = 0;
        val[0] = beta;
        for (j = 1; j <= r; j++)
            cov[j] = ind[cov[j]];
        xassert(r <= nb);
        for (k = 1; k <= r; k++) {
            if (cov[k] > 0) {
                ind[k] = +cov[k];
                val[k] = +1;
            } else {
                ind[k] = -cov[k];
                val[k] = -1;
                val[0] -= 1;
            }
        }
        for (k = nb + 1; k <= len; k++) {
            r++;
            ind[r] = ind[k];
            val[r] = alfa * val[k];
        }
        val[0] += alfa * f_min;
        xassert(r <= len);
        len = r;
        return len;
    }
    function lpx_eval_row(lp, len, ind, val) {
        var n = lpx_get_num_cols(lp);
        var j, k;
        var sum = 0;
        if (len < 0)
            xerror('lpx_eval_row: len = ' + len + '; invalid row length');
        for (k = 1; k <= len; k++) {
            j = ind[k];
            if (!(1 <= j && j <= n))
                xerror('lpx_eval_row: j = ' + j + '; column number out of range');
            sum += val[k] * lpx_get_col_prim(lp, j);
        }
        return sum;
    }
    function ios_cov_gen(tree) {
        var prob = tree.mip;
        var m = lpx_get_num_rows(prob);
        var n = lpx_get_num_cols(prob);
        var i, k, type, kase, len, ind;
        var r, val, work;
        xassert(lpx_get_status(prob) == LPX_OPT);
        ind = new Int32Array(1 + n);
        val = new Float64Array(1 + n);
        work = new Float64Array(1 + n);
        for (i = 1; i <= m; i++)
            for (kase = 1; kase <= 2; kase++) {
                type = lpx_get_row_type(prob, i);
                if (kase == 1) {
                    if (!(type == LPX_UP || type == LPX_DB))
                        continue;
                    len = lpx_get_mat_row(prob, i, ind, val);
                    val[0] = lpx_get_row_ub(prob, i);
                } else {
                    if (!(type == LPX_LO || type == LPX_DB))
                        continue;
                    len = lpx_get_mat_row(prob, i, ind, val);
                    for (k = 1; k <= len; k++)
                        val[k] = -val[k];
                    val[0] = -lpx_get_row_lb(prob, i);
                }
                len = lpx_cover_cut(prob, len, ind, val, work);
                if (len == 0)
                    continue;
                r = lpx_eval_row(prob, len, ind, val) - val[0];
                if (r < 0.001)
                    continue;
                glp_ios_add_row(tree, null, GLP_RF_COV, 0, len, ind, val, GLP_UP, val[0]);
            }
    }
    function lpx_create_cog(lp) {
        var MAX_NB = 4000;
        var MAX_ROW_LEN = 500;
        function get_row_lb(lp, i) {
            var lb;
            switch (lpx_get_row_type(lp, i)) {
            case LPX_FR:
            case LPX_UP:
                lb = -DBL_MAX;
                break;
            case LPX_LO:
            case LPX_DB:
            case LPX_FX:
                lb = lpx_get_row_lb(lp, i);
                break;
            default:
                xassert(lp != lp);
            }
            return lb;
        }
        function get_row_ub(lp, i) {
            var ub;
            switch (lpx_get_row_type(lp, i)) {
            case LPX_FR:
            case LPX_LO:
                ub = +DBL_MAX;
                break;
            case LPX_UP:
            case LPX_DB:
            case LPX_FX:
                ub = lpx_get_row_ub(lp, i);
                break;
            default:
                xassert(lp != lp);
            }
            return ub;
        }
        function get_col_lb(lp, j) {
            var lb;
            switch (lpx_get_col_type(lp, j)) {
            case LPX_FR:
            case LPX_UP:
                lb = -DBL_MAX;
                break;
            case LPX_LO:
            case LPX_DB:
            case LPX_FX:
                lb = lpx_get_col_lb(lp, j);
                break;
            default:
                xassert(lp != lp);
            }
            return lb;
        }
        function get_col_ub(lp, j) {
            var ub;
            switch (lpx_get_col_type(lp, j)) {
            case LPX_FR:
            case LPX_LO:
                ub = +DBL_MAX;
                break;
            case LPX_UP:
            case LPX_DB:
            case LPX_FX:
                ub = lpx_get_col_ub(lp, j);
                break;
            default:
                xassert(lp != lp);
            }
            return ub;
        }
        function is_binary(lp, j) {
            return lpx_get_col_kind(lp, j) == LPX_IV && lpx_get_col_type(lp, j) == LPX_DB && lpx_get_col_lb(lp, j) == 0 && lpx_get_col_ub(lp, j) == 1;
        }
        function eval_lf_min(lp, len, ind, val) {
            var j, t;
            var lb, ub, sum;
            sum = 0;
            for (t = 1; t <= len; t++) {
                j = ind[t];
                if (val[t] > 0) {
                    lb = get_col_lb(lp, j);
                    if (lb == -DBL_MAX) {
                        sum = -DBL_MAX;
                        break;
                    }
                    sum += val[t] * lb;
                } else if (val[t] < 0) {
                    ub = get_col_ub(lp, j);
                    if (ub == +DBL_MAX) {
                        sum = -DBL_MAX;
                        break;
                    }
                    sum += val[t] * ub;
                } else
                    xassert(val != val);
            }
            return sum;
        }
        function eval_lf_max(lp, len, ind, val) {
            var j, t;
            var lb, ub, sum;
            sum = 0;
            for (t = 1; t <= len; t++) {
                j = ind[t];
                if (val[t] > 0) {
                    ub = get_col_ub(lp, j);
                    if (ub == +DBL_MAX) {
                        sum = +DBL_MAX;
                        break;
                    }
                    sum += val[t] * ub;
                } else if (val[t] < 0) {
                    lb = get_col_lb(lp, j);
                    if (lb == -DBL_MAX) {
                        sum = +DBL_MAX;
                        break;
                    }
                    sum += val[t] * lb;
                } else
                    xassert(val != val);
            }
            return sum;
        }
        function probing(len, val, L, U, lf_min, lf_max, p, set, q) {
            var temp;
            xassert(1 <= p && p < q && q <= len);
            if (L != -DBL_MAX && set)
                L -= val[p];
            if (U != +DBL_MAX && set)
                U -= val[p];
            if (lf_min != -DBL_MAX) {
                if (val[p] < 0)
                    lf_min -= val[p];
                if (val[q] < 0)
                    lf_min -= val[q];
            }
            if (lf_max != +DBL_MAX) {
                if (val[p] > 0)
                    lf_max -= val[p];
                if (val[q] > 0)
                    lf_max -= val[q];
            }
            if (val[q] > 0) {
                if (L == -DBL_MAX || lf_max == +DBL_MAX)
                    temp = -DBL_MAX;
                else
                    temp = (L - lf_max) / val[q];
            } else {
                if (U == +DBL_MAX || lf_min == -DBL_MAX)
                    temp = -DBL_MAX;
                else
                    temp = (U - lf_min) / val[q];
            }
            if (temp > 0.001)
                return 2;
            if (val[q] > 0) {
                if (U == +DBL_MAX || lf_min == -DBL_MAX)
                    temp = +DBL_MAX;
                else
                    temp = (U - lf_min) / val[q];
            } else {
                if (L == -DBL_MAX || lf_max == +DBL_MAX)
                    temp = +DBL_MAX;
                else
                    temp = (L - lf_max) / val[q];
            }
            if (temp < 0.999)
                return 1;
            return 0;
        }
        var cog = null;
        var m, n, nb, i, j, p, q, len, ind, vert, orig;
        var L, U, lf_min, lf_max, val;
        xprintf('Creating the conflict graph...');
        m = lpx_get_num_rows(lp);
        n = lpx_get_num_cols(lp);
        nb = 0;
        vert = new Int32Array(1 + n);
        orig = new Int32Array(1 + n);
        ind = new Int32Array(1 + n);
        val = new Float64Array(1 + n);
        for (i = 1; i <= m; i++) {
            L = get_row_lb(lp, i);
            U = get_row_ub(lp, i);
            if (L == -DBL_MAX && U == +DBL_MAX)
                continue;
            len = lpx_get_mat_row(lp, i, ind, val);
            if (len > MAX_ROW_LEN)
                continue;
            lf_min = eval_lf_min(lp, len, ind, val);
            lf_max = eval_lf_max(lp, len, ind, val);
            for (p = 1; p <= len; p++) {
                if (!is_binary(lp, ind[p]))
                    continue;
                for (q = p + 1; q <= len; q++) {
                    if (!is_binary(lp, ind[q]))
                        continue;
                    if (probing(len, val, L, U, lf_min, lf_max, p, 0, q) || probing(len, val, L, U, lf_min, lf_max, p, 1, q)) {
                        j = ind[p];
                        if (vert[j] == 0) {
                            nb++;
                            vert[j] = nb;
                            orig[nb] = j;
                        }
                        j = ind[q];
                        if (vert[j] == 0) {
                            nb++;
                            vert[j] = nb;
                            orig[nb] = j;
                        }
                    }
                }
            }
        }
        if (nb == 0 || nb > MAX_NB) {
            xprintf('The conflict graph is either empty or too big');
            return cog;
        }
        cog = {};
        cog.n = n;
        cog.nb = nb;
        cog.ne = 0;
        cog.vert = vert;
        cog.orig = orig;
        len = nb + nb;
        len = len * (len - 1) / 2;
        len = (len + (CHAR_BIT - 1)) / CHAR_BIT;
        cog.a = new Array(len);
        for (j = 1; j <= nb; j++) {
            lpx_add_cog_edge(cog, +orig[j], -orig[j]);
        }
        for (i = 1; i <= m; i++) {
            L = get_row_lb(lp, i);
            U = get_row_ub(lp, i);
            if (L == -DBL_MAX && U == +DBL_MAX)
                continue;
            len = lpx_get_mat_row(lp, i, ind, val);
            if (len > MAX_ROW_LEN)
                continue;
            lf_min = eval_lf_min(lp, len, ind, val);
            lf_max = eval_lf_max(lp, len, ind, val);
            for (p = 1; p <= len; p++) {
                if (!is_binary(lp, ind[p]))
                    continue;
                for (q = p + 1; q <= len; q++) {
                    if (!is_binary(lp, ind[q]))
                        continue;
                    switch (probing(len, val, L, U, lf_min, lf_max, p, 0, q)) {
                    case 0:
                        break;
                    case 1:
                        lpx_add_cog_edge(cog, -ind[p], +ind[q]);
                        break;
                    case 2:
                        lpx_add_cog_edge(cog, -ind[p], -ind[q]);
                        break;
                    default:
                        xassert(lp != lp);
                    }
                    switch (probing(len, val, L, U, lf_min, lf_max, p, 1, q)) {
                    case 0:
                        break;
                    case 1:
                        lpx_add_cog_edge(cog, +ind[p], +ind[q]);
                        break;
                    case 2:
                        lpx_add_cog_edge(cog, +ind[p], -ind[q]);
                        break;
                    default:
                        xassert(lp != lp);
                    }
                }
            }
        }
        xprintf('The conflict graph has 2*' + cog.nb + ' vertices and ' + cog.ne + ' edges');
        return cog;
    }
    function lpx_add_cog_edge(cog, i, j) {
        var k;
        xassert(i != j);
        if (i > 0) {
            xassert(1 <= i && i <= cog.n);
            i = cog.vert[i];
            xassert(i != 0);
        } else {
            i = -i;
            xassert(1 <= i && i <= cog.n);
            i = cog.vert[i];
            xassert(i != 0);
            i += cog.nb;
        }
        if (j > 0) {
            xassert(1 <= j && j <= cog.n);
            j = cog.vert[j];
            xassert(j != 0);
        } else {
            j = -j;
            xassert(1 <= j && j <= cog.n);
            j = cog.vert[j];
            xassert(j != 0);
            j += cog.nb;
        }
        if (i < j) {
            k = i;
            i = j;
            j = k;
        }
        k = (i - 1) * (i - 2) / 2 + (j - 1);
        cog.a[k / CHAR_BIT] |= 1 << CHAR_BIT - 1 - k % CHAR_BIT;
        cog.ne++;
    }
    function lpx_clique_cut(lp, cog, ind, val) {
        function is_edge(dsa, i, j) {
            return i == j ? 0 : i > j ? is_edge1(dsa, i, j) : is_edge1(dsa, j, i);
        }
        function is_edge1(dsa, i, j) {
            return is_edge2(dsa, i * (i - 1) / 2 + j);
        }
        function is_edge2(dsa, k) {
            return dsa.a[k / CHAR_BIT] & 1 << CHAR_BIT - 1 - k % CHAR_BIT;
        }
        function sub(dsa, ct, table, level, weight, l_weight) {
            var i, j, k, curr_weight, left_weight, p1, p2, newtable;
            newtable = new Int32Array(dsa.n);
            if (ct <= 0) {
                if (ct == 0) {
                    dsa.set[level++] = table[0];
                    weight += l_weight;
                }
                if (weight > dsa.record) {
                    dsa.record = weight;
                    dsa.rec_level = level;
                    for (i = 0; i < level; i++)
                        dsa.rec[i + 1] = dsa.set[i];
                }
                return;
            }
            for (i = ct; i >= 0; i--) {
                if (level == 0 && i < ct)
                    return;
                k = table[i];
                if (level > 0 && dsa.clique[k] <= dsa.record - weight)
                    return;
                dsa.set[level] = k;
                curr_weight = weight + dsa.wt[k + 1];
                l_weight -= dsa.wt[k + 1];
                if (l_weight <= dsa.record - curr_weight)
                    return;
                p1 = 0;
                p2 = 0;
                left_weight = 0;
                while (p2 < table + i) {
                    j = table[p2];
                    p2++;
                    if (is_edge(dsa, j, k)) {
                        newtable[p1] = j;
                        p1++;
                        left_weight += dsa.wt[j + 1];
                    }
                }
                if (left_weight <= dsa.record - curr_weight)
                    continue;
                sub(dsa, p1 - 1, newtable, level + 1, curr_weight, left_weight);
            }
        }
        function wclique(_n, w, _a, sol) {
            var dsa = {};
            var i, j, p, max_wt, max_nwt, wth, used, nwt, pos;
            var timer;
            dsa.n = _n;
            dsa.wt = w;
            dsa.a = _a;
            dsa.record = 0;
            dsa.rec_level = 0;
            dsa.rec = sol;
            dsa.clique = new Int32Array(dsa.n);
            dsa.set = new Int32Array(dsa.n);
            used = new Int32Array(dsa.n);
            nwt = new Int32Array(dsa.n);
            pos = new Int32Array(dsa.n);
            timer = xtime();
            for (i = 0; i < dsa.n; i++) {
                nwt[i] = 0;
                for (j = 0; j < dsa.n; j++)
                    if (is_edge(dsa, i, j))
                        nwt[i] += dsa.wt[j + 1];
            }
            for (i = 0; i < dsa.n; i++)
                used[i] = 0;
            for (i = dsa.n - 1; i >= 0; i--) {
                max_wt = -1;
                max_nwt = -1;
                for (j = 0; j < dsa.n; j++) {
                    if (!used[j] && (dsa.wt[j + 1] > max_wt || dsa.wt[j + 1] == max_wt && nwt[j] > max_nwt)) {
                        max_wt = dsa.wt[j + 1];
                        max_nwt = nwt[j];
                        p = j;
                    }
                }
                pos[i] = p;
                used[p] = 1;
                for (j = 0; j < dsa.n; j++)
                    if (!used[j] && j != p && is_edge(dsa, p, j))
                        nwt[j] -= dsa.wt[p + 1];
            }
            wth = 0;
            for (i = 0; i < dsa.n; i++) {
                wth += dsa.wt[pos[i] + 1];
                sub(dsa, i, pos, 0, 0, wth);
                dsa.clique[pos[i]] = dsa.record;
                if (xdifftime(xtime(), timer) >= 5 - 0.001) {
                    xprintf('level = ' + i + 1 + ' (' + dsa.n + '); best = ' + dsa.record + '');
                    timer = xtime();
                }
            }
            for (i = 1; i <= dsa.rec_level; i++)
                sol[i]++;
            return dsa.rec_level;
        }
        var n = lpx_get_num_cols(lp);
        var j, t, v, card, temp, len = 0, w, sol;
        var x, sum, b, vec;
        w = new Int32Array(1 + 2 * cog.nb);
        sol = new Int32Array(1 + 2 * cog.nb);
        vec = new Float64Array(1 + n);
        for (t = 1; t <= cog.nb; t++) {
            j = cog.orig[t];
            x = lpx_get_col_prim(lp, j);
            temp = 100 * x + 0.5 | 0;
            if (temp < 0)
                temp = 0;
            if (temp > 100)
                temp = 100;
            w[t] = temp;
            w[cog.nb + t] = 100 - temp;
        }
        card = wclique(2 * cog.nb, w, cog.a, sol);
        sum = 0;
        for (t = 1; t <= card; t++) {
            v = sol[t];
            xassert(1 <= v && v <= 2 * cog.nb);
            if (v <= cog.nb) {
                j = cog.orig[v];
                x = lpx_get_col_prim(lp, j);
                sum += x;
            } else {
                j = cog.orig[v - cog.nb];
                x = lpx_get_col_prim(lp, j);
                sum += 1 - x;
            }
        }
        if (sum >= 1.01) {
            b = 1;
            for (t = 1; t <= card; t++) {
                v = sol[t];
                if (v <= cog.nb) {
                    j = cog.orig[v];
                    xassert(1 <= j && j <= n);
                    vec[j] += 1;
                } else {
                    j = cog.orig[v - cog.nb];
                    xassert(1 <= j && j <= n);
                    vec[j] -= 1;
                    b -= 1;
                }
            }
            xassert(len == 0);
            for (j = 1; j <= n; j++) {
                if (vec[j] != 0) {
                    len++;
                    ind[len] = j;
                    val[len] = vec[j];
                }
            }
            ind[0] = 0;
            val[0] = b;
        }
        return len;
    }
    function ios_clq_init(tree) {
        var mip = tree.mip;
        xassert(mip != null);
        return lpx_create_cog(mip);
    }
    function ios_clq_gen(tree, gen) {
        var n = lpx_get_num_cols(tree.mip);
        var len, ind;
        var val;
        xassert(gen != null);
        ind = new Int32Array(1 + n);
        val = new Float64Array(1 + n);
        len = lpx_clique_cut(tree.mip, gen, ind, val);
        if (len > 0) {
            glp_ios_add_row(tree, null, GLP_RF_CLQ, 0, len, ind, val, GLP_UP, val[0]);
        }
    }
    function ios_choose_var(T, callback) {
        var j;
        if (T.parm.br_tech == GLP_BR_FFV) {
            j = branch_first(T, callback);
        } else if (T.parm.br_tech == GLP_BR_LFV) {
            j = branch_last(T, callback);
        } else if (T.parm.br_tech == GLP_BR_MFV) {
            j = branch_mostf(T, callback);
        } else if (T.parm.br_tech == GLP_BR_DTH) {
            j = branch_drtom(T, callback);
        } else if (T.parm.br_tech == GLP_BR_PCH) {
            j = ios_pcost_branch(T, callback);
        } else
            xassert(T != T);
        return j;
    }
    function branch_first(T, callback) {
        var j, next;
        var beta;
        for (j = 1; j <= T.n; j++)
            if (T.non_int[j])
                break;
        xassert(1 <= j && j <= T.n);
        beta = glp_get_col_prim(T.mip, j);
        if (beta - Math.floor(beta) < Math.ceil(beta) - beta)
            next = GLP_DN_BRNCH;
        else
            next = GLP_UP_BRNCH;
        callback(next);
        return j;
    }
    function branch_last(T, callback) {
        var j, next;
        var beta;
        for (j = T.n; j >= 1; j--)
            if (T.non_int[j])
                break;
        xassert(1 <= j && j <= T.n);
        beta = glp_get_col_prim(T.mip, j);
        if (beta - Math.floor(beta) < Math.ceil(beta) - beta)
            next = GLP_DN_BRNCH;
        else
            next = GLP_UP_BRNCH;
        callback(next);
        return j;
    }
    function branch_mostf(T, callback) {
        var j, jj, next;
        var beta, most, temp;
        jj = 0;
        most = DBL_MAX;
        for (j = 1; j <= T.n; j++) {
            if (T.non_int[j]) {
                beta = glp_get_col_prim(T.mip, j);
                temp = Math.floor(beta) + 0.5;
                if (most > Math.abs(beta - temp)) {
                    jj = j;
                    most = Math.abs(beta - temp);
                    if (beta < temp)
                        next = GLP_DN_BRNCH;
                    else
                        next = GLP_UP_BRNCH;
                }
            }
        }
        callback(next);
        return jj;
    }
    function branch_drtom(T, callback) {
        var mip = T.mip;
        var m = mip.m;
        var n = mip.n;
        var non_int = T.non_int;
        var j, jj, k, t, next, kase, len, stat, ind;
        var x, dk, alfa, delta_j, delta_k, delta_z, dz_dn, dz_up, dd_dn, dd_up, degrad, val;
        xassert(glp_get_status(mip) == GLP_OPT);
        ind = new Int32Array(1 + n);
        val = new Float64Array(1 + n);
        jj = 0;
        degrad = -1;
        for (j = 1; j <= n; j++) {
            if (!non_int[j])
                continue;
            x = glp_get_col_prim(mip, j);
            len = glp_eval_tab_row(mip, m + j, ind, val);
            for (kase = -1; kase <= +1; kase += 2) {
                k = glp_dual_rtest(mip, len, ind, val, kase, 1e-9);
                if (k != 0)
                    k = ind[k];
                if (k == 0) {
                    delta_z = T.mip.dir == GLP_MIN ? +DBL_MAX : -DBL_MAX;
                } else {
                    for (t = 1; t <= len; t++)
                        if (ind[t] == k)
                            break;
                    xassert(1 <= t && t <= len);
                    alfa = val[t];
                    delta_j = (kase < 0 ? Math.floor(x) : Math.ceil(x)) - x;
                    delta_k = delta_j / alfa;
                    if (k > m && glp_get_col_kind(mip, k - m) != GLP_CV) {
                        if (Math.abs(delta_k - Math.floor(delta_k + 0.5)) > 0.001) {
                            if (delta_k > 0)
                                delta_k = Math.ceil(delta_k);
                            else
                                delta_k = Math.floor(delta_k);
                        }
                    }
                    if (k <= m) {
                        stat = glp_get_row_stat(mip, k);
                        dk = glp_get_row_dual(mip, k);
                    } else {
                        stat = glp_get_col_stat(mip, k - m);
                        dk = glp_get_col_dual(mip, k - m);
                    }
                    switch (T.mip.dir) {
                    case GLP_MIN:
                        if (stat == GLP_NL && dk < 0 || stat == GLP_NU && dk > 0 || stat == GLP_NF)
                            dk = 0;
                        break;
                    case GLP_MAX:
                        if (stat == GLP_NL && dk > 0 || stat == GLP_NU && dk < 0 || stat == GLP_NF)
                            dk = 0;
                        break;
                    default:
                        xassert(T != T);
                    }
                    delta_z = dk * delta_k;
                }
                switch (T.mip.dir) {
                case GLP_MIN:
                    xassert(delta_z >= 0);
                    break;
                case GLP_MAX:
                    xassert(delta_z <= 0);
                    break;
                default:
                    xassert(T != T);
                }
                if (kase < 0)
                    dz_dn = delta_z;
                else
                    dz_up = delta_z;
            }
            if (degrad < Math.abs(dz_dn) || degrad < Math.abs(dz_up)) {
                jj = j;
                if (Math.abs(dz_dn) < Math.abs(dz_up)) {
                    next = GLP_DN_BRNCH;
                    degrad = Math.abs(dz_up);
                } else {
                    next = GLP_UP_BRNCH;
                    degrad = Math.abs(dz_dn);
                }
                dd_dn = dz_dn;
                dd_up = dz_up;
                if (degrad == DBL_MAX)
                    break;
            }
        }
        xassert(1 <= jj && jj <= n);
        if (degrad < 0.000001 * (1 + 0.001 * Math.abs(mip.obj_val))) {
            jj = branch_mostf(T, callback);
            return jj;
        }
        if (T.parm.msg_lev >= GLP_MSG_DBG) {
            xprintf('branch_drtom: column ' + jj + ' chosen to branch on');
            if (Math.abs(dd_dn) == DBL_MAX)
                xprintf('branch_drtom: down-branch is infeasible');
            else
                xprintf('branch_drtom: down-branch bound is ' + (lpx_get_obj_val(mip) + dd_dn) + '');
            if (Math.abs(dd_up) == DBL_MAX)
                xprintf('branch_drtom: up-branch   is infeasible');
            else
                xprintf('branch_drtom: up-branch   bound is ' + (lpx_get_obj_val(mip) + dd_up) + '');
        }
        callback(next);
        return jj;
    }
    function ios_pcost_init(tree) {
        var n = tree.n, j;
        var csa = {};
        csa.dn_cnt = new Int32Array(1 + n);
        csa.dn_sum = new Float64Array(1 + n);
        csa.up_cnt = new Int32Array(1 + n);
        csa.up_sum = new Float64Array(1 + n);
        for (j = 1; j <= n; j++) {
            csa.dn_cnt[j] = csa.up_cnt[j] = 0;
            csa.dn_sum[j] = csa.up_sum[j] = 0;
        }
        return csa;
    }
    function ios_pcost_update(tree) {
        var j;
        var dx, dz, psi;
        var csa = tree.pcost;
        xassert(csa != null);
        xassert(tree.curr != null);
        if (tree.curr.up == null)
            return;
        j = tree.curr.up.br_var;
        xassert(1 <= j && j <= tree.n);
        dx = tree.mip.col[j].prim - tree.curr.up.br_val;
        xassert(dx != 0);
        dz = tree.mip.obj_val - tree.curr.up.lp_obj;
        psi = Math.abs(dz / dx);
        if (dx < 0) {
            csa.dn_cnt[j]++;
            csa.dn_sum[j] += psi;
        } else {
            csa.up_cnt[j]++;
            csa.up_sum[j] += psi;
        }
    }
    function ios_pcost_free(tree) {
        var csa = tree.pcost;
        xassert(csa != null);
        tree.pcost = null;
    }
    function ios_pcost_branch(T, callback) {
        function eval_degrad(P, j, bnd) {
            var lp;
            var ret;
            var degrad;
            xassert(glp_get_status(P) == GLP_OPT);
            lp = glp_create_prob();
            glp_copy_prob(lp, P, 0);
            glp_set_col_bnds(lp, j, GLP_FX, bnd, bnd);
            var parm = new SMCP();
            parm.msg_lev = GLP_MSG_OFF;
            parm.meth = GLP_DUAL;
            parm.it_lim = 30;
            parm.out_dly = 1000;
            parm.meth = GLP_DUAL;
            ret = glp_simplex(lp, parm);
            if (ret == 0 || ret == GLP_EITLIM) {
                if (glp_get_prim_stat(lp) == GLP_NOFEAS) {
                    degrad = DBL_MAX;
                } else if (glp_get_dual_stat(lp) == GLP_FEAS) {
                    if (P.dir == GLP_MIN)
                        degrad = lp.obj_val - P.obj_val;
                    else if (P.dir == GLP_MAX)
                        degrad = P.obj_val - lp.obj_val;
                    else
                        xassert(P != P);
                    if (degrad < 0.000001 * (1 + 0.001 * Math.abs(P.obj_val)))
                        degrad = 0;
                } else {
                    degrad = 0;
                }
            } else {
                degrad = 0;
            }
            return degrad;
        }
        function eval_psi(T, j, brnch) {
            var csa = T.pcost;
            var beta, degrad, psi;
            xassert(csa != null);
            xassert(1 <= j && j <= T.n);
            if (brnch == GLP_DN_BRNCH) {
                if (csa.dn_cnt[j] == 0) {
                    beta = T.mip.col[j].prim;
                    degrad = eval_degrad(T.mip, j, Math.floor(beta));
                    if (degrad == DBL_MAX) {
                        psi = DBL_MAX;
                        return psi;
                    }
                    csa.dn_cnt[j] = 1;
                    csa.dn_sum[j] = degrad / (beta - Math.floor(beta));
                }
                psi = csa.dn_sum[j] / csa.dn_cnt[j];
            } else if (brnch == GLP_UP_BRNCH) {
                if (csa.up_cnt[j] == 0) {
                    beta = T.mip.col[j].prim;
                    degrad = eval_degrad(T.mip, j, Math.ceil(beta));
                    if (degrad == DBL_MAX) {
                        psi = DBL_MAX;
                        return psi;
                    }
                    csa.up_cnt[j] = 1;
                    csa.up_sum[j] = degrad / (Math.ceil(beta) - beta);
                }
                psi = csa.up_sum[j] / csa.up_cnt[j];
            } else
                xassert(brnch != brnch);
            return psi;
        }
        function progress(T) {
            var csa = T.pcost;
            var j, nv = 0, ni = 0;
            for (j = 1; j <= T.n; j++) {
                if (glp_ios_can_branch(T, j)) {
                    nv++;
                    if (csa.dn_cnt[j] > 0 && csa.up_cnt[j] > 0)
                        ni++;
                }
            }
            xprintf('Pseudocosts initialized for ' + ni + ' of ' + nv + ' variables');
        }
        var t = xtime();
        var j, jjj, sel;
        var beta, psi, d1, d2, d, dmax;
        if (T.pcost == null)
            T.pcost = ios_pcost_init(T);
        jjj = 0;
        dmax = -1;
        for (j = 1; j <= T.n; j++) {
            if (!glp_ios_can_branch(T, j))
                continue;
            beta = T.mip.col[j].prim;
            psi = eval_psi(T, j, GLP_DN_BRNCH);
            if (psi == DBL_MAX) {
                jjj = j;
                sel = GLP_DN_BRNCH;
                callback(sel);
                return jjj;
            }
            d1 = psi * (beta - Math.floor(beta));
            psi = eval_psi(T, j, GLP_UP_BRNCH);
            if (psi == DBL_MAX) {
                jjj = j;
                sel = GLP_UP_BRNCH;
                callback(sel);
                return jjj;
            }
            d2 = psi * (Math.ceil(beta) - beta);
            d = d1 > d2 ? d1 : d2;
            if (dmax < d) {
                dmax = d;
                jjj = j;
                sel = d1 <= d2 ? GLP_DN_BRNCH : GLP_UP_BRNCH;
            }
            if (T.parm.msg_lev >= GLP_ON) {
                if (xdifftime(xtime(), t) >= 10) {
                    progress(T);
                    t = xtime();
                }
            }
        }
        if (dmax == 0) {
            jjj = branch_mostf(T, callback);
            return jjj;
        }
        callback(sel);
        return jjj;
    }
    function ios_feas_pump(T) {
        var P = T.mip;
        var n = P.n;
        var lp = null;
        var var_ = null;
        var rand = null;
        var col;
        var parm;
        var j, k, new_x, nfail, npass, nv, ret, stalling;
        var dist, tol;
        var start = 0, more = 1, pass = 2, loop = 3, skip = 4, done = 5;
        var label = start;
        while (true) {
            var go_to = null;
            switch (label) {
            case start:
                xassert(glp_get_status(P) == GLP_OPT);
                if (!(T.curr.level == 0 && T.curr.solved == 1)) {
                    go_to = done;
                    break;
                }
                nv = 0;
                for (j = 1; j <= n; j++) {
                    col = P.col[j];
                    if (col.kind == GLP_CV)
                        continue;
                    if (col.type == GLP_FX)
                        continue;
                    xassert(col.kind == GLP_IV);
                    if (col.type == GLP_DB && col.lb == 0 && col.ub == 1) {
                        nv++;
                    } else {
                        if (T.parm.msg_lev >= GLP_MSG_ALL)
                            xprintf('FPUMP heuristic cannot be applied due to genera' + 'l integer variables');
                        go_to = done;
                        break;
                    }
                }
                if (go_to != null)
                    break;
                if (nv == 0) {
                    go_to = done;
                    break;
                }
                if (T.parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('Applying FPUMP heuristic...');
                var_ = new Array(1 + nv);
                xfillObjArr(var_, 1, nv);
                k = 0;
                for (j = 1; j <= n; j++) {
                    col = P.col[j];
                    if (col.kind == GLP_IV && col.type == GLP_DB)
                        var_[++k].j = j;
                }
                xassert(k == nv);
                lp = glp_create_prob();
            case more:
                glp_copy_prob(lp, P, GLP_OFF);
                if (P.mip_stat == GLP_FEAS) {
                    var ind;
                    var val, bnd;
                    glp_add_rows(lp, 1);
                    ind = new Int32Array(1 + n);
                    val = new Float64Array(1 + n);
                    for (j = 1; j <= n; j++) {
                        ind[j] = j;
                        val[j] = P.col[j].coef;
                    }
                    glp_set_mat_row(lp, lp.m, n, ind, val);
                    bnd = 0.1 * P.obj_val + 0.9 * P.mip_obj;
                    if (P.dir == GLP_MIN)
                        glp_set_row_bnds(lp, lp.m, GLP_UP, 0, bnd - P.c0);
                    else if (P.dir == GLP_MAX)
                        glp_set_row_bnds(lp, lp.m, GLP_LO, bnd - P.c0, 0);
                    else
                        xassert(P != P);
                }
                npass = 0;
                for (k = 1; k <= nv; k++)
                    var_[k].x = -1;
            case pass:
                npass++;
                if (T.parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('Pass ' + npass + '');
                dist = DBL_MAX;
                nfail = 0;
                if (npass > 1) {
                    var rho, temp;
                    if (rand == null)
                        rand = rng_create_rand();
                    for (k = 1; k <= nv; k++) {
                        j = var_[k].j;
                        col = lp.col[j];
                        rho = rng_uniform(rand, -0.3, 0.7);
                        if (rho < 0)
                            rho = 0;
                        temp = Math.abs(var_[k].x - col.prim);
                        if (temp + rho > 0.5)
                            var_[k].x = 1 - var_[k].x;
                    }
                    go_to = skip;
                    break;
                }
            case loop:
                stalling = 1;
                for (k = 1; k <= nv; k++) {
                    col = lp.col[var_[k].j];
                    if (col.prim < 0.5) {
                        new_x = 0;
                    } else {
                        new_x = 1;
                    }
                    if (var_[k].x != new_x) {
                        stalling = 0;
                        var_[k].x = new_x;
                    }
                }
                if (stalling) {
                    for (k = 1; k <= nv; k++) {
                        col = lp.col[var_[k].j];
                        var_[k].d = Math.abs(col.prim - var_[k].x);
                    }
                    xqsort(var_, 1, nv, function (vx, vy) {
                        if (vx.d > vy.d)
                            return -1;
                        else if (vx.d < vy.d)
                            return +1;
                        else
                            return 0;
                    });
                    for (k = 1; k <= nv; k++) {
                        if (k >= 5 && var_[k].d < 0.35 || k >= 10)
                            break;
                        var_[k].x = 1 - var_[k].x;
                    }
                }
            case skip:
                if (T.parm.tm_lim < INT_MAX && T.parm.tm_lim - 1 <= 1000 * xdifftime(xtime(), T.tm_beg)) {
                    go_to = done;
                    break;
                }
                lp.dir = GLP_MIN;
                lp.c0 = 0;
                for (j = 1; j <= n; j++)
                    lp.col[j].coef = 0;
                for (k = 1; k <= nv; k++) {
                    j = var_[k].j;
                    if (var_[k].x == 0)
                        lp.col[j].coef = +1;
                    else {
                        lp.col[j].coef = -1;
                        lp.c0 += 1;
                    }
                }
                parm = new SMCP();
                if (T.parm.msg_lev <= GLP_MSG_ERR)
                    parm.msg_lev = T.parm.msg_lev;
                else if (T.parm.msg_lev <= GLP_MSG_ALL) {
                    parm.msg_lev = GLP_MSG_ON;
                    parm.out_dly = 10000;
                }
                ret = glp_simplex(lp, parm);
                if (ret != 0) {
                    if (T.parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('Warning: glp_simplex returned ' + ret + '');
                    go_to = done;
                    break;
                }
                ret = glp_get_status(lp);
                if (ret != GLP_OPT) {
                    if (T.parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('Warning: glp_get_status returned ' + ret + '');
                    go_to = done;
                    break;
                }
                if (T.parm.msg_lev >= GLP_MSG_DBG)
                    xprintf('delta = ' + lp.obj_val + '');
                tol = 0.3 * T.parm.tol_int;
                for (k = 1; k <= nv; k++) {
                    col = lp.col[var_[k].j];
                    if (tol < col.prim && col.prim < 1 - tol)
                        break;
                }
                if (k > nv) {
                    var x = new Float64Array(1 + n);
                    for (j = 1; j <= n; j++) {
                        x[j] = lp.col[j].prim;
                        if (P.col[j].kind == GLP_IV)
                            x[j] = Math.floor(x[j] + 0.5);
                    }
                    lp.c0 = P.c0;
                    lp.dir = P.dir;
                    for (k = 1; k <= nv; k++) {
                        lp.col[var_[k].j].lb = x[var_[k].j];
                        lp.col[var_[k].j].ub = x[var_[k].j];
                        lp.col[var_[k].j].type = GLP_FX;
                    }
                    for (j = 1; j <= n; j++)
                        lp.col[j].coef = P.col[j].coef;
                    ret = glp_simplex(lp, parm);
                    if (ret != 0) {
                        if (T.parm.msg_lev >= GLP_MSG_ERR)
                            xprintf('Warning: glp_simplex returned ' + ret + '');
                        go_to = done;
                        break;
                    }
                    ret = glp_get_status(lp);
                    if (ret != GLP_OPT) {
                        if (T.parm.msg_lev >= GLP_MSG_ERR)
                            xprintf('Warning: glp_get_status returned ' + ret + '');
                        go_to = done;
                        break;
                    }
                    for (j = 1; j <= n; j++)
                        if (P.col[j].kind != GLP_IV)
                            x[j] = lp.col[j].prim;
                    ret = glp_ios_heur_sol(T, x);
                    if (ret == 0) {
                        if (ios_is_hopeful(T, T.curr.bound)) {
                            go_to = more;
                            break;
                        } else {
                            go_to = done;
                            break;
                        }
                    }
                }
                if (dist == DBL_MAX || lp.obj_val <= dist - 0.000001 * (1 + dist)) {
                    nfail = 0;
                    dist = lp.obj_val;
                } else {
                    nfail++;
                }
                if (nfail < 3) {
                    go_to = loop;
                    break;
                }
                if (npass < 5) {
                    go_to = pass;
                    break;
                }
            case done:
            }
            if (go_to == null)
                break;
            label = go_to;
        }
    }
    function ios_process_cuts(T) {
        function parallel(a, b, work) {
            var aij;
            var s = 0, sa = 0, sb = 0, temp;
            for (aij = a.ptr; aij != null; aij = aij.next) {
                work[aij.j] = aij.val;
                sa += aij.val * aij.val;
            }
            for (aij = b.ptr; aij != null; aij = aij.next) {
                s += work[aij.j] * aij.val;
                sb += aij.val * aij.val;
            }
            for (aij = a.ptr; aij != null; aij = aij.next)
                work[aij.j] = 0;
            temp = Math.sqrt(sa) * Math.sqrt(sb);
            if (temp < DBL_EPSILON * DBL_EPSILON)
                temp = DBL_EPSILON;
            return s / temp;
        }
        var pool;
        var cut;
        var aij;
        var info;
        var k, kk, max_cuts, len, ret, ind;
        var val, work;
        xassert(T.curr != null);
        pool = T.local;
        xassert(pool != null);
        xassert(pool.size > 0);
        info = new Array(1 + pool.size);
        ind = new Int32Array(1 + T.n);
        val = new Float64Array(1 + T.n);
        work = new Float64Array(1 + T.n);
        for (k = 0, cut = pool.head; cut != null; cut = cut.next) {
            k++;
            info[k].cut = cut;
            info[k].flag = 0;
        }
        xassert(k == pool.size);
        for (k = 1; k <= pool.size; k++) {
            var temp, dy = null, dz = null;
            cut = info[k].cut;
            len = 0;
            temp = 0;
            for (aij = cut.ptr; aij != null; aij = aij.next) {
                xassert(1 <= aij.j && aij.j <= T.n);
                len++;
                ind[len] = aij.j;
                val[len] = aij.val;
                temp += aij.val * aij.val;
            }
            if (temp < DBL_EPSILON * DBL_EPSILON)
                temp = DBL_EPSILON;
            len = glp_transform_row(T.mip, len, ind, val);
            ret = _glp_analyze_row(T.mip, len, ind, val, cut.type, cut.rhs, 1e-9, function (piv, x, dx, y, dy_, dz_) {
                dy = dy_;
                dz = dz_;
            });
            if (ret == 0) {
                info[k].eff = Math.abs(dy) / Math.sqrt(temp);
                if (T.mip.dir == GLP_MIN) {
                    if (dz < 0)
                        dz = 0;
                    info[k].deg = +dz;
                } else {
                    if (dz > 0)
                        dz = 0;
                    info[k].deg = -dz;
                }
            } else if (ret == 1) {
                info[k].eff = info[k].deg = 0;
            } else if (ret == 2) {
                info[k].eff = 1;
                info[k].deg = DBL_MAX;
            } else
                xassert(ret != ret);
            if (info[k].deg < 0.01)
                info[k].deg = 0;
        }
        xqsort(info, 1, pool.size, function (info1, info2) {
            if (info1.deg == 0 && info2.deg == 0) {
                if (info1.eff > info2.eff)
                    return -1;
                if (info1.eff < info2.eff)
                    return +1;
            } else {
                if (info1.deg > info2.deg)
                    return -1;
                if (info1.deg < info2.deg)
                    return +1;
            }
            return 0;
        });
        max_cuts = T.curr.level == 0 ? 90 : 10;
        if (max_cuts > pool.size)
            max_cuts = pool.size;
        for (k = 1; k <= max_cuts; k++) {
            var i;
            if (info[k].deg < 0.01 && info[k].eff < 0.01)
                continue;
            for (kk = 1; kk < k; kk++) {
                if (info[kk].flag) {
                    if (parallel(info[k].cut, info[kk].cut, work) > 0.9)
                        break;
                }
            }
            if (kk < k)
                continue;
            cut = info[k].cut;
            info[k].flag = 1;
            i = glp_add_rows(T.mip, 1);
            if (cut.name != null)
                glp_set_row_name(T.mip, i, cut.name);
            xassert(T.mip.row[i].origin == GLP_RF_CUT);
            T.mip.row[i].klass = cut.klass;
            len = 0;
            for (aij = cut.ptr; aij != null; aij = aij.next) {
                len++;
                ind[len] = aij.j;
                val[len] = aij.val;
            }
            glp_set_mat_row(T.mip, i, len, ind, val);
            xassert(cut.type == GLP_LO || cut.type == GLP_UP);
            glp_set_row_bnds(T.mip, i, cut.type, cut.rhs, cut.rhs);
        }
    }
    function ios_choose_node(T) {
        function most_feas(T) {
            var node;
            var p;
            var best;
            p = 0;
            best = DBL_MAX;
            for (node = T.head; node != null; node = node.next) {
                xassert(node.up != null);
                if (best > node.up.ii_sum) {
                    p = node.p;
                    best = node.up.ii_sum;
                }
            }
            return p;
        }
        function best_proj(T) {
            var root, node;
            var p;
            var best, deg, obj;
            xassert(T.mip.mip_stat == GLP_FEAS);
            root = T.slot[1].node;
            xassert(root != null);
            xassert(root.ii_sum > 0);
            deg = (T.mip.mip_obj - root.bound) / root.ii_sum;
            p = 0;
            best = DBL_MAX;
            for (node = T.head; node != null; node = node.next) {
                xassert(node.up != null);
                obj = node.up.bound + deg * node.up.ii_sum;
                if (T.mip.dir == GLP_MAX)
                    obj = -obj;
                if (best > obj) {
                    p = node.p;
                    best = obj;
                }
            }
            return p;
        }
        function best_node(T) {
            var node, best = null;
            var bound, eps;
            switch (T.mip.dir) {
            case GLP_MIN:
                bound = +DBL_MAX;
                for (node = T.head; node != null; node = node.next)
                    if (bound > node.bound)
                        bound = node.bound;
                xassert(bound != +DBL_MAX);
                eps = 0.001 * (1 + Math.abs(bound));
                for (node = T.head; node != null; node = node.next) {
                    if (node.bound <= bound + eps) {
                        xassert(node.up != null);
                        if (best == null || best.up.ii_sum > node.up.ii_sum)
                            best = node;
                    }
                }
                break;
            case GLP_MAX:
                bound = -DBL_MAX;
                for (node = T.head; node != null; node = node.next)
                    if (bound < node.bound)
                        bound = node.bound;
                xassert(bound != -DBL_MAX);
                eps = 0.001 * (1 + Math.abs(bound));
                for (node = T.head; node != null; node = node.next) {
                    if (node.bound >= bound - eps) {
                        xassert(node.up != null);
                        if (best == null || best.lp_obj < node.lp_obj)
                            best = node;
                    }
                }
                break;
            default:
                xassert(T != T);
            }
            xassert(best != null);
            return best.p;
        }
        var p;
        if (T.parm.bt_tech == GLP_BT_DFS) {
            xassert(T.tail != null);
            p = T.tail.p;
        } else if (T.parm.bt_tech == GLP_BT_BFS) {
            xassert(T.head != null);
            p = T.head.p;
        } else if (T.parm.bt_tech == GLP_BT_BLB) {
            p = best_node(T);
        } else if (T.parm.bt_tech == GLP_BT_BPH) {
            if (T.mip.mip_stat == GLP_UNDEF) {
                p = most_feas(T);
            } else {
                p = best_proj(T);
            }
        } else
            xassert(T != T);
        return p;
    }
    var GLP_MAJOR_VERSION = exports['GLP_MAJOR_VERSION'] = 4, GLP_MINOR_VERSION = exports['GLP_MINOR_VERSION'] = 49, GLP_MIN = exports['GLP_MIN'] = 1, GLP_MAX = exports['GLP_MAX'] = 2, GLP_CV = exports['GLP_CV'] = 1, GLP_IV = exports['GLP_IV'] = 2, GLP_BV = exports['GLP_BV'] = 3, GLP_FR = exports['GLP_FR'] = 1, GLP_LO = exports['GLP_LO'] = 2, GLP_UP = exports['GLP_UP'] = 3, GLP_DB = exports['GLP_DB'] = 4, GLP_FX = exports['GLP_FX'] = 5, GLP_BS = exports['GLP_BS'] = 1, GLP_NL = exports['GLP_NL'] = 2, GLP_NU = exports['GLP_NU'] = 3, GLP_NF = exports['GLP_NF'] = 4, GLP_NS = exports['GLP_NS'] = 5, GLP_SF_GM = exports['GLP_SF_GM'] = 1, GLP_SF_EQ = exports['GLP_SF_EQ'] = 16, GLP_SF_2N = exports['GLP_SF_2N'] = 32, GLP_SF_SKIP = exports['GLP_SF_SKIP'] = 64, GLP_SF_AUTO = exports['GLP_SF_AUTO'] = 128, GLP_SOL = exports['GLP_SOL'] = 1, GLP_IPT = exports['GLP_IPT'] = 2, GLP_MIP = exports['GLP_MIP'] = 3, GLP_UNDEF = exports['GLP_UNDEF'] = 1, GLP_FEAS = exports['GLP_FEAS'] = 2, GLP_INFEAS = exports['GLP_INFEAS'] = 3, GLP_NOFEAS = exports['GLP_NOFEAS'] = 4, GLP_OPT = exports['GLP_OPT'] = 5, GLP_UNBND = exports['GLP_UNBND'] = 6, GLP_BF_FT = exports['GLP_BF_FT'] = 1, GLP_BF_BG = exports['GLP_BF_BG'] = 2, GLP_BF_GR = exports['GLP_BF_GR'] = 3, GLP_MSG_OFF = exports['GLP_MSG_OFF'] = 0, GLP_MSG_ERR = exports['GLP_MSG_ERR'] = 1, GLP_MSG_ON = exports['GLP_MSG_ON'] = 2, GLP_MSG_ALL = exports['GLP_MSG_ALL'] = 3, GLP_MSG_DBG = exports['GLP_MSG_DBG'] = 4, GLP_PRIMAL = exports['GLP_PRIMAL'] = 1, GLP_DUALP = exports['GLP_DUALP'] = 2, GLP_DUAL = exports['GLP_DUAL'] = 3, GLP_PT_STD = exports['GLP_PT_STD'] = 17, GLP_PT_PSE = exports['GLP_PT_PSE'] = 34, GLP_RT_STD = exports['GLP_RT_STD'] = 17, GLP_RT_HAR = exports['GLP_RT_HAR'] = 34, GLP_ORD_NONE = exports['GLP_ORD_NONE'] = 0, GLP_ORD_QMD = exports['GLP_ORD_QMD'] = 1, GLP_ORD_AMD = exports['GLP_ORD_AMD'] = 2, GLP_ORD_SYMAMD = exports['GLP_ORD_SYMAMD'] = 3, GLP_BR_FFV = exports['GLP_BR_FFV'] = 1, GLP_BR_LFV = exports['GLP_BR_LFV'] = 2, GLP_BR_MFV = exports['GLP_BR_MFV'] = 3, GLP_BR_DTH = exports['GLP_BR_DTH'] = 4, GLP_BR_PCH = exports['GLP_BR_PCH'] = 5, GLP_BT_DFS = exports['GLP_BT_DFS'] = 1, GLP_BT_BFS = exports['GLP_BT_BFS'] = 2, GLP_BT_BLB = exports['GLP_BT_BLB'] = 3, GLP_BT_BPH = exports['GLP_BT_BPH'] = 4, GLP_PP_NONE = exports['GLP_PP_NONE'] = 0, GLP_PP_ROOT = exports['GLP_PP_ROOT'] = 1, GLP_PP_ALL = exports['GLP_PP_ALL'] = 2, GLP_RF_REG = exports['GLP_RF_REG'] = 0, GLP_RF_LAZY = exports['GLP_RF_LAZY'] = 1, GLP_RF_CUT = exports['GLP_RF_CUT'] = 2, GLP_RF_GMI = exports['GLP_RF_GMI'] = 1, GLP_RF_MIR = exports['GLP_RF_MIR'] = 2, GLP_RF_COV = exports['GLP_RF_COV'] = 3, GLP_RF_CLQ = exports['GLP_RF_CLQ'] = 4, GLP_ON = exports['GLP_ON'] = 1, GLP_OFF = exports['GLP_OFF'] = 0, GLP_IROWGEN = exports['GLP_IROWGEN'] = 1, GLP_IBINGO = exports['GLP_IBINGO'] = 2, GLP_IHEUR = exports['GLP_IHEUR'] = 3, GLP_ICUTGEN = exports['GLP_ICUTGEN'] = 4, GLP_IBRANCH = exports['GLP_IBRANCH'] = 5, GLP_ISELECT = exports['GLP_ISELECT'] = 6, GLP_IPREPRO = exports['GLP_IPREPRO'] = 7, GLP_NO_BRNCH = exports['GLP_NO_BRNCH'] = 0, GLP_DN_BRNCH = exports['GLP_DN_BRNCH'] = 1, GLP_UP_BRNCH = exports['GLP_UP_BRNCH'] = 2, GLP_EBADB = exports['GLP_EBADB'] = 1, GLP_ESING = exports['GLP_ESING'] = 2, GLP_ECOND = exports['GLP_ECOND'] = 3, GLP_EBOUND = exports['GLP_EBOUND'] = 4, GLP_EFAIL = exports['GLP_EFAIL'] = 5, GLP_EOBJLL = exports['GLP_EOBJLL'] = 6, GLP_EOBJUL = exports['GLP_EOBJUL'] = 7, GLP_EITLIM = exports['GLP_EITLIM'] = 8, GLP_ETMLIM = exports['GLP_ETMLIM'] = 9, GLP_ENOPFS = exports['GLP_ENOPFS'] = 10, GLP_ENODFS = exports['GLP_ENODFS'] = 11, GLP_EROOT = exports['GLP_EROOT'] = 12, GLP_ESTOP = exports['GLP_ESTOP'] = 13, GLP_EMIPGAP = exports['GLP_EMIPGAP'] = 14, GLP_ENOFEAS = exports['GLP_ENOFEAS'] = 15, GLP_ENOCVG = exports['GLP_ENOCVG'] = 16, GLP_EINSTAB = exports['GLP_EINSTAB'] = 17, GLP_EDATA = exports['GLP_EDATA'] = 18, GLP_ERANGE = exports['GLP_ERANGE'] = 19, GLP_KKT_PE = exports['GLP_KKT_PE'] = 1, GLP_KKT_PB = exports['GLP_KKT_PB'] = 2, GLP_KKT_DE = exports['GLP_KKT_DE'] = 3, GLP_KKT_DB = exports['GLP_KKT_DB'] = 4, GLP_KKT_CS = exports['GLP_KKT_CS'] = 5, GLP_MPS_DECK = exports['GLP_MPS_DECK'] = 1, GLP_MPS_FILE = exports['GLP_MPS_FILE'] = 2, GLP_ASN_MIN = exports['GLP_ASN_MIN'] = 1, GLP_ASN_MAX = exports['GLP_ASN_MAX'] = 2, GLP_ASN_MMP = exports['GLP_ASN_MMP'] = 3;
    function gcd(x, y) {
        var r;
        xassert(x > 0 && y > 0);
        while (y > 0) {
            r = x % y;
            x = y;
            y = r;
        }
        return x;
    }
    function gcdn(n, x) {
        var d = 0, j;
        xassert(n > 0);
        for (j = 1; j <= n; j++) {
            xassert(x[j] > 0);
            if (j == 1)
                d = x[1];
            else
                d = gcd(d, x[j]);
            if (d == 1)
                break;
        }
        return d;
    }
    function round2n(x) {
        xassert(x > 0);
        var e = Math.floor(Math.log(x) / Math.log(2)) + 1;
        var f = x / Math.pow(2, e);
        return Math.pow(2, f <= 0.75 ? e - 1 : e);
    }
    function str2num(str, callback) {
        var ret = Number(str);
        if (isNaN(ret))
            return 2;
        switch (ret) {
        case Number.POSITIVE_INFINITY:
        case Number.NEGATIVE_INFINITY:
            return 1;
        default:
            callback(ret);
            return 0;
        }
    }
    function str2int(str, callback) {
        var ret = Number(str);
        if (isNaN(ret))
            return 2;
        switch (ret) {
        case Number.POSITIVE_INFINITY:
        case Number.NEGATIVE_INFINITY:
            return 1;
        default:
            if (ret % 1 == 0) {
                callback(ret);
                return 0;
            } else {
                return 2;
            }
        }
    }
    function jday(d, m, y) {
        var c, ya, j, dd;
        if (!(1 <= d && d <= 31 && 1 <= m && m <= 12 && 1 <= y && y <= 4000))
            return -1;
        if (m >= 3)
            m -= 3;
        else {
            m += 9;
            y--;
        }
        c = y / 100 | 0;
        ya = y - 100 * c;
        j = 146097 * c / 4 | 0;
        j += 1461 * ya / 4 | 0;
        j += (153 * m + 2) / 5 | 0;
        j += d + 1721119;
        jdate(j, function (d) {
            dd = d;
        });
        if (d != dd)
            j = -1;
        return j;
    }
    function jdate(j, callback) {
        var d, m, y, ret = 0;
        if (!(1721426 <= j && j <= 3182395))
            return 1;
        j -= 1721119;
        y = (4 * j - 1) / 146097 | 0;
        j = (4 * j - 1) % 146097;
        d = j / 4 | 0;
        j = (4 * d + 3) / 1461 | 0;
        d = (4 * d + 3) % 1461;
        d = (d + 4) / 4 | 0;
        m = (5 * d - 3) / 153 | 0;
        d = (5 * d - 3) % 153;
        d = (d + 5) / 5 | 0;
        y = 100 * y + j;
        if (m <= 9)
            m += 3;
        else {
            m -= 9;
            y++;
        }
        callback(d, m, y);
        return ret;
    }
    var LPF_ESING = 1;
    LPF_ECOND = 2;
    LPF_ELIMIT = 3;
    var _GLPLPF_DEBUG = 0;
    function lpf_create_it() {
        var lpf;
        if (_GLPLPF_DEBUG) {
            xprintf('lpf_create_it: warning: debug mode enabled');
        }
        lpf = {};
        lpf.valid = 0;
        lpf.m0_max = lpf.m0 = 0;
        lpf.luf = luf_create_it();
        lpf.m = 0;
        lpf.B = null;
        lpf.n_max = 50;
        lpf.n = 0;
        lpf.R_ptr = lpf.R_len = null;
        lpf.S_ptr = lpf.S_len = null;
        lpf.scf = null;
        lpf.P_row = lpf.P_col = null;
        lpf.Q_row = lpf.Q_col = null;
        lpf.v_size = 1000;
        lpf.v_ptr = 0;
        lpf.v_ind = null;
        lpf.v_val = null;
        lpf.work1 = lpf.work2 = null;
        return lpf;
    }
    function lpf_factorize(lpf, m, bh, col, info) {
        var k, ret;
        if (_GLPLPF_DEBUG) {
            var i, j, len, ind;
            var B, val;
        }
        xassert(bh == bh);
        if (m < 1)
            xerror('lpf_factorize: m = ' + m + '; invalid parameter');
        if (m > M_MAX)
            xerror('lpf_factorize: m = ' + m + '; matrix too big');
        lpf.m0 = lpf.m = m;
        lpf.valid = 0;
        if (lpf.R_ptr == null)
            lpf.R_ptr = new Int32Array(1 + lpf.n_max);
        if (lpf.R_len == null)
            lpf.R_len = new Int32Array(1 + lpf.n_max);
        if (lpf.S_ptr == null)
            lpf.S_ptr = new Int32Array(1 + lpf.n_max);
        if (lpf.S_len == null)
            lpf.S_len = new Int32Array(1 + lpf.n_max);
        if (lpf.scf == null)
            lpf.scf = scf_create_it(lpf.n_max);
        if (lpf.v_ind == null)
            lpf.v_ind = new Int32Array(1 + lpf.v_size);
        if (lpf.v_val == null)
            lpf.v_val = new Float64Array(1 + lpf.v_size);
        if (lpf.m0_max < m) {
            lpf.m0_max = m + 100;
            lpf.P_row = new Int32Array(1 + lpf.m0_max + lpf.n_max);
            lpf.P_col = new Int32Array(1 + lpf.m0_max + lpf.n_max);
            lpf.Q_row = new Int32Array(1 + lpf.m0_max + lpf.n_max);
            lpf.Q_col = new Int32Array(1 + lpf.m0_max + lpf.n_max);
            lpf.work1 = new Float64Array(1 + lpf.m0_max + lpf.n_max);
            lpf.work2 = new Float64Array(1 + lpf.m0_max + lpf.n_max);
        }
        switch (luf_factorize(lpf.luf, m, col, info)) {
        case 0:
            break;
        case LUF_ESING:
            ret = LPF_ESING;
            return ret;
        case LUF_ECOND:
            ret = LPF_ECOND;
            return ret;
        default:
            xassert(lpf != lpf);
        }
        lpf.valid = 1;
        if (_GLPLPF_DEBUG) {
            xassert(m <= 32767);
            lpf.B = B = new Float64Array(1 + m * m);
            ind = new Int32Array(1 + m);
            val = new Float64Array(1 + m);
            for (k = 1; k <= m * m; k++)
                B[k] = 0;
            for (j = 1; j <= m; j++) {
                len = col(info, j, ind, val);
                xassert(0 <= len && len <= m);
                for (k = 1; k <= len; k++) {
                    i = ind[k];
                    xassert(1 <= i && i <= m);
                    xassert(B[(i - 1) * m + j] == 0);
                    xassert(val[k] != 0);
                    B[(i - 1) * m + j] = val[k];
                }
            }
        }
        lpf.n = 0;
        scf_reset_it(lpf.scf);
        for (k = 1; k <= m; k++) {
            lpf.P_row[k] = lpf.P_col[k] = k;
            lpf.Q_row[k] = lpf.Q_col[k] = k;
        }
        lpf.v_ptr = 1;
        ret = 0;
        return ret;
    }
    function r_prod(lpf, y, a, x, idx) {
        var n = lpf.n;
        var R_ptr = lpf.R_ptr;
        var R_len = lpf.R_len;
        var v_ind = lpf.v_ind;
        var v_val = lpf.v_val;
        var j, beg, end, ptr;
        var t;
        for (j = 1; j <= n; j++) {
            if (x[j + idx] == 0)
                continue;
            t = a * x[j + idx];
            beg = R_ptr[j];
            end = beg + R_len[j];
            for (ptr = beg; ptr < end; ptr++)
                y[v_ind[ptr]] += t * v_val[ptr];
        }
    }
    function rt_prod(lpf, y, idx, a, x) {
        var n = lpf.n;
        var R_ptr = lpf.R_ptr;
        var R_len = lpf.R_len;
        var v_ind = lpf.v_ind;
        var v_val = lpf.v_val;
        var j, beg, end, ptr;
        var t;
        for (j = 1; j <= n; j++) {
            t = 0;
            beg = R_ptr[j];
            end = beg + R_len[j];
            for (ptr = beg; ptr < end; ptr++)
                t += v_val[ptr] * x[v_ind[ptr]];
            y[j + idx] += a * t;
        }
    }
    function s_prod(lpf, y, idx, a, x) {
        var n = lpf.n;
        var S_ptr = lpf.S_ptr;
        var S_len = lpf.S_len;
        var v_ind = lpf.v_ind;
        var v_val = lpf.v_val;
        var i, beg, end, ptr;
        var t;
        for (i = 1; i <= n; i++) {
            t = 0;
            beg = S_ptr[i];
            end = beg + S_len[i];
            for (ptr = beg; ptr < end; ptr++)
                t += v_val[ptr] * x[v_ind[ptr]];
            y[i + idx] += a * t;
        }
    }
    function st_prod(lpf, y, a, x, idx) {
        var n = lpf.n;
        var S_ptr = lpf.S_ptr;
        var S_len = lpf.S_len;
        var v_ind = lpf.v_ind;
        var v_val = lpf.v_val;
        var i, beg, end, ptr;
        var t;
        for (i = 1; i <= n; i++) {
            if (x[i + idx] == 0)
                continue;
            t = a * x[i + idx];
            beg = S_ptr[i];
            end = beg + S_len[i];
            for (ptr = beg; ptr < end; ptr++)
                y[v_ind[ptr]] += t * v_val[ptr];
        }
    }
    if (_GLPLPF_DEBUG) {
        function check_error(lpf, tr, x, b) {
            var m = lpf.m;
            var B = lpf.B;
            var i, j;
            var d, dmax = 0, s, t, tmax;
            for (i = 1; i <= m; i++) {
                s = 0;
                tmax = 1;
                for (j = 1; j <= m; j++) {
                    if (!tr)
                        t = B[m * (i - 1) + j] * x[j];
                    else
                        t = B[m * (j - 1) + i] * x[j];
                    if (tmax < Math.abs(t))
                        tmax = Math.abs(t);
                    s += t;
                }
                d = Math.abs(s - b[i]) / tmax;
                if (dmax < d)
                    dmax = d;
            }
            if (dmax > 1e-8)
                xprintf((!tr ? 'lpf_ftran' : 'lpf_btran') + ': dmax = ' + dmax + '; relative error too large');
        }
    }
    function lpf_ftran(lpf, x) {
        var m0 = lpf.m0;
        var m = lpf.m;
        var n = lpf.n;
        var P_col = lpf.P_col;
        var Q_col = lpf.Q_col;
        var fg = lpf.work1;
        var f = fg;
        var g = fg;
        var i, ii;
        if (_GLPLPF_DEBUG) {
            var b;
        }
        if (!lpf.valid)
            xerror('lpf_ftran: the factorization is not valid');
        xassert(0 <= m && m <= m0 + n);
        if (_GLPLPF_DEBUG) {
            b = new Float64Array(1 + m);
            for (i = 1; i <= m; i++)
                b[i] = x[i];
        }
        for (i = 1; i <= m0 + n; i++)
            fg[i] = (ii = P_col[i]) <= m ? x[ii] : 0;
        luf_f_solve(lpf.luf, 0, f);
        s_prod(lpf, g, m0, -1, f);
        scf_solve_it(lpf.scf, 0, g, m0);
        r_prod(lpf, f, -1, g, m0);
        luf_v_solve(lpf.luf, 0, f);
        for (i = 1; i <= m; i++)
            x[i] = fg[Q_col[i]];
        if (_GLPLPF_DEBUG) {
            check_error(lpf, 0, x, b);
        }
    }
    function lpf_btran(lpf, x) {
        var m0 = lpf.m0;
        var m = lpf.m;
        var n = lpf.n;
        var P_row = lpf.P_row;
        var Q_row = lpf.Q_row;
        var fg = lpf.work1;
        var f = fg;
        var g = fg;
        var i, ii;
        if (_GLPLPF_DEBUG) {
            var b;
        }
        if (!lpf.valid)
            xerror('lpf_btran: the factorization is not valid');
        xassert(0 <= m && m <= m0 + n);
        if (_GLPLPF_DEBUG) {
            b = new Float64Array(1 + m);
            for (i = 1; i <= m; i++)
                b[i] = x[i];
        }
        for (i = 1; i <= m0 + n; i++)
            fg[i] = (ii = Q_row[i]) <= m ? x[ii] : 0;
        luf_v_solve(lpf.luf, 1, f);
        rt_prod(lpf, g, m0, -1, f);
        scf_solve_it(lpf.scf, 1, g, m0);
        st_prod(lpf, f, -1, g, m0);
        luf_f_solve(lpf.luf, 1, f);
        for (i = 1; i <= m; i++)
            x[i] = fg[P_row[i]];
        if (_GLPLPF_DEBUG) {
            check_error(lpf, 1, x, b);
        }
    }
    function enlarge_sva(lpf, new_size) {
        var v_size = lpf.v_size;
        var used = lpf.v_ptr - 1;
        var v_ind = lpf.v_ind;
        var v_val = lpf.v_val;
        xassert(v_size < new_size);
        while (v_size < new_size)
            v_size += v_size;
        lpf.v_size = v_size;
        lpf.v_ind = new Int32Array(1 + v_size);
        lpf.v_val = new Float64Array(1 + v_size);
        xassert(used >= 0);
        xcopyArr(lpf.v_ind, 1, v_ind, 1, used);
        xcopyArr(lpf.v_val, 1, v_val, 1, used);
    }
    function lpf_update_it(lpf, j, bh, len, ind, idx, val) {
        var m0 = lpf.m0;
        var m = lpf.m;
        if (_GLPLPF_DEBUG) {
            var B = lpf.B;
        }
        var n = lpf.n;
        var R_ptr = lpf.R_ptr;
        var R_len = lpf.R_len;
        var S_ptr = lpf.S_ptr;
        var S_len = lpf.S_len;
        var P_row = lpf.P_row;
        var P_col = lpf.P_col;
        var Q_row = lpf.Q_row;
        var Q_col = lpf.Q_col;
        var v_ptr = lpf.v_ptr;
        var v_ind = lpf.v_ind;
        var v_val = lpf.v_val;
        var a = lpf.work2;
        var fg = lpf.work1, f = fg, g = fg;
        var vw = lpf.work2, v = vw, w = vw;
        var x = g, y = w, z;
        var i, ii, k, ret;
        xassert(bh == bh);
        if (!lpf.valid)
            xerror('lpf_update_it: the factorization is not valid');
        if (!(1 <= j && j <= m))
            xerror('lpf_update_it: j = ' + j + '; column number out of range');
        xassert(0 <= m && m <= m0 + n);
        if (n == lpf.n_max) {
            lpf.valid = 0;
            ret = LPF_ELIMIT;
            return ret;
        }
        for (i = 1; i <= m; i++)
            a[i] = 0;
        for (k = 1; k <= len; k++) {
            i = ind[idx + k];
            if (!(1 <= i && i <= m))
                xerror('lpf_update_it: ind[' + k + '] = ' + i + '; row number out of range');
            if (a[i] != 0)
                xerror('lpf_update_it: ind[' + k + '] = ' + i + '; duplicate row index not allowed');
            if (val[k] == 0)
                xerror('lpf_update_it: val[' + k + '] = ' + val[k] + '; zero element not allowed');
            a[i] = val[k];
        }
        if (_GLPLPF_DEBUG) {
            for (i = 1; i <= m; i++)
                B[(i - 1) * m + j] = a[i];
        }
        for (i = 1; i <= m0 + n; i++)
            fg[i] = (ii = P_col[i]) <= m ? a[ii] : 0;
        for (i = 1; i <= m0 + n; i++)
            vw[i] = 0;
        vw[Q_col[j]] = 1;
        luf_f_solve(lpf.luf, 0, f);
        luf_v_solve(lpf.luf, 1, v);
        if (lpf.v_size < v_ptr + m0 + m0) {
            enlarge_sva(lpf, v_ptr + m0 + m0);
            v_ind = lpf.v_ind;
            v_val = lpf.v_val;
        }
        R_ptr[n + 1] = v_ptr;
        for (i = 1; i <= m0; i++) {
            if (f[i] != 0) {
                v_ind[v_ptr] = i;
                v_val[v_ptr] = f[i];
                v_ptr++;
            }
        }
        R_len[n + 1] = v_ptr - lpf.v_ptr;
        lpf.v_ptr = v_ptr;
        S_ptr[n + 1] = v_ptr;
        for (i = 1; i <= m0; i++) {
            if (v[i] != 0) {
                v_ind[v_ptr] = i;
                v_val[v_ptr] = v[i];
                v_ptr++;
            }
        }
        S_len[n + 1] = v_ptr - lpf.v_ptr;
        lpf.v_ptr = v_ptr;
        s_prod(lpf, x, 0, -1, f);
        rt_prod(lpf, y, 0, -1, v);
        z = 0;
        for (i = 1; i <= m0; i++)
            z -= v[i] * f[i];
        switch (scf_update_exp(lpf.scf, x, m0, y, m0, z)) {
        case 0:
            break;
        case SCF_ESING:
            lpf.valid = 0;
            ret = LPF_ESING;
            return ret;
        case SCF_ELIMIT:
            xassert(lpf != lpf);
        default:
            xassert(lpf != lpf);
        }
        P_row[m0 + n + 1] = P_col[m0 + n + 1] = m0 + n + 1;
        Q_row[m0 + n + 1] = Q_col[m0 + n + 1] = m0 + n + 1;
        i = Q_col[j];
        ii = Q_col[m0 + n + 1];
        Q_row[i] = m0 + n + 1;
        Q_col[m0 + n + 1] = i;
        Q_row[ii] = j;
        Q_col[j] = ii;
        lpf.n++;
        xassert(lpf.n <= lpf.n_max);
        ret = 0;
        return ret;
    }
    var LPX_LP = exports['LPX_LP'] = 100, LPX_MIP = exports['LPX_MIP'] = 101, LPX_FR = exports['LPX_FR'] = 110, LPX_LO = exports['LPX_LO'] = 111, LPX_UP = exports['LPX_UP'] = 112, LPX_DB = exports['LPX_DB'] = 113, LPX_FX = exports['LPX_FX'] = 114, LPX_MIN = exports['LPX_MIN'] = 120, LPX_MAX = exports['LPX_MAX'] = 121, LPX_P_UNDEF = exports['LPX_P_UNDEF'] = 132, LPX_P_FEAS = exports['LPX_P_FEAS'] = 133, LPX_P_INFEAS = exports['LPX_P_INFEAS'] = 134, LPX_P_NOFEAS = exports['LPX_P_NOFEAS'] = 135, LPX_D_UNDEF = exports['LPX_D_UNDEF'] = 136, LPX_D_FEAS = exports['LPX_D_FEAS'] = 137, LPX_D_INFEAS = exports['LPX_D_INFEAS'] = 138, LPX_D_NOFEAS = exports['LPX_D_NOFEAS'] = 139, LPX_BS = exports['LPX_BS'] = 140, LPX_NL = exports['LPX_NL'] = 141, LPX_NU = exports['LPX_NU'] = 142, LPX_NF = exports['LPX_NF'] = 143, LPX_NS = exports['LPX_NS'] = 144, LPX_T_UNDEF = exports['LPX_T_UNDEF'] = 150, LPX_T_OPT = exports['LPX_T_OPT'] = 151, LPX_CV = exports['LPX_CV'] = 160, LPX_IV = exports['LPX_IV'] = 161, LPX_I_UNDEF = exports['LPX_I_UNDEF'] = 170, LPX_I_OPT = exports['LPX_I_OPT'] = 171, LPX_I_FEAS = exports['LPX_I_FEAS'] = 172, LPX_I_NOFEAS = exports['LPX_I_NOFEAS'] = 173, LPX_OPT = exports['LPX_OPT'] = 180, LPX_FEAS = exports['LPX_FEAS'] = 181, LPX_INFEAS = exports['LPX_INFEAS'] = 182, LPX_NOFEAS = exports['LPX_NOFEAS'] = 183, LPX_UNBND = exports['LPX_UNBND'] = 184, LPX_UNDEF = exports['LPX_UNDEF'] = 185, LPX_E_OK = exports['LPX_E_OK'] = 200, LPX_E_EMPTY = exports['LPX_E_EMPTY'] = 201, LPX_E_BADB = exports['LPX_E_BADB'] = 202, LPX_E_INFEAS = exports['LPX_E_INFEAS'] = 203, LPX_E_FAULT = exports['LPX_E_FAULT'] = 204, LPX_E_OBJLL = exports['LPX_E_OBJLL'] = 205, LPX_E_OBJUL = exports['LPX_E_OBJUL'] = 206, LPX_E_ITLIM = exports['LPX_E_ITLIM'] = 207, LPX_E_TMLIM = exports['LPX_E_TMLIM'] = 208, LPX_E_NOFEAS = exports['LPX_E_NOFEAS'] = 209, LPX_E_INSTAB = exports['LPX_E_INSTAB'] = 210, LPX_E_SING = exports['LPX_E_SING'] = 211, LPX_E_NOCONV = exports['LPX_E_NOCONV'] = 212, LPX_E_NOPFS = exports['LPX_E_NOPFS'] = 213, LPX_E_NODFS = exports['LPX_E_NODFS'] = 214, LPX_E_MIPGAP = exports['LPX_E_MIPGAP'] = 215, LPX_K_MSGLEV = exports['LPX_K_MSGLEV'] = 300, LPX_K_SCALE = exports['LPX_K_SCALE'] = 301, LPX_K_DUAL = exports['LPX_K_DUAL'] = 302, LPX_K_PRICE = exports['LPX_K_PRICE'] = 303, LPX_K_RELAX = exports['LPX_K_RELAX'] = 304, LPX_K_TOLBND = exports['LPX_K_TOLBND'] = 305, LPX_K_TOLDJ = exports['LPX_K_TOLDJ'] = 306, LPX_K_TOLPIV = exports['LPX_K_TOLPIV'] = 307, LPX_K_ROUND = exports['LPX_K_ROUND'] = 308, LPX_K_OBJLL = exports['LPX_K_OBJLL'] = 309, LPX_K_OBJUL = exports['LPX_K_OBJUL'] = 310, LPX_K_ITLIM = exports['LPX_K_ITLIM'] = 311, LPX_K_ITCNT = exports['LPX_K_ITCNT'] = 312, LPX_K_TMLIM = exports['LPX_K_TMLIM'] = 313, LPX_K_OUTFRQ = exports['LPX_K_OUTFRQ'] = 314, LPX_K_OUTDLY = exports['LPX_K_OUTDLY'] = 315, LPX_K_BRANCH = exports['LPX_K_BRANCH'] = 316, LPX_K_BTRACK = exports['LPX_K_BTRACK'] = 317, LPX_K_TOLINT = exports['LPX_K_TOLINT'] = 318, LPX_K_TOLOBJ = exports['LPX_K_TOLOBJ'] = 319, LPX_K_MPSINFO = exports['LPX_K_MPSINFO'] = 320, LPX_K_MPSOBJ = exports['LPX_K_MPSOBJ'] = 321, LPX_K_MPSORIG = exports['LPX_K_MPSORIG'] = 322, LPX_K_MPSWIDE = exports['LPX_K_MPSWIDE'] = 323, LPX_K_MPSFREE = exports['LPX_K_MPSFREE'] = 324, LPX_K_MPSSKIP = exports['LPX_K_MPSSKIP'] = 325, LPX_K_LPTORIG = exports['LPX_K_LPTORIG'] = 326, LPX_K_PRESOL = exports['LPX_K_PRESOL'] = 327, LPX_K_BINARIZE = exports['LPX_K_BINARIZE'] = 328, LPX_K_USECUTS = exports['LPX_K_USECUTS'] = 329, LPX_K_BFTYPE = exports['LPX_K_BFTYPE'] = 330, LPX_K_MIPGAP = exports['LPX_K_MIPGAP'] = 331, LPX_C_COVER = exports['LPX_C_COVER'] = 1, LPX_C_CLIQUE = exports['LPX_C_CLIQUE'] = 2, LPX_C_GOMORY = exports['LPX_C_GOMORY'] = 4, LPX_C_MIR = exports['LPX_C_MIR'] = 8, LPX_C_ALL = exports['LPX_C_ALL'] = 255;
    function lpx_create_prob() {
        return glp_create_prob();
    }
    function lpx_set_prob_name(lp, name) {
        glp_set_prob_name(lp, name);
    }
    function lpx_set_obj_name(lp, name) {
        glp_set_obj_name(lp, name);
    }
    function lpx_set_obj_dir(lp, dir) {
        glp_set_obj_dir(lp, dir - LPX_MIN + GLP_MIN);
    }
    function lpx_add_rows(lp, nrs) {
        return glp_add_rows(lp, nrs);
    }
    function lpx_add_cols(lp, ncs) {
        return glp_add_cols(lp, ncs);
    }
    function lpx_set_row_name(lp, i, name) {
        glp_set_row_name(lp, i, name);
    }
    function lpx_set_col_name(lp, j, name) {
        glp_set_col_name(lp, j, name);
    }
    function lpx_set_row_bnds(lp, i, type, lb, ub) {
        glp_set_row_bnds(lp, i, type - LPX_FR + GLP_FR, lb, ub);
    }
    function lpx_set_col_bnds(lp, j, type, lb, ub) {
        glp_set_col_bnds(lp, j, type - LPX_FR + GLP_FR, lb, ub);
    }
    function lpx_set_obj_coef(lp, j, coef) {
        glp_set_obj_coef(lp, j, coef);
    }
    function lpx_set_mat_row(lp, i, len, ind, val) {
        glp_set_mat_row(lp, i, len, ind, val);
    }
    function lpx_set_mat_col(lp, j, len, ind, val) {
        glp_set_mat_col(lp, j, len, ind, val);
    }
    function lpx_load_matrix(lp, ne, ia, ja, ar) {
        glp_load_matrix(lp, ne, ia, ja, ar);
    }
    function lpx_del_rows(lp, nrs, num) {
        glp_del_rows(lp, nrs, num);
    }
    function lpx_del_cols(lp, ncs, num) {
        glp_del_cols(lp, ncs, num);
    }
    function lpx_get_prob_name(lp) {
        return glp_get_prob_name(lp);
    }
    function lpx_get_obj_name(lp) {
        return glp_get_obj_name(lp);
    }
    function lpx_get_obj_dir(lp) {
        return glp_get_obj_dir(lp) - GLP_MIN + LPX_MIN;
    }
    function lpx_get_num_rows(lp) {
        return glp_get_num_rows(lp);
    }
    function lpx_get_num_cols(lp) {
        return glp_get_num_cols(lp);
    }
    function lpx_get_row_name(lp, i) {
        return glp_get_row_name(lp, i);
    }
    function lpx_get_col_name(lp, j) {
        return glp_get_col_name(lp, j);
    }
    function lpx_get_row_type(lp, i) {
        return glp_get_row_type(lp, i) - GLP_FR + LPX_FR;
    }
    function lpx_get_row_lb(lp, i) {
        var lb = glp_get_row_lb(lp, i);
        if (lb == -DBL_MAX)
            lb = 0;
        return lb;
    }
    function lpx_get_row_ub(lp, i) {
        var ub = glp_get_row_ub(lp, i);
        if (ub == +DBL_MAX)
            ub = 0;
        return ub;
    }
    function lpx_get_row_bnds(lp, i, callback) {
        callback(lpx_get_row_type(lp, i), lpx_get_row_lb(lp, i), lpx_get_row_ub(lp, i));
    }
    function lpx_get_col_type(lp, j) {
        return glp_get_col_type(lp, j) - GLP_FR + LPX_FR;
    }
    function lpx_get_col_lb(lp, j) {
        var lb = glp_get_col_lb(lp, j);
        if (lb == -DBL_MAX)
            lb = 0;
        return lb;
    }
    function lpx_get_col_ub(lp, j) {
        var ub = glp_get_col_ub(lp, j);
        if (ub == +DBL_MAX)
            ub = 0;
        return ub;
    }
    function lpx_get_col_bnds(lp, j, callback) {
        callback(lpx_get_col_type(lp, j), lpx_get_col_lb(lp, j), lpx_get_col_ub(lp, j));
    }
    function lpx_get_obj_coef(lp, j) {
        return glp_get_obj_coef(lp, j);
    }
    function lpx_get_num_nz(lp) {
        return glp_get_num_nz(lp);
    }
    function lpx_get_mat_row(lp, i, ind, val) {
        return glp_get_mat_row(lp, i, ind, val);
    }
    function lpx_get_mat_col(lp, j, ind, val) {
        return glp_get_mat_col(lp, j, ind, val);
    }
    function lpx_create_index(lp) {
        glp_create_index(lp);
    }
    function lpx_find_row(lp, name) {
        return glp_find_row(lp, name);
    }
    function lpx_find_col(lp, name) {
        return glp_find_col(lp, name);
    }
    function lpx_delete_index(lp) {
        glp_delete_index(lp);
    }
    function lpx_scale_prob(lp) {
        switch (lpx_get_int_parm(lp, LPX_K_SCALE)) {
        case 0:
            glp_unscale_prob(lp);
            break;
        case 1:
            glp_scale_prob(lp, GLP_SF_EQ);
            break;
        case 2:
            glp_scale_prob(lp, GLP_SF_GM);
            break;
        case 3:
            glp_scale_prob(lp, GLP_SF_GM | GLP_SF_EQ);
            break;
        default:
            xassert(lp != lp);
        }
    }
    function lpx_unscale_prob(lp) {
        glp_unscale_prob(lp);
    }
    function lpx_set_row_stat(lp, i, stat) {
        glp_set_row_stat(lp, i, stat - LPX_BS + GLP_BS);
    }
    function lpx_set_col_stat(lp, j, stat) {
        glp_set_col_stat(lp, j, stat - LPX_BS + GLP_BS);
    }
    function lpx_std_basis(lp) {
        glp_std_basis(lp);
    }
    function lpx_adv_basis(lp) {
        glp_adv_basis(lp, 0);
    }
    function lpx_cpx_basis(lp) {
        glp_cpx_basis(lp);
    }
    function fill_smcp(lp, parm) {
        switch (lpx_get_int_parm(lp, LPX_K_MSGLEV)) {
        case 0:
            parm.msg_lev = GLP_MSG_OFF;
            break;
        case 1:
            parm.msg_lev = GLP_MSG_ERR;
            break;
        case 2:
            parm.msg_lev = GLP_MSG_ON;
            break;
        case 3:
            parm.msg_lev = GLP_MSG_ALL;
            break;
        default:
            xassert(lp != lp);
        }
        switch (lpx_get_int_parm(lp, LPX_K_DUAL)) {
        case 0:
            parm.meth = GLP_PRIMAL;
            break;
        case 1:
            parm.meth = GLP_DUAL;
            break;
        default:
            xassert(lp != lp);
        }
        switch (lpx_get_int_parm(lp, LPX_K_PRICE)) {
        case 0:
            parm.pricing = GLP_PT_STD;
            break;
        case 1:
            parm.pricing = GLP_PT_PSE;
            break;
        default:
            xassert(lp != lp);
        }
        if (lpx_get_real_parm(lp, LPX_K_RELAX) == 0)
            parm.r_test = GLP_RT_STD;
        else
            parm.r_test = GLP_RT_HAR;
        parm.tol_bnd = lpx_get_real_parm(lp, LPX_K_TOLBND);
        parm.tol_dj = lpx_get_real_parm(lp, LPX_K_TOLDJ);
        parm.tol_piv = lpx_get_real_parm(lp, LPX_K_TOLPIV);
        parm.obj_ll = lpx_get_real_parm(lp, LPX_K_OBJLL);
        parm.obj_ul = lpx_get_real_parm(lp, LPX_K_OBJUL);
        if (lpx_get_int_parm(lp, LPX_K_ITLIM) < 0)
            parm.it_lim = INT_MAX;
        else
            parm.it_lim = lpx_get_int_parm(lp, LPX_K_ITLIM);
        if (lpx_get_real_parm(lp, LPX_K_TMLIM) < 0)
            parm.tm_lim = INT_MAX;
        else
            parm.tm_lim = 1000 * lpx_get_real_parm(lp, LPX_K_TMLIM) | 0;
        parm.out_frq = lpx_get_int_parm(lp, LPX_K_OUTFRQ);
        parm.out_dly = 1000 * lpx_get_real_parm(lp, LPX_K_OUTDLY) | 0;
        switch (lpx_get_int_parm(lp, LPX_K_PRESOL)) {
        case 0:
            parm.presolve = GLP_OFF;
            break;
        case 1:
            parm.presolve = GLP_ON;
            break;
        default:
            xassert(lp != lp);
        }
    }
    function lpx_simplex(lp) {
        var parm = new SMCP();
        var ret;
        fill_smcp(lp, parm);
        ret = glp_simplex(lp, parm);
        switch (ret) {
        case 0:
            ret = LPX_E_OK;
            break;
        case GLP_EBADB:
        case GLP_ESING:
        case GLP_ECOND:
        case GLP_EBOUND:
            ret = LPX_E_FAULT;
            break;
        case GLP_EFAIL:
            ret = LPX_E_SING;
            break;
        case GLP_EOBJLL:
            ret = LPX_E_OBJLL;
            break;
        case GLP_EOBJUL:
            ret = LPX_E_OBJUL;
            break;
        case GLP_EITLIM:
            ret = LPX_E_ITLIM;
            break;
        case GLP_ETMLIM:
            ret = LPX_E_TMLIM;
            break;
        case GLP_ENOPFS:
            ret = LPX_E_NOPFS;
            break;
        case GLP_ENODFS:
            ret = LPX_E_NODFS;
            break;
        default:
            xassert(ret != ret);
        }
        return ret;
    }
    function lpx_exact(lp) {
        var parm = new SMCP();
        var ret;
        fill_smcp(lp, parm);
        ret = glp_exact(lp, parm);
        switch (ret) {
        case 0:
            ret = LPX_E_OK;
            break;
        case GLP_EBADB:
        case GLP_ESING:
        case GLP_EBOUND:
        case GLP_EFAIL:
            ret = LPX_E_FAULT;
            break;
        case GLP_EITLIM:
            ret = LPX_E_ITLIM;
            break;
        case GLP_ETMLIM:
            ret = LPX_E_TMLIM;
            break;
        default:
            xassert(ret != ret);
        }
        return ret;
    }
    function lpx_get_status(lp) {
        var status;
        switch (glp_get_status(lp)) {
        case GLP_OPT:
            status = LPX_OPT;
            break;
        case GLP_FEAS:
            status = LPX_FEAS;
            break;
        case GLP_INFEAS:
            status = LPX_INFEAS;
            break;
        case GLP_NOFEAS:
            status = LPX_NOFEAS;
            break;
        case GLP_UNBND:
            status = LPX_UNBND;
            break;
        case GLP_UNDEF:
            status = LPX_UNDEF;
            break;
        default:
            xassert(lp != lp);
        }
        return status;
    }
    function lpx_get_prim_stat(lp) {
        return glp_get_prim_stat(lp) - GLP_UNDEF + LPX_P_UNDEF;
    }
    function lpx_get_dual_stat(lp) {
        return glp_get_dual_stat(lp) - GLP_UNDEF + LPX_D_UNDEF;
    }
    function lpx_get_obj_val(lp) {
        return glp_get_obj_val(lp);
    }
    function lpx_get_row_stat(lp, i) {
        return glp_get_row_stat(lp, i) - GLP_BS + LPX_BS;
    }
    function lpx_get_row_prim(lp, i) {
        return glp_get_row_prim(lp, i);
    }
    function lpx_get_row_dual(lp, i) {
        return glp_get_row_dual(lp, i);
    }
    function lpx_get_row_info(lp, i, callback) {
        callback(lpx_get_row_stat(lp, i), lpx_get_row_prim(lp, i), lpx_get_row_dual(lp, i));
    }
    function lpx_get_col_stat(lp, j) {
        return glp_get_col_stat(lp, j) - GLP_BS + LPX_BS;
    }
    function lpx_get_col_prim(lp, j) {
        return glp_get_col_prim(lp, j);
    }
    function lpx_get_col_dual(lp, j) {
        return glp_get_col_dual(lp, j);
    }
    function lpx_get_col_info(lp, j, callback) {
        callback(lpx_get_col_stat(lp, j), lpx_get_col_prim(lp, j), lpx_get_col_dual(lp, j));
    }
    function lpx_get_ray_info(lp) {
        return glp_get_unbnd_ray(lp);
    }
    function lpx_check_kkt(lp, scaled, kkt) {
        xassert(scaled == scaled);
        glp_check_kkt(lp, GLP_SOL, GLP_KKT_PE, function (ae_max, ae_ind, re_max, re_ind) {
            kkt.pe_ae_max = ae_max;
            kkt.pe_ae_row = ae_ind;
            kkt.pe_re_max = re_max;
            kkt.pe_re_row = re_ind;
            if (re_max <= 1e-9)
                kkt.pe_quality = 'H';
            else if (re_max <= 0.000001)
                kkt.pe_quality = 'M';
            else if (re_max <= 0.001)
                kkt.pe_quality = 'L';
            else
                kkt.pe_quality = '?';
        });
        glp_check_kkt(lp, GLP_SOL, GLP_KKT_PB, function (ae_max, ae_ind, re_max, re_ind) {
            kkt.pb_ae_max = ae_max;
            kkt.pb_ae_ind = ae_ind;
            kkt.pb_re_max = re_max;
            kkt.pb_re_ind = re_ind;
            if (re_max <= 1e-9)
                kkt.pb_quality = 'H';
            else if (re_max <= 0.000001)
                kkt.pb_quality = 'M';
            else if (re_max <= 0.001)
                kkt.pb_quality = 'L';
            else
                kkt.pb_quality = '?';
        });
        glp_check_kkt(lp, GLP_SOL, GLP_KKT_DE, function (ae_max, ae_ind, re_max, re_ind) {
            kkt.de_ae_max = ae_max;
            if (ae_ind == 0)
                kkt.de_ae_col = 0;
            else
                kkt.de_ae_col = ae_ind - lp.m;
            kkt.de_re_max = re_max;
            if (re_ind == 0)
                kkt.de_re_col = 0;
            else
                kkt.de_re_col = ae_ind - lp.m;
            if (re_max <= 1e-9)
                kkt.de_quality = 'H';
            else if (re_max <= 0.000001)
                kkt.de_quality = 'M';
            else if (re_max <= 0.001)
                kkt.de_quality = 'L';
            else
                kkt.de_quality = '?';
        });
        glp_check_kkt(lp, GLP_SOL, GLP_KKT_DB, function (ae_max, ae_ind, re_max, re_ind) {
            kkt.db_ae_max = ae_max;
            kkt.db_ae_ind = ae_ind;
            kkt.db_re_max = re_max;
            kkt.db_re_ind = re_ind;
            if (re_max <= 1e-9)
                kkt.db_quality = 'H';
            else if (re_max <= 0.000001)
                kkt.db_quality = 'M';
            else if (re_max <= 0.001)
                kkt.db_quality = 'L';
            else
                kkt.db_quality = '?';
            kkt.cs_ae_max = 0;
            kkt.cs_ae_ind = 0;
            kkt.cs_re_max = 0;
            kkt.cs_re_ind = 0;
            kkt.cs_quality = 'H';
        });
    }
    function lpx_warm_up(lp) {
        var ret = glp_warm_up(lp);
        if (ret == 0)
            ret = LPX_E_OK;
        else if (ret == GLP_EBADB)
            ret = LPX_E_BADB;
        else if (ret == GLP_ESING)
            ret = LPX_E_SING;
        else if (ret == GLP_ECOND)
            ret = LPX_E_SING;
        else
            xassert(ret != ret);
        return ret;
    }
    function lpx_eval_tab_row(lp, k, ind, val) {
        return glp_eval_tab_row(lp, k, ind, val);
    }
    function lpx_eval_tab_col(lp, k, ind, val) {
        return glp_eval_tab_col(lp, k, ind, val);
    }
    function lpx_transform_row(lp, len, ind, val) {
        return glp_transform_row(lp, len, ind, val);
    }
    function lpx_transform_col(lp, len, ind, val) {
        return glp_transform_col(lp, len, ind, val);
    }
    function lpx_prim_ratio_test(lp, len, ind, val, how, tol) {
        var piv = glp_prim_rtest(lp, len, ind, val, how, tol);
        xassert(0 <= piv && piv <= len);
        return piv == 0 ? 0 : ind[piv];
    }
    function lpx_dual_ratio_test(lp, len, ind, val, how, tol) {
        var piv = glp_dual_rtest(lp, len, ind, val, how, tol);
        xassert(0 <= piv && piv <= len);
        return piv == 0 ? 0 : ind[piv];
    }
    function lpx_interior(lp) {
        var ret = glp_interior(lp, null);
        switch (ret) {
        case 0:
            ret = LPX_E_OK;
            break;
        case GLP_EFAIL:
            ret = LPX_E_FAULT;
            break;
        case GLP_ENOFEAS:
            ret = LPX_E_NOFEAS;
            break;
        case GLP_ENOCVG:
            ret = LPX_E_NOCONV;
            break;
        case GLP_EITLIM:
            ret = LPX_E_ITLIM;
            break;
        case GLP_EINSTAB:
            ret = LPX_E_INSTAB;
            break;
        default:
            xassert(ret != ret);
        }
        return ret;
    }
    function lpx_ipt_status(lp) {
        var status;
        switch (glp_ipt_status(lp)) {
        case GLP_UNDEF:
            status = LPX_T_UNDEF;
            break;
        case GLP_OPT:
            status = LPX_T_OPT;
            break;
        default:
            xassert(lp != lp);
        }
        return status;
    }
    function lpx_ipt_obj_val(lp) {
        return glp_ipt_obj_val(lp);
    }
    function lpx_ipt_row_prim(lp, i) {
        return glp_ipt_row_prim(lp, i);
    }
    function lpx_ipt_row_dual(lp, i) {
        return glp_ipt_row_dual(lp, i);
    }
    function lpx_ipt_col_prim(lp, j) {
        return glp_ipt_col_prim(lp, j);
    }
    function lpx_ipt_col_dual(lp, j) {
        return glp_ipt_col_dual(lp, j);
    }
    function lpx_set_class(lp, klass) {
        xassert(lp == lp);
        if (!(klass == LPX_LP || klass == LPX_MIP))
            xerror('lpx_set_class: invalid problem class');
    }
    function lpx_get_class(lp) {
        return glp_get_num_int(lp) == 0 ? LPX_LP : LPX_MIP;
    }
    function lpx_set_col_kind(lp, j, kind) {
        glp_set_col_kind(lp, j, kind - LPX_CV + GLP_CV);
    }
    function lpx_get_col_kind(lp, j) {
        return glp_get_col_kind(lp, j) == GLP_CV ? LPX_CV : LPX_IV;
    }
    function lpx_get_num_int(lp) {
        return glp_get_num_int(lp);
    }
    function lpx_get_num_bin(lp) {
        return glp_get_num_bin(lp);
    }
    function solve_mip(lp, presolve) {
        var parm = new IOCP();
        var ret;
        switch (lpx_get_int_parm(lp, LPX_K_MSGLEV)) {
        case 0:
            parm.msg_lev = GLP_MSG_OFF;
            break;
        case 1:
            parm.msg_lev = GLP_MSG_ERR;
            break;
        case 2:
            parm.msg_lev = GLP_MSG_ON;
            break;
        case 3:
            parm.msg_lev = GLP_MSG_ALL;
            break;
        default:
            xassert(lp != lp);
        }
        switch (lpx_get_int_parm(lp, LPX_K_BRANCH)) {
        case 0:
            parm.br_tech = GLP_BR_FFV;
            break;
        case 1:
            parm.br_tech = GLP_BR_LFV;
            break;
        case 2:
            parm.br_tech = GLP_BR_DTH;
            break;
        case 3:
            parm.br_tech = GLP_BR_MFV;
            break;
        default:
            xassert(lp != lp);
        }
        switch (lpx_get_int_parm(lp, LPX_K_BTRACK)) {
        case 0:
            parm.bt_tech = GLP_BT_DFS;
            break;
        case 1:
            parm.bt_tech = GLP_BT_BFS;
            break;
        case 2:
            parm.bt_tech = GLP_BT_BPH;
            break;
        case 3:
            parm.bt_tech = GLP_BT_BLB;
            break;
        default:
            xassert(lp != lp);
        }
        parm.tol_int = lpx_get_real_parm(lp, LPX_K_TOLINT);
        parm.tol_obj = lpx_get_real_parm(lp, LPX_K_TOLOBJ);
        if (lpx_get_real_parm(lp, LPX_K_TMLIM) < 0 || lpx_get_real_parm(lp, LPX_K_TMLIM) > 1000000)
            parm.tm_lim = INT_MAX;
        else
            parm.tm_lim = 1000 * lpx_get_real_parm(lp, LPX_K_TMLIM) | 0;
        parm.mip_gap = lpx_get_real_parm(lp, LPX_K_MIPGAP);
        if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_GOMORY)
            parm.gmi_cuts = GLP_ON;
        else
            parm.gmi_cuts = GLP_OFF;
        if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_MIR)
            parm.mir_cuts = GLP_ON;
        else
            parm.mir_cuts = GLP_OFF;
        if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_COVER)
            parm.cov_cuts = GLP_ON;
        else
            parm.cov_cuts = GLP_OFF;
        if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_CLIQUE)
            parm.clq_cuts = GLP_ON;
        else
            parm.clq_cuts = GLP_OFF;
        parm.presolve = presolve;
        if (lpx_get_int_parm(lp, LPX_K_BINARIZE))
            parm.binarize = GLP_ON;
        ret = glp_intopt(lp, parm);
        switch (ret) {
        case 0:
            ret = LPX_E_OK;
            break;
        case GLP_ENOPFS:
            ret = LPX_E_NOPFS;
            break;
        case GLP_ENODFS:
            ret = LPX_E_NODFS;
            break;
        case GLP_EBOUND:
        case GLP_EROOT:
            ret = LPX_E_FAULT;
            break;
        case GLP_EFAIL:
            ret = LPX_E_SING;
            break;
        case GLP_EMIPGAP:
            ret = LPX_E_MIPGAP;
            break;
        case GLP_ETMLIM:
            ret = LPX_E_TMLIM;
            break;
        default:
            xassert(ret != ret);
        }
        return ret;
    }
    function lpx_integer(lp) {
        return solve_mip(lp, GLP_OFF);
    }
    function lpx_intopt(lp) {
        return solve_mip(lp, GLP_ON);
    }
    function lpx_mip_status(lp) {
        var status;
        switch (glp_mip_status(lp)) {
        case GLP_UNDEF:
            status = LPX_I_UNDEF;
            break;
        case GLP_OPT:
            status = LPX_I_OPT;
            break;
        case GLP_FEAS:
            status = LPX_I_FEAS;
            break;
        case GLP_NOFEAS:
            status = LPX_I_NOFEAS;
            break;
        default:
            xassert(lp != lp);
        }
        return status;
    }
    function lpx_mip_obj_val(lp) {
        return glp_mip_obj_val(lp);
    }
    function lpx_mip_row_val(lp, i) {
        return glp_mip_row_val(lp, i);
    }
    function lpx_mip_col_val(lp, j) {
        return glp_mip_col_val(lp, j);
    }
    function lpx_check_int(lp, kkt) {
        glp_check_kkt(lp, GLP_MIP, GLP_KKT_PE, function (ae_max, ae_ind, re_max, re_ind) {
            kkt.pe_ae_max = ae_max;
            kkt.pe_ae_row = ae_ind;
            kkt.pe_re_max = re_max;
            kkt.pe_re_row = re_ind;
            if (re_max <= 1e-9)
                kkt.pe_quality = 'H';
            else if (re_max <= 0.000001)
                kkt.pe_quality = 'M';
            else if (re_max <= 0.001)
                kkt.pe_quality = 'L';
            else
                kkt.pe_quality = '?';
        });
        glp_check_kkt(lp, GLP_MIP, GLP_KKT_PB, function (ae_max, ae_ind, re_max, re_ind) {
            kkt.pb_ae_max = ae_max;
            kkt.pb_ae_ind = ae_ind;
            kkt.pb_re_max = re_max;
            kkt.pb_re_ind = re_ind;
            if (re_max <= 1e-9)
                kkt.pb_quality = 'H';
            else if (re_max <= 0.000001)
                kkt.pb_quality = 'M';
            else if (re_max <= 0.001)
                kkt.pb_quality = 'L';
            else
                kkt.pb_quality = '?';
        });
    }
    function reset_parms(lp) {
        var cps = lp.parms;
        xassert(cps != null);
        cps.msg_lev = 3;
        cps.scale = 1;
        cps.dual = 0;
        cps.price = 1;
        cps.relax = 0.07;
        cps.tol_bnd = 1e-7;
        cps.tol_dj = 1e-7;
        cps.tol_piv = 1e-9;
        cps.round = 0;
        cps.obj_ll = -DBL_MAX;
        cps.obj_ul = +DBL_MAX;
        cps.it_lim = -1;
        cps.tm_lim = -1;
        cps.out_frq = 200;
        cps.out_dly = 0;
        cps.branch = 2;
        cps.btrack = 3;
        cps.tol_int = 0.00001;
        cps.tol_obj = 1e-7;
        cps.mps_info = 1;
        cps.mps_obj = 2;
        cps.mps_orig = 0;
        cps.mps_wide = 1;
        cps.mps_free = 0;
        cps.mps_skip = 0;
        cps.lpt_orig = 0;
        cps.presol = 0;
        cps.binarize = 0;
        cps.use_cuts = 0;
        cps.mip_gap = 0;
    }
    function access_parms(lp) {
        if (lp.parms == null) {
            lp.parms = {};
            reset_parms(lp);
        }
        return lp.parms;
    }
    function lpx_reset_parms(lp) {
        access_parms(lp);
        reset_parms(lp);
    }
    function lpx_set_int_parm(lp, parm, val) {
        var cps = access_parms(lp);
        switch (parm) {
        case LPX_K_MSGLEV:
            if (!(0 <= val && val <= 3))
                xerror('lpx_set_int_parm: MSGLEV = ' + val + '; invalid value');
            cps.msg_lev = val;
            break;
        case LPX_K_SCALE:
            if (!(0 <= val && val <= 3))
                xerror('lpx_set_int_parm: SCALE = ' + val + '; invalid value');
            cps.scale = val;
            break;
        case LPX_K_DUAL:
            if (!(val == 0 || val == 1))
                xerror('lpx_set_int_parm: DUAL = ' + val + '; invalid value');
            cps.dual = val;
            break;
        case LPX_K_PRICE:
            if (!(val == 0 || val == 1))
                xerror('lpx_set_int_parm: PRICE = ' + val + '; invalid value');
            cps.price = val;
            break;
        case LPX_K_ROUND:
            if (!(val == 0 || val == 1))
                xerror('lpx_set_int_parm: ROUND = ' + val + '; invalid value');
            cps.round = val;
            break;
        case LPX_K_ITLIM:
            cps.it_lim = val;
            break;
        case LPX_K_ITCNT:
            lp.it_cnt = val;
            break;
        case LPX_K_OUTFRQ:
            if (!(val > 0))
                xerror('lpx_set_int_parm: OUTFRQ = ' + val + '; invalid value');
            cps.out_frq = val;
            break;
        case LPX_K_BRANCH:
            if (!(val == 0 || val == 1 || val == 2 || val == 3))
                xerror('lpx_set_int_parm: BRANCH = ' + val + '; invalid value');
            cps.branch = val;
            break;
        case LPX_K_BTRACK:
            if (!(val == 0 || val == 1 || val == 2 || val == 3))
                xerror('lpx_set_int_parm: BTRACK = ' + val + '; invalid value');
            cps.btrack = val;
            break;
        case LPX_K_MPSINFO:
            if (!(val == 0 || val == 1))
                xerror('lpx_set_int_parm: MPSINFO = ' + val + '; invalid value');
            cps.mps_info = val;
            break;
        case LPX_K_MPSOBJ:
            if (!(val == 0 || val == 1 || val == 2))
                xerror('lpx_set_int_parm: MPSOBJ = ' + val + '; invalid value');
            cps.mps_obj = val;
            break;
        case LPX_K_MPSORIG:
            if (!(val == 0 || val == 1))
                xerror('lpx_set_int_parm: MPSORIG = ' + val + '; invalid value');
            cps.mps_orig = val;
            break;
        case LPX_K_MPSWIDE:
            if (!(val == 0 || val == 1))
                xerror('lpx_set_int_parm: MPSWIDE = ' + val + '; invalid value');
            cps.mps_wide = val;
            break;
        case LPX_K_MPSFREE:
            if (!(val == 0 || val == 1))
                xerror('lpx_set_int_parm: MPSFREE = ' + val + '; invalid value');
            cps.mps_free = val;
            break;
        case LPX_K_MPSSKIP:
            if (!(val == 0 || val == 1))
                xerror('lpx_set_int_parm: MPSSKIP = ' + val + '; invalid value');
            cps.mps_skip = val;
            break;
        case LPX_K_LPTORIG:
            if (!(val == 0 || val == 1))
                xerror('lpx_set_int_parm: LPTORIG = ' + val + '; invalid value');
            cps.lpt_orig = val;
            break;
        case LPX_K_PRESOL:
            if (!(val == 0 || val == 1))
                xerror('lpx_set_int_parm: PRESOL = ' + val + '; invalid value');
            cps.presol = val;
            break;
        case LPX_K_BINARIZE:
            if (!(val == 0 || val == 1))
                xerror('lpx_set_int_parm: BINARIZE = ' + val + '; invalid value');
            cps.binarize = val;
            break;
        case LPX_K_USECUTS:
            if (val & ~LPX_C_ALL)
                xerror('lpx_set_int_parm: USECUTS = ' + val + '; invalid value');
            cps.use_cuts = val;
            break;
        case LPX_K_BFTYPE: {
                parm = {};
                glp_get_bfcp(lp, parm);
                switch (val) {
                case 1:
                    parm.type = GLP_BF_FT;
                    break;
                case 2:
                    parm.type = GLP_BF_BG;
                    break;
                case 3:
                    parm.type = GLP_BF_GR;
                    break;
                default:
                    xerror('lpx_set_int_parm: BFTYPE = ' + val + '; invalid value');
                }
                glp_set_bfcp(lp, parm);
            }
            break;
        default:
            xerror('lpx_set_int_parm: parm = ' + parm + '; invalid parameter');
        }
    }
    function lpx_get_int_parm(lp, parm) {
        var cps = access_parms(lp);
        var val = 0;
        switch (parm) {
        case LPX_K_MSGLEV:
            val = cps.msg_lev;
            break;
        case LPX_K_SCALE:
            val = cps.scale;
            break;
        case LPX_K_DUAL:
            val = cps.dual;
            break;
        case LPX_K_PRICE:
            val = cps.price;
            break;
        case LPX_K_ROUND:
            val = cps.round;
            break;
        case LPX_K_ITLIM:
            val = cps.it_lim;
            break;
        case LPX_K_ITCNT:
            val = lp.it_cnt;
            break;
        case LPX_K_OUTFRQ:
            val = cps.out_frq;
            break;
        case LPX_K_BRANCH:
            val = cps.branch;
            break;
        case LPX_K_BTRACK:
            val = cps.btrack;
            break;
        case LPX_K_MPSINFO:
            val = cps.mps_info;
            break;
        case LPX_K_MPSOBJ:
            val = cps.mps_obj;
            break;
        case LPX_K_MPSORIG:
            val = cps.mps_orig;
            break;
        case LPX_K_MPSWIDE:
            val = cps.mps_wide;
            break;
        case LPX_K_MPSFREE:
            val = cps.mps_free;
            break;
        case LPX_K_MPSSKIP:
            val = cps.mps_skip;
            break;
        case LPX_K_LPTORIG:
            val = cps.lpt_orig;
            break;
        case LPX_K_PRESOL:
            val = cps.presol;
            break;
        case LPX_K_BINARIZE:
            val = cps.binarize;
            break;
        case LPX_K_USECUTS:
            val = cps.use_cuts;
            break;
        case LPX_K_BFTYPE: {
                parm = {};
                glp_get_bfcp(lp, parm);
                switch (parm.type) {
                case GLP_BF_FT:
                    val = 1;
                    break;
                case GLP_BF_BG:
                    val = 2;
                    break;
                case GLP_BF_GR:
                    val = 3;
                    break;
                default:
                    xassert(lp != lp);
                }
            }
            break;
        default:
            xerror('lpx_get_int_parm: parm = ' + parm + '; invalid parameter');
        }
        return val;
    }
    function lpx_set_real_parm(lp, parm, val) {
        var cps = access_parms(lp);
        switch (parm) {
        case LPX_K_RELAX:
            if (!(0 <= val && val <= 1))
                xerror('lpx_set_real_parm: RELAX = ' + val + '; invalid value');
            cps.relax = val;
            break;
        case LPX_K_TOLBND:
            if (!(DBL_EPSILON <= val && val <= 0.001))
                xerror('lpx_set_real_parm: TOLBND = ' + val + '; invalid value');
            cps.tol_bnd = val;
            break;
        case LPX_K_TOLDJ:
            if (!(DBL_EPSILON <= val && val <= 0.001))
                xerror('lpx_set_real_parm: TOLDJ = ' + val + '; invalid value');
            cps.tol_dj = val;
            break;
        case LPX_K_TOLPIV:
            if (!(DBL_EPSILON <= val && val <= 0.001))
                xerror('lpx_set_real_parm: TOLPIV = ' + val + '; invalid value');
            cps.tol_piv = val;
            break;
        case LPX_K_OBJLL:
            cps.obj_ll = val;
            break;
        case LPX_K_OBJUL:
            cps.obj_ul = val;
            break;
        case LPX_K_TMLIM:
            cps.tm_lim = val;
            break;
        case LPX_K_OUTDLY:
            cps.out_dly = val;
            break;
        case LPX_K_TOLINT:
            if (!(DBL_EPSILON <= val && val <= 0.001))
                xerror('lpx_set_real_parm: TOLINT = ' + val + '; invalid value');
            cps.tol_int = val;
            break;
        case LPX_K_TOLOBJ:
            if (!(DBL_EPSILON <= val && val <= 0.001))
                xerror('lpx_set_real_parm: TOLOBJ = ' + val + '; invalid value');
            cps.tol_obj = val;
            break;
        case LPX_K_MIPGAP:
            if (val < 0)
                xerror('lpx_set_real_parm: MIPGAP = ' + val + '; invalid value');
            cps.mip_gap = val;
            break;
        default:
            xerror('lpx_set_real_parm: parm = ' + parm + '; invalid parameter');
        }
    }
    function lpx_get_real_parm(lp, parm) {
        var cps = access_parms(lp);
        var val = 0;
        switch (parm) {
        case LPX_K_RELAX:
            val = cps.relax;
            break;
        case LPX_K_TOLBND:
            val = cps.tol_bnd;
            break;
        case LPX_K_TOLDJ:
            val = cps.tol_dj;
            break;
        case LPX_K_TOLPIV:
            val = cps.tol_piv;
            break;
        case LPX_K_OBJLL:
            val = cps.obj_ll;
            break;
        case LPX_K_OBJUL:
            val = cps.obj_ul;
            break;
        case LPX_K_TMLIM:
            val = cps.tm_lim;
            break;
        case LPX_K_OUTDLY:
            val = cps.out_dly;
            break;
        case LPX_K_TOLINT:
            val = cps.tol_int;
            break;
        case LPX_K_TOLOBJ:
            val = cps.tol_obj;
            break;
        case LPX_K_MIPGAP:
            val = cps.mip_gap;
            break;
        default:
            xerror('lpx_get_real_parm: parm = ' + parm + '; invalid parameter');
        }
        return val;
    }
    function lpx_read_mps(fname) {
        var lp = lpx_create_prob();
        if (glp_read_mps(lp, GLP_MPS_DECK, null, fname)) {
            lp = null;
        }
        return lp;
    }
    function lpx_write_mps(lp, fname) {
        return glp_write_mps(lp, GLP_MPS_DECK, null, fname);
    }
    function lpx_read_bas(lp, fname) {
        xassert(lp == lp);
        xassert(fname == fname);
        xerror('lpx_read_bas: operation not supported');
        return 0;
    }
    function lpx_write_bas(lp, fname) {
        xassert(lp == lp);
        xassert(fname == fname);
        xerror('lpx_write_bas: operation not supported');
        return 0;
    }
    function lpx_read_freemps(fname) {
        var lp = lpx_create_prob();
        if (glp_read_mps(lp, GLP_MPS_FILE, null, fname)) {
            lp = null;
        }
        return lp;
    }
    function lpx_write_freemps(lp, fname) {
        return glp_write_mps(lp, GLP_MPS_FILE, null, fname);
    }
    function lpx_read_cpxlp(fname) {
        var lp = lpx_create_prob();
        if (glp_read_lp(lp, null, fname)) {
            lp = null;
        }
        return lp;
    }
    function lpx_write_cpxlp(lp, fname) {
        return glp_write_lp(lp, null, fname);
    }
    function lpx_read_model(model, data, output, tablecb) {
        var lp = null;
        var tran = glp_mpl_alloc_wksp();
        if (glp_mpl_read_model(tran, model, data != null))
            return done();
        if (data != null)
            if (glp_mpl_read_data(tran, data))
                return done();
        if (glp_mpl_generate(tran, output, tablecb))
            return done();
        lp = glp_create_prob();
        glp_mpl_build_prob(tran, lp);
        function done() {
            return lp;
        }
        return done();
    }
    function lpx_print_prob(lp, fname) {
        return glp_write_lp(lp, null, fname);
    }
    function lpx_print_sol(lp, fname) {
        return glp_print_sol(lp, fname);
    }
    function lpx_print_sens_bnds(lp, fname) {
        if (glp_get_status(lp) == GLP_OPT && !glp_bf_exists(lp))
            glp_factorize(lp);
        return glp_print_ranges(lp, 0, null, 0, fname);
    }
    function lpx_print_ips(lp, fname) {
        return glp_print_ipt(lp, fname);
    }
    function lpx_print_mip(lp, fname) {
        return glp_print_mip(lp, fname);
    }
    function lpx_is_b_avail(lp) {
        return glp_bf_exists(lp);
    }
    function lpx_main(argc, argv) {
        return glp_main(argc, argv);
    }
    var LUF_ESING = 1, LUF_ECOND = 2;
    function luf_create_it() {
        var luf = {};
        luf.n_max = luf.n = 0;
        luf.valid = 0;
        luf.fr_ptr = luf.fr_len = null;
        luf.fc_ptr = luf.fc_len = null;
        luf.vr_ptr = luf.vr_len = luf.vr_cap = null;
        luf.vr_piv = null;
        luf.vc_ptr = luf.vc_len = luf.vc_cap = null;
        luf.pp_row = luf.pp_col = null;
        luf.qq_row = luf.qq_col = null;
        luf.sv_size = 0;
        luf.sv_beg = luf.sv_end = 0;
        luf.sv_ind = null;
        luf.sv_val = null;
        luf.sv_head = luf.sv_tail = 0;
        luf.sv_prev = luf.sv_next = null;
        luf.vr_max = null;
        luf.rs_head = luf.rs_prev = luf.rs_next = null;
        luf.cs_head = luf.cs_prev = luf.cs_next = null;
        luf.flag = null;
        luf.work = null;
        luf.new_sva = 0;
        luf.piv_tol = 0.1;
        luf.piv_lim = 4;
        luf.suhl = 1;
        luf.eps_tol = 1e-15;
        luf.max_gro = 10000000000;
        luf.nnz_a = luf.nnz_f = luf.nnz_v = 0;
        luf.max_a = luf.big_v = 0;
        luf.rank = 0;
        return luf;
    }
    function luf_defrag_sva(luf) {
        var n = luf.n;
        var vr_ptr = luf.vr_ptr;
        var vr_len = luf.vr_len;
        var vr_cap = luf.vr_cap;
        var vc_ptr = luf.vc_ptr;
        var vc_len = luf.vc_len;
        var vc_cap = luf.vc_cap;
        var sv_ind = luf.sv_ind;
        var sv_val = luf.sv_val;
        var sv_next = luf.sv_next;
        var sv_beg = 1;
        var i, j, k;
        for (k = luf.sv_head; k != 0; k = sv_next[k]) {
            if (k <= n) {
                i = k;
                if (vr_ptr[i] != sv_beg)
                    break;
                vr_cap[i] = vr_len[i];
                sv_beg += vr_cap[i];
            } else {
                j = k - n;
                if (vc_ptr[j] != sv_beg)
                    break;
                vc_cap[j] = vc_len[j];
                sv_beg += vc_cap[j];
            }
        }
        for (; k != 0; k = sv_next[k]) {
            if (k <= n) {
                i = k;
                xcopyArr(sv_ind, sv_beg, sv_ind, vr_ptr[i], vr_len[i]);
                xcopyArr(sv_val, sv_beg, sv_val, vr_ptr[i], vr_len[i]);
                vr_ptr[i] = sv_beg;
                vr_cap[i] = vr_len[i];
                sv_beg += vr_cap[i];
            } else {
                j = k - n;
                xcopyArr(sv_ind, sv_beg, sv_ind, vc_ptr[j], vc_len[j]);
                xcopyArr(sv_val, sv_beg, sv_val, vc_ptr[j], vc_len[j]);
                vc_ptr[j] = sv_beg;
                vc_cap[j] = vc_len[j];
                sv_beg += vc_cap[j];
            }
        }
        luf.sv_beg = sv_beg;
    }
    function luf_enlarge_row(luf, i, cap) {
        var n = luf.n;
        var vr_ptr = luf.vr_ptr;
        var vr_len = luf.vr_len;
        var vr_cap = luf.vr_cap;
        var vc_cap = luf.vc_cap;
        var sv_ind = luf.sv_ind;
        var sv_val = luf.sv_val;
        var sv_prev = luf.sv_prev;
        var sv_next = luf.sv_next;
        var ret = 0;
        var cur, k, kk;
        xassert(1 <= i && i <= n);
        xassert(vr_cap[i] < cap);
        if (luf.sv_end - luf.sv_beg < cap) {
            luf_defrag_sva(luf);
            if (luf.sv_end - luf.sv_beg < cap) {
                ret = 1;
                return ret;
            }
        }
        cur = vr_cap[i];
        xcopyArr(sv_ind, luf.sv_beg, sv_ind, vr_ptr[i], vr_len[i]);
        xcopyArr(sv_val, luf.sv_beg, sv_val, vr_ptr[i], vr_len[i]);
        vr_ptr[i] = luf.sv_beg;
        vr_cap[i] = cap;
        luf.sv_beg += cap;
        k = i;
        if (sv_prev[k] == 0)
            luf.sv_head = sv_next[k];
        else {
            kk = sv_prev[k];
            if (kk <= n)
                vr_cap[kk] += cur;
            else
                vc_cap[kk - n] += cur;
            sv_next[sv_prev[k]] = sv_next[k];
        }
        if (sv_next[k] == 0)
            luf.sv_tail = sv_prev[k];
        else
            sv_prev[sv_next[k]] = sv_prev[k];
        sv_prev[k] = luf.sv_tail;
        sv_next[k] = 0;
        if (sv_prev[k] == 0)
            luf.sv_head = k;
        else
            sv_next[sv_prev[k]] = k;
        luf.sv_tail = k;
        return ret;
    }
    function luf_enlarge_col(luf, j, cap) {
        var n = luf.n;
        var vr_cap = luf.vr_cap;
        var vc_ptr = luf.vc_ptr;
        var vc_len = luf.vc_len;
        var vc_cap = luf.vc_cap;
        var sv_ind = luf.sv_ind;
        var sv_val = luf.sv_val;
        var sv_prev = luf.sv_prev;
        var sv_next = luf.sv_next;
        var ret = 0;
        var cur, k, kk;
        xassert(1 <= j && j <= n);
        xassert(vc_cap[j] < cap);
        if (luf.sv_end - luf.sv_beg < cap) {
            luf_defrag_sva(luf);
            if (luf.sv_end - luf.sv_beg < cap) {
                ret = 1;
                return ret;
            }
        }
        cur = vc_cap[j];
        xcopyArr(sv_ind, luf.sv_beg, sv_ind, vc_ptr[j], vc_len[j]);
        xcopyArr(sv_val, luf.sv_beg, sv_val, vc_ptr[j], vc_len[j]);
        vc_ptr[j] = luf.sv_beg;
        vc_cap[j] = cap;
        luf.sv_beg += cap;
        k = n + j;
        if (sv_prev[k] == 0)
            luf.sv_head = sv_next[k];
        else {
            kk = sv_prev[k];
            if (kk <= n)
                vr_cap[kk] += cur;
            else
                vc_cap[kk - n] += cur;
            sv_next[sv_prev[k]] = sv_next[k];
        }
        if (sv_next[k] == 0)
            luf.sv_tail = sv_prev[k];
        else
            sv_prev[sv_next[k]] = sv_prev[k];
        sv_prev[k] = luf.sv_tail;
        sv_next[k] = 0;
        if (sv_prev[k] == 0)
            luf.sv_head = k;
        else
            sv_next[sv_prev[k]] = k;
        luf.sv_tail = k;
        return ret;
    }
    function reallocate(luf, n) {
        var n_max = luf.n_max;
        luf.n = n;
        if (n <= n_max)
            return;
        luf.n_max = n_max = n + 100;
        luf.fr_ptr = new Int32Array(1 + n_max);
        luf.fr_len = new Int32Array(1 + n_max);
        luf.fc_ptr = new Int32Array(1 + n_max);
        luf.fc_len = new Int32Array(1 + n_max);
        luf.vr_ptr = new Int32Array(1 + n_max);
        luf.vr_len = new Int32Array(1 + n_max);
        luf.vr_cap = new Int32Array(1 + n_max);
        luf.vr_piv = new Float64Array(1 + n_max);
        luf.vc_ptr = new Int32Array(1 + n_max);
        luf.vc_len = new Int32Array(1 + n_max);
        luf.vc_cap = new Int32Array(1 + n_max);
        luf.pp_row = new Int32Array(1 + n_max);
        luf.pp_col = new Int32Array(1 + n_max);
        luf.qq_row = new Int32Array(1 + n_max);
        luf.qq_col = new Int32Array(1 + n_max);
        luf.sv_prev = new Int32Array(1 + n_max + n_max);
        luf.sv_next = new Int32Array(1 + n_max + n_max);
        luf.vr_max = new Float64Array(1 + n_max);
        luf.rs_head = new Int32Array(1 + n_max);
        luf.rs_prev = new Int32Array(1 + n_max);
        luf.rs_next = new Int32Array(1 + n_max);
        luf.cs_head = new Int32Array(1 + n_max);
        luf.cs_prev = new Int32Array(1 + n_max);
        luf.cs_next = new Int32Array(1 + n_max);
        luf.flag = new Int32Array(1 + n_max);
        luf.work = new Float64Array(1 + n_max);
    }
    function initialize(luf, col, info) {
        var n = luf.n;
        var fc_ptr = luf.fc_ptr;
        var fc_len = luf.fc_len;
        var vr_ptr = luf.vr_ptr;
        var vr_len = luf.vr_len;
        var vr_cap = luf.vr_cap;
        var vc_ptr = luf.vc_ptr;
        var vc_len = luf.vc_len;
        var vc_cap = luf.vc_cap;
        var pp_row = luf.pp_row;
        var pp_col = luf.pp_col;
        var qq_row = luf.qq_row;
        var qq_col = luf.qq_col;
        var sv_ind = luf.sv_ind;
        var sv_val = luf.sv_val;
        var sv_prev = luf.sv_prev;
        var sv_next = luf.sv_next;
        var vr_max = luf.vr_max;
        var rs_head = luf.rs_head;
        var rs_prev = luf.rs_prev;
        var rs_next = luf.rs_next;
        var cs_head = luf.cs_head;
        var cs_prev = luf.cs_prev;
        var cs_next = luf.cs_next;
        var flag = luf.flag;
        var work = luf.work;
        var ret = 0;
        var i, i_ptr, j, j_beg, j_end, k, len, nnz, sv_beg, sv_end, ptr;
        var big, val;
        sv_beg = 1;
        sv_end = luf.sv_size + 1;
        for (j = 1; j <= n; j++) {
            fc_ptr[j] = sv_end;
            fc_len[j] = 0;
        }
        for (i = 1; i <= n; i++)
            vr_len[i] = vr_cap[i] = 0, flag[i] = 0;
        nnz = 0;
        big = 0;
        for (j = 1; j <= n; j++) {
            var rn = pp_row;
            var aj = work;
            len = col(info, j, rn, aj);
            if (!(0 <= len && len <= n))
                xerror('luf_factorize: j = ' + j + '; len = ' + len + '; invalid column length');
            if (sv_end - sv_beg < len) {
                ret = 1;
                return ret;
            }
            vc_ptr[j] = sv_beg;
            vc_len[j] = vc_cap[j] = len;
            nnz += len;
            for (ptr = 1; ptr <= len; ptr++) {
                i = rn[ptr];
                val = aj[ptr];
                if (!(1 <= i && i <= n))
                    xerror('luf_factorize: i = ' + i + '; j = ' + j + '; invalid row index');
                if (flag[i])
                    xerror('luf_factorize: i = ' + i + '; j = ' + j + '; duplicate element not allowed');
                if (val == 0)
                    xerror('luf_factorize: i = ' + i + '; j = ' + j + '; zero element not allowed');
                sv_ind[sv_beg] = i;
                sv_val[sv_beg] = val;
                sv_beg++;
                if (val < 0)
                    val = -val;
                if (big < val)
                    big = val;
                flag[i] = 1;
                vr_cap[i]++;
            }
            for (ptr = 1; ptr <= len; ptr++)
                flag[rn[ptr]] = 0;
        }
        for (i = 1; i <= n; i++) {
            len = vr_cap[i];
            if (sv_end - sv_beg < len) {
                ret = 1;
                return ret;
            }
            vr_ptr[i] = sv_beg;
            sv_beg += len;
        }
        for (j = 1; j <= n; j++) {
            j_beg = vc_ptr[j];
            j_end = j_beg + vc_len[j] - 1;
            for (k = j_beg; k <= j_end; k++) {
                i = sv_ind[k];
                val = sv_val[k];
                i_ptr = vr_ptr[i] + vr_len[i];
                sv_ind[i_ptr] = j;
                sv_val[i_ptr] = val;
                vr_len[i]++;
            }
        }
        for (k = 1; k <= n; k++)
            pp_row[k] = pp_col[k] = qq_row[k] = qq_col[k] = k;
        luf.sv_beg = sv_beg;
        luf.sv_end = sv_end;
        luf.sv_head = n + 1;
        luf.sv_tail = n;
        for (i = 1; i <= n; i++) {
            sv_prev[i] = i - 1;
            sv_next[i] = i + 1;
        }
        sv_prev[1] = n + n;
        sv_next[n] = 0;
        for (j = 1; j <= n; j++) {
            sv_prev[n + j] = n + j - 1;
            sv_next[n + j] = n + j + 1;
        }
        sv_prev[n + 1] = 0;
        sv_next[n + n] = 1;
        for (k = 1; k <= n; k++) {
            flag[k] = 0;
            work[k] = 0;
        }
        luf.nnz_a = nnz;
        luf.nnz_f = 0;
        luf.nnz_v = nnz;
        luf.max_a = big;
        luf.big_v = big;
        luf.rank = -1;
        for (i = 1; i <= n; i++)
            vr_max[i] = -1;
        for (len = 0; len <= n; len++)
            rs_head[len] = 0;
        for (i = 1; i <= n; i++) {
            len = vr_len[i];
            rs_prev[i] = 0;
            rs_next[i] = rs_head[len];
            if (rs_next[i] != 0)
                rs_prev[rs_next[i]] = i;
            rs_head[len] = i;
        }
        for (len = 0; len <= n; len++)
            cs_head[len] = 0;
        for (j = 1; j <= n; j++) {
            len = vc_len[j];
            cs_prev[j] = 0;
            cs_next[j] = cs_head[len];
            if (cs_next[j] != 0)
                cs_prev[cs_next[j]] = j;
            cs_head[len] = j;
        }
        return ret;
    }
    function find_pivot(luf, callback) {
        var n = luf.n;
        var vr_ptr = luf.vr_ptr;
        var vr_len = luf.vr_len;
        var vc_ptr = luf.vc_ptr;
        var vc_len = luf.vc_len;
        var sv_ind = luf.sv_ind;
        var sv_val = luf.sv_val;
        var vr_max = luf.vr_max;
        var rs_head = luf.rs_head;
        var rs_next = luf.rs_next;
        var cs_head = luf.cs_head;
        var cs_prev = luf.cs_prev;
        var cs_next = luf.cs_next;
        var piv_tol = luf.piv_tol;
        var piv_lim = luf.piv_lim;
        var suhl = luf.suhl;
        var p, q, len, i, i_beg, i_end, i_ptr, j, j_beg, j_end, j_ptr, ncand, next_j, min_p, min_q, min_len;
        var best, cost, big, temp;
        p = q = 0;
        best = DBL_MAX;
        ncand = 0;
        j = cs_head[1];
        if (j != 0) {
            xassert(vc_len[j] == 1);
            p = sv_ind[vc_ptr[j]];
            q = j;
            return done();
        }
        i = rs_head[1];
        if (i != 0) {
            xassert(vr_len[i] == 1);
            p = i;
            q = sv_ind[vr_ptr[i]];
            return done();
        }
        for (len = 2; len <= n; len++) {
            for (j = cs_head[len]; j != 0; j = next_j) {
                j_beg = vc_ptr[j];
                j_end = j_beg + vc_len[j] - 1;
                next_j = cs_next[j];
                min_p = min_q = 0;
                min_len = INT_MAX;
                for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++) {
                    i = sv_ind[j_ptr];
                    i_beg = vr_ptr[i];
                    i_end = i_beg + vr_len[i] - 1;
                    if (vr_len[i] >= min_len)
                        continue;
                    big = vr_max[i];
                    if (big < 0) {
                        for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++) {
                            temp = sv_val[i_ptr];
                            if (temp < 0)
                                temp = -temp;
                            if (big < temp)
                                big = temp;
                        }
                        vr_max[i] = big;
                    }
                    for (i_ptr = vr_ptr[i]; sv_ind[i_ptr] != j; i_ptr++) {
                    }
                    xassert(i_ptr <= i_end);
                    temp = sv_val[i_ptr];
                    if (temp < 0)
                        temp = -temp;
                    if (temp < piv_tol * big)
                        continue;
                    min_p = i;
                    min_q = j;
                    min_len = vr_len[i];
                    if (min_len <= len) {
                        p = min_p;
                        q = min_q;
                        return done();
                    }
                }
                if (min_p != 0) {
                    ncand++;
                    cost = (min_len - 1) * (len - 1);
                    if (cost < best) {
                        p = min_p;
                        q = min_q;
                        best = cost;
                    }
                    if (ncand == piv_lim)
                        return done();
                } else {
                    if (suhl) {
                        if (cs_prev[j] == 0)
                            cs_head[len] = cs_next[j];
                        else
                            cs_next[cs_prev[j]] = cs_next[j];
                        if (cs_next[j] == 0) {
                        } else
                            cs_prev[cs_next[j]] = cs_prev[j];
                        cs_prev[j] = cs_next[j] = j;
                    }
                }
            }
            for (i = rs_head[len]; i != 0; i = rs_next[i]) {
                i_beg = vr_ptr[i];
                i_end = i_beg + vr_len[i] - 1;
                big = vr_max[i];
                if (big < 0) {
                    for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++) {
                        temp = sv_val[i_ptr];
                        if (temp < 0)
                            temp = -temp;
                        if (big < temp)
                            big = temp;
                    }
                    vr_max[i] = big;
                }
                min_p = min_q = 0;
                min_len = INT_MAX;
                for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++) {
                    j = sv_ind[i_ptr];
                    if (vc_len[j] >= min_len)
                        continue;
                    temp = sv_val[i_ptr];
                    if (temp < 0)
                        temp = -temp;
                    if (temp < piv_tol * big)
                        continue;
                    min_p = i;
                    min_q = j;
                    min_len = vc_len[j];
                    if (min_len <= len) {
                        p = min_p;
                        q = min_q;
                        return done();
                    }
                }
                if (min_p != 0) {
                    ncand++;
                    cost = (len - 1) * (min_len - 1);
                    if (cost < best) {
                        p = min_p;
                        q = min_q;
                        best = cost;
                    }
                    if (ncand == piv_lim)
                        return done();
                } else {
                    xassert(min_p != min_p);
                }
            }
        }
        function done() {
            callback(p, q);
            return p == 0;
        }
        return done();
    }
    function eliminate(luf, p, q) {
        var n = luf.n;
        var fc_ptr = luf.fc_ptr;
        var fc_len = luf.fc_len;
        var vr_ptr = luf.vr_ptr;
        var vr_len = luf.vr_len;
        var vr_cap = luf.vr_cap;
        var vr_piv = luf.vr_piv;
        var vc_ptr = luf.vc_ptr;
        var vc_len = luf.vc_len;
        var vc_cap = luf.vc_cap;
        var sv_ind = luf.sv_ind;
        var sv_val = luf.sv_val;
        var sv_prev = luf.sv_prev;
        var sv_next = luf.sv_next;
        var vr_max = luf.vr_max;
        var rs_head = luf.rs_head;
        var rs_prev = luf.rs_prev;
        var rs_next = luf.rs_next;
        var cs_head = luf.cs_head;
        var cs_prev = luf.cs_prev;
        var cs_next = luf.cs_next;
        var flag = luf.flag;
        var work = luf.work;
        var eps_tol = luf.eps_tol;
        var ndx = luf.fr_len;
        var ret = 0;
        var len, fill, i, i_beg, i_end, i_ptr, j, j_beg, j_end, j_ptr, k, p_beg, p_end, p_ptr, q_beg, q_end, q_ptr;
        var fip, val, vpq, temp;
        xassert(1 <= p && p <= n);
        xassert(1 <= q && q <= n);
        if (rs_prev[p] == 0)
            rs_head[vr_len[p]] = rs_next[p];
        else
            rs_next[rs_prev[p]] = rs_next[p];
        if (rs_next[p] == 0) {
        } else
            rs_prev[rs_next[p]] = rs_prev[p];
        if (cs_prev[q] == 0)
            cs_head[vc_len[q]] = cs_next[q];
        else
            cs_next[cs_prev[q]] = cs_next[q];
        if (cs_next[q] == 0) {
        } else
            cs_prev[cs_next[q]] = cs_prev[q];
        p_beg = vr_ptr[p];
        p_end = p_beg + vr_len[p] - 1;
        for (p_ptr = p_beg; sv_ind[p_ptr] != q; p_ptr++) {
        }
        xassert(p_ptr <= p_end);
        vpq = vr_piv[p] = sv_val[p_ptr];
        sv_ind[p_ptr] = sv_ind[p_end];
        sv_val[p_ptr] = sv_val[p_end];
        vr_len[p]--;
        p_end--;
        q_beg = vc_ptr[q];
        q_end = q_beg + vc_len[q] - 1;
        for (q_ptr = q_beg; sv_ind[q_ptr] != p; q_ptr++) {
        }
        xassert(q_ptr <= q_end);
        sv_ind[q_ptr] = sv_ind[q_end];
        vc_len[q]--;
        q_end--;
        for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++) {
            j = sv_ind[p_ptr];
            flag[j] = 1;
            work[j] = sv_val[p_ptr];
            if (cs_prev[j] == 0)
                cs_head[vc_len[j]] = cs_next[j];
            else
                cs_next[cs_prev[j]] = cs_next[j];
            if (cs_next[j] == 0) {
            } else
                cs_prev[cs_next[j]] = cs_prev[j];
            j_beg = vc_ptr[j];
            j_end = j_beg + vc_len[j] - 1;
            for (j_ptr = j_beg; sv_ind[j_ptr] != p; j_ptr++) {
            }
            xassert(j_ptr <= j_end);
            sv_ind[j_ptr] = sv_ind[j_end];
            vc_len[j]--;
        }
        while (q_beg <= q_end) {
            i = sv_ind[q_beg];
            if (rs_prev[i] == 0)
                rs_head[vr_len[i]] = rs_next[i];
            else
                rs_next[rs_prev[i]] = rs_next[i];
            if (rs_next[i] == 0) {
            } else
                rs_prev[rs_next[i]] = rs_prev[i];
            i_beg = vr_ptr[i];
            i_end = i_beg + vr_len[i] - 1;
            for (i_ptr = i_beg; sv_ind[i_ptr] != q; i_ptr++) {
            }
            xassert(i_ptr <= i_end);
            fip = sv_val[i_ptr] / vpq;
            sv_ind[i_ptr] = sv_ind[i_end];
            sv_val[i_ptr] = sv_val[i_end];
            vr_len[i]--;
            i_end--;
            sv_ind[q_beg] = sv_ind[q_end];
            vc_len[q]--;
            q_end--;
            fill = vr_len[p];
            for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++) {
                j = sv_ind[i_ptr];
                if (flag[j]) {
                    temp = sv_val[i_ptr] -= fip * work[j];
                    if (temp < 0)
                        temp = -temp;
                    flag[j] = 0;
                    fill--;
                    if (temp == 0 || temp < eps_tol) {
                        sv_ind[i_ptr] = sv_ind[i_end];
                        sv_val[i_ptr] = sv_val[i_end];
                        vr_len[i]--;
                        i_ptr--;
                        i_end--;
                        j_beg = vc_ptr[j];
                        j_end = j_beg + vc_len[j] - 1;
                        for (j_ptr = j_beg; sv_ind[j_ptr] != i; j_ptr++) {
                        }
                        xassert(j_ptr <= j_end);
                        sv_ind[j_ptr] = sv_ind[j_end];
                        vc_len[j]--;
                    } else {
                        if (luf.big_v < temp)
                            luf.big_v = temp;
                    }
                }
            }
            if (vr_len[i] + fill > vr_cap[i]) {
                if (luf_enlarge_row(luf, i, vr_len[i] + fill)) {
                    ret = 1;
                    return ret;
                }
                p_beg = vr_ptr[p];
                p_end = p_beg + vr_len[p] - 1;
                q_beg = vc_ptr[q];
                q_end = q_beg + vc_len[q] - 1;
            }
            len = 0;
            for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++) {
                j = sv_ind[p_ptr];
                if (flag[j]) {
                    temp = val = -fip * work[j];
                    if (temp < 0)
                        temp = -temp;
                    if (temp == 0 || temp < eps_tol) {
                    } else {
                        i_ptr = vr_ptr[i] + vr_len[i];
                        sv_ind[i_ptr] = j;
                        sv_val[i_ptr] = val;
                        vr_len[i]++;
                        ndx[++len] = j;
                        if (luf.big_v < temp)
                            luf.big_v = temp;
                    }
                } else {
                    flag[j] = 1;
                }
            }
            for (k = 1; k <= len; k++) {
                j = ndx[k];
                if (vc_len[j] + 1 > vc_cap[j]) {
                    if (luf_enlarge_col(luf, j, vc_len[j] + 10)) {
                        ret = 1;
                        return ret;
                    }
                    p_beg = vr_ptr[p];
                    p_end = p_beg + vr_len[p] - 1;
                    q_beg = vc_ptr[q];
                    q_end = q_beg + vc_len[q] - 1;
                }
                j_ptr = vc_ptr[j] + vc_len[j];
                sv_ind[j_ptr] = i;
                vc_len[j]++;
            }
            rs_prev[i] = 0;
            rs_next[i] = rs_head[vr_len[i]];
            if (rs_next[i] != 0)
                rs_prev[rs_next[i]] = i;
            rs_head[vr_len[i]] = i;
            vr_max[i] = -1;
            if (luf.sv_end - luf.sv_beg < 1) {
                luf_defrag_sva(luf);
                if (luf.sv_end - luf.sv_beg < 1) {
                    ret = 1;
                    return ret;
                }
                p_beg = vr_ptr[p];
                p_end = p_beg + vr_len[p] - 1;
                q_beg = vc_ptr[q];
                q_end = q_beg + vc_len[q] - 1;
            }
            luf.sv_end--;
            sv_ind[luf.sv_end] = i;
            sv_val[luf.sv_end] = fip;
            fc_len[p]++;
        }
        xassert(vc_len[q] == 0);
        vc_cap[q] = 0;
        k = n + q;
        if (sv_prev[k] == 0)
            luf.sv_head = sv_next[k];
        else
            sv_next[sv_prev[k]] = sv_next[k];
        if (sv_next[k] == 0)
            luf.sv_tail = sv_prev[k];
        else
            sv_prev[sv_next[k]] = sv_prev[k];
        fc_ptr[p] = luf.sv_end;
        for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++) {
            j = sv_ind[p_ptr];
            flag[j] = 0;
            work[j] = 0;
            if (!(vc_len[j] != 1 && cs_prev[j] == j && cs_next[j] == j)) {
                cs_prev[j] = 0;
                cs_next[j] = cs_head[vc_len[j]];
                if (cs_next[j] != 0)
                    cs_prev[cs_next[j]] = j;
                cs_head[vc_len[j]] = j;
            }
        }
        return ret;
    }
    function build_v_cols(luf) {
        var n = luf.n;
        var vr_ptr = luf.vr_ptr;
        var vr_len = luf.vr_len;
        var vc_ptr = luf.vc_ptr;
        var vc_len = luf.vc_len;
        var vc_cap = luf.vc_cap;
        var sv_ind = luf.sv_ind;
        var sv_val = luf.sv_val;
        var sv_prev = luf.sv_prev;
        var sv_next = luf.sv_next;
        var ret = 0;
        var i, i_beg, i_end, i_ptr, j, j_ptr, k, nnz;
        nnz = 0;
        for (i = 1; i <= n; i++) {
            i_beg = vr_ptr[i];
            i_end = i_beg + vr_len[i] - 1;
            for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)
                vc_cap[sv_ind[i_ptr]]++;
            nnz += vr_len[i];
        }
        luf.nnz_v = nnz;
        if (luf.sv_end - luf.sv_beg < nnz) {
            ret = 1;
            return ret;
        }
        for (j = 1; j <= n; j++) {
            vc_ptr[j] = luf.sv_beg;
            luf.sv_beg += vc_cap[j];
        }
        for (i = 1; i <= n; i++) {
            i_beg = vr_ptr[i];
            i_end = i_beg + vr_len[i] - 1;
            for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++) {
                j = sv_ind[i_ptr];
                j_ptr = vc_ptr[j] + vc_len[j];
                sv_ind[j_ptr] = i;
                sv_val[j_ptr] = sv_val[i_ptr];
                vc_len[j]++;
            }
        }
        for (k = n + 1; k <= n + n; k++) {
            sv_prev[k] = k - 1;
            sv_next[k] = k + 1;
        }
        sv_prev[n + 1] = luf.sv_tail;
        sv_next[luf.sv_tail] = n + 1;
        sv_next[n + n] = 0;
        luf.sv_tail = n + n;
        return ret;
    }
    function build_f_rows(luf) {
        var n = luf.n;
        var fr_ptr = luf.fr_ptr;
        var fr_len = luf.fr_len;
        var fc_ptr = luf.fc_ptr;
        var fc_len = luf.fc_len;
        var sv_ind = luf.sv_ind;
        var sv_val = luf.sv_val;
        var ret = 0;
        var i, j, j_beg, j_end, j_ptr, ptr, nnz;
        for (i = 1; i <= n; i++)
            fr_len[i] = 0;
        nnz = 0;
        for (j = 1; j <= n; j++) {
            j_beg = fc_ptr[j];
            j_end = j_beg + fc_len[j] - 1;
            for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)
                fr_len[sv_ind[j_ptr]]++;
            nnz += fc_len[j];
        }
        luf.nnz_f = nnz;
        if (luf.sv_end - luf.sv_beg < nnz) {
            ret = 1;
            return ret;
        }
        for (i = 1; i <= n; i++) {
            fr_ptr[i] = luf.sv_end;
            luf.sv_end -= fr_len[i];
        }
        for (j = 1; j <= n; j++) {
            j_beg = fc_ptr[j];
            j_end = j_beg + fc_len[j] - 1;
            for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++) {
                i = sv_ind[j_ptr];
                ptr = --fr_ptr[i];
                sv_ind[ptr] = j;
                sv_val[ptr] = sv_val[j_ptr];
            }
        }
        return ret;
    }
    function luf_factorize(luf, n, col, info) {
        var pp_row, pp_col, qq_row, qq_col;
        var max_gro = luf.max_gro;
        var i, j, k, p, q, t, ret = null;
        if (n < 1)
            xerror('luf_factorize: n = ' + n + '; invalid parameter');
        if (n > N_MAX)
            xerror('luf_factorize: n = ' + n + '; matrix too big');
        luf.valid = 0;
        reallocate(luf, n);
        pp_row = luf.pp_row;
        pp_col = luf.pp_col;
        qq_row = luf.qq_row;
        qq_col = luf.qq_col;
        if (luf.sv_size == 0 && luf.new_sva == 0)
            luf.new_sva = 5 * (n + 10);
        function more() {
            if (luf.new_sva > 0) {
                luf.sv_size = luf.new_sva;
                luf.sv_ind = new Int32Array(1 + luf.sv_size);
                luf.sv_val = new Float64Array(1 + luf.sv_size);
                luf.new_sva = 0;
            }
            if (initialize(luf, col, info)) {
                luf.new_sva = luf.sv_size + luf.sv_size;
                xassert(luf.new_sva > luf.sv_size);
                return true;
            }
            for (k = 1; k <= n; k++) {
                if (find_pivot(luf, function (_p, _q) {
                        p = _p;
                        q = _q;
                    })) {
                    luf.rank = k - 1;
                    ret = LUF_ESING;
                    return false;
                }
                i = pp_col[p];
                j = qq_row[q];
                xassert(k <= i && i <= n && k <= j && j <= n);
                t = pp_row[k];
                pp_row[i] = t;
                pp_col[t] = i;
                pp_row[k] = p;
                pp_col[p] = k;
                t = qq_col[k];
                qq_col[j] = t;
                qq_row[t] = j;
                qq_col[k] = q;
                qq_row[q] = k;
                if (eliminate(luf, p, q)) {
                    luf.new_sva = luf.sv_size + luf.sv_size;
                    xassert(luf.new_sva > luf.sv_size);
                    return true;
                }
                if (luf.big_v > max_gro * luf.max_a) {
                    luf.rank = k - 1;
                    ret = LUF_ECOND;
                    return false;
                }
            }
            luf_defrag_sva(luf);
            if (build_v_cols(luf)) {
                luf.new_sva = luf.sv_size + luf.sv_size;
                xassert(luf.new_sva > luf.sv_size);
                return true;
            }
            if (build_f_rows(luf)) {
                luf.new_sva = luf.sv_size + luf.sv_size;
                xassert(luf.new_sva > luf.sv_size);
                return true;
            }
            return false;
        }
        while (more()) {
        }
        if (ret != null)
            return ret;
        luf.valid = 1;
        luf.rank = n;
        ret = 0;
        t = 3 * (n + luf.nnz_v) + 2 * luf.nnz_f;
        if (luf.sv_size < t) {
            luf.new_sva = luf.sv_size;
            while (luf.new_sva < t) {
                k = luf.new_sva;
                luf.new_sva = k + k;
                xassert(luf.new_sva > k);
            }
        }
        return ret;
    }
    function luf_f_solve(luf, tr, x) {
        var n = luf.n;
        var fr_ptr = luf.fr_ptr;
        var fr_len = luf.fr_len;
        var fc_ptr = luf.fc_ptr;
        var fc_len = luf.fc_len;
        var pp_row = luf.pp_row;
        var sv_ind = luf.sv_ind;
        var sv_val = luf.sv_val;
        var i, j, k, beg, end, ptr;
        var xk;
        if (!luf.valid)
            xerror('luf_f_solve: LU-factorization is not valid');
        if (!tr) {
            for (j = 1; j <= n; j++) {
                k = pp_row[j];
                xk = x[k];
                if (xk != 0) {
                    beg = fc_ptr[k];
                    end = beg + fc_len[k] - 1;
                    for (ptr = beg; ptr <= end; ptr++)
                        x[sv_ind[ptr]] -= sv_val[ptr] * xk;
                }
            }
        } else {
            for (i = n; i >= 1; i--) {
                k = pp_row[i];
                xk = x[k];
                if (xk != 0) {
                    beg = fr_ptr[k];
                    end = beg + fr_len[k] - 1;
                    for (ptr = beg; ptr <= end; ptr++)
                        x[sv_ind[ptr]] -= sv_val[ptr] * xk;
                }
            }
        }
    }
    function luf_v_solve(luf, tr, x) {
        var n = luf.n;
        var vr_ptr = luf.vr_ptr;
        var vr_len = luf.vr_len;
        var vr_piv = luf.vr_piv;
        var vc_ptr = luf.vc_ptr;
        var vc_len = luf.vc_len;
        var pp_row = luf.pp_row;
        var qq_col = luf.qq_col;
        var sv_ind = luf.sv_ind;
        var sv_val = luf.sv_val;
        var b = luf.work;
        var i, j, k, beg, end, ptr;
        var temp;
        if (!luf.valid)
            xerror('luf_v_solve: LU-factorization is not valid');
        for (k = 1; k <= n; k++) {
            b[k] = x[k];
            x[k] = 0;
        }
        if (!tr) {
            for (k = n; k >= 1; k--) {
                i = pp_row[k];
                j = qq_col[k];
                temp = b[i];
                if (temp != 0) {
                    x[j] = temp /= vr_piv[i];
                    beg = vc_ptr[j];
                    end = beg + vc_len[j] - 1;
                    for (ptr = beg; ptr <= end; ptr++)
                        b[sv_ind[ptr]] -= sv_val[ptr] * temp;
                }
            }
        } else {
            for (k = 1; k <= n; k++) {
                i = pp_row[k];
                j = qq_col[k];
                temp = b[j];
                if (temp != 0) {
                    x[i] = temp /= vr_piv[i];
                    beg = vr_ptr[i];
                    end = beg + vr_len[i] - 1;
                    for (ptr = beg; ptr <= end; ptr++)
                        b[sv_ind[ptr]] -= sv_val[ptr] * temp;
                }
            }
        }
    }
    function luf_a_solve(luf, tr, x) {
        if (!luf.valid)
            xerror('luf_a_solve: LU-factorization is not valid');
        if (!tr) {
            luf_f_solve(luf, 0, x);
            luf_v_solve(luf, 0, x);
        } else {
            luf_v_solve(luf, 1, x);
            luf_f_solve(luf, 1, x);
        }
    }
    var MPL_EOF = -1;
    var A_BINARY = 101, A_CHECK = 102, A_CONSTRAINT = 103, A_DISPLAY = 104, A_ELEMCON = 105, A_ELEMSET = 106, A_ELEMVAR = 107, A_EXPRESSION = 108, A_FOR = 109, A_FORMULA = 110, A_INDEX = 111, A_INPUT = 112, A_INTEGER = 113, A_LOGICAL = 114, A_MAXIMIZE = 115, A_MINIMIZE = 116, A_NONE = 117, A_NUMERIC = 118, A_OUTPUT = 119, A_PARAMETER = 120, A_PRINTF = 121, A_SET = 122, A_SOLVE = 123, A_SYMBOLIC = 124, A_TABLE = 125, A_TUPLE = 126, A_VARIABLE = 127;
    var CONTEXT_SIZE = 60;
    var OUTBUF_SIZE = 1024;
    var T_EOF = 201, T_NAME = 202, T_SYMBOL = 203, T_NUMBER = 204, T_STRING = 205, T_AND = 206, T_BY = 207, T_CROSS = 208, T_DIFF = 209, T_DIV = 210, T_ELSE = 211, T_IF = 212, T_IN = 213, T_INFINITY = 214, T_INTER = 215, T_LESS = 216, T_MOD = 217, T_NOT = 218, T_OR = 219, T_SPTP = 220, T_SYMDIFF = 221, T_THEN = 222, T_UNION = 223, T_WITHIN = 224, T_PLUS = 225, T_MINUS = 226, T_ASTERISK = 227, T_SLASH = 228, T_POWER = 229, T_LT = 230, T_LE = 231, T_EQ = 232, T_GE = 233, T_GT = 234, T_NE = 235, T_CONCAT = 236, T_BAR = 237, T_POINT = 238, T_COMMA = 239, T_COLON = 240, T_SEMICOLON = 241, T_ASSIGN = 242, T_DOTS = 243, T_LEFT = 244, T_RIGHT = 245, T_LBRACKET = 246, T_RBRACKET = 247, T_LBRACE = 248, T_RBRACE = 249, T_APPEND = 250, T_TILDE = 251, T_INPUT = 252;
    var DOT_NONE = 0, DOT_LB = 1, DOT_UB = 2, DOT_STATUS = 3, DOT_VAL = 4, DOT_DUAL = 5;
    var O_NUMBER = 301, O_STRING = 302, O_INDEX = 303, O_MEMNUM = 304, O_MEMSYM = 305, O_MEMSET = 306, O_MEMVAR = 307, O_MEMCON = 308, O_TUPLE = 309, O_MAKE = 310, O_SLICE = 311, O_IRAND224 = 312, O_UNIFORM01 = 313, O_NORMAL01 = 314, O_GMTIME = 315, O_CVTNUM = 316, O_CVTSYM = 317, O_CVTLOG = 318, O_CVTTUP = 319, O_CVTLFM = 320, O_PLUS = 321, O_MINUS = 322, O_NOT = 323, O_ABS = 324, O_CEIL = 325, O_FLOOR = 326, O_EXP = 327, O_LOG = 328, O_LOG10 = 329, O_SQRT = 330, O_SIN = 331, O_COS = 332, O_ATAN = 333, O_ROUND = 334, O_TRUNC = 335, O_CARD = 336, O_LENGTH = 337, O_ADD = 338, O_SUB = 339, O_LESS = 340, O_MUL = 341, O_DIV = 342, O_IDIV = 343, O_MOD = 344, O_POWER = 345, O_ATAN2 = 346, O_ROUND2 = 347, O_TRUNC2 = 348, O_UNIFORM = 349, O_NORMAL = 350, O_CONCAT = 351, O_LT = 352, O_LE = 353, O_EQ = 354, O_GE = 355, O_GT = 356, O_NE = 357, O_AND = 358, O_OR = 359, O_UNION = 360, O_DIFF = 361, O_SYMDIFF = 362, O_INTER = 363, O_CROSS = 364, O_IN = 365, O_NOTIN = 366, O_WITHIN = 367, O_NOTWITHIN = 368, O_SUBSTR = 369, O_STR2TIME = 370, O_TIME2STR = 371, O_DOTS = 372, O_FORK = 373, O_SUBSTR3 = 374, O_MIN = 375, O_MAX = 376, O_SUM = 377, O_PROD = 378, O_MINIMUM = 379, O_MAXIMUM = 380, O_FORALL = 381, O_EXISTS = 382, O_SETOF = 383, O_BUILD = 384;
    var MPL_FR = 401, MPL_LO = 402, MPL_UP = 403, MPL_DB = 404, MPL_FX = 405, MPL_ST = 411, MPL_MIN = 412, MPL_MAX = 413, MPL_NUM = 421, MPL_INT = 422, MPL_BIN = 423;
    function mpl_internal_create_operands() {
        return {
            index: {},
            par: {},
            set: {},
            var_: {},
            con: {},
            arg: {},
            loop: {}
        };
    }
    function mpl_internal_enter_context(mpl) {
        var image;
        if (mpl.token == T_EOF)
            image = '_|_';
        else if (mpl.token == T_STRING)
            image = '\'...\'';
        else
            image = mpl.image;
        xassert(0 <= mpl.c_ptr && mpl.c_ptr < CONTEXT_SIZE);
        mpl.context[mpl.c_ptr++] = ' ';
        if (mpl.c_ptr == CONTEXT_SIZE)
            mpl.c_ptr = 0;
        for (var s = 0; s < image.length; s++) {
            mpl.context[mpl.c_ptr++] = image[s];
            if (mpl.c_ptr == CONTEXT_SIZE)
                mpl.c_ptr = 0;
        }
    }
    function mpl_internal_print_context(mpl) {
        var c;
        while (mpl.c_ptr > 0) {
            mpl.c_ptr--;
            c = mpl.context[0];
            xcopyArr(mpl.context, 0, mpl.context, 1, CONTEXT_SIZE - 1);
            mpl.context[CONTEXT_SIZE - 1] = c;
        }
        xprintf('Context: ' + mpl.line + ' > ' + (mpl.context[0] == ' ' ? '' : '...') + mpl.context.join('').trim());
    }
    function mpl_internal_get_char(mpl) {
        var c;
        if (mpl.c == MPL_EOF)
            return;
        if (mpl.c == '\n') {
            mpl.line++;
            mpl.column = 0;
        }
        c = mpl_internal_read_char(mpl);
        mpl.column++;
        if (c == MPL_EOF) {
            if (mpl.c == '\n')
                mpl.line--;
            else
                mpl_internal_warning(mpl, 'final NL missing before end of file');
        } else if (c == '\n') {
        } else if (isspace(c))
            c = ' ';
        else if (iscntrl(c)) {
            mpl_internal_enter_context(mpl);
            mpl_internal_error(mpl, 'control character ' + c + ' not allowed');
        }
        mpl.c = c;
    }
    function mpl_internal_append_char(mpl) {
        xassert(0 <= mpl.imlen);
        mpl.image += mpl.c;
        mpl.imlen++;
        mpl_internal_get_char(mpl);
    }
    function mpl_internal_get_token(mpl) {
        function sptp() {
            mpl_internal_enter_context(mpl);
            mpl_internal_error(mpl, 'keyword s.t. incomplete');
        }
        function err() {
            mpl_internal_enter_context(mpl);
            mpl_internal_error(mpl, 'cannot convert numeric literal ' + mpl.image + ' to floating-point number');
        }
        function scanDecimal() {
            if (mpl.c == 'e' || mpl.c == 'E') {
                mpl_internal_append_char(mpl);
                if (mpl.c == '+' || mpl.c == '-')
                    mpl_internal_append_char(mpl);
                if (!isdigit(mpl.c)) {
                    mpl_internal_enter_context(mpl);
                    mpl_internal_error(mpl, 'numeric literal ' + mpl.image + ' incomplete');
                }
                while (isdigit(mpl.c))
                    mpl_internal_append_char(mpl);
            }
            if (isalpha(mpl.c) || mpl.c == '_') {
                mpl_internal_enter_context(mpl);
                mpl_internal_error(mpl, 'symbol ' + mpl.image + mpl.c + '... should be enclosed in quotes');
            }
        }
        mpl.b_token = mpl.token;
        mpl.b_imlen = mpl.imlen;
        mpl.b_image = mpl.image;
        mpl.b_value = mpl.value;
        if (mpl.f_scan) {
            mpl.f_scan = 0;
            mpl.token = mpl.f_token;
            mpl.imlen = mpl.f_imlen;
            mpl.image = mpl.f_image;
            mpl.value = mpl.f_value;
            return;
        }
        while (true) {
            mpl.token = 0;
            mpl.imlen = 0;
            mpl.image = '';
            mpl.value = 0;
            while (mpl.c == ' ' || mpl.c == '\n')
                mpl_internal_get_char(mpl);
            if (mpl.c == MPL_EOF) {
                mpl.token = T_EOF;
            } else if (mpl.c == '#') {
                while (mpl.c != '\n' && mpl.c != MPL_EOF)
                    mpl_internal_get_char(mpl);
                continue;
            } else if (!mpl.flag_d && (isalpha(mpl.c) || mpl.c == '_')) {
                mpl.token = T_NAME;
                while (isalnum(mpl.c) || mpl.c == '_')
                    mpl_internal_append_char(mpl);
                if (mpl.image == 'and')
                    mpl.token = T_AND;
                else if (mpl.image == 'by')
                    mpl.token = T_BY;
                else if (mpl.image == 'cross')
                    mpl.token = T_CROSS;
                else if (mpl.image == 'diff')
                    mpl.token = T_DIFF;
                else if (mpl.image == 'div')
                    mpl.token = T_DIV;
                else if (mpl.image == 'else')
                    mpl.token = T_ELSE;
                else if (mpl.image == 'if')
                    mpl.token = T_IF;
                else if (mpl.image == 'in')
                    mpl.token = T_IN;
                else if (mpl.image == 'Infinity')
                    mpl.token = T_INFINITY;
                else if (mpl.image == 'inter')
                    mpl.token = T_INTER;
                else if (mpl.image == 'less')
                    mpl.token = T_LESS;
                else if (mpl.image == 'mod')
                    mpl.token = T_MOD;
                else if (mpl.image == 'not')
                    mpl.token = T_NOT;
                else if (mpl.image == 'or')
                    mpl.token = T_OR;
                else if (mpl.image == 's' && mpl.c == '.') {
                    mpl.token = T_SPTP;
                    mpl_internal_append_char(mpl);
                    if (mpl.c != 't')
                        sptp();
                    mpl_internal_append_char(mpl);
                    if (mpl.c != '.')
                        sptp();
                    mpl_internal_append_char(mpl);
                } else if (mpl.image == 'symdiff')
                    mpl.token = T_SYMDIFF;
                else if (mpl.image == 'then')
                    mpl.token = T_THEN;
                else if (mpl.image == 'union')
                    mpl.token = T_UNION;
                else if (mpl.image == 'within')
                    mpl.token = T_WITHIN;
            } else if (!mpl.flag_d && isdigit(mpl.c)) {
                mpl.token = T_NUMBER;
                while (isdigit(mpl.c))
                    mpl_internal_append_char(mpl);
                var skip = false;
                if (mpl.c == '.') {
                    mpl_internal_append_char(mpl);
                    if (mpl.c == '.') {
                        mpl.imlen--;
                        mpl.image = mpl.image.substr(0, mpl.image.length - 1);
                        mpl.f_dots = 1;
                        skip = true;
                    } else {
                        while (isdigit(mpl.c))
                            mpl_internal_append_char(mpl);
                    }
                }
                if (!skip)
                    scanDecimal();
                if (str2num(mpl.image, function (v) {
                        mpl.value = v;
                    }))
                    err();
            } else if (mpl.c == '\'' || mpl.c == '"') {
                var quote = mpl.c;
                var triple = false;
                mpl.token = T_STRING;
                mpl_internal_get_char(mpl);
                function eat() {
                    for (;;) {
                        if (mpl.c == '\n' && !triple || mpl.c == MPL_EOF) {
                            mpl_internal_enter_context(mpl);
                            mpl_internal_error(mpl, 'unexpected end of line; string literal incomplete');
                        }
                        if (mpl.c == quote) {
                            mpl_internal_get_char(mpl);
                            if (mpl.c == quote) {
                                if (triple) {
                                    mpl_internal_get_char(mpl);
                                    if (mpl.c == quote) {
                                        mpl_internal_get_char(mpl);
                                        break;
                                    } else {
                                        mpl.image += '""';
                                        mpl.imlen += 2;
                                    }
                                }
                            } else {
                                if (triple) {
                                    mpl.image += '"';
                                    mpl.imlen++;
                                } else
                                    break;
                            }
                        }
                        mpl_internal_append_char(mpl);
                    }
                }
                if (mpl.c == quote) {
                    mpl_internal_get_char(mpl);
                    if (mpl.c == quote) {
                        triple = true;
                        mpl_internal_get_char(mpl);
                        eat();
                    } else {
                    }
                } else {
                    eat();
                }
            } else if (!mpl.flag_d && mpl.c == '+') {
                mpl.token = T_PLUS;
                mpl_internal_append_char(mpl);
            } else if (!mpl.flag_d && mpl.c == '-') {
                mpl.token = T_MINUS;
                mpl_internal_append_char(mpl);
            } else if (mpl.c == '*') {
                mpl.token = T_ASTERISK;
                mpl_internal_append_char(mpl);
                if (mpl.c == '*') {
                    mpl.token = T_POWER;
                    mpl_internal_append_char(mpl);
                }
            } else if (mpl.c == '/') {
                mpl.token = T_SLASH;
                mpl_internal_append_char(mpl);
                if (mpl.c == '*') {
                    mpl_internal_get_char(mpl);
                    for (;;) {
                        if (mpl.c == MPL_EOF) {
                            mpl_internal_error(mpl, 'unexpected end of file; comment sequence incomplete');
                        } else if (mpl.c == '*') {
                            mpl_internal_get_char(mpl);
                            if (mpl.c == '/')
                                break;
                        } else
                            mpl_internal_get_char(mpl);
                    }
                    mpl_internal_get_char(mpl);
                    continue;
                }
            } else if (mpl.c == '^') {
                mpl.token = T_POWER;
                mpl_internal_append_char(mpl);
            } else if (mpl.c == '<') {
                mpl.token = T_LT;
                mpl_internal_append_char(mpl);
                if (mpl.c == '=') {
                    mpl.token = T_LE;
                    mpl_internal_append_char(mpl);
                } else if (mpl.c == '>') {
                    mpl.token = T_NE;
                    mpl_internal_append_char(mpl);
                } else if (mpl.c == '-') {
                    mpl.token = T_INPUT;
                    mpl_internal_append_char(mpl);
                }
            } else if (mpl.c == '=') {
                mpl.token = T_EQ;
                mpl_internal_append_char(mpl);
                if (mpl.c == '=')
                    mpl_internal_append_char(mpl);
            } else if (mpl.c == '>') {
                mpl.token = T_GT;
                mpl_internal_append_char(mpl);
                if (mpl.c == '=') {
                    mpl.token = T_GE;
                    mpl_internal_append_char(mpl);
                } else if (mpl.c == '>') {
                    mpl.token = T_APPEND;
                    mpl_internal_append_char(mpl);
                }
            } else if (mpl.c == '!') {
                mpl.token = T_NOT;
                mpl_internal_append_char(mpl);
                if (mpl.c == '=') {
                    mpl.token = T_NE;
                    mpl_internal_append_char(mpl);
                }
            } else if (mpl.c == '&') {
                mpl.token = T_CONCAT;
                mpl_internal_append_char(mpl);
                if (mpl.c == '&') {
                    mpl.token = T_AND;
                    mpl_internal_append_char(mpl);
                }
            } else if (mpl.c == '|') {
                mpl.token = T_BAR;
                mpl_internal_append_char(mpl);
                if (mpl.c == '|') {
                    mpl.token = T_OR;
                    mpl_internal_append_char(mpl);
                }
            } else if (!mpl.flag_d && mpl.c == '.') {
                mpl.token = T_POINT;
                mpl_internal_append_char(mpl);
                if (mpl.f_dots) {
                    mpl.token = T_DOTS;
                    mpl.imlen = 2;
                    mpl.image = '..';
                    mpl.f_dots = 0;
                } else if (mpl.c == '.') {
                    mpl.token = T_DOTS;
                    mpl_internal_append_char(mpl);
                } else if (isdigit(mpl.c)) {
                    mpl.token = T_NUMBER;
                    mpl_internal_append_char(mpl);
                    while (isdigit(mpl.c))
                        mpl_internal_append_char(mpl);
                    scanDecimal();
                    if (str2num(mpl.image, function (v) {
                            mpl.value = v;
                        }))
                        err();
                }
            } else if (mpl.c == ',') {
                mpl.token = T_COMMA;
                mpl_internal_append_char(mpl);
            } else if (mpl.c == ':') {
                mpl.token = T_COLON;
                mpl_internal_append_char(mpl);
                if (mpl.c == '=') {
                    mpl.token = T_ASSIGN;
                    mpl_internal_append_char(mpl);
                }
            } else if (mpl.c == ';') {
                mpl.token = T_SEMICOLON;
                mpl_internal_append_char(mpl);
            } else if (mpl.c == '(') {
                mpl.token = T_LEFT;
                mpl_internal_append_char(mpl);
            } else if (mpl.c == ')') {
                mpl.token = T_RIGHT;
                mpl_internal_append_char(mpl);
            } else if (mpl.c == '[') {
                mpl.token = T_LBRACKET;
                mpl_internal_append_char(mpl);
            } else if (mpl.c == ']') {
                mpl.token = T_RBRACKET;
                mpl_internal_append_char(mpl);
            } else if (mpl.c == '{') {
                mpl.token = T_LBRACE;
                mpl_internal_append_char(mpl);
            } else if (mpl.c == '}') {
                mpl.token = T_RBRACE;
                mpl_internal_append_char(mpl);
            } else if (mpl.c == '~') {
                mpl.token = T_TILDE;
                mpl_internal_append_char(mpl);
            } else if (isalnum(mpl.c) || strchr('+-._', mpl.c) >= 0) {
                xassert(mpl.flag_d);
                mpl.token = T_SYMBOL;
                while (isalnum(mpl.c) || strchr('+-._', mpl.c) >= 0)
                    mpl_internal_append_char(mpl);
                switch (str2num(mpl.image, function (v) {
                        mpl.value = v;
                    })) {
                case 0:
                    mpl.token = T_NUMBER;
                    break;
                case 1:
                    err();
                    break;
                case 2:
                    break;
                default:
                    xassert(mpl != mpl);
                }
            } else {
                mpl_internal_enter_context(mpl);
                mpl_internal_error(mpl, 'character ' + mpl.c + ' not allowed');
            }
            break;
        }
        mpl_internal_enter_context(mpl);
        mpl.flag_x = 0;
    }
    function mpl_internal_unget_token(mpl) {
        xassert(!mpl.f_scan);
        mpl.f_scan = 1;
        mpl.f_token = mpl.token;
        mpl.f_imlen = mpl.imlen;
        mpl.f_image = mpl.image;
        mpl.f_value = mpl.value;
        mpl.token = mpl.b_token;
        mpl.imlen = mpl.b_imlen;
        mpl.image = mpl.b_image;
        mpl.value = mpl.b_value;
    }
    function mpl_internal_is_keyword(mpl, keyword) {
        return mpl.token == T_NAME && mpl.image == keyword;
    }
    function mpl_internal_is_reserved(mpl) {
        return mpl.token == T_AND && mpl.image[0] == 'a' || mpl.token == T_BY || mpl.token == T_CROSS || mpl.token == T_DIFF || mpl.token == T_DIV || mpl.token == T_ELSE || mpl.token == T_IF || mpl.token == T_IN || mpl.token == T_INTER || mpl.token == T_LESS || mpl.token == T_MOD || mpl.token == T_NOT && mpl.image[0] == 'n' || mpl.token == T_OR && mpl.image[0] == 'o' || mpl.token == T_SYMDIFF || mpl.token == T_THEN || mpl.token == T_UNION || mpl.token == T_WITHIN;
    }
    function mpl_internal_make_code(mpl, op, arg, type, dim) {
        var code = {};
        var domain;
        var block;
        var e;
        code.op = op;
        code.vflag = 0;
        code.arg = mpl_internal_create_operands();
        code.value = {};
        switch (op) {
        case O_NUMBER:
            code.arg.num = arg.num;
            break;
        case O_STRING:
            code.arg.str = arg.str;
            break;
        case O_INDEX:
            code.arg.index.slot = arg.index.slot;
            code.arg.index.next = arg.index.next;
            break;
        case O_MEMNUM:
        case O_MEMSYM:
            for (e = arg.par.list; e != null; e = e.next) {
                xassert(e.x != null);
                xassert(e.x.up == null);
                e.x.up = code;
                code.vflag |= e.x.vflag;
            }
            code.arg.par.par = arg.par.par;
            code.arg.par.list = arg.par.list;
            break;
        case O_MEMSET:
            for (e = arg.set.list; e != null; e = e.next) {
                xassert(e.x != null);
                xassert(e.x.up == null);
                e.x.up = code;
                code.vflag |= e.x.vflag;
            }
            code.arg.set.set = arg.set.set;
            code.arg.set.list = arg.set.list;
            break;
        case O_MEMVAR:
            for (e = arg.var_.list; e != null; e = e.next) {
                xassert(e.x != null);
                xassert(e.x.up == null);
                e.x.up = code;
                code.vflag |= e.x.vflag;
            }
            code.arg.var_.var_ = arg.var_.var_;
            code.arg.var_.list = arg.var_.list;
            code.arg.var_.suff = arg.var_.suff;
            break;
        case O_MEMCON:
            for (e = arg.con.list; e != null; e = e.next) {
                xassert(e.x != null);
                xassert(e.x.up == null);
                e.x.up = code;
                code.vflag |= e.x.vflag;
            }
            code.arg.con.con = arg.con.con;
            code.arg.con.list = arg.con.list;
            code.arg.con.suff = arg.con.suff;
            break;
        case O_TUPLE:
        case O_MAKE:
            for (e = arg.list; e != null; e = e.next) {
                xassert(e.x != null);
                xassert(e.x.up == null);
                e.x.up = code;
                code.vflag |= e.x.vflag;
            }
            code.arg.list = arg.list;
            break;
        case O_SLICE:
            xassert(arg.slice != null);
            code.arg.slice = arg.slice;
            break;
        case O_IRAND224:
        case O_UNIFORM01:
        case O_NORMAL01:
        case O_GMTIME:
            code.vflag = 1;
            break;
        case O_CVTNUM:
        case O_CVTSYM:
        case O_CVTLOG:
        case O_CVTTUP:
        case O_CVTLFM:
        case O_PLUS:
        case O_MINUS:
        case O_NOT:
        case O_ABS:
        case O_CEIL:
        case O_FLOOR:
        case O_EXP:
        case O_LOG:
        case O_LOG10:
        case O_SQRT:
        case O_SIN:
        case O_COS:
        case O_ATAN:
        case O_ROUND:
        case O_TRUNC:
        case O_CARD:
        case O_LENGTH:
            xassert(arg.arg.x != null);
            xassert(arg.arg.x.up == null);
            arg.arg.x.up = code;
            code.vflag |= arg.arg.x.vflag;
            code.arg.arg.x = arg.arg.x;
            break;
        case O_ADD:
        case O_SUB:
        case O_LESS:
        case O_MUL:
        case O_DIV:
        case O_IDIV:
        case O_MOD:
        case O_POWER:
        case O_ATAN2:
        case O_ROUND2:
        case O_TRUNC2:
        case O_UNIFORM:
            if (op == O_UNIFORM)
                code.vflag = 1;
        case O_NORMAL:
            if (op == O_NORMAL)
                code.vflag = 1;
        case O_CONCAT:
        case O_LT:
        case O_LE:
        case O_EQ:
        case O_GE:
        case O_GT:
        case O_NE:
        case O_AND:
        case O_OR:
        case O_UNION:
        case O_DIFF:
        case O_SYMDIFF:
        case O_INTER:
        case O_CROSS:
        case O_IN:
        case O_NOTIN:
        case O_WITHIN:
        case O_NOTWITHIN:
        case O_SUBSTR:
        case O_STR2TIME:
        case O_TIME2STR:
            xassert(arg.arg.x != null);
            xassert(arg.arg.x.up == null);
            arg.arg.x.up = code;
            code.vflag |= arg.arg.x.vflag;
            xassert(arg.arg.y != null);
            xassert(arg.arg.y.up == null);
            arg.arg.y.up = code;
            code.vflag |= arg.arg.y.vflag;
            code.arg.arg.x = arg.arg.x;
            code.arg.arg.y = arg.arg.y;
            break;
        case O_DOTS:
        case O_FORK:
        case O_SUBSTR3:
            xassert(arg.arg.x != null);
            xassert(arg.arg.x.up == null);
            arg.arg.x.up = code;
            code.vflag |= arg.arg.x.vflag;
            xassert(arg.arg.y != null);
            xassert(arg.arg.y.up == null);
            arg.arg.y.up = code;
            code.vflag |= arg.arg.y.vflag;
            if (arg.arg.z != null) {
                xassert(arg.arg.z.up == null);
                arg.arg.z.up = code;
                code.vflag |= arg.arg.z.vflag;
            }
            code.arg.arg.x = arg.arg.x;
            code.arg.arg.y = arg.arg.y;
            code.arg.arg.z = arg.arg.z;
            break;
        case O_MIN:
        case O_MAX:
            for (e = arg.list; e != null; e = e.next) {
                xassert(e.x != null);
                xassert(e.x.up == null);
                e.x.up = code;
                code.vflag |= e.x.vflag;
            }
            code.arg.list = arg.list;
            break;
        case O_SUM:
        case O_PROD:
        case O_MINIMUM:
        case O_MAXIMUM:
        case O_FORALL:
        case O_EXISTS:
        case O_SETOF:
        case O_BUILD:
            domain = arg.loop.domain;
            xassert(domain != null);
            if (domain.code != null) {
                xassert(domain.code.up == null);
                domain.code.up = code;
                code.vflag |= domain.code.vflag;
            }
            for (block = domain.list; block != null; block = block.next) {
                xassert(block.code != null);
                xassert(block.code.up == null);
                block.code.up = code;
                code.vflag |= block.code.vflag;
            }
            if (arg.loop.x != null) {
                xassert(arg.loop.x.up == null);
                arg.loop.x.up = code;
                code.vflag |= arg.loop.x.vflag;
            }
            code.arg.loop.domain = arg.loop.domain;
            code.arg.loop.x = arg.loop.x;
            break;
        default:
            xassert(op != op);
        }
        code.type = type;
        code.dim = dim;
        code.up = null;
        code.valid = 0;
        code.value = {};
        return code;
    }
    function mpl_internal_make_unary(mpl, op, x, type, dim) {
        var code;
        var arg = mpl_internal_create_operands();
        xassert(x != null);
        arg.arg.x = x;
        code = mpl_internal_make_code(mpl, op, arg, type, dim);
        return code;
    }
    function mpl_internal_make_binary(mpl, op, x, y, type, dim) {
        var code;
        var arg = mpl_internal_create_operands();
        xassert(x != null);
        xassert(y != null);
        arg.arg.x = x;
        arg.arg.y = y;
        code = mpl_internal_make_code(mpl, op, arg, type, dim);
        return code;
    }
    function mpl_internal_make_ternary(mpl, op, x, y, z, type, dim) {
        var code;
        var arg = mpl_internal_create_operands();
        xassert(x != null);
        xassert(y != null);
        arg.arg.x = x;
        arg.arg.y = y;
        arg.arg.z = z;
        code = mpl_internal_make_code(mpl, op, arg, type, dim);
        return code;
    }
    function mpl_internal_numeric_literal(mpl) {
        var code;
        var arg = mpl_internal_create_operands();
        xassert(mpl.token == T_NUMBER);
        arg.num = mpl.value;
        code = mpl_internal_make_code(mpl, O_NUMBER, arg, A_NUMERIC, 0);
        mpl_internal_get_token(mpl);
        return code;
    }
    function mpl_internal_string_literal(mpl) {
        var code;
        var arg = mpl_internal_create_operands();
        xassert(mpl.token == T_STRING);
        arg.str = mpl.image;
        code = mpl_internal_make_code(mpl, O_STRING, arg, A_SYMBOLIC, 0);
        mpl_internal_get_token(mpl);
        return code;
    }
    function mpl_internal_expand_arg_list(mpl, list, x) {
        var tail = {}, temp;
        xassert(x != null);
        tail.x = x;
        tail.next = null;
        if (list == null)
            list = tail;
        else {
            for (temp = list; temp.next != null; temp = temp.next) {
            }
            temp.next = tail;
        }
        return list;
    }
    function mpl_internal_arg_list_len(mpl, list) {
        var temp;
        var len;
        len = 0;
        for (temp = list; temp != null; temp = temp.next)
            len++;
        return len;
    }
    function mpl_internal_subscript_list(mpl) {
        var x;
        var list = null;
        for (;;) {
            x = mpl_internal_expression_5(mpl);
            if (x.type == A_NUMERIC)
                x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);
            if (x.type != A_SYMBOLIC)
                mpl_internal_error(mpl, 'subscript expression has invalid type');
            xassert(x.dim == 0);
            list = mpl_internal_expand_arg_list(mpl, list, x);
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            else if (mpl.token == T_RBRACKET)
                break;
            else
                mpl_internal_error(mpl, 'syntax error in subscript list');
        }
        return list;
    }
    function mpl_internal_object_reference(mpl) {
        var slot, set, par, var_, con, list, code, name, dim, suff;
        var arg = mpl_internal_create_operands();
        xassert(mpl.token == T_NAME);
        var node = mpl.tree[mpl.image];
        if (node == null)
            mpl_internal_error(mpl, mpl.image + ' not defined');
        switch (node.type) {
        case A_INDEX:
            slot = node.link;
            name = slot.name;
            dim = 0;
            break;
        case A_SET:
            set = node.link;
            name = set.name;
            dim = set.dim;
            if (set.dimen == 0)
                set.dimen = 1;
            break;
        case A_PARAMETER:
            par = node.link;
            name = par.name;
            dim = par.dim;
            break;
        case A_VARIABLE:
            var_ = node.link;
            name = var_.name;
            dim = var_.dim;
            break;
        case A_CONSTRAINT:
            con = node.link;
            name = con.name;
            dim = con.dim;
            break;
        default:
            xassert(node != node);
        }
        mpl_internal_get_token(mpl);
        if (mpl.token == T_LBRACKET) {
            if (dim == 0)
                mpl_internal_error(mpl, name + ' cannot be subscripted');
            mpl_internal_get_token(mpl);
            list = mpl_internal_subscript_list(mpl);
            if (dim != mpl_internal_arg_list_len(mpl, list))
                mpl_internal_error(mpl, name + ' must have ' + dim + ' subscript' + (dim == 1 ? '' : 's') + ' rather than ' + mpl_internal_arg_list_len(mpl, list));
            xassert(mpl.token == T_RBRACKET);
            mpl_internal_get_token(mpl);
        } else {
            if (dim != 0)
                mpl_internal_error(mpl, name + ' must be subscripted');
            list = null;
        }
        if (!mpl.flag_s && node.type == A_VARIABLE)
            suff = DOT_NONE;
        else
            suff = DOT_VAL;
        if (mpl.token == T_POINT) {
            mpl_internal_get_token(mpl);
            if (mpl.token != T_NAME)
                mpl_internal_error(mpl, 'invalid use of period');
            if (!(node.type == A_VARIABLE || node.type == A_CONSTRAINT))
                mpl_internal_error(mpl, name + ' cannot have a suffix');
            if (mpl.image == 'lb')
                suff = DOT_LB;
            else if (mpl.image == 'ub')
                suff = DOT_UB;
            else if (mpl.image == 'status')
                suff = DOT_STATUS;
            else if (mpl.image == 'val')
                suff = DOT_VAL;
            else if (mpl.image == 'dual')
                suff = DOT_DUAL;
            else
                mpl_internal_error(mpl, 'suffix .' + mpl.image + ' invalid');
            mpl_internal_get_token(mpl);
        }
        switch (node.type) {
        case A_INDEX:
            arg.index.slot = slot;
            arg.index.next = slot.list;
            code = mpl_internal_make_code(mpl, O_INDEX, arg, A_SYMBOLIC, 0);
            slot.list = code;
            break;
        case A_SET:
            arg.set.set = set;
            arg.set.list = list;
            code = mpl_internal_make_code(mpl, O_MEMSET, arg, A_ELEMSET, set.dimen);
            break;
        case A_PARAMETER:
            arg.par.par = par;
            arg.par.list = list;
            if (par.type == A_SYMBOLIC)
                code = mpl_internal_make_code(mpl, O_MEMSYM, arg, A_SYMBOLIC, 0);
            else
                code = mpl_internal_make_code(mpl, O_MEMNUM, arg, A_NUMERIC, 0);
            break;
        case A_VARIABLE:
            if (!mpl.flag_s && (suff == DOT_STATUS || suff == DOT_VAL || suff == DOT_DUAL))
                mpl_internal_error(mpl, 'invalid reference to status, primal value, or dual value of variable ' + var_.name + ' above solve statement');
            arg.var_.var_ = var_;
            arg.var_.list = list;
            arg.var_.suff = suff;
            code = mpl_internal_make_code(mpl, O_MEMVAR, arg, suff == DOT_NONE ? A_FORMULA : A_NUMERIC, 0);
            break;
        case A_CONSTRAINT:
            if (!mpl.flag_s && (suff == DOT_STATUS || suff == DOT_VAL || suff == DOT_DUAL))
                mpl_internal_error(mpl, 'invalid reference to status, primal value, o' + 'r dual value of ' + (con.type == A_CONSTRAINT ? 'constraint' : 'objective') + ' ' + con.name + ' above solve statement');
            arg.con.con = con;
            arg.con.list = list;
            arg.con.suff = suff;
            code = mpl_internal_make_code(mpl, O_MEMCON, arg, A_NUMERIC, 0);
            break;
        default:
            xassert(node != node);
        }
        return code;
    }
    function mpl_internal_numeric_argument(mpl, func) {
        var x = mpl_internal_expression_5(mpl);
        if (x.type == A_SYMBOLIC)
            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
        if (x.type != A_NUMERIC)
            mpl_internal_error(mpl, 'argument for ' + func + ' has invalid type');
        xassert(x.dim == 0);
        return x;
    }
    function mpl_internal_symbolic_argument(mpl, func) {
        var x = mpl_internal_expression_5(mpl);
        if (x.type == A_NUMERIC)
            x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);
        if (x.type != A_SYMBOLIC)
            mpl_internal_error(mpl, 'argument for ' + func + ' has invalid type');
        xassert(x.dim == 0);
        return x;
    }
    function mpl_internal_elemset_argument(mpl, func) {
        var x = mpl_internal_expression_9(mpl);
        if (x.type != A_ELEMSET)
            mpl_internal_error(mpl, 'argument for ' + func + ' has invalid type');
        xassert(x.dim > 0);
        return x;
    }
    function mpl_internal_function_reference(mpl) {
        var code;
        var arg = mpl_internal_create_operands();
        var op;
        var func;
        xassert(mpl.token == T_NAME);
        if (mpl.image == 'abs')
            op = O_ABS;
        else if (mpl.image == 'ceil')
            op = O_CEIL;
        else if (mpl.image == 'floor')
            op = O_FLOOR;
        else if (mpl.image == 'exp')
            op = O_EXP;
        else if (mpl.image == 'log')
            op = O_LOG;
        else if (mpl.image == 'log10')
            op = O_LOG10;
        else if (mpl.image == 'sqrt')
            op = O_SQRT;
        else if (mpl.image == 'sin')
            op = O_SIN;
        else if (mpl.image == 'cos')
            op = O_COS;
        else if (mpl.image == 'atan')
            op = O_ATAN;
        else if (mpl.image == 'min')
            op = O_MIN;
        else if (mpl.image == 'max')
            op = O_MAX;
        else if (mpl.image == 'round')
            op = O_ROUND;
        else if (mpl.image == 'trunc')
            op = O_TRUNC;
        else if (mpl.image == 'Irand224')
            op = O_IRAND224;
        else if (mpl.image == 'Uniform01')
            op = O_UNIFORM01;
        else if (mpl.image == 'Uniform')
            op = O_UNIFORM;
        else if (mpl.image == 'Normal01')
            op = O_NORMAL01;
        else if (mpl.image == 'Normal')
            op = O_NORMAL;
        else if (mpl.image == 'card')
            op = O_CARD;
        else if (mpl.image == 'length')
            op = O_LENGTH;
        else if (mpl.image == 'substr')
            op = O_SUBSTR;
        else if (mpl.image == 'str2time')
            op = O_STR2TIME;
        else if (mpl.image == 'time2str')
            op = O_TIME2STR;
        else if (mpl.image == 'gmtime')
            op = O_GMTIME;
        else
            mpl_internal_error(mpl, 'function ' + mpl.image + ' unknown');
        func = mpl.image;
        xassert(func.length < 16);
        mpl_internal_get_token(mpl);
        xassert(mpl.token == T_LEFT);
        mpl_internal_get_token(mpl);
        if (op == O_MIN || op == O_MAX) {
            arg.list = null;
            for (;;) {
                arg.list = mpl_internal_expand_arg_list(mpl, arg.list, mpl_internal_numeric_argument(mpl, func));
                if (mpl.token == T_COMMA)
                    mpl_internal_get_token(mpl);
                else if (mpl.token == T_RIGHT)
                    break;
                else
                    mpl_internal_error(mpl, 'syntax error in argument list for ' + func);
            }
        } else if (op == O_IRAND224 || op == O_UNIFORM01 || op == O_NORMAL01 || op == O_GMTIME) {
            if (mpl.token != T_RIGHT)
                mpl_internal_error(mpl, func + ' needs no arguments');
        } else if (op == O_UNIFORM || op == O_NORMAL) {
            arg.arg.x = mpl_internal_numeric_argument(mpl, func);
            if (mpl.token == T_COMMA) {
            } else if (mpl.token == T_RIGHT)
                mpl_internal_error(mpl, func + ' needs two arguments');
            else
                mpl_internal_error(mpl, 'syntax error in argument for ' + func);
            mpl_internal_get_token(mpl);
            arg.arg.y = mpl_internal_numeric_argument(mpl, func);
            if (mpl.token == T_COMMA)
                mpl_internal_error(mpl, func + ' needs two argument');
            else if (mpl.token == T_RIGHT) {
            } else
                mpl_internal_error(mpl, 'syntax error in argument for ' + func);
        } else if (op == O_ATAN || op == O_ROUND || op == O_TRUNC) {
            arg.arg.x = mpl_internal_numeric_argument(mpl, func);
            if (mpl.token == T_COMMA) {
                switch (op) {
                case O_ATAN:
                    op = O_ATAN2;
                    break;
                case O_ROUND:
                    op = O_ROUND2;
                    break;
                case O_TRUNC:
                    op = O_TRUNC2;
                    break;
                default:
                    xassert(op != op);
                }
                mpl_internal_get_token(mpl);
                arg.arg.y = mpl_internal_numeric_argument(mpl, func);
            }
            if (mpl.token == T_COMMA)
                mpl_internal_error(mpl, func + ' needs one or two arguments');
            else if (mpl.token == T_RIGHT) {
            } else
                mpl_internal_error(mpl, 'syntax error in argument for ' + func);
        } else if (op == O_SUBSTR) {
            arg.arg.x = mpl_internal_symbolic_argument(mpl, func);
            if (mpl.token == T_COMMA) {
            } else if (mpl.token == T_RIGHT)
                mpl_internal_error(mpl, func + ' needs two or three arguments');
            else
                mpl_internal_error(mpl, 'syntax error in argument for ' + func);
            mpl_internal_get_token(mpl);
            arg.arg.y = mpl_internal_numeric_argument(mpl, func);
            if (mpl.token == T_COMMA) {
                op = O_SUBSTR3;
                mpl_internal_get_token(mpl);
                arg.arg.z = mpl_internal_numeric_argument(mpl, func);
            }
            if (mpl.token == T_COMMA)
                mpl_internal_error(mpl, func + ' needs two or three arguments');
            else if (mpl.token == T_RIGHT) {
            } else
                mpl_internal_error(mpl, 'syntax error in argument for ' + func);
        } else if (op == O_STR2TIME) {
            arg.arg.x = mpl_internal_symbolic_argument(mpl, func);
            if (mpl.token == T_COMMA) {
            } else if (mpl.token == T_RIGHT)
                mpl_internal_error(mpl, func + ' needs two arguments');
            else
                mpl_internal_error(mpl, 'syntax error in argument for ' + func);
            mpl_internal_get_token(mpl);
            arg.arg.y = mpl_internal_symbolic_argument(mpl, func);
            if (mpl.token == T_COMMA)
                mpl_internal_error(mpl, func + ' needs two argument');
            else if (mpl.token == T_RIGHT) {
            } else
                mpl_internal_error(mpl, 'syntax error in argument for ' + func);
        } else if (op == O_TIME2STR) {
            arg.arg.x = mpl_internal_numeric_argument(mpl, func);
            if (mpl.token == T_COMMA) {
            } else if (mpl.token == T_RIGHT)
                mpl_internal_error(mpl, func + ' needs two arguments');
            else
                mpl_internal_error(mpl, 'syntax error in argument for ' + func);
            mpl_internal_get_token(mpl);
            arg.arg.y = mpl_internal_symbolic_argument(mpl, func);
            if (mpl.token == T_COMMA)
                mpl_internal_error(mpl, func + ' needs two argument');
            else if (mpl.token == T_RIGHT) {
            } else
                mpl_internal_error(mpl, 'syntax error in argument for ' + func);
        } else {
            if (op == O_CARD)
                arg.arg.x = mpl_internal_elemset_argument(mpl, func);
            else if (op == O_LENGTH)
                arg.arg.x = mpl_internal_symbolic_argument(mpl, func);
            else
                arg.arg.x = mpl_internal_numeric_argument(mpl, func);
            if (mpl.token == T_COMMA)
                mpl_internal_error(mpl, func + ' needs one argument');
            else if (mpl.token == T_RIGHT) {
            } else
                mpl_internal_error(mpl, 'syntax error in argument for ' + func);
        }
        if (op == O_SUBSTR || op == O_SUBSTR3 || op == O_TIME2STR)
            code = mpl_internal_make_code(mpl, op, arg, A_SYMBOLIC, 0);
        else
            code = mpl_internal_make_code(mpl, op, arg, A_NUMERIC, 0);
        xassert(mpl.token == T_RIGHT);
        mpl_internal_get_token(mpl);
        return code;
    }
    function mpl_internal_append_block(mpl, domain, block) {
        var temp;
        xassert(domain != null);
        xassert(block != null);
        xassert(block.next == null);
        if (domain.list == null)
            domain.list = block;
        else {
            for (temp = domain.list; temp.next != null; temp = temp.next) {
            }
            temp.next = block;
        }
    }
    function mpl_internal_append_slot(mpl, block, name, code) {
        var slot = {}, temp;
        xassert(block != null);
        slot.name = name;
        slot.code = code;
        slot.value = null;
        slot.list = null;
        slot.next = null;
        if (block.list == null)
            block.list = slot;
        else {
            for (temp = block.list; temp.next != null; temp = temp.next) {
            }
            temp.next = slot;
        }
        return slot;
    }
    function mpl_internal_expression_list(mpl) {
        var code;
        var arg = mpl_internal_create_operands();
        var max_dim = 20;
        var list = new Array(max_dim + 1);
        xfillObjArr(list, 0, max_dim + 1);
        var flag_x, next_token, dim, j, slice = 0;
        xassert(mpl.token == T_LEFT);
        flag_x = mpl.flag_x;
        mpl_internal_get_token(mpl);
        for (dim = 1;; dim++) {
            if (dim > max_dim)
                mpl_internal_error(mpl, 'too many components within parentheses');
            function expr() {
                code = mpl_internal_expression_13(mpl);
                if (mpl.token == T_COMMA || dim > 1) {
                    if (code.type == A_NUMERIC)
                        code = mpl_internal_make_unary(mpl, O_CVTSYM, code, A_SYMBOLIC, 0);
                    if (code.type != A_SYMBOLIC)
                        mpl_internal_error(mpl, 'component expression has invalid type');
                    xassert(code.dim == 0);
                }
                list[dim].name = null;
                list[dim].code = code;
            }
            if (mpl.token == T_NAME) {
                mpl_internal_get_token(mpl);
                next_token = mpl.token;
                mpl_internal_unget_token(mpl);
                if (!(flag_x && (next_token == T_COMMA || next_token == T_RIGHT) && mpl.tree[mpl.image] == null)) {
                    expr();
                } else {
                    for (j = 1; j < dim; j++) {
                        if (list[j].name != null && list[j].name == mpl.image)
                            mpl_internal_error(mpl, 'duplicate dummy index ' + mpl.image + ' not allowed');
                    }
                    list[dim].name = mpl.image;
                    list[dim].code = null;
                    mpl_internal_get_token(mpl);
                    slice = 1;
                    if (dim == 1 && mpl.token == T_RIGHT)
                        mpl_internal_error(mpl, list[dim].name + ' not defined');
                }
            } else
                expr();
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            else if (mpl.token == T_RIGHT)
                break;
            else
                mpl_internal_error(mpl, 'right parenthesis missing where expected');
        }
        if (dim == 1 && !slice) {
            code = list[1].code;
        } else if (!slice) {
            arg.list = null;
            for (j = 1; j <= dim; j++)
                arg.list = mpl_internal_expand_arg_list(mpl, arg.list, list[j].code);
            code = mpl_internal_make_code(mpl, O_TUPLE, arg, A_TUPLE, dim);
        } else {
            arg.slice = {};
            for (j = 1; j <= dim; j++)
                mpl_internal_append_slot(mpl, arg.slice, list[j].name, list[j].code);
            code = mpl_internal_make_code(mpl, O_SLICE, arg, A_TUPLE, dim);
        }
        mpl_internal_get_token(mpl);
        if (slice && mpl.token != T_IN)
            mpl_internal_error(mpl, 'keyword in missing where expected');
        if (flag_x && mpl.token == T_IN && !slice) {
            if (dim == 1)
                mpl_internal_error(mpl, 'syntax error in indexing expression');
            else
                mpl_internal_error(mpl, '0-ary slice not allowed');
        }
        return code;
    }
    function mpl_internal_literal_set(mpl, code) {
        var arg = mpl_internal_create_operands();
        var j;
        xassert(code != null);
        arg.list = null;
        for (j = 1;; j++) {
            if (code.type == A_NUMERIC)
                code = mpl_internal_make_unary(mpl, O_CVTSYM, code, A_SYMBOLIC, 0);
            if (code.type == A_SYMBOLIC)
                code = mpl_internal_make_unary(mpl, O_CVTTUP, code, A_TUPLE, 1);
            if (code.type != A_TUPLE)
                mpl_internal_error(mpl, 'member expression has invalid type');
            if (arg.list != null && arg.list.x.dim != code.dim)
                mpl_internal_error(mpl, 'member ' + (j - 1) + ' has ' + arg.list.x.dim + ' component' + (arg.list.x.dim == 1 ? '' : 's') + ' while member ' + j + ' has ' + code.dim + ' component' + (code.dim == 1 ? '' : 's'));
            arg.list = mpl_internal_expand_arg_list(mpl, arg.list, code);
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            else if (mpl.token == T_RBRACE)
                break;
            else
                mpl_internal_error(mpl, 'syntax error in literal set');
            code = mpl_internal_expression_5(mpl);
        }
        code = mpl_internal_make_code(mpl, O_MAKE, arg, A_ELEMSET, arg.list.x.dim);
        return code;
    }
    function mpl_internal_indexing_expression(mpl) {
        var domain;
        var block;
        var slot;
        var code;
        xassert(mpl.token == T_LBRACE);
        mpl_internal_get_token(mpl);
        if (mpl.token == T_RBRACE)
            mpl_internal_error(mpl, 'empty indexing expression not allowed');
        domain = {};
        for (;;) {
            block = null;
            code = null;
            if (mpl.token == T_NAME) {
                var next_token;
                var name;
                mpl_internal_get_token(mpl);
                next_token = mpl.token;
                mpl_internal_unget_token(mpl);
                if (next_token == T_IN && mpl.tree[mpl.image] == null) {
                    block = {};
                    name = mpl.image;
                    mpl_internal_append_slot(mpl, block, name, null);
                    mpl_internal_get_token(mpl);
                    xassert(mpl.token == T_IN);
                    mpl_internal_get_token(mpl);
                }
            } else if (mpl.token == T_LEFT) {
                mpl.flag_x = 1;
                code = mpl_internal_expression_9(mpl);
                if (code.op == O_SLICE) {
                    block = code.arg.slice;
                    code = null;
                    xassert(mpl.token == T_IN);
                    mpl_internal_get_token(mpl);
                }
            }
            if (code == null)
                code = mpl_internal_expression_9(mpl);
            if (code.type != A_ELEMSET) {
                if (block != null)
                    mpl_internal_error(mpl, 'domain expression has invalid type');
                code = mpl_internal_literal_set(mpl, code);
            }
            xassert(code != null);
            xassert(code.type == A_ELEMSET);
            xassert(code.dim > 0);
            if (block == null) {
                var j;
                block = {};
                for (j = 1; j <= code.dim; j++)
                    mpl_internal_append_slot(mpl, block, null, null);
            }
            {
                var dim = 0;
                for (slot = block.list; slot != null; slot = slot.next)
                    dim++;
                if (dim != code.dim)
                    mpl_internal_error(mpl, dim + ' ' + (dim == 1 ? 'index' : 'indices') + ' specified for set of dimension ' + code.dim);
            }
            xassert(block.code == null);
            block.code = code;
            mpl_internal_append_block(mpl, domain, block);
            for (slot = block.list; slot != null; slot = slot.next)
                if (slot.name != null) {
                    var node;
                    xassert(mpl.tree[slot.name] == null);
                    mpl.tree[slot.name] = node = {
                        type: A_INDEX,
                        link: slot
                    };
                }
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            else if (mpl.token == T_COLON || mpl.token == T_RBRACE)
                break;
            else
                mpl_internal_error(mpl, 'syntax error in indexing expression');
        }
        if (mpl.token == T_COLON) {
            mpl_internal_get_token(mpl);
            code = mpl_internal_expression_13(mpl);
            if (code.type == A_SYMBOLIC)
                code = mpl_internal_make_unary(mpl, O_CVTNUM, code, A_NUMERIC, 0);
            if (code.type == A_NUMERIC)
                code = mpl_internal_make_unary(mpl, O_CVTLOG, code, A_LOGICAL, 0);
            if (code.type != A_LOGICAL)
                mpl_internal_error(mpl, 'expression following colon has invalid type');
            xassert(code.dim == 0);
            domain.code = code;
            if (mpl.token != T_RBRACE)
                mpl_internal_error(mpl, 'syntax error in indexing expression');
        }
        mpl_internal_get_token(mpl);
        return domain;
    }
    function mpl_internal_close_scope(mpl, domain) {
        var block;
        var slot;
        var node;
        xassert(domain != null);
        for (block = domain.list; block != null; block = block.next) {
            for (slot = block.list; slot != null; slot = slot.next) {
                if (slot.name != null) {
                    node = mpl.tree[slot.name];
                    xassert(node != null);
                    xassert(node.type == A_INDEX);
                    delete mpl.tree[slot.name];
                }
            }
        }
    }
    function mpl_internal_link_up(code) {
        var block;
        var slot;
        for (block = code.arg.loop.domain.list; block != null; block = block.next) {
            for (slot = block.list; slot != null; slot = slot.next) {
                if (slot.code != null) {
                    xassert(slot.code.up == null);
                    slot.code.up = code;
                }
            }
        }
    }
    function mpl_internal_iterated_expression(mpl) {
        var code;
        var arg = mpl_internal_create_operands();
        var op;
        var opstr;
        xassert(mpl.token == T_NAME);
        if (mpl.image == 'sum')
            op = O_SUM;
        else if (mpl.image == 'prod')
            op = O_PROD;
        else if (mpl.image == 'min')
            op = O_MINIMUM;
        else if (mpl.image == 'max')
            op = O_MAXIMUM;
        else if (mpl.image == 'forall')
            op = O_FORALL;
        else if (mpl.image == 'exists')
            op = O_EXISTS;
        else if (mpl.image == 'setof')
            op = O_SETOF;
        else
            mpl_internal_error(mpl, 'operator ' + mpl.image + ' unknown');
        opstr = mpl.image;
        xassert(opstr.length < 8);
        mpl_internal_get_token(mpl);
        xassert(mpl.token == T_LBRACE);
        arg.loop.domain = mpl_internal_indexing_expression(mpl);
        function err() {
            mpl_internal_error(mpl, 'integrand following ' + opstr + '{...} has invalid type');
        }
        switch (op) {
        case O_SUM:
        case O_PROD:
        case O_MINIMUM:
        case O_MAXIMUM:
            arg.loop.x = mpl_internal_expression_3(mpl);
            if (arg.loop.x.type == A_SYMBOLIC)
                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTNUM, arg.loop.x, A_NUMERIC, 0);
            if (!(arg.loop.x.type == A_NUMERIC || op == O_SUM && arg.loop.x.type == A_FORMULA))
                err();
            xassert(arg.loop.x.dim == 0);
            code = mpl_internal_make_code(mpl, op, arg, arg.loop.x.type, 0);
            break;
        case O_FORALL:
        case O_EXISTS:
            arg.loop.x = mpl_internal_expression_12(mpl);
            if (arg.loop.x.type == A_SYMBOLIC)
                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTNUM, arg.loop.x, A_NUMERIC, 0);
            if (arg.loop.x.type == A_NUMERIC)
                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTLOG, arg.loop.x, A_LOGICAL, 0);
            if (arg.loop.x.type != A_LOGICAL)
                err();
            xassert(arg.loop.x.dim == 0);
            code = mpl_internal_make_code(mpl, op, arg, A_LOGICAL, 0);
            break;
        case O_SETOF:
            arg.loop.x = mpl_internal_expression_5(mpl);
            if (arg.loop.x.type == A_NUMERIC)
                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTSYM, arg.loop.x, A_SYMBOLIC, 0);
            if (arg.loop.x.type == A_SYMBOLIC)
                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTTUP, arg.loop.x, A_TUPLE, 1);
            if (arg.loop.x.type != A_TUPLE)
                err();
            xassert(arg.loop.x.dim > 0);
            code = mpl_internal_make_code(mpl, op, arg, A_ELEMSET, arg.loop.x.dim);
            break;
        default:
            xassert(op != op);
        }
        mpl_internal_close_scope(mpl, arg.loop.domain);
        mpl_internal_link_up(code);
        return code;
    }
    function mpl_internal_domain_arity(mpl, domain) {
        var arity = 0;
        for (var block = domain.list; block != null; block = block.next)
            for (var slot = block.list; slot != null; slot = slot.next)
                if (slot.code == null)
                    arity++;
        return arity;
    }
    function mpl_internal_set_expression(mpl) {
        var code;
        var arg = mpl_internal_create_operands();
        xassert(mpl.token == T_LBRACE);
        mpl_internal_get_token(mpl);
        if (mpl.token == T_RBRACE) {
            arg.list = null;
            code = mpl_internal_make_code(mpl, O_MAKE, arg, A_ELEMSET, 1);
            mpl_internal_get_token(mpl);
        } else {
            mpl_internal_unget_token(mpl);
            arg.loop.domain = mpl_internal_indexing_expression(mpl);
            arg.loop.x = null;
            mpl_internal_close_scope(mpl, arg.loop.domain);
            code = mpl_internal_make_code(mpl, O_BUILD, arg, A_ELEMSET, mpl_internal_domain_arity(mpl, arg.loop.domain));
            mpl_internal_link_up(code);
        }
        return code;
    }
    function mpl_internal_branched_expression(mpl) {
        var x, y, z;
        xassert(mpl.token == T_IF);
        mpl_internal_get_token(mpl);
        x = mpl_internal_expression_13(mpl);
        if (x.type == A_SYMBOLIC)
            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
        if (x.type == A_NUMERIC)
            x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);
        if (x.type != A_LOGICAL)
            mpl_internal_error(mpl, 'expression following if has invalid type');
        xassert(x.dim == 0);
        if (mpl.token != T_THEN)
            mpl_internal_error(mpl, 'keyword then missing where expected');
        mpl_internal_get_token(mpl);
        y = mpl_internal_expression_9(mpl);
        if (!(y.type == A_NUMERIC || y.type == A_SYMBOLIC || y.type == A_ELEMSET || y.type == A_FORMULA))
            mpl_internal_error(mpl, 'expression following then has invalid type');
        if (mpl.token != T_ELSE) {
            if (y.type == A_ELEMSET)
                mpl_internal_error(mpl, 'keyword else missing where expected');
            z = null;
        } else {
            mpl_internal_get_token(mpl);
            z = mpl_internal_expression_9(mpl);
            if (!(z.type == A_NUMERIC || z.type == A_SYMBOLIC || z.type == A_ELEMSET || z.type == A_FORMULA))
                mpl_internal_error(mpl, 'expression following else has invalid type');
            if (y.type == A_FORMULA || z.type == A_FORMULA) {
                if (y.type == A_SYMBOLIC)
                    y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
                if (y.type == A_NUMERIC)
                    y = mpl_internal_make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);
                if (z.type == A_SYMBOLIC)
                    z = mpl_internal_make_unary(mpl, O_CVTNUM, z, A_NUMERIC, 0);
                if (z.type == A_NUMERIC)
                    z = mpl_internal_make_unary(mpl, O_CVTLFM, z, A_FORMULA, 0);
            }
            if (y.type == A_SYMBOLIC || z.type == A_SYMBOLIC) {
                if (y.type == A_NUMERIC)
                    y = mpl_internal_make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);
                if (z.type == A_NUMERIC)
                    z = mpl_internal_make_unary(mpl, O_CVTSYM, z, A_SYMBOLIC, 0);
            }
            if (y.type != z.type)
                mpl_internal_error(mpl, 'expressions following then and else have incompatible types');
            if (y.dim != z.dim)
                mpl_internal_error(mpl, 'expressions following then and else have different' + ' dimensions ' + y.dim + ' and ' + z.dim + ', respectively');
        }
        return mpl_internal_make_ternary(mpl, O_FORK, x, y, z, y.type, y.dim);
    }
    function mpl_internal_primary_expression(mpl) {
        var code;
        if (mpl.token == T_NUMBER) {
            code = mpl_internal_numeric_literal(mpl);
        } else if (mpl.token == T_INFINITY) {
            var arg = mpl_internal_create_operands();
            arg.num = DBL_MAX;
            code = mpl_internal_make_code(mpl, O_NUMBER, arg, A_NUMERIC, 0);
            mpl_internal_get_token(mpl);
        } else if (mpl.token == T_STRING) {
            code = mpl_internal_string_literal(mpl);
        } else if (mpl.token == T_NAME) {
            var next_token;
            mpl_internal_get_token(mpl);
            next_token = mpl.token;
            mpl_internal_unget_token(mpl);
            switch (next_token) {
            case T_LBRACKET:
                code = mpl_internal_object_reference(mpl);
                break;
            case T_LEFT:
                code = mpl_internal_function_reference(mpl);
                break;
            case T_LBRACE:
                code = mpl_internal_iterated_expression(mpl);
                break;
            default:
                code = mpl_internal_object_reference(mpl);
                break;
            }
        } else if (mpl.token == T_LEFT) {
            code = mpl_internal_expression_list(mpl);
        } else if (mpl.token == T_LBRACE) {
            code = mpl_internal_set_expression(mpl);
        } else if (mpl.token == T_IF) {
            code = mpl_internal_branched_expression(mpl);
        } else if (mpl_internal_is_reserved(mpl)) {
            mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
        } else
            mpl_internal_error(mpl, 'syntax error in expression');
        return code;
    }
    function mpl_internal_error_preceding(mpl, opstr) {
        mpl_internal_error(mpl, 'operand preceding ' + opstr + ' has invalid type');
    }
    function mpl_internal_error_following(mpl, opstr) {
        mpl_internal_error(mpl, 'operand following ' + opstr + ' has invalid type');
    }
    function mpl_internal_error_dimension(mpl, opstr, dim1, dim2) {
        mpl_internal_error(mpl, 'operands preceding and following ' + opstr + ' have different di' + 'mensions ' + dim1 + ' and ' + dim2 + ', respectively');
    }
    function mpl_internal_expression_0(mpl) {
        return mpl_internal_primary_expression(mpl);
    }
    function mpl_internal_expression_1(mpl) {
        var y;
        var x = mpl_internal_expression_0(mpl);
        if (mpl.token == T_POWER) {
            var opstr = mpl.image;
            xassert(opstr.length < 8);
            if (x.type == A_SYMBOLIC)
                x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
            if (x.type != A_NUMERIC)
                mpl_internal_error_preceding(mpl, opstr);
            mpl_internal_get_token(mpl);
            if (mpl.token == T_PLUS || mpl.token == T_MINUS)
                y = mpl_internal_expression_2(mpl);
            else
                y = mpl_internal_expression_1(mpl);
            if (y.type == A_SYMBOLIC)
                y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
            if (y.type != A_NUMERIC)
                mpl_internal_error_following(mpl, opstr);
            x = mpl_internal_make_binary(mpl, O_POWER, x, y, A_NUMERIC, 0);
        }
        return x;
    }
    function mpl_internal_expression_2(mpl) {
        var x;
        if (mpl.token == T_PLUS) {
            mpl_internal_get_token(mpl);
            x = mpl_internal_expression_1(mpl);
            if (x.type == A_SYMBOLIC)
                x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
            if (!(x.type == A_NUMERIC || x.type == A_FORMULA))
                mpl_internal_error_following(mpl, '+');
            x = mpl_internal_make_unary(mpl, O_PLUS, x, x.type, 0);
        } else if (mpl.token == T_MINUS) {
            mpl_internal_get_token(mpl);
            x = mpl_internal_expression_1(mpl);
            if (x.type == A_SYMBOLIC)
                x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
            if (!(x.type == A_NUMERIC || x.type == A_FORMULA))
                mpl_internal_error_following(mpl, '-');
            x = mpl_internal_make_unary(mpl, O_MINUS, x, x.type, 0);
        } else
            x = mpl_internal_expression_1(mpl);
        return x;
    }
    function mpl_internal_expression_3(mpl) {
        var y;
        var x = mpl_internal_expression_2(mpl);
        for (;;) {
            if (mpl.token == T_ASTERISK) {
                if (x.type == A_SYMBOLIC)
                    x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
                if (!(x.type == A_NUMERIC || x.type == A_FORMULA))
                    mpl_internal_error_preceding(mpl, '*');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_2(mpl);
                if (y.type == A_SYMBOLIC)
                    y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
                if (!(y.type == A_NUMERIC || y.type == A_FORMULA))
                    mpl_internal_error_following(mpl, '*');
                if (x.type == A_FORMULA && y.type == A_FORMULA)
                    mpl_internal_error(mpl, 'multiplication of linear forms not allowed');
                if (x.type == A_NUMERIC && y.type == A_NUMERIC)
                    x = mpl_internal_make_binary(mpl, O_MUL, x, y, A_NUMERIC, 0);
                else
                    x = mpl_internal_make_binary(mpl, O_MUL, x, y, A_FORMULA, 0);
            } else if (mpl.token == T_SLASH) {
                if (x.type == A_SYMBOLIC)
                    x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
                if (!(x.type == A_NUMERIC || x.type == A_FORMULA))
                    mpl_internal_error_preceding(mpl, '/');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_2(mpl);
                if (y.type == A_SYMBOLIC)
                    y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
                if (y.type != A_NUMERIC)
                    mpl_internal_error_following(mpl, '/');
                if (x.type == A_NUMERIC)
                    x = mpl_internal_make_binary(mpl, O_DIV, x, y, A_NUMERIC, 0);
                else
                    x = mpl_internal_make_binary(mpl, O_DIV, x, y, A_FORMULA, 0);
            } else if (mpl.token == T_DIV) {
                if (x.type == A_SYMBOLIC)
                    x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
                if (x.type != A_NUMERIC)
                    mpl_internal_error_preceding(mpl, 'div');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_2(mpl);
                if (y.type == A_SYMBOLIC)
                    y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
                if (y.type != A_NUMERIC)
                    mpl_internal_error_following(mpl, 'div');
                x = mpl_internal_make_binary(mpl, O_IDIV, x, y, A_NUMERIC, 0);
            } else if (mpl.token == T_MOD) {
                if (x.type == A_SYMBOLIC)
                    x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
                if (x.type != A_NUMERIC)
                    mpl_internal_error_preceding(mpl, 'mod');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_2(mpl);
                if (y.type == A_SYMBOLIC)
                    y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
                if (y.type != A_NUMERIC)
                    mpl_internal_error_following(mpl, 'mod');
                x = mpl_internal_make_binary(mpl, O_MOD, x, y, A_NUMERIC, 0);
            } else
                break;
        }
        return x;
    }
    function mpl_internal_expression_4(mpl) {
        var y;
        var x = mpl_internal_expression_3(mpl);
        for (;;) {
            if (mpl.token == T_PLUS) {
                if (x.type == A_SYMBOLIC)
                    x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
                if (!(x.type == A_NUMERIC || x.type == A_FORMULA))
                    mpl_internal_error_preceding(mpl, '+');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_3(mpl);
                if (y.type == A_SYMBOLIC)
                    y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
                if (!(y.type == A_NUMERIC || y.type == A_FORMULA))
                    mpl_internal_error_following(mpl, '+');
                if (x.type == A_NUMERIC && y.type == A_FORMULA)
                    x = mpl_internal_make_unary(mpl, O_CVTLFM, x, A_FORMULA, 0);
                if (x.type == A_FORMULA && y.type == A_NUMERIC)
                    y = mpl_internal_make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);
                x = mpl_internal_make_binary(mpl, O_ADD, x, y, x.type, 0);
            } else if (mpl.token == T_MINUS) {
                if (x.type == A_SYMBOLIC)
                    x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
                if (!(x.type == A_NUMERIC || x.type == A_FORMULA))
                    mpl_internal_error_preceding(mpl, '-');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_3(mpl);
                if (y.type == A_SYMBOLIC)
                    y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
                if (!(y.type == A_NUMERIC || y.type == A_FORMULA))
                    mpl_internal_error_following(mpl, '-');
                if (x.type == A_NUMERIC && y.type == A_FORMULA)
                    x = mpl_internal_make_unary(mpl, O_CVTLFM, x, A_FORMULA, 0);
                if (x.type == A_FORMULA && y.type == A_NUMERIC)
                    y = mpl_internal_make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);
                x = mpl_internal_make_binary(mpl, O_SUB, x, y, x.type, 0);
            } else if (mpl.token == T_LESS) {
                if (x.type == A_SYMBOLIC)
                    x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
                if (x.type != A_NUMERIC)
                    mpl_internal_error_preceding(mpl, 'less');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_3(mpl);
                if (y.type == A_SYMBOLIC)
                    y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
                if (y.type != A_NUMERIC)
                    mpl_internal_error_following(mpl, 'less');
                x = mpl_internal_make_binary(mpl, O_LESS, x, y, A_NUMERIC, 0);
            } else
                break;
        }
        return x;
    }
    function mpl_internal_expression_5(mpl) {
        var y;
        var x = mpl_internal_expression_4(mpl);
        for (;;) {
            if (mpl.token == T_CONCAT) {
                if (x.type == A_NUMERIC)
                    x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);
                if (x.type != A_SYMBOLIC)
                    mpl_internal_error_preceding(mpl, '&');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_4(mpl);
                if (y.type == A_NUMERIC)
                    y = mpl_internal_make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);
                if (y.type != A_SYMBOLIC)
                    mpl_internal_error_following(mpl, '&');
                x = mpl_internal_make_binary(mpl, O_CONCAT, x, y, A_SYMBOLIC, 0);
            } else
                break;
        }
        return x;
    }
    function mpl_internal_expression_6(mpl) {
        var y, z;
        var x = mpl_internal_expression_5(mpl);
        if (mpl.token == T_DOTS) {
            if (x.type == A_SYMBOLIC)
                x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
            if (x.type != A_NUMERIC)
                mpl_internal_error_preceding(mpl, '..');
            mpl_internal_get_token(mpl);
            y = mpl_internal_expression_5(mpl);
            if (y.type == A_SYMBOLIC)
                y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
            if (y.type != A_NUMERIC)
                mpl_internal_error_following(mpl, '..');
            if (mpl.token == T_BY) {
                mpl_internal_get_token(mpl);
                z = mpl_internal_expression_5(mpl);
                if (z.type == A_SYMBOLIC)
                    z = mpl_internal_make_unary(mpl, O_CVTNUM, z, A_NUMERIC, 0);
                if (z.type != A_NUMERIC)
                    mpl_internal_error_following(mpl, 'by');
            } else
                z = null;
            x = mpl_internal_make_ternary(mpl, O_DOTS, x, y, z, A_ELEMSET, 1);
        }
        return x;
    }
    function mpl_internal_expression_7(mpl) {
        var y;
        var x = mpl_internal_expression_6(mpl);
        for (;;) {
            if (mpl.token == T_CROSS) {
                if (x.type != A_ELEMSET)
                    mpl_internal_error_preceding(mpl, 'cross');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_6(mpl);
                if (y.type != A_ELEMSET)
                    mpl_internal_error_following(mpl, 'cross');
                x = mpl_internal_make_binary(mpl, O_CROSS, x, y, A_ELEMSET, x.dim + y.dim);
            } else
                break;
        }
        return x;
    }
    function mpl_internal_expression_8(mpl) {
        var y;
        var x = mpl_internal_expression_7(mpl);
        for (;;) {
            if (mpl.token == T_INTER) {
                if (x.type != A_ELEMSET)
                    mpl_internal_error_preceding(mpl, 'inter');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_7(mpl);
                if (y.type != A_ELEMSET)
                    mpl_internal_error_following(mpl, 'inter');
                if (x.dim != y.dim)
                    mpl_internal_error_dimension(mpl, 'inter', x.dim, y.dim);
                x = mpl_internal_make_binary(mpl, O_INTER, x, y, A_ELEMSET, x.dim);
            } else
                break;
        }
        return x;
    }
    function mpl_internal_expression_9(mpl) {
        var y;
        var x = mpl_internal_expression_8(mpl);
        for (;;) {
            if (mpl.token == T_UNION) {
                if (x.type != A_ELEMSET)
                    mpl_internal_error_preceding(mpl, 'union');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_8(mpl);
                if (y.type != A_ELEMSET)
                    mpl_internal_error_following(mpl, 'union');
                if (x.dim != y.dim)
                    mpl_internal_error_dimension(mpl, 'union', x.dim, y.dim);
                x = mpl_internal_make_binary(mpl, O_UNION, x, y, A_ELEMSET, x.dim);
            } else if (mpl.token == T_DIFF) {
                if (x.type != A_ELEMSET)
                    mpl_internal_error_preceding(mpl, 'diff');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_8(mpl);
                if (y.type != A_ELEMSET)
                    mpl_internal_error_following(mpl, 'diff');
                if (x.dim != y.dim)
                    mpl_internal_error_dimension(mpl, 'diff', x.dim, y.dim);
                x = mpl_internal_make_binary(mpl, O_DIFF, x, y, A_ELEMSET, x.dim);
            } else if (mpl.token == T_SYMDIFF) {
                if (x.type != A_ELEMSET)
                    mpl_internal_error_preceding(mpl, 'symdiff');
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_8(mpl);
                if (y.type != A_ELEMSET)
                    mpl_internal_error_following(mpl, 'symdiff');
                if (x.dim != y.dim)
                    mpl_internal_error_dimension(mpl, 'symdiff', x.dim, y.dim);
                x = mpl_internal_make_binary(mpl, O_SYMDIFF, x, y, A_ELEMSET, x.dim);
            } else
                break;
        }
        return x;
    }
    function mpl_internal_expression_10(mpl) {
        var y;
        var op = -1;
        var opstr = '';
        var x = mpl_internal_expression_9(mpl);
        switch (mpl.token) {
        case T_LT:
            op = O_LT;
            break;
        case T_LE:
            op = O_LE;
            break;
        case T_EQ:
            op = O_EQ;
            break;
        case T_GE:
            op = O_GE;
            break;
        case T_GT:
            op = O_GT;
            break;
        case T_NE:
            op = O_NE;
            break;
        case T_IN:
            op = O_IN;
            break;
        case T_WITHIN:
            op = O_WITHIN;
            break;
        case T_NOT:
            opstr = mpl.image;
            mpl_internal_get_token(mpl);
            if (mpl.token == T_IN)
                op = O_NOTIN;
            else if (mpl.token == T_WITHIN)
                op = O_NOTWITHIN;
            else
                mpl_internal_error(mpl, 'invalid use of ' + opstr);
            opstr += ' ';
            break;
        default:
            return x;
        }
        opstr += mpl.image;
        xassert(opstr.length < 16);
        switch (op) {
        case O_EQ:
        case O_NE:
        case O_LT:
        case O_LE:
        case O_GT:
        case O_GE:
            if (!(x.type == A_NUMERIC || x.type == A_SYMBOLIC))
                mpl_internal_error_preceding(mpl, opstr);
            mpl_internal_get_token(mpl);
            y = mpl_internal_expression_9(mpl);
            if (!(y.type == A_NUMERIC || y.type == A_SYMBOLIC))
                mpl_internal_error_following(mpl, opstr);
            if (x.type == A_NUMERIC && y.type == A_SYMBOLIC)
                x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);
            if (x.type == A_SYMBOLIC && y.type == A_NUMERIC)
                y = mpl_internal_make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);
            x = mpl_internal_make_binary(mpl, op, x, y, A_LOGICAL, 0);
            break;
        case O_IN:
        case O_NOTIN:
            if (x.type == A_NUMERIC)
                x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);
            if (x.type == A_SYMBOLIC)
                x = mpl_internal_make_unary(mpl, O_CVTTUP, x, A_TUPLE, 1);
            if (x.type != A_TUPLE)
                mpl_internal_error_preceding(mpl, opstr);
            mpl_internal_get_token(mpl);
            y = mpl_internal_expression_9(mpl);
            if (y.type != A_ELEMSET)
                mpl_internal_error_following(mpl, opstr);
            if (x.dim != y.dim)
                mpl_internal_error_dimension(mpl, opstr, x.dim, y.dim);
            x = mpl_internal_make_binary(mpl, op, x, y, A_LOGICAL, 0);
            break;
        case O_WITHIN:
        case O_NOTWITHIN:
            if (x.type != A_ELEMSET)
                mpl_internal_error_preceding(mpl, opstr);
            mpl_internal_get_token(mpl);
            y = mpl_internal_expression_9(mpl);
            if (y.type != A_ELEMSET)
                mpl_internal_error_following(mpl, opstr);
            if (x.dim != y.dim)
                mpl_internal_error_dimension(mpl, opstr, x.dim, y.dim);
            x = mpl_internal_make_binary(mpl, op, x, y, A_LOGICAL, 0);
            break;
        default:
            xassert(op != op);
        }
        return x;
    }
    function mpl_internal_expression_11(mpl) {
        var x;
        var opstr;
        if (mpl.token == T_NOT) {
            opstr = mpl.image;
            xassert(opstr.length < 8);
            mpl_internal_get_token(mpl);
            x = mpl_internal_expression_10(mpl);
            if (x.type == A_SYMBOLIC)
                x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
            if (x.type == A_NUMERIC)
                x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);
            if (x.type != A_LOGICAL)
                mpl_internal_error_following(mpl, opstr);
            x = mpl_internal_make_unary(mpl, O_NOT, x, A_LOGICAL, 0);
        } else
            x = mpl_internal_expression_10(mpl);
        return x;
    }
    function mpl_internal_expression_12(mpl) {
        var y;
        var opstr = '';
        var x = mpl_internal_expression_11(mpl);
        for (;;) {
            if (mpl.token == T_AND) {
                opstr = mpl.image;
                xassert(opstr.length < 8);
                if (x.type == A_SYMBOLIC)
                    x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
                if (x.type == A_NUMERIC)
                    x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);
                if (x.type != A_LOGICAL)
                    mpl_internal_error_preceding(mpl, opstr);
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_11(mpl);
                if (y.type == A_SYMBOLIC)
                    y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
                if (y.type == A_NUMERIC)
                    y = mpl_internal_make_unary(mpl, O_CVTLOG, y, A_LOGICAL, 0);
                if (y.type != A_LOGICAL)
                    mpl_internal_error_following(mpl, opstr);
                x = mpl_internal_make_binary(mpl, O_AND, x, y, A_LOGICAL, 0);
            } else
                break;
        }
        return x;
    }
    function mpl_internal_expression_13(mpl) {
        var y;
        var x = mpl_internal_expression_12(mpl);
        for (;;) {
            if (mpl.token == T_OR) {
                var opstr = mpl.image;
                xassert(opstr.length < 8);
                if (x.type == A_SYMBOLIC)
                    x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);
                if (x.type == A_NUMERIC)
                    x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);
                if (x.type != A_LOGICAL)
                    mpl_internal_error_preceding(mpl, opstr);
                mpl_internal_get_token(mpl);
                y = mpl_internal_expression_12(mpl);
                if (y.type == A_SYMBOLIC)
                    y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);
                if (y.type == A_NUMERIC)
                    y = mpl_internal_make_unary(mpl, O_CVTLOG, y, A_LOGICAL, 0);
                if (y.type != A_LOGICAL)
                    mpl_internal_error_following(mpl, opstr);
                x = mpl_internal_make_binary(mpl, O_OR, x, y, A_LOGICAL, 0);
            } else
                break;
        }
        return x;
    }
    function mpl_internal_set_statement(mpl) {
        var set, node;
        var dimen_used = 0;
        var gadget;
        function err() {
            mpl_internal_error(mpl, 'at most one := or default/data allowed');
        }
        function err1() {
            mpl_internal_error(mpl, mpl.image + ' not a plain set');
        }
        function err2() {
            mpl_internal_error(mpl, 'dimension of ' + mpl.image + ' too small');
        }
        function err3() {
            mpl_internal_error(mpl, 'component number must be integer between 1 and ' + gadget.set.dimen);
        }
        ;
        xassert(mpl_internal_is_keyword(mpl, 'set'));
        mpl_internal_get_token(mpl);
        if (mpl.token == T_NAME) {
        } else if (mpl_internal_is_reserved(mpl))
            mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
        else
            mpl_internal_error(mpl, 'symbolic name missing where expected');
        if (mpl.tree[mpl.image] != null)
            mpl_internal_error(mpl, mpl.image + ' multiply declared');
        set = {};
        set.name = mpl.image;
        set.alias = null;
        set.dim = 0;
        set.domain = null;
        set.dimen = 0;
        set.within = null;
        set.assign = null;
        set.option = null;
        set.gadget = null;
        set.data = 0;
        set.array = null;
        mpl_internal_get_token(mpl);
        if (mpl.token == T_STRING) {
            set.alias = mpl.image;
            mpl_internal_get_token(mpl);
        }
        if (mpl.token == T_LBRACE) {
            set.domain = mpl_internal_indexing_expression(mpl);
            set.dim = mpl_internal_domain_arity(mpl, set.domain);
        }
        {
            node = mpl.tree[set.name] = {};
            node.type = A_SET;
            node.link = set;
        }
        for (;;) {
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            else if (mpl.token == T_SEMICOLON)
                break;
            if (mpl_internal_is_keyword(mpl, 'dimen')) {
                var dimen;
                mpl_internal_get_token(mpl);
                if (!(mpl.token == T_NUMBER && 1 <= mpl.value && mpl.value <= 20 && Math.floor(mpl.value) == mpl.value))
                    mpl_internal_error(mpl, 'dimension must be integer between 1 and 20');
                dimen = mpl.value + 0.5 | 0;
                if (dimen_used)
                    mpl_internal_error(mpl, 'at most one dimension attribute allowed');
                if (set.dimen > 0)
                    mpl_internal_error(mpl, 'dimension ' + dimen + ' conflicts with dimension ' + set.dimen + ' already determined');
                set.dimen = dimen;
                dimen_used = 1;
                mpl_internal_get_token(mpl);
            } else if (mpl.token == T_WITHIN || mpl.token == T_IN) {
                var within, temp;
                if (mpl.token == T_IN && !mpl.as_within) {
                    mpl_internal_warning(mpl, 'keyword in understood as within');
                    mpl.as_within = 1;
                }
                mpl_internal_get_token(mpl);
                within = {};
                within.code = null;
                within.next = null;
                if (set.within == null)
                    set.within = within;
                else {
                    for (temp = set.within; temp.next != null; temp = temp.next) {
                    }
                    temp.next = within;
                }
                within.code = mpl_internal_expression_9(mpl);
                if (within.code.type != A_ELEMSET)
                    mpl_internal_error(mpl, 'expression following within has invalid type');
                xassert(within.code.dim > 0);
                if (set.dimen == 0)
                    set.dimen = within.code.dim;
                if (set.dimen != within.code.dim)
                    mpl_internal_error(mpl, 'set expression following within must have di' + 'mension ' + set.dimen + ' rather than ' + within.code.dim);
            } else if (mpl.token == T_ASSIGN) {
                if (!(set.assign == null && set.option == null && set.gadget == null))
                    err();
                mpl_internal_get_token(mpl);
                set.assign = mpl_internal_expression_9(mpl);
                if (set.assign.type != A_ELEMSET)
                    mpl_internal_error(mpl, 'expression following := has invalid type');
                xassert(set.assign.dim > 0);
                if (set.dimen == 0)
                    set.dimen = set.assign.dim;
                if (set.dimen != set.assign.dim)
                    mpl_internal_error(mpl, 'set expression following := must have dimens' + 'ion ' + set.dimen + ' rather than ' + set.assign.dim);
            } else if (mpl_internal_is_keyword(mpl, 'default')) {
                if (!(set.assign == null && set.option == null))
                    err();
                mpl_internal_get_token(mpl);
                set.option = mpl_internal_expression_9(mpl);
                if (set.option.type != A_ELEMSET)
                    mpl_internal_error(mpl, 'expression following default has invalid type');
                xassert(set.option.dim > 0);
                if (set.dimen == 0)
                    set.dimen = set.option.dim;
                if (set.dimen != set.option.dim)
                    mpl_internal_error(mpl, 'set expression following default must have d' + 'imension ' + set.dimen + ' rather than ' + set.option.dim);
            } else if (mpl_internal_is_keyword(mpl, 'data')) {
                var i = 0, k, fff = new Array(20);
                if (!(set.assign == null && set.gadget == null))
                    err();
                mpl_internal_get_token(mpl);
                set.gadget = gadget = {};
                if (mpl.token == T_NAME) {
                } else if (mpl_internal_is_reserved(mpl))
                    mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
                else
                    mpl_internal_error(mpl, 'set name missing where expected');
                node = mpl.tree[mpl.image];
                if (node == null)
                    mpl_internal_error(mpl, mpl.image + ' not defined');
                if (node.type != A_SET)
                    err1();
                gadget.set = node.link;
                if (gadget.set.dim != 0)
                    err1();
                if (gadget.set == set)
                    mpl_internal_error(mpl, 'set cannot be initialized by itself');
                if (set.dim >= gadget.set.dimen)
                    err2();
                if (set.dimen == 0)
                    set.dimen = gadget.set.dimen - set.dim;
                if (set.dim + set.dimen > gadget.set.dimen)
                    err2();
                else if (set.dim + set.dimen < gadget.set.dimen)
                    mpl_internal_error(mpl, 'dimension of ' + mpl.image + ' too big');
                mpl_internal_get_token(mpl);
                if (mpl.token == T_LEFT)
                    mpl_internal_get_token(mpl);
                else
                    mpl_internal_error(mpl, 'left parenthesis missing where expected');
                for (k = 0; k < gadget.set.dimen; k++)
                    fff[k] = 0;
                k = 0;
                for (;;) {
                    if (mpl.token != T_NUMBER)
                        mpl_internal_error(mpl, 'component number missing where expected');
                    if (str2int(mpl.image, function (v) {
                            i = v;
                        }) != 0)
                        err3();
                    if (!(1 <= i && i <= gadget.set.dimen))
                        err3();
                    if (fff[i - 1] != 0)
                        mpl_internal_error(mpl, 'component ' + i + ' multiply specified');
                    gadget.ind[k++] = i;
                    fff[i - 1] = 1;
                    xassert(k <= gadget.set.dimen);
                    mpl_internal_get_token(mpl);
                    if (mpl.token == T_COMMA)
                        mpl_internal_get_token(mpl);
                    else if (mpl.token == T_RIGHT)
                        break;
                    else
                        mpl_internal_error(mpl, 'syntax error in data attribute');
                }
                if (k < gadget.set.dimen)
                    mpl_internal_error(mpl, 'there are must be ' + gadget.set.dimen + ' components rather than ' + k);
                mpl_internal_get_token(mpl);
            } else
                mpl_internal_error(mpl, 'syntax error in set statement');
        }
        if (set.domain != null)
            mpl_internal_close_scope(mpl, set.domain);
        if (set.dimen == 0)
            set.dimen = 1;
        xassert(mpl.token == T_SEMICOLON);
        mpl_internal_get_token(mpl);
        return set;
    }
    function mpl_internal_parameter_statement(mpl) {
        var par, temp;
        var integer_used = 0, binary_used = 0, symbolic_used = 0;
        function process_binary() {
            if (binary_used)
                mpl_internal_error(mpl, 'at most one binary allowed');
            if (par.type == A_SYMBOLIC)
                mpl_internal_error(mpl, 'symbolic parameter cannot be binary');
            par.type = A_BINARY;
            binary_used = 1;
            mpl_internal_get_token(mpl);
        }
        function err() {
            mpl_internal_error(mpl, 'at most one := or default allowed');
        }
        xassert(mpl_internal_is_keyword(mpl, 'param'));
        mpl_internal_get_token(mpl);
        if (mpl.token == T_NAME) {
        } else if (mpl_internal_is_reserved(mpl))
            mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
        else
            mpl_internal_error(mpl, 'symbolic name missing where expected');
        if (mpl.tree[mpl.image] != null)
            mpl_internal_error(mpl, mpl.image + ' multiply declared');
        par = {};
        par.name = mpl.image;
        par.alias = null;
        par.dim = 0;
        par.domain = null;
        par.type = A_NUMERIC;
        par.cond = null;
        par.in_ = null;
        par.assign = null;
        par.option = null;
        par.data = 0;
        par.defval = null;
        par.array = null;
        mpl_internal_get_token(mpl);
        if (mpl.token == T_STRING) {
            par.alias = mpl.image;
            mpl_internal_get_token(mpl);
        }
        if (mpl.token == T_LBRACE) {
            par.domain = mpl_internal_indexing_expression(mpl);
            par.dim = mpl_internal_domain_arity(mpl, par.domain);
        }
        {
            var node = mpl.tree[par.name] = {};
            node.type = A_PARAMETER;
            node.link = par;
        }
        for (;;) {
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            else if (mpl.token == T_SEMICOLON)
                break;
            if (mpl_internal_is_keyword(mpl, 'integer')) {
                if (integer_used)
                    mpl_internal_error(mpl, 'at most one integer allowed');
                if (par.type == A_SYMBOLIC)
                    mpl_internal_error(mpl, 'symbolic parameter cannot be integer');
                if (par.type != A_BINARY)
                    par.type = A_INTEGER;
                integer_used = 1;
                mpl_internal_get_token(mpl);
            } else if (mpl_internal_is_keyword(mpl, 'binary'))
                process_binary();
            else if (mpl_internal_is_keyword(mpl, 'logical')) {
                if (!mpl.as_binary) {
                    mpl_internal_warning(mpl, 'keyword logical understood as binary');
                    mpl.as_binary = 1;
                }
                process_binary();
            } else if (mpl_internal_is_keyword(mpl, 'symbolic')) {
                if (symbolic_used)
                    mpl_internal_error(mpl, 'at most one symbolic allowed');
                if (par.type != A_NUMERIC)
                    mpl_internal_error(mpl, 'integer or binary parameter cannot be symbolic');
                if (!(par.cond == null && par.in_ == null && par.assign == null && par.option == null))
                    mpl_internal_error(mpl, 'keyword symbolic must precede any other parameter attributes');
                par.type = A_SYMBOLIC;
                symbolic_used = 1;
                mpl_internal_get_token(mpl);
            } else if (mpl.token == T_LT || mpl.token == T_LE || mpl.token == T_EQ || mpl.token == T_GE || mpl.token == T_GT || mpl.token == T_NE) {
                var opstr;
                var cond = {};
                switch (mpl.token) {
                case T_LT:
                    cond.rho = O_LT;
                    opstr = mpl.image;
                    break;
                case T_LE:
                    cond.rho = O_LE;
                    opstr = mpl.image;
                    break;
                case T_EQ:
                    cond.rho = O_EQ;
                    opstr = mpl.image;
                    break;
                case T_GE:
                    cond.rho = O_GE;
                    opstr = mpl.image;
                    break;
                case T_GT:
                    cond.rho = O_GT;
                    opstr = mpl.image;
                    break;
                case T_NE:
                    cond.rho = O_NE;
                    opstr = mpl.image;
                    break;
                default:
                    xassert(mpl.token != mpl.token);
                }
                xassert(opstr.length < 8);
                cond.code = null;
                cond.next = null;
                if (par.cond == null)
                    par.cond = cond;
                else {
                    for (temp = par.cond; temp.next != null; temp = temp.next) {
                    }
                    temp.next = cond;
                }
                mpl_internal_get_token(mpl);
                cond.code = mpl_internal_expression_5(mpl);
                if (!(cond.code.type == A_NUMERIC || cond.code.type == A_SYMBOLIC))
                    mpl_internal_error(mpl, 'expression following ' + opstr + ' has invalid type');
                xassert(cond.code.dim == 0);
                if (par.type != A_SYMBOLIC && cond.code.type == A_SYMBOLIC)
                    cond.code = mpl_internal_make_unary(mpl, O_CVTNUM, cond.code, A_NUMERIC, 0);
                if (par.type == A_SYMBOLIC && cond.code.type != A_SYMBOLIC)
                    cond.code = mpl_internal_make_unary(mpl, O_CVTSYM, cond.code, A_SYMBOLIC, 0);
            } else if (mpl.token == T_IN || mpl.token == T_WITHIN) {
                var in_;
                if (mpl.token == T_WITHIN && !mpl.as_in) {
                    mpl_internal_warning(mpl, 'keyword within understood as in');
                    mpl.as_in = 1;
                }
                mpl_internal_get_token(mpl);
                in_ = {};
                in_.code = null;
                in_.next = null;
                if (par.in_ == null)
                    par.in_ = in_;
                else {
                    for (temp = par.in_; temp.next != null; temp = temp.next) {
                    }
                    temp.next = in_;
                }
                in_.code = mpl_internal_expression_9(mpl);
                if (in_.code.type != A_ELEMSET)
                    mpl_internal_error(mpl, 'expression following in has invalid type');
                xassert(in_.code.dim > 0);
                if (in_.code.dim != 1)
                    mpl_internal_error(mpl, 'set expression following in must have dimens' + 'ion 1 rather than ' + in_.code.dim);
            } else if (mpl.token == T_ASSIGN) {
                if (!(par.assign == null && par.option == null))
                    err();
                mpl_internal_get_token(mpl);
                par.assign = mpl_internal_expression_5(mpl);
                if (!(par.assign.type == A_NUMERIC || par.assign.type == A_SYMBOLIC))
                    mpl_internal_error(mpl, 'expression following := has invalid type');
                xassert(par.assign.dim == 0);
                if (par.type != A_SYMBOLIC && par.assign.type == A_SYMBOLIC)
                    par.assign = mpl_internal_make_unary(mpl, O_CVTNUM, par.assign, A_NUMERIC, 0);
                if (par.type == A_SYMBOLIC && par.assign.type != A_SYMBOLIC)
                    par.assign = mpl_internal_make_unary(mpl, O_CVTSYM, par.assign, A_SYMBOLIC, 0);
            } else if (mpl_internal_is_keyword(mpl, 'default')) {
                if (!(par.assign == null && par.option == null))
                    err();
                mpl_internal_get_token(mpl);
                par.option = mpl_internal_expression_5(mpl);
                if (!(par.option.type == A_NUMERIC || par.option.type == A_SYMBOLIC))
                    mpl_internal_error(mpl, 'expression following default has invalid type');
                xassert(par.option.dim == 0);
                if (par.type != A_SYMBOLIC && par.option.type == A_SYMBOLIC)
                    par.option = mpl_internal_make_unary(mpl, O_CVTNUM, par.option, A_NUMERIC, 0);
                if (par.type == A_SYMBOLIC && par.option.type != A_SYMBOLIC)
                    par.option = mpl_internal_make_unary(mpl, O_CVTSYM, par.option, A_SYMBOLIC, 0);
            } else
                mpl_internal_error(mpl, 'syntax error in parameter statement');
        }
        if (par.domain != null)
            mpl_internal_close_scope(mpl, par.domain);
        xassert(mpl.token == T_SEMICOLON);
        mpl_internal_get_token(mpl);
        return par;
    }
    function mpl_internal_variable_statement(mpl) {
        var integer_used = 0, binary_used = 0;
        function process_binary() {
            if (binary_used)
                mpl_internal_error(mpl, 'at most one binary allowed');
            var_.type = A_BINARY;
            binary_used = 1;
            mpl_internal_get_token(mpl);
        }
        xassert(mpl_internal_is_keyword(mpl, 'var'));
        if (mpl.flag_s)
            mpl_internal_error(mpl, 'variable statement must precede solve statement');
        mpl_internal_get_token(mpl);
        if (mpl.token == T_NAME) {
        } else if (mpl_internal_is_reserved(mpl))
            mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
        else
            mpl_internal_error(mpl, 'symbolic name missing where expected');
        if (mpl.tree[mpl.image] != null)
            mpl_internal_error(mpl, mpl.image + ' multiply declared');
        var var_ = {};
        var_.name = mpl.image;
        var_.alias = null;
        var_.dim = 0;
        var_.domain = null;
        var_.type = A_NUMERIC;
        var_.lbnd = null;
        var_.ubnd = null;
        var_.array = null;
        mpl_internal_get_token(mpl);
        if (mpl.token == T_STRING) {
            var_.alias = mpl.image;
            mpl_internal_get_token(mpl);
        }
        if (mpl.token == T_LBRACE) {
            var_.domain = mpl_internal_indexing_expression(mpl);
            var_.dim = mpl_internal_domain_arity(mpl, var_.domain);
        }
        {
            var node = mpl.tree[var_.name] = {};
            node.type = A_VARIABLE;
            node.link = var_;
        }
        for (;;) {
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            else if (mpl.token == T_SEMICOLON)
                break;
            if (mpl_internal_is_keyword(mpl, 'integer')) {
                if (integer_used)
                    mpl_internal_error(mpl, 'at most one integer allowed');
                if (var_.type != A_BINARY)
                    var_.type = A_INTEGER;
                integer_used = 1;
                mpl_internal_get_token(mpl);
            } else if (mpl_internal_is_keyword(mpl, 'binary'))
                process_binary();
            else if (mpl_internal_is_keyword(mpl, 'logical')) {
                if (!mpl.as_binary) {
                    mpl_internal_warning(mpl, 'keyword logical understood as binary');
                    mpl.as_binary = 1;
                }
                process_binary();
            } else if (mpl_internal_is_keyword(mpl, 'symbolic'))
                mpl_internal_error(mpl, 'variable cannot be symbolic');
            else if (mpl.token == T_GE) {
                if (var_.lbnd != null) {
                    if (var_.lbnd == var_.ubnd)
                        mpl_internal_error(mpl, 'both fixed value and lower bound not allowed');
                    else
                        mpl_internal_error(mpl, 'at most one lower bound allowed');
                }
                mpl_internal_get_token(mpl);
                var_.lbnd = mpl_internal_expression_5(mpl);
                if (var_.lbnd.type == A_SYMBOLIC)
                    var_.lbnd = mpl_internal_make_unary(mpl, O_CVTNUM, var_.lbnd, A_NUMERIC, 0);
                if (var_.lbnd.type != A_NUMERIC)
                    mpl_internal_error(mpl, 'expression following >= has invalid type');
                xassert(var_.lbnd.dim == 0);
            } else if (mpl.token == T_LE) {
                if (var_.ubnd != null) {
                    if (var_.ubnd == var_.lbnd)
                        mpl_internal_error(mpl, 'both fixed value and upper bound not allowed');
                    else
                        mpl_internal_error(mpl, 'at most one upper bound allowed');
                }
                mpl_internal_get_token(mpl);
                var_.ubnd = mpl_internal_expression_5(mpl);
                if (var_.ubnd.type == A_SYMBOLIC)
                    var_.ubnd = mpl_internal_make_unary(mpl, O_CVTNUM, var_.ubnd, A_NUMERIC, 0);
                if (var_.ubnd.type != A_NUMERIC)
                    mpl_internal_error(mpl, 'expression following <= has invalid type');
                xassert(var_.ubnd.dim == 0);
            } else if (mpl.token == T_EQ) {
                var opstr;
                if (!(var_.lbnd == null && var_.ubnd == null)) {
                    if (var_.lbnd == var_.ubnd)
                        mpl_internal_error(mpl, 'at most one fixed value allowed');
                    else if (var_.lbnd != null)
                        mpl_internal_error(mpl, 'both lower bound and fixed value not allowed');
                    else
                        mpl_internal_error(mpl, 'both upper bound and fixed value not allowed');
                }
                opstr = mpl.image;
                xassert(opstr.length < 8);
                mpl_internal_get_token(mpl);
                var_.lbnd = mpl_internal_expression_5(mpl);
                if (var_.lbnd.type == A_SYMBOLIC)
                    var_.lbnd = mpl_internal_make_unary(mpl, O_CVTNUM, var_.lbnd, A_NUMERIC, 0);
                if (var_.lbnd.type != A_NUMERIC)
                    mpl_internal_error(mpl, 'expression following ' + opstr + ' has invalid type');
                xassert(var_.lbnd.dim == 0);
                var_.ubnd = var_.lbnd;
            } else if (mpl.token == T_LT || mpl.token == T_GT || mpl.token == T_NE)
                mpl_internal_error(mpl, 'strict bound not allowed');
            else
                mpl_internal_error(mpl, 'syntax error in variable statement');
        }
        if (var_.domain != null)
            mpl_internal_close_scope(mpl, var_.domain);
        xassert(mpl.token == T_SEMICOLON);
        mpl_internal_get_token(mpl);
        return var_;
    }
    function mpl_internal_constraint_statement(mpl) {
        var first, second, third;
        var rho;
        var opstr;
        function err() {
            mpl_internal_error(mpl, 'syntax error in constraint statement');
        }
        if (mpl.flag_s)
            mpl_internal_error(mpl, 'constraint statement must precede solve statement');
        if (mpl_internal_is_keyword(mpl, 'subject')) {
            mpl_internal_get_token(mpl);
            if (!mpl_internal_is_keyword(mpl, 'to'))
                mpl_internal_error(mpl, 'keyword subject to incomplete');
            mpl_internal_get_token(mpl);
        } else if (mpl_internal_is_keyword(mpl, 'subj')) {
            mpl_internal_get_token(mpl);
            if (!mpl_internal_is_keyword(mpl, 'to'))
                mpl_internal_error(mpl, 'keyword subj to incomplete');
            mpl_internal_get_token(mpl);
        } else if (mpl.token == T_SPTP)
            mpl_internal_get_token(mpl);
        if (mpl.token == T_NAME) {
        } else if (mpl_internal_is_reserved(mpl))
            mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
        else
            mpl_internal_error(mpl, 'symbolic name missing where expected');
        if (mpl.tree[mpl.image] != null)
            mpl_internal_error(mpl, mpl.image + ' multiply declared');
        var con = {};
        con.name = mpl.image;
        con.alias = null;
        con.dim = 0;
        con.domain = null;
        con.type = A_CONSTRAINT;
        con.code = null;
        con.lbnd = null;
        con.ubnd = null;
        con.array = null;
        mpl_internal_get_token(mpl);
        if (mpl.token == T_STRING) {
            con.alias = mpl.image;
            mpl_internal_get_token(mpl);
        }
        if (mpl.token == T_LBRACE) {
            con.domain = mpl_internal_indexing_expression(mpl);
            con.dim = mpl_internal_domain_arity(mpl, con.domain);
        }
        {
            var node = mpl.tree[con.name] = {};
            node.type = A_CONSTRAINT;
            node.link = con;
        }
        if (mpl.token != T_COLON)
            mpl_internal_error(mpl, 'colon missing where expected');
        mpl_internal_get_token(mpl);
        first = mpl_internal_expression_5(mpl);
        if (first.type == A_SYMBOLIC)
            first = mpl_internal_make_unary(mpl, O_CVTNUM, first, A_NUMERIC, 0);
        if (!(first.type == A_NUMERIC || first.type == A_FORMULA))
            mpl_internal_error(mpl, 'expression following colon has invalid type');
        xassert(first.dim == 0);
        if (mpl.token == T_COMMA)
            mpl_internal_get_token(mpl);
        switch (mpl.token) {
        case T_LE:
        case T_GE:
        case T_EQ:
            break;
        case T_LT:
        case T_GT:
        case T_NE:
            mpl_internal_error(mpl, 'strict inequality not allowed');
            break;
        case T_SEMICOLON:
            mpl_internal_error(mpl, 'constraint must be equality or inequality');
            break;
        default:
            err();
        }
        rho = mpl.token;
        opstr = mpl.image;
        xassert(opstr.length < 8);
        mpl_internal_get_token(mpl);
        second = mpl_internal_expression_5(mpl);
        if (second.type == A_SYMBOLIC)
            second = mpl_internal_make_unary(mpl, O_CVTNUM, second, A_NUMERIC, 0);
        if (!(second.type == A_NUMERIC || second.type == A_FORMULA))
            mpl_internal_error(mpl, 'expression following ' + opstr + ' has invalid type');
        xassert(second.dim == 0);
        if (mpl.token == T_COMMA) {
            mpl_internal_get_token(mpl);
            if (mpl.token == T_SEMICOLON)
                err();
        }
        if (mpl.token == T_LT || mpl.token == T_LE || mpl.token == T_EQ || mpl.token == T_GE || mpl.token == T_GT || mpl.token == T_NE) {
            if (rho == T_EQ || mpl.token != rho)
                mpl_internal_error(mpl, 'double inequality must be ... <= ... <= ... or ' + '... >= ... >= ...');
            if (first.type == A_FORMULA)
                mpl_internal_error(mpl, 'leftmost expression in double inequality cannot' + ' be linear form');
            mpl_internal_get_token(mpl);
            third = mpl_internal_expression_5(mpl);
            if (third.type == A_SYMBOLIC)
                third = mpl_internal_make_unary(mpl, O_CVTNUM, second, A_NUMERIC, 0);
            if (!(third.type == A_NUMERIC || third.type == A_FORMULA))
                mpl_internal_error(mpl, 'rightmost expression in double inequality const' + 'raint has invalid type');
            xassert(third.dim == 0);
            if (third.type == A_FORMULA)
                mpl_internal_error(mpl, 'rightmost expression in double inequality canno' + 't be linear form');
        } else {
            third = null;
        }
        if (con.domain != null)
            mpl_internal_close_scope(mpl, con.domain);
        if (first.type != A_FORMULA)
            first = mpl_internal_make_unary(mpl, O_CVTLFM, first, A_FORMULA, 0);
        if (second.type != A_FORMULA)
            second = mpl_internal_make_unary(mpl, O_CVTLFM, second, A_FORMULA, 0);
        if (third != null)
            third = mpl_internal_make_unary(mpl, O_CVTLFM, third, A_FORMULA, 0);
        if (third == null) {
            switch (rho) {
            case T_LE:
                con.code = first;
                con.lbnd = null;
                con.ubnd = second;
                break;
            case T_GE:
                con.code = first;
                con.lbnd = second;
                con.ubnd = null;
                break;
            case T_EQ:
                con.code = first;
                con.lbnd = second;
                con.ubnd = second;
                break;
            default:
                xassert(rho != rho);
            }
        } else {
            switch (rho) {
            case T_LE:
                con.code = second;
                con.lbnd = first;
                con.ubnd = third;
                break;
            case T_GE:
                con.code = second;
                con.lbnd = third;
                con.ubnd = first;
                break;
            default:
                xassert(rho != rho);
            }
        }
        if (mpl.token != T_SEMICOLON)
            err();
        mpl_internal_get_token(mpl);
        return con;
    }
    function mpl_internal_objective_statement(mpl) {
        var obj;
        var type;
        if (mpl_internal_is_keyword(mpl, 'minimize'))
            type = A_MINIMIZE;
        else if (mpl_internal_is_keyword(mpl, 'maximize'))
            type = A_MAXIMIZE;
        else
            xassert(mpl != mpl);
        if (mpl.flag_s)
            mpl_internal_error(mpl, 'objective statement must precede solve statement');
        mpl_internal_get_token(mpl);
        if (mpl.token == T_NAME) {
        } else if (mpl_internal_is_reserved(mpl))
            mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
        else
            mpl_internal_error(mpl, 'symbolic name missing where expected');
        if (mpl.tree[mpl.image] != null)
            mpl_internal_error(mpl, mpl.image + ' multiply declared');
        obj = {};
        obj.name = mpl.image;
        obj.alias = null;
        obj.dim = 0;
        obj.domain = null;
        obj.type = type;
        obj.code = null;
        obj.lbnd = null;
        obj.ubnd = null;
        obj.array = null;
        mpl_internal_get_token(mpl);
        if (mpl.token == T_STRING) {
            obj.alias = mpl.image;
            mpl_internal_get_token(mpl);
        }
        if (mpl.token == T_LBRACE) {
            obj.domain = mpl_internal_indexing_expression(mpl);
            obj.dim = mpl_internal_domain_arity(mpl, obj.domain);
        }
        {
            var node = mpl.tree[obj.name] = {};
            node.type = A_CONSTRAINT;
            node.link = obj;
        }
        if (mpl.token != T_COLON)
            mpl_internal_error(mpl, 'colon missing where expected');
        mpl_internal_get_token(mpl);
        obj.code = mpl_internal_expression_5(mpl);
        if (obj.code.type == A_SYMBOLIC)
            obj.code = mpl_internal_make_unary(mpl, O_CVTNUM, obj.code, A_NUMERIC, 0);
        if (obj.code.type == A_NUMERIC)
            obj.code = mpl_internal_make_unary(mpl, O_CVTLFM, obj.code, A_FORMULA, 0);
        if (obj.code.type != A_FORMULA)
            mpl_internal_error(mpl, 'expression following colon has invalid type');
        xassert(obj.code.dim == 0);
        if (obj.domain != null)
            mpl_internal_close_scope(mpl, obj.domain);
        if (mpl.token != T_SEMICOLON)
            mpl_internal_error(mpl, 'syntax error in objective statement');
        mpl_internal_get_token(mpl);
        return obj;
    }
    function mpl_internal_table_statement(mpl) {
        var last_arg, arg;
        var last_fld, fld;
        var last_in, in_;
        var last_out, out;
        var node;
        var nflds;
        var name;
        xassert(mpl_internal_is_keyword(mpl, 'table'));
        mpl_internal_get_token(mpl);
        if (mpl.token == T_NAME) {
        } else if (mpl_internal_is_reserved(mpl))
            mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
        else
            mpl_internal_error(mpl, 'symbolic name missing where expected');
        if (mpl.tree[mpl.image] != null)
            mpl_internal_error(mpl, mpl.image + ' multiply declared');
        var tab = {
            u: {
                in_: {},
                out: {}
            }
        };
        tab.name = mpl.image;
        mpl_internal_get_token(mpl);
        if (mpl.token == T_STRING) {
            tab.alias = mpl.image;
            mpl_internal_get_token(mpl);
        } else
            tab.alias = null;
        if (mpl.token == T_LBRACE) {
            tab.type = A_OUTPUT;
            tab.u.out.domain = mpl_internal_indexing_expression(mpl);
            if (!mpl_internal_is_keyword(mpl, 'OUT'))
                mpl_internal_error(mpl, 'keyword OUT missing where expected');
            mpl_internal_get_token(mpl);
        } else {
            tab.type = A_INPUT;
            if (!mpl_internal_is_keyword(mpl, 'IN'))
                mpl_internal_error(mpl, 'keyword IN missing where expected');
            mpl_internal_get_token(mpl);
        }
        tab.arg = last_arg = null;
        for (;;) {
            arg = {};
            if (mpl.token == T_COMMA || mpl.token == T_COLON || mpl.token == T_SEMICOLON)
                mpl_internal_error(mpl, 'argument expression missing where expected');
            arg.code = mpl_internal_expression_5(mpl);
            if (arg.code.type == A_NUMERIC)
                arg.code = mpl_internal_make_unary(mpl, O_CVTSYM, arg.code, A_SYMBOLIC, 0);
            if (arg.code.type != A_SYMBOLIC)
                mpl_internal_error(mpl, 'argument expression has invalid type');
            arg.next = null;
            if (last_arg == null)
                tab.arg = arg;
            else
                last_arg.next = arg;
            last_arg = arg;
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            else if (mpl.token == T_COLON || mpl.token == T_SEMICOLON)
                break;
        }
        xassert(tab.arg != null);
        if (mpl.token == T_COLON)
            mpl_internal_get_token(mpl);
        else
            mpl_internal_error(mpl, 'colon missing where expected');
        switch (tab.type) {
        case A_INPUT:
            if (mpl.token == T_NAME) {
                node = mpl.tree[mpl.image];
                if (node == null)
                    mpl_internal_error(mpl, mpl.image + ' not defined');
                if (node.type != A_SET)
                    mpl_internal_error(mpl, mpl.image + ' not a set');
                tab.u.in_.set = node.link;
                if (tab.u.in_.set.assign != null)
                    mpl_internal_error(mpl, mpl.image + ' needs no data');
                if (tab.u.in_.set.dim != 0)
                    mpl_internal_error(mpl, mpl.image + ' must be a simple set');
                mpl_internal_get_token(mpl);
                if (mpl.token == T_INPUT)
                    mpl_internal_get_token(mpl);
                else
                    mpl_internal_error(mpl, 'delimiter <- missing where expected');
            } else if (mpl_internal_is_reserved(mpl))
                mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
            else
                tab.u.in_.set = null;
            tab.u.in_.fld = last_fld = null;
            nflds = 0;
            if (mpl.token == T_LBRACKET)
                mpl_internal_get_token(mpl);
            else
                mpl_internal_error(mpl, 'field list missing where expected');
            for (;;) {
                fld = {};
                if (mpl.token == T_NAME) {
                } else if (mpl_internal_is_reserved(mpl))
                    mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
                else
                    mpl_internal_error(mpl, 'field name missing where expected');
                fld.name = mpl.image;
                mpl_internal_get_token(mpl);
                fld.next = null;
                if (last_fld == null)
                    tab.u.in_.fld = fld;
                else
                    last_fld.next = fld;
                last_fld = fld;
                nflds++;
                if (mpl.token == T_COMMA)
                    mpl_internal_get_token(mpl);
                else if (mpl.token == T_RBRACKET)
                    break;
                else
                    mpl_internal_error(mpl, 'syntax error in field list');
            }
            if (tab.u.in_.set != null && tab.u.in_.set.dimen != nflds)
                mpl_internal_error(mpl, 'there must be ' + tab.u.in_.set.dimen + ' field' + (tab.u.in_.set.dimen == 1 ? '' : 's') + ' rather than ' + nflds);
            mpl_internal_get_token(mpl);
            tab.u.in_.list = last_in = null;
            while (mpl.token == T_COMMA) {
                mpl_internal_get_token(mpl);
                in_ = {};
                if (mpl.token == T_NAME) {
                } else if (mpl_internal_is_reserved(mpl))
                    mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
                else
                    mpl_internal_error(mpl, 'parameter name missing where expected');
                node = mpl.tree[mpl.image];
                if (node == null)
                    mpl_internal_error(mpl, mpl.image + ' not defined');
                if (node.type != A_PARAMETER)
                    mpl_internal_error(mpl, mpl.image + ' not a parameter');
                in_.par = node.link;
                if (in_.par.dim != nflds)
                    mpl_internal_error(mpl, mpl.image + ' must have ' + nflds + ' subscript' + (nflds == 1 ? '' : 's') + ' rather than ' + in_.par.dim);
                if (in_.par.assign != null)
                    mpl_internal_error(mpl, mpl.image + ' needs no data');
                mpl_internal_get_token(mpl);
                if (mpl.token == T_TILDE) {
                    mpl_internal_get_token(mpl);
                    if (mpl.token == T_NAME) {
                    } else if (mpl_internal_is_reserved(mpl))
                        mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
                    else
                        mpl_internal_error(mpl, 'field name missing where expected');
                    name = mpl.image;
                    mpl_internal_get_token(mpl);
                } else {
                    name = in_.par.name;
                }
                in_.name = name;
                in_.next = null;
                if (last_in == null)
                    tab.u.in_.list = in_;
                else
                    last_in.next = in_;
                last_in = in_;
            }
            break;
        case A_OUTPUT:
            tab.u.out.list = last_out = null;
            for (;;) {
                out = {};
                if (mpl.token == T_COMMA || mpl.token == T_SEMICOLON)
                    mpl_internal_error(mpl, 'expression missing where expected');
                if (mpl.token == T_NAME) {
                    name = mpl.image;
                } else
                    name = '';
                out.code = mpl_internal_expression_5(mpl);
                if (mpl.token == T_TILDE) {
                    mpl_internal_get_token(mpl);
                    if (mpl.token == T_NAME) {
                    } else if (mpl_internal_is_reserved(mpl))
                        mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
                    else
                        mpl_internal_error(mpl, 'field name missing where expected');
                    name = mpl.image;
                    mpl_internal_get_token(mpl);
                }
                if (name == '')
                    mpl_internal_error(mpl, 'field name required');
                out.name = name;
                out.next = null;
                if (last_out == null)
                    tab.u.out.list = out;
                else
                    last_out.next = out;
                last_out = out;
                if (mpl.token == T_COMMA)
                    mpl_internal_get_token(mpl);
                else if (mpl.token == T_SEMICOLON)
                    break;
                else
                    mpl_internal_error(mpl, 'syntax error in output list');
            }
            mpl_internal_close_scope(mpl, tab.u.out.domain);
            break;
        default:
            xassert(tab != tab);
        }
        if (mpl.token != T_SEMICOLON)
            mpl_internal_error(mpl, 'syntax error in table statement');
        mpl_internal_get_token(mpl);
        return tab;
    }
    function mpl_internal_solve_statement(mpl) {
        xassert(mpl_internal_is_keyword(mpl, 'solve'));
        if (mpl.flag_s)
            mpl_internal_error(mpl, 'at most one solve statement allowed');
        mpl.flag_s = 1;
        mpl_internal_get_token(mpl);
        if (mpl.token != T_SEMICOLON)
            mpl_internal_error(mpl, 'syntax error in solve statement');
        mpl_internal_get_token(mpl);
        return null;
    }
    function mpl_internal_check_statement(mpl) {
        xassert(mpl_internal_is_keyword(mpl, 'check'));
        var chk = {};
        chk.domain = null;
        chk.code = null;
        mpl_internal_get_token(mpl);
        if (mpl.token == T_LBRACE) {
            chk.domain = mpl_internal_indexing_expression(mpl);
        }
        if (mpl.token == T_COLON)
            mpl_internal_get_token(mpl);
        chk.code = mpl_internal_expression_13(mpl);
        if (chk.code.type != A_LOGICAL)
            mpl_internal_error(mpl, 'expression has invalid type');
        xassert(chk.code.dim == 0);
        if (chk.domain != null)
            mpl_internal_close_scope(mpl, chk.domain);
        if (mpl.token != T_SEMICOLON)
            mpl_internal_error(mpl, 'syntax error in check statement');
        mpl_internal_get_token(mpl);
        return chk;
    }
    function mpl_internal_display_statement(mpl) {
        var last_entry;
        xassert(mpl_internal_is_keyword(mpl, 'display'));
        var dpy = {};
        dpy.domain = null;
        dpy.list = last_entry = null;
        mpl_internal_get_token(mpl);
        if (mpl.token == T_LBRACE)
            dpy.domain = mpl_internal_indexing_expression(mpl);
        if (mpl.token == T_COLON)
            mpl_internal_get_token(mpl);
        for (;;) {
            var entry = { u: {} };
            function expr() {
                entry.type = A_EXPRESSION;
                entry.u.code = mpl_internal_expression_13(mpl);
            }
            entry.type = 0;
            entry.next = null;
            if (dpy.list == null)
                dpy.list = entry;
            else
                last_entry.next = entry;
            last_entry = entry;
            if (mpl.token == T_NAME) {
                var node;
                var next_token;
                mpl_internal_get_token(mpl);
                next_token = mpl.token;
                mpl_internal_unget_token(mpl);
                if (!(next_token == T_COMMA || next_token == T_SEMICOLON)) {
                    expr();
                } else {
                    node = mpl.tree[mpl.image];
                    if (node == null)
                        mpl_internal_error(mpl, mpl.image + ' not defined');
                    entry.type = node.type;
                    switch (node.type) {
                    case A_INDEX:
                        entry.u.slot = node.link;
                        break;
                    case A_SET:
                        entry.u.set = node.link;
                        break;
                    case A_PARAMETER:
                        entry.u.par = node.link;
                        break;
                    case A_VARIABLE:
                        entry.u.var_ = node.link;
                        if (!mpl.flag_s)
                            mpl_internal_error(mpl, 'invalid reference to variable ' + entry.u.var_.name + ' above solve statement');
                        break;
                    case A_CONSTRAINT:
                        entry.u.con = node.link;
                        if (!mpl.flag_s)
                            mpl_internal_error(mpl, 'invalid reference to ' + (entry.u.con.type == A_CONSTRAINT ? 'constraint' : 'objective') + ' ' + entry.u.con.name + ' above solve statement');
                        break;
                    default:
                        xassert(node != node);
                    }
                    mpl_internal_get_token(mpl);
                }
            } else
                expr();
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            else
                break;
        }
        if (dpy.domain != null)
            mpl_internal_close_scope(mpl, dpy.domain);
        if (mpl.token != T_SEMICOLON)
            mpl_internal_error(mpl, 'syntax error in display statement');
        mpl_internal_get_token(mpl);
        return dpy;
    }
    function mpl_internal_printf_statement(mpl) {
        var entry, last_entry;
        xassert(mpl_internal_is_keyword(mpl, 'printf'));
        var prt = {};
        prt.domain = null;
        prt.fmt = null;
        prt.list = last_entry = null;
        mpl_internal_get_token(mpl);
        if (mpl.token == T_LBRACE) {
            prt.domain = mpl_internal_indexing_expression(mpl);
        }
        if (mpl.token == T_COLON)
            mpl_internal_get_token(mpl);
        prt.fmt = mpl_internal_expression_5(mpl);
        if (prt.fmt.type == A_NUMERIC)
            prt.fmt = mpl_internal_make_unary(mpl, O_CVTSYM, prt.fmt, A_SYMBOLIC, 0);
        if (prt.fmt.type != A_SYMBOLIC)
            mpl_internal_error(mpl, 'format expression has invalid type');
        while (mpl.token == T_COMMA) {
            mpl_internal_get_token(mpl);
            entry = {};
            entry.code = null;
            entry.next = null;
            if (prt.list == null)
                prt.list = entry;
            else
                last_entry.next = entry;
            last_entry = entry;
            entry.code = mpl_internal_expression_9(mpl);
            if (!(entry.code.type == A_NUMERIC || entry.code.type == A_SYMBOLIC || entry.code.type == A_LOGICAL))
                mpl_internal_error(mpl, 'only numeric, symbolic, or logical expression allowed');
        }
        if (prt.domain != null)
            mpl_internal_close_scope(mpl, prt.domain);
        prt.fname = null;
        prt.app = 0;
        if (mpl.token == T_GT || mpl.token == T_APPEND) {
            prt.app = mpl.token == T_APPEND;
            mpl_internal_get_token(mpl);
            prt.fname = mpl_internal_expression_5(mpl);
            if (prt.fname.type == A_NUMERIC)
                prt.fname = mpl_internal_make_unary(mpl, O_CVTSYM, prt.fname, A_SYMBOLIC, 0);
            if (prt.fname.type != A_SYMBOLIC)
                mpl_internal_error(mpl, 'file name expression has invalid type');
        }
        if (mpl.token != T_SEMICOLON)
            mpl_internal_error(mpl, 'syntax error in printf statement');
        mpl_internal_get_token(mpl);
        return prt;
    }
    function mpl_internal_for_statement(mpl) {
        var stmt, last_stmt;
        xassert(mpl_internal_is_keyword(mpl, 'for'));
        var fur = {};
        fur.domain = null;
        fur.list = last_stmt = null;
        mpl_internal_get_token(mpl);
        if (mpl.token != T_LBRACE)
            mpl_internal_error(mpl, 'indexing expression missing where expected');
        fur.domain = mpl_internal_indexing_expression(mpl);
        if (mpl.token == T_COLON)
            mpl_internal_get_token(mpl);
        if (mpl.token != T_LBRACE) {
            fur.list = mpl_internal_simple_statement(mpl, 1);
        } else {
            mpl_internal_get_token(mpl);
            while (mpl.token != T_RBRACE) {
                stmt = mpl_internal_simple_statement(mpl, 1);
                if (last_stmt == null)
                    fur.list = stmt;
                else
                    last_stmt.next = stmt;
                last_stmt = stmt;
            }
            mpl_internal_get_token(mpl);
        }
        xassert(fur.domain != null);
        mpl_internal_close_scope(mpl, fur.domain);
        return fur;
    }
    function mpl_internal_end_statement(mpl) {
        if (!mpl.flag_d && mpl_internal_is_keyword(mpl, 'end') || mpl.flag_d && mpl_internal_is_literal(mpl, 'end')) {
            mpl_internal_get_token(mpl);
            if (mpl.token == T_SEMICOLON)
                mpl_internal_get_token(mpl);
            else
                mpl_internal_warning(mpl, 'no semicolon following end statement; missing' + ' semicolon inserted');
        } else
            mpl_internal_warning(mpl, 'unexpected end of file; missing end statement inserted');
        if (mpl.token != T_EOF)
            mpl_internal_warning(mpl, 'some text detected beyond end statement; text ignored');
    }
    function mpl_internal_simple_statement(mpl, spec) {
        var stmt = { u: {} };
        stmt.line = mpl.line;
        stmt.column = mpl.column;
        stmt.next = null;
        if (mpl_internal_is_keyword(mpl, 'set')) {
            if (spec)
                mpl_internal_error(mpl, 'set statement not allowed here');
            stmt.type = A_SET;
            stmt.u.set = mpl_internal_set_statement(mpl);
        } else if (mpl_internal_is_keyword(mpl, 'param')) {
            if (spec)
                mpl_internal_error(mpl, 'parameter statement not allowed here');
            stmt.type = A_PARAMETER;
            stmt.u.par = mpl_internal_parameter_statement(mpl);
        } else if (mpl_internal_is_keyword(mpl, 'var')) {
            if (spec)
                mpl_internal_error(mpl, 'variable statement not allowed here');
            stmt.type = A_VARIABLE;
            stmt.u.var_ = mpl_internal_variable_statement(mpl);
        } else if (mpl_internal_is_keyword(mpl, 'subject') || mpl_internal_is_keyword(mpl, 'subj') || mpl.token == T_SPTP) {
            if (spec)
                mpl_internal_error(mpl, 'constraint statement not allowed here');
            stmt.type = A_CONSTRAINT;
            stmt.u.con = mpl_internal_constraint_statement(mpl);
        } else if (mpl_internal_is_keyword(mpl, 'minimize') || mpl_internal_is_keyword(mpl, 'maximize')) {
            if (spec)
                mpl_internal_error(mpl, 'objective statement not allowed here');
            stmt.type = A_CONSTRAINT;
            stmt.u.con = mpl_internal_objective_statement(mpl);
        } else if (mpl_internal_is_keyword(mpl, 'table')) {
            if (spec)
                mpl_internal_error(mpl, 'table statement not allowed here');
            stmt.type = A_TABLE;
            stmt.u.tab = mpl_internal_table_statement(mpl);
        } else if (mpl_internal_is_keyword(mpl, 'solve')) {
            if (spec)
                mpl_internal_error(mpl, 'solve statement not allowed here');
            stmt.type = A_SOLVE;
            stmt.u.slv = mpl_internal_solve_statement(mpl);
        } else if (mpl_internal_is_keyword(mpl, 'check')) {
            stmt.type = A_CHECK;
            stmt.u.chk = mpl_internal_check_statement(mpl);
        } else if (mpl_internal_is_keyword(mpl, 'display')) {
            stmt.type = A_DISPLAY;
            stmt.u.dpy = mpl_internal_display_statement(mpl);
        } else if (mpl_internal_is_keyword(mpl, 'printf')) {
            stmt.type = A_PRINTF;
            stmt.u.prt = mpl_internal_printf_statement(mpl);
        } else if (mpl_internal_is_keyword(mpl, 'for')) {
            stmt.type = A_FOR;
            stmt.u.fur = mpl_internal_for_statement(mpl);
        } else if (mpl.token == T_NAME) {
            if (spec)
                mpl_internal_error(mpl, 'constraint statement not allowed here');
            stmt.type = A_CONSTRAINT;
            stmt.u.con = mpl_internal_constraint_statement(mpl);
        } else if (mpl_internal_is_reserved(mpl))
            mpl_internal_error(mpl, 'invalid use of reserved keyword ' + mpl.image);
        else
            mpl_internal_error(mpl, 'syntax error in model section');
        return stmt;
    }
    function mpl_internal_model_section(mpl) {
        var stmt, last_stmt;
        xassert(mpl.model == null);
        last_stmt = null;
        while (!(mpl.token == T_EOF || mpl_internal_is_keyword(mpl, 'data') || mpl_internal_is_keyword(mpl, 'end'))) {
            stmt = mpl_internal_simple_statement(mpl, 0);
            if (last_stmt == null)
                mpl.model = stmt;
            else
                last_stmt.next = stmt;
            last_stmt = stmt;
        }
    }
    function mpl_internal_expand_slice(mpl, slice, sym) {
        var temp;
        var tail = {};
        tail.sym = sym;
        tail.next = null;
        if (slice == null)
            slice = tail;
        else {
            for (temp = slice; temp.next != null; temp = temp.next) {
            }
            temp.next = tail;
        }
        return slice;
    }
    function mpl_internal_slice_dimen(mpl, slice) {
        var temp;
        var dim = 0;
        for (temp = slice; temp != null; temp = temp.next)
            dim++;
        return dim;
    }
    function mpl_internal_slice_arity(mpl, slice) {
        var temp;
        var arity = 0;
        for (temp = slice; temp != null; temp = temp.next)
            if (temp.sym == null)
                arity++;
        return arity;
    }
    function mpl_internal_fake_slice(mpl, dim) {
        var slice = null;
        while (dim-- > 0)
            slice = mpl_internal_expand_slice(mpl, slice, null);
        return slice;
    }
    function mpl_internal_delete_slice(mpl, slice) {
        var temp;
        while (slice != null) {
            temp = slice;
            slice = temp.next;
        }
    }
    function mpl_internal_is_number(mpl) {
        return mpl.token == T_NUMBER;
    }
    function mpl_internal_is_symbol(mpl) {
        return mpl.token == T_NUMBER || mpl.token == T_SYMBOL || mpl.token == T_STRING;
    }
    function mpl_internal_is_literal(mpl, literal) {
        return mpl_internal_is_symbol(mpl) && mpl.image == literal;
    }
    function mpl_internal_read_number(mpl) {
        xassert(mpl_internal_is_number(mpl));
        var num = mpl.value;
        mpl_internal_get_token(mpl);
        return num;
    }
    function mpl_internal_read_symbol(mpl) {
        var sym;
        xassert(mpl_internal_is_symbol(mpl));
        if (mpl_internal_is_number(mpl))
            sym = mpl_internal_create_symbol_num(mpl, mpl.value);
        else
            sym = mpl_internal_create_symbol_str(mpl, mpl.image);
        mpl_internal_get_token(mpl);
        return sym;
    }
    function mpl_internal_read_slice(mpl, name, dim) {
        var slice;
        var close;
        xassert(name != null);
        switch (mpl.token) {
        case T_LBRACKET:
            close = T_RBRACKET;
            break;
        case T_LEFT:
            xassert(dim > 0);
            close = T_RIGHT;
            break;
        default:
            xassert(mpl != mpl);
        }
        if (dim == 0)
            mpl_internal_error(mpl, name + ' cannot be subscripted');
        mpl_internal_get_token(mpl);
        slice = null;
        for (;;) {
            if (mpl_internal_is_symbol(mpl))
                slice = mpl_internal_expand_slice(mpl, slice, mpl_internal_read_symbol(mpl));
            else if (mpl.token == T_ASTERISK) {
                slice = mpl_internal_expand_slice(mpl, slice, null);
                mpl_internal_get_token(mpl);
            } else
                mpl_internal_error(mpl, 'number, symbol, or asterisk missing where expected');
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            else if (mpl.token == close)
                break;
            else
                mpl_internal_error(mpl, 'syntax error in slice');
        }
        if (mpl_internal_slice_dimen(mpl, slice) != dim) {
            switch (close) {
            case T_RBRACKET:
                mpl_internal_error(mpl, name + ' must have ' + dim + ' subscript' + (dim == 1 ? '' : 's') + ', not ' + mpl_internal_slice_dimen(mpl, slice));
                break;
            case T_RIGHT:
                mpl_internal_error(mpl, name + ' has dimension ' + dim + ', not ' + mpl_internal_slice_dimen(mpl, slice));
                break;
            default:
                xassert(close != close);
            }
        }
        mpl_internal_get_token(mpl);
        return slice;
    }
    function mpl_internal_select_set(mpl, name) {
        var set;
        var node;
        xassert(name != null);
        node = mpl.tree[name];
        if (node == null || node.type != A_SET)
            mpl_internal_error(mpl, name + ' not a set');
        set = node.link;
        if (set.assign != null || set.gadget != null)
            mpl_internal_error(mpl, name + ' needs no data');
        set.data = 1;
        return set;
    }
    function mpl_internal_simple_format(mpl, set, memb, slice) {
        var tuple;
        var temp;
        var sym, with_ = null;
        xassert(set != null);
        xassert(memb != null);
        xassert(slice != null);
        xassert(set.dimen == mpl_internal_slice_dimen(mpl, slice));
        xassert(memb.value.set.dim == set.dimen);
        if (mpl_internal_slice_arity(mpl, slice) > 0)
            xassert(mpl_internal_is_symbol(mpl));
        tuple = null;
        for (temp = slice; temp != null; temp = temp.next) {
            if (temp.sym == null) {
                if (!mpl_internal_is_symbol(mpl)) {
                    var lack = mpl_internal_slice_arity(mpl, temp);
                    xassert(with_ != null);
                    if (lack == 1)
                        mpl_internal_error(mpl, 'one item missing in data group beginning with ' + mpl_internal_format_symbol(mpl, with_));
                    else
                        mpl_internal_error(mpl, lack + ' items missing in data group beginning with ' + mpl_internal_format_symbol(mpl, with_));
                }
                sym = mpl_internal_read_symbol(mpl);
                if (with_ == null)
                    with_ = sym;
            } else {
                sym = mpl_internal_copy_symbol(mpl, temp.sym);
            }
            tuple = mpl_internal_expand_tuple(mpl, tuple, sym);
            if (temp.next != null && mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
        }
        mpl_internal_check_then_add(mpl, memb.value.set, tuple);
    }
    function mpl_internal_matrix_format(mpl, set, memb, slice, tr) {
        var list, col, temp;
        var tuple;
        var row;
        xassert(set != null);
        xassert(memb != null);
        xassert(slice != null);
        xassert(set.dimen == mpl_internal_slice_dimen(mpl, slice));
        xassert(memb.value.set.dim == set.dimen);
        xassert(mpl_internal_slice_arity(mpl, slice) == 2);
        list = null;
        while (mpl.token != T_ASSIGN) {
            if (!mpl_internal_is_symbol(mpl))
                mpl_internal_error(mpl, 'number, symbol, or := missing where expected');
            list = mpl_internal_expand_slice(mpl, list, mpl_internal_read_symbol(mpl));
        }
        mpl_internal_get_token(mpl);
        while (mpl_internal_is_symbol(mpl)) {
            row = mpl_internal_read_symbol(mpl);
            for (col = list; col != null; col = col.next) {
                var which = 0;
                if (mpl_internal_is_literal(mpl, '+')) {
                } else if (mpl_internal_is_literal(mpl, '-')) {
                    mpl_internal_get_token(mpl);
                    continue;
                } else {
                    var lack = mpl_internal_slice_dimen(mpl, col);
                    if (lack == 1)
                        mpl_internal_error(mpl, 'one item missing in data group beginning with ' + mpl_internal_format_symbol(mpl, row));
                    else
                        mpl_internal_error(mpl, lack + ' items missing in data group beginning with ' + mpl_internal_format_symbol(mpl, row));
                }
                tuple = null;
                for (temp = slice; temp != null; temp = temp.next) {
                    if (temp.sym == null) {
                        switch (++which) {
                        case 1:
                            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl, tr ? col.sym : row));
                            break;
                        case 2:
                            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl, tr ? row : col.sym));
                            break;
                        default:
                            xassert(which != which);
                        }
                    } else {
                        tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl, temp.sym));
                    }
                }
                xassert(which == 2);
                mpl_internal_check_then_add(mpl, memb.value.set, tuple);
                mpl_internal_get_token(mpl);
            }
        }
        mpl_internal_delete_slice(mpl, list);
    }
    function mpl_internal_set_data(mpl) {
        var set;
        var tuple;
        var memb;
        var slice;
        var tr = 0;
        function err1() {
            mpl_internal_error(mpl, 'slice currently used must specify 2 asterisks, not ' + mpl_internal_slice_arity(mpl, slice));
        }
        function err2() {
            mpl_internal_error(mpl, 'transpose indicator (tr) incomplete');
        }
        function left() {
            mpl_internal_get_token(mpl);
            if (!mpl_internal_is_literal(mpl, 'tr'))
                err2();
            if (mpl_internal_slice_arity(mpl, slice) != 2)
                err1();
            mpl_internal_get_token(mpl);
            if (mpl.token != T_RIGHT)
                err2();
            mpl_internal_get_token(mpl);
            if (mpl.token == T_COLON)
                mpl_internal_get_token(mpl);
            tr = 1;
            mpl_internal_matrix_format(mpl, set, memb, slice, tr);
        }
        xassert(mpl_internal_is_literal(mpl, 'set'));
        mpl_internal_get_token(mpl);
        if (!mpl_internal_is_symbol(mpl))
            mpl_internal_error(mpl, 'set name missing where expected');
        set = mpl_internal_select_set(mpl, mpl.image);
        mpl_internal_get_token(mpl);
        tuple = null;
        if (mpl.token == T_LBRACKET) {
            if (set.dim == 0)
                mpl_internal_error(mpl, set.name + ' cannot be subscripted');
            mpl_internal_get_token(mpl);
            for (;;) {
                if (!mpl_internal_is_symbol(mpl))
                    mpl_internal_error(mpl, 'number or symbol missing where expected');
                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_read_symbol(mpl));
                if (mpl.token == T_COMMA)
                    mpl_internal_get_token(mpl);
                else if (mpl.token == T_RBRACKET)
                    break;
                else
                    mpl_internal_error(mpl, 'syntax error in subscript list');
            }
            if (set.dim != mpl_internal_tuple_dimen(mpl, tuple))
                mpl_internal_error(mpl, set.name + ' must have ' + set.dim + ' subscript' + (set.dim == 1 ? '' : 's') + ' rather than ' + mpl_internal_tuple_dimen(mpl, tuple));
            mpl_internal_get_token(mpl);
        } else {
            if (set.dim != 0)
                mpl_internal_error(mpl, set.name + ' must be subscripted');
        }
        if (mpl_internal_find_member(mpl, set.array, tuple) != null)
            mpl_internal_error(mpl, set.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' already defined');
        memb = mpl_internal_add_member(mpl, set.array, tuple);
        memb.value.set = mpl_internal_create_elemset(mpl, set.dimen);
        slice = mpl_internal_fake_slice(mpl, set.dimen);
        for (;;) {
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            if (mpl.token == T_ASSIGN) {
                mpl_internal_get_token(mpl);
            } else if (mpl.token == T_LEFT) {
                var is_tr;
                mpl_internal_get_token(mpl);
                is_tr = mpl_internal_is_literal(mpl, 'tr');
                mpl_internal_unget_token(mpl);
                if (is_tr) {
                    left();
                } else {
                    mpl_internal_delete_slice(mpl, slice);
                    slice = mpl_internal_read_slice(mpl, set.name, set.dimen);
                    tr = 0;
                    if (mpl_internal_slice_arity(mpl, slice) == 0)
                        mpl_internal_simple_format(mpl, set, memb, slice);
                }
            } else if (mpl_internal_is_symbol(mpl)) {
                mpl_internal_simple_format(mpl, set, memb, slice);
            } else if (mpl.token == T_COLON) {
                if (mpl_internal_slice_arity(mpl, slice) != 2)
                    err1();
                mpl_internal_get_token(mpl);
                mpl_internal_matrix_format(mpl, set, memb, slice, tr);
            } else if (mpl.token == T_LEFT) {
                left();
            } else if (mpl.token == T_SEMICOLON) {
                mpl_internal_get_token(mpl);
                break;
            } else
                mpl_internal_error(mpl, 'syntax error in set data block');
        }
        mpl_internal_delete_slice(mpl, slice);
    }
    function mpl_internal_select_parameter(mpl, name) {
        var par;
        var node;
        xassert(name != null);
        node = mpl.tree[name];
        if (node == null || node.type != A_PARAMETER)
            mpl_internal_error(mpl, name + ' not a parameter');
        par = node.link;
        if (par.assign != null)
            mpl_internal_error(mpl, name + ' needs no data');
        if (par.data)
            mpl_internal_error(mpl, name + ' already provided with data');
        par.data = 1;
        return par;
    }
    function mpl_internal_set_default(mpl, par, altval) {
        xassert(par != null);
        xassert(altval != null);
        if (par.option != null)
            mpl_internal_error(mpl, 'default value for ' + par.name + ' already specified in model section');
        xassert(par.defval == null);
        par.defval = altval;
    }
    function mpl_internal_read_value(mpl, par, tuple) {
        var memb;
        xassert(par != null);
        xassert(mpl_internal_is_symbol(mpl));
        if (mpl_internal_find_member(mpl, par.array, tuple) != null)
            mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' already defined');
        memb = mpl_internal_add_member(mpl, par.array, tuple);
        switch (par.type) {
        case A_NUMERIC:
        case A_INTEGER:
        case A_BINARY:
            if (!mpl_internal_is_number(mpl))
                mpl_internal_error(mpl, par.name + ' requires numeric data');
            memb.value.num = mpl_internal_read_number(mpl);
            break;
        case A_SYMBOLIC:
            memb.value.sym = mpl_internal_read_symbol(mpl);
            break;
        default:
            xassert(par != par);
        }
        return memb;
    }
    function mpl_internal_plain_format(mpl, par, slice) {
        var tuple;
        var temp;
        var sym, with_ = null;
        xassert(par != null);
        xassert(par.dim == mpl_internal_slice_dimen(mpl, slice));
        xassert(mpl_internal_is_symbol(mpl));
        tuple = null;
        for (temp = slice; temp != null; temp = temp.next) {
            if (temp.sym == null) {
                if (!mpl_internal_is_symbol(mpl)) {
                    var lack = mpl_internal_slice_arity(mpl, temp) + 1;
                    xassert(with_ != null);
                    xassert(lack > 1);
                    mpl_internal_error(mpl, lack + ' items missing in data group beginning with ' + mpl_internal_format_symbol(mpl, with_));
                }
                sym = mpl_internal_read_symbol(mpl);
                if (with_ == null)
                    with_ = sym;
            } else {
                sym = mpl_internal_copy_symbol(mpl, temp.sym);
            }
            tuple = mpl_internal_expand_tuple(mpl, tuple, sym);
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
        }
        if (!mpl_internal_is_symbol(mpl)) {
            xassert(with_ != null);
            mpl_internal_error(mpl, 'one item missing in data group beginning with ' + mpl_internal_format_symbol(mpl, with_));
        }
        mpl_internal_read_value(mpl, par, tuple);
    }
    function mpl_internal_tabular_format(mpl, par, slice, tr) {
        var list, col, temp;
        var tuple;
        var row;
        xassert(par != null);
        xassert(par.dim == mpl_internal_slice_dimen(mpl, slice));
        xassert(mpl_internal_slice_arity(mpl, slice) == 2);
        list = null;
        while (mpl.token != T_ASSIGN) {
            if (!mpl_internal_is_symbol(mpl))
                mpl_internal_error(mpl, 'number, symbol, or := missing where expected');
            list = mpl_internal_expand_slice(mpl, list, mpl_internal_read_symbol(mpl));
        }
        mpl_internal_get_token(mpl);
        while (mpl_internal_is_symbol(mpl)) {
            row = mpl_internal_read_symbol(mpl);
            for (col = list; col != null; col = col.next) {
                var which = 0;
                if (mpl_internal_is_literal(mpl, '.')) {
                    mpl_internal_get_token(mpl);
                    continue;
                }
                tuple = null;
                for (temp = slice; temp != null; temp = temp.next) {
                    if (temp.sym == null) {
                        switch (++which) {
                        case 1:
                            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl, tr ? col.sym : row));
                            break;
                        case 2:
                            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl, tr ? row : col.sym));
                            break;
                        default:
                            xassert(which != which);
                        }
                    } else {
                        tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl, temp.sym));
                    }
                }
                xassert(which == 2);
                if (!mpl_internal_is_symbol(mpl)) {
                    var lack = mpl_internal_slice_dimen(mpl, col);
                    if (lack == 1)
                        mpl_internal_error(mpl, 'one item missing in data group beginning with ' + mpl_internal_format_symbol(mpl, row));
                    else
                        mpl_internal_error(mpl, lack + ' items missing in data group beginning with ' + mpl_internal_format_symbol(mpl, row));
                }
                mpl_internal_read_value(mpl, par, tuple);
            }
        }
        mpl_internal_delete_slice(mpl, list);
    }
    function mpl_internal_tabbing_format(mpl, altval) {
        var set = null;
        var par;
        var list, col;
        var tuple;
        var next_token, j, dim = 0;
        var last_name = null;
        if (mpl_internal_is_symbol(mpl)) {
            mpl_internal_get_token(mpl);
            next_token = mpl.token;
            mpl_internal_unget_token(mpl);
            if (next_token == T_COLON) {
                set = mpl_internal_select_set(mpl, mpl.image);
                if (set.dim != 0)
                    mpl_internal_error(mpl, set.name + ' must be a simple set');
                if (set.array.head != null)
                    mpl_internal_error(mpl, set.name + ' already defined');
                mpl_internal_add_member(mpl, set.array, null).value.set = mpl_internal_create_elemset(mpl, set.dimen);
                last_name = set.name;
                dim = set.dimen;
                mpl_internal_get_token(mpl);
                xassert(mpl.token == T_COLON);
                mpl_internal_get_token(mpl);
            }
        }
        list = null;
        while (mpl.token != T_ASSIGN) {
            if (!mpl_internal_is_symbol(mpl))
                mpl_internal_error(mpl, 'parameter name or := missing where expected');
            par = mpl_internal_select_parameter(mpl, mpl.image);
            if (par.dim == 0)
                mpl_internal_error(mpl, mpl.image + ' not a subscripted parameter');
            if (dim != 0 && par.dim != dim) {
                xassert(last_name != null);
                mpl_internal_error(mpl, last_name + ' has dimension ' + dim + ' while ' + par.name + ' has dimension ' + par.dim);
            }
            if (altval != null)
                mpl_internal_set_default(mpl, par, mpl_internal_copy_symbol(mpl, altval));
            list = mpl_internal_expand_slice(mpl, list, par);
            last_name = par.name;
            dim = par.dim;
            mpl_internal_get_token(mpl);
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
        }
        if (mpl_internal_slice_dimen(mpl, list) == 0)
            mpl_internal_error(mpl, 'at least one parameter name required');
        mpl_internal_get_token(mpl);
        if (mpl.token == T_COMMA)
            mpl_internal_get_token(mpl);
        while (mpl_internal_is_symbol(mpl)) {
            var lack;
            tuple = null;
            for (j = 1; j <= dim; j++) {
                if (!mpl_internal_is_symbol(mpl)) {
                    lack = mpl_internal_slice_dimen(mpl, list) + dim - j + 1;
                    xassert(tuple != null);
                    xassert(lack > 1);
                    mpl_internal_error(mpl, lack + ' items missing in data group beginning with ' + mpl_internal_format_symbol(mpl, tuple.sym));
                }
                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_read_symbol(mpl));
                if (j < dim && mpl.token == T_COMMA)
                    mpl_internal_get_token(mpl);
            }
            if (set != null)
                mpl_internal_check_then_add(mpl, set.array.head.value.set, mpl_internal_copy_tuple(mpl, tuple));
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            for (col = list; col != null; col = col.next) {
                if (mpl_internal_is_literal(mpl, '.')) {
                    mpl_internal_get_token(mpl);
                    continue;
                }
                if (!mpl_internal_is_symbol(mpl)) {
                    lack = mpl_internal_slice_dimen(mpl, col);
                    xassert(tuple != null);
                    if (lack == 1)
                        mpl_internal_error(mpl, 'one item missing in data group beginning with ' + mpl_internal_format_symbol(mpl, tuple.sym));
                    else
                        mpl_internal_error(mpl, lack + ' items missing in data group beginning with ' + mpl_internal_format_symbol(mpl, tuple.sym));
                }
                mpl_internal_read_value(mpl, col.sym, mpl_internal_copy_tuple(mpl, tuple));
                if (col.next != null && mpl.token == T_COMMA)
                    mpl_internal_get_token(mpl);
            }
            if (mpl.token == T_COMMA) {
                mpl_internal_get_token(mpl);
                if (!mpl_internal_is_symbol(mpl))
                    mpl_internal_unget_token(mpl);
            }
        }
        for (col = list; col != null; col = col.next)
            col.sym = null;
        mpl_internal_delete_slice(mpl, list);
    }
    function mpl_internal_parameter_data(mpl) {
        var par;
        var altval = null;
        var slice;
        var tr = 0;
        xassert(mpl_internal_is_literal(mpl, 'param'));
        mpl_internal_get_token(mpl);
        if (mpl_internal_is_literal(mpl, 'default')) {
            mpl_internal_get_token(mpl);
            if (!mpl_internal_is_symbol(mpl))
                mpl_internal_error(mpl, 'default value missing where expected');
            altval = mpl_internal_read_symbol(mpl);
            if (mpl.token != T_COLON)
                mpl_internal_error(mpl, 'colon missing where expected');
        }
        if (mpl.token == T_COLON) {
            mpl_internal_get_token(mpl);
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            mpl_internal_tabbing_format(mpl, altval);
            if (mpl.token != T_SEMICOLON)
                mpl_internal_error(mpl, 'symbol, number, or semicolon missing where expected');
            mpl_internal_get_token(mpl);
            return;
        }
        if (!mpl_internal_is_symbol(mpl))
            mpl_internal_error(mpl, 'parameter name missing where expected');
        par = mpl_internal_select_parameter(mpl, mpl.image);
        mpl_internal_get_token(mpl);
        if (mpl_internal_is_literal(mpl, 'default')) {
            mpl_internal_get_token(mpl);
            if (!mpl_internal_is_symbol(mpl))
                mpl_internal_error(mpl, 'default value missing where expected');
            altval = mpl_internal_read_symbol(mpl);
            mpl_internal_set_default(mpl, par, altval);
        }
        slice = mpl_internal_fake_slice(mpl, par.dim);
        function err1() {
            mpl_internal_error(mpl, par.name + ' not a subscripted parameter');
        }
        function err2() {
            mpl_internal_error(mpl, 'slice currently used must specify 2 asterisks, not ' + mpl_internal_slice_arity(mpl, slice));
        }
        function err3() {
            mpl_internal_error(mpl, 'transpose indicator (tr) incomplete');
        }
        for (;;) {
            if (mpl.token == T_COMMA)
                mpl_internal_get_token(mpl);
            if (mpl.token == T_ASSIGN) {
                mpl_internal_get_token(mpl);
            } else if (mpl.token == T_LBRACKET) {
                mpl_internal_delete_slice(mpl, slice);
                slice = mpl_internal_read_slice(mpl, par.name, par.dim);
                tr = 0;
            } else if (mpl_internal_is_symbol(mpl)) {
                mpl_internal_plain_format(mpl, par, slice);
            } else if (mpl.token == T_COLON) {
                if (par.dim == 0)
                    err1();
                if (mpl_internal_slice_arity(mpl, slice) != 2)
                    err2();
                mpl_internal_get_token(mpl);
                mpl_internal_tabular_format(mpl, par, slice, tr);
            } else if (mpl.token == T_LEFT) {
                mpl_internal_get_token(mpl);
                if (!mpl_internal_is_literal(mpl, 'tr'))
                    err3();
                if (par.dim == 0)
                    err1();
                if (mpl_internal_slice_arity(mpl, slice) != 2)
                    err2();
                mpl_internal_get_token(mpl);
                if (mpl.token != T_RIGHT)
                    err3();
                mpl_internal_get_token(mpl);
                if (mpl.token == T_COLON)
                    mpl_internal_get_token(mpl);
                tr = 1;
                mpl_internal_tabular_format(mpl, par, slice, tr);
            } else if (mpl.token == T_SEMICOLON) {
                mpl_internal_get_token(mpl);
                break;
            } else
                mpl_internal_error(mpl, 'syntax error in parameter data block');
        }
        mpl_internal_delete_slice(mpl, slice);
    }
    function mpl_internal_data_section(mpl) {
        while (!(mpl.token == T_EOF || mpl_internal_is_literal(mpl, 'end'))) {
            if (mpl_internal_is_literal(mpl, 'set'))
                mpl_internal_set_data(mpl);
            else if (mpl_internal_is_literal(mpl, 'param'))
                mpl_internal_parameter_data(mpl);
            else
                mpl_internal_error(mpl, 'syntax error in data section');
        }
    }
    function mpl_internal_fp_add(mpl, x, y) {
        if (x > 0 && y > 0 && x > +0.999 * DBL_MAX - y || x < 0 && y < 0 && x < -0.999 * DBL_MAX - y)
            mpl_internal_error(mpl, x + ' + ' + y + '; floating-point overflow');
        return x + y;
    }
    function mpl_internal_fp_sub(mpl, x, y) {
        if (x > 0 && y < 0 && x > +0.999 * DBL_MAX + y || x < 0 && y > 0 && x < -0.999 * DBL_MAX + y)
            mpl_internal_error(mpl, x + ' - ' + y + '; floating-point overflow');
        return x - y;
    }
    function mpl_internal_fp_less(mpl, x, y) {
        if (x < y)
            return 0;
        if (x > 0 && y < 0 && x > +0.999 * DBL_MAX + y)
            mpl_internal_error(mpl, x + ' less ' + y + '; floating-point overflow');
        return x - y;
    }
    function mpl_internal_fp_mul(mpl, x, y) {
        if (Math.abs(y) > 1 && Math.abs(x) > 0.999 * DBL_MAX / Math.abs(y))
            mpl_internal_error(mpl, x + ' * ' + y + '; floating-point overflow');
        return x * y;
    }
    function mpl_internal_fp_div(mpl, x, y) {
        if (Math.abs(y) < DBL_MIN)
            mpl_internal_error(mpl, x + ' / ' + y + '; floating-point zero divide');
        if (Math.abs(y) < 1 && Math.abs(x) > 0.999 * DBL_MAX * Math.abs(y))
            mpl_internal_error(mpl, x + ' / ' + y + '; floating-point overflow');
        return x / y;
    }
    function mpl_internal_fp_idiv(mpl, x, y) {
        if (Math.abs(y) < DBL_MIN)
            mpl_internal_error(mpl, x + ' div ' + y + '; floating-point zero divide');
        if (Math.abs(y) < 1 && Math.abs(x) > 0.999 * DBL_MAX * Math.abs(y))
            mpl_internal_error(mpl, x + ' div ' + y + '; floating-point overflow');
        x /= y;
        return x > 0 ? Math.floor(x) : x < 0 ? Math.ceil(x) : 0;
    }
    function mpl_internal_fp_mod(mpl, x, y) {
        var r;
        if (x == 0)
            r = 0;
        else if (y == 0)
            r = x;
        else {
            r = Math.abs(x) % Math.abs(y);
            if (r != 0) {
                if (x < 0)
                    r = -r;
                if (x > 0 && y < 0 || x < 0 && y > 0)
                    r += y;
            }
        }
        return r;
    }
    function mpl_internal_fp_power(mpl, x, y) {
        var r;
        if (x == 0 && y <= 0 || x < 0 && y != Math.floor(y))
            mpl_internal_error(mpl, x + ' ** ' + y + '; result undefined');
        if (x == 0) {
            r = Math.pow(x, y);
        } else {
            if (Math.abs(x) > 1 && y > +1 && +Math.log(Math.abs(x)) > 0.999 * Math.log(DBL_MAX) / y || Math.abs(x) < 1 && y < -1 && +Math.log(Math.abs(x)) < 0.999 * Math.log(DBL_MAX) / y)
                mpl_internal_error(mpl, x + ' ** ' + y + '; floating-point overflow');
            if (Math.abs(x) > 1 && y < -1 && -Math.log(Math.abs(x)) < 0.999 * Math.log(DBL_MAX) / y || Math.abs(x) < 1 && y > +1 && -Math.log(Math.abs(x)) > 0.999 * Math.log(DBL_MAX) / y)
                r = 0;
            else
                r = Math.pow(x, y);
        }
        return r;
    }
    function mpl_internal_fp_exp(mpl, x) {
        if (x > 0.999 * Math.log(DBL_MAX))
            mpl_internal_error(mpl, 'exp(' + x + '); floating-point overflow');
        return Math.exp(x);
    }
    function mpl_internal_fp_log(mpl, x) {
        if (x <= 0)
            mpl_internal_error(mpl, 'log(' + x + '); non-positive argument');
        return Math.log(x);
    }
    function mpl_internal_fp_log10(mpl, x) {
        if (x <= 0)
            mpl_internal_error(mpl, 'log10(' + x + '); non-positive argument');
        return Math.log(x) / Math.LN10;
    }
    function mpl_internal_fp_sqrt(mpl, x) {
        if (x < 0)
            mpl_internal_error(mpl, 'sqrt(' + x + '); negative argument');
        return Math.sqrt(x);
    }
    function mpl_internal_fp_sin(mpl, x) {
        if (!(-1000000 <= x && x <= +1000000))
            mpl_internal_error(mpl, 'sin(' + x + '); argument too large');
        return Math.sin(x);
    }
    function mpl_internal_fp_cos(mpl, x) {
        if (!(-1000000 <= x && x <= +1000000))
            mpl_internal_error(mpl, 'cos(' + x + '); argument too large');
        return Math.cos(x);
    }
    function mpl_internal_fp_atan(mpl, x) {
        return Math.atan(x);
    }
    function mpl_internal_fp_atan2(mpl, y, x) {
        return Math.atan2(y, x);
    }
    function mpl_internal_fp_round(mpl, x, n) {
        var ten_to_n;
        if (n != Math.floor(n))
            mpl_internal_error(mpl, 'round(' + x + ', ' + n + '); non-integer second argument');
        if (n <= DBL_DIG + 2) {
            ten_to_n = Math.pow(10, n);
            if (Math.abs(x) < 0.999 * DBL_MAX / ten_to_n) {
                x = Math.floor(x * ten_to_n + 0.5);
                if (x != 0)
                    x /= ten_to_n;
            }
        }
        return x;
    }
    function mpl_internal_fp_trunc(mpl, x, n) {
        var ten_to_n;
        if (n != Math.floor(n))
            mpl_internal_error(mpl, 'trunc(' + x + ', ' + n + '); non-integer second argument');
        if (n <= DBL_DIG + 2) {
            ten_to_n = Math.pow(10, n);
            if (Math.abs(x) < 0.999 * DBL_MAX / ten_to_n) {
                x = x >= 0 ? Math.floor(x * ten_to_n) : Math.ceil(x * ten_to_n);
                if (x != 0)
                    x /= ten_to_n;
            }
        }
        return x;
    }
    function mpl_internal_fp_irand224(mpl) {
        var two_to_the_24 = 16777216;
        return rng_unif_rand(mpl.rand, two_to_the_24);
    }
    function mpl_internal_fp_uniform01(mpl) {
        var two_to_the_31 = 2147483648;
        return rng_next_rand(mpl.rand) / two_to_the_31;
    }
    function mpl_internal_fp_uniform(mpl, a, b) {
        var x;
        if (a >= b)
            mpl_internal_error(mpl, 'Uniform(' + a + ', ' + b + '); invalid range');
        x = mpl_internal_fp_uniform01(mpl);
        x = mpl_internal_fp_add(mpl, a * (1 - x), b * x);
        return x;
    }
    function mpl_internal_fp_normal01(mpl) {
        var x, y, r2;
        do {
            x = -1 + 2 * mpl_internal_fp_uniform01(mpl);
            y = -1 + 2 * mpl_internal_fp_uniform01(mpl);
            r2 = x * x + y * y;
        } while (r2 > 1 || r2 == 0);
        return y * Math.sqrt(-2 * Math.log(r2) / r2);
    }
    function mpl_internal_fp_normal(mpl, mu, sigma) {
        return mpl_internal_fp_add(mpl, mu, mpl_internal_fp_mul(mpl, sigma, mpl_internal_fp_normal01(mpl)));
    }
    function mpl_internal_compare_strings(mpl, str1, str2) {
        if (str1 == str2)
            return 0;
        else if (str1 > str2)
            return 1;
        else
            return -1;
    }
    function mpl_internal_create_symbol_num(mpl, num) {
        var sym = {};
        sym.num = num;
        sym.str = null;
        return sym;
    }
    function mpl_internal_create_symbol_str(mpl, str) {
        xassert(str != null);
        var sym = {};
        sym.num = 0;
        sym.str = str;
        return sym;
    }
    function mpl_internal_copy_symbol(mpl, sym) {
        xassert(sym != null);
        var copy = {};
        if (sym.str == null) {
            copy.num = sym.num;
            copy.str = null;
        } else {
            copy.num = 0;
            copy.str = sym.str;
        }
        return copy;
    }
    function mpl_internal_compare_symbols(mpl, sym1, sym2) {
        xassert(sym1 != null);
        xassert(sym2 != null);
        if (sym1.str == null && sym2.str == null) {
            if (sym1.num < sym2.num)
                return -1;
            if (sym1.num > sym2.num)
                return +1;
            return 0;
        }
        if (sym1.str == null)
            return -1;
        if (sym2.str == null)
            return +1;
        return mpl_internal_compare_strings(mpl, sym1.str, sym2.str);
    }
    function mpl_internal_format_symbol(mpl, sym) {
        xassert(sym != null);
        var buf;
        if (sym.str == null)
            buf = String(sym.num);
        else {
            var quoted, j, len;
            var str = sym.str;
            if (!(isalpha(str[0]) || str[0] == '_'))
                quoted = true;
            else {
                quoted = false;
                for (j = 1; j < str.length; j++) {
                    if (!(isalnum(str[j]) || strchr('+-._', str[j]) >= 0)) {
                        quoted = true;
                        break;
                    }
                }
            }
            buf = '';
            len = 0;
            function safe_append(c) {
                if (len < 255) {
                    buf += c;
                    len++;
                }
            }
            if (quoted)
                safe_append('\'');
            for (j = 0; j < str.length; j++) {
                if (quoted && str[j] == '\'')
                    safe_append('\'');
                safe_append(str[j]);
            }
            if (quoted)
                safe_append('\'');
            if (len == 255)
                buf = buf.slice(0, 252) + '...';
        }
        xassert(buf.length <= 255);
        return buf;
    }
    function mpl_internal_concat_symbols(mpl, sym1, sym2) {
        var str1, str2;
        if (sym1.str == null)
            str1 = String(sym1.num);
        else
            str1 = sym1.str;
        if (sym2.str == null)
            str2 = String(sym2.num);
        else
            str2 = sym2.str;
        return mpl_internal_create_symbol_str(mpl, str1 + str2);
    }
    function mpl_internal_expand_tuple(mpl, tuple, sym) {
        var temp;
        xassert(sym != null);
        var tail = {};
        tail.sym = sym;
        tail.next = null;
        if (tuple == null)
            tuple = tail;
        else {
            for (temp = tuple; temp.next != null; temp = temp.next) {
            }
            temp.next = tail;
        }
        return tuple;
    }
    function mpl_internal_tuple_dimen(mpl, tuple) {
        var dim = 0;
        for (var temp = tuple; temp != null; temp = temp.next)
            dim++;
        return dim;
    }
    function mpl_internal_copy_tuple(mpl, tuple) {
        var head, tail;
        if (tuple == null)
            head = null;
        else {
            head = tail = {};
            for (; tuple != null; tuple = tuple.next) {
                xassert(tuple.sym != null);
                tail.sym = mpl_internal_copy_symbol(mpl, tuple.sym);
                if (tuple.next != null)
                    tail = tail.next = {};
            }
            tail.next = null;
        }
        return head;
    }
    function mpl_internal_compare_tuples(mpl, tuple1, tuple2) {
        var item1, item2;
        var ret;
        for (item1 = tuple1, item2 = tuple2; item1 != null; item1 = item1.next, item2 = item2.next) {
            xassert(item2 != null);
            xassert(item1.sym != null);
            xassert(item2.sym != null);
            ret = mpl_internal_compare_symbols(mpl, item1.sym, item2.sym);
            if (ret != 0)
                return ret;
        }
        xassert(item2 == null);
        return 0;
    }
    function mpl_internal_build_subtuple(mpl, tuple, dim) {
        var head = null;
        for (var j = 1, temp = tuple; j <= dim; j++, temp = temp.next) {
            xassert(temp != null);
            head = mpl_internal_expand_tuple(mpl, head, mpl_internal_copy_symbol(mpl, temp.sym));
        }
        return head;
    }
    function mpl_internal_format_tuple(mpl, c, tuple) {
        var temp;
        var j, len = 0;
        var buf = '', str = '', save;
        function safe_append(c) {
            if (len < 255)
                buf += c;
            len++;
        }
        var dim = mpl_internal_tuple_dimen(mpl, tuple);
        if (c == '[' && dim > 0)
            safe_append('[');
        if (c == '(' && dim > 1)
            safe_append('(');
        for (temp = tuple; temp != null; temp = temp.next) {
            if (temp != tuple)
                safe_append(',');
            xassert(temp.sym != null);
            str = mpl_internal_format_symbol(mpl, temp.sym);
            xassert(str.length <= 255);
            for (j = 0; j < str.length; j++)
                safe_append(str[j]);
        }
        if (c == '[' && dim > 0)
            safe_append(']');
        if (c == '(' && dim > 1)
            safe_append(')');
        if (len == 255)
            buf = buf.slice(0, 252) + '...';
        xassert(buf.length <= 255);
        return buf;
    }
    function mpl_internal_create_elemset(mpl, dim) {
        xassert(dim > 0);
        return mpl_internal_create_array(mpl, A_NONE, dim);
    }
    function mpl_internal_find_tuple(mpl, set, tuple) {
        xassert(set != null);
        xassert(set.type == A_NONE);
        xassert(set.dim == mpl_internal_tuple_dimen(mpl, tuple));
        return mpl_internal_find_member(mpl, set, tuple);
    }
    function mpl_internal_add_tuple(mpl, set, tuple) {
        var memb;
        xassert(set != null);
        xassert(set.type == A_NONE);
        xassert(set.dim == mpl_internal_tuple_dimen(mpl, tuple));
        memb = mpl_internal_add_member(mpl, set, tuple);
        memb.value.none = null;
        return memb;
    }
    function mpl_internal_check_then_add(mpl, set, tuple) {
        if (mpl_internal_find_tuple(mpl, set, tuple) != null)
            mpl_internal_error(mpl, 'duplicate tuple ' + mpl_internal_format_tuple(mpl, '(', tuple) + ' detected');
        return mpl_internal_add_tuple(mpl, set, tuple);
    }
    function mpl_internal_copy_elemset(mpl, set) {
        var copy;
        var memb;
        xassert(set != null);
        xassert(set.type == A_NONE);
        xassert(set.dim > 0);
        copy = mpl_internal_create_elemset(mpl, set.dim);
        for (memb = set.head; memb != null; memb = memb.next)
            mpl_internal_add_tuple(mpl, copy, mpl_internal_copy_tuple(mpl, memb.tuple));
        return copy;
    }
    function mpl_internal_arelset_size(mpl, t0, tf, dt) {
        var temp;
        if (dt == 0)
            mpl_internal_error(mpl, t0 + ' .. ' + tf + ' by ' + dt + '; zero stride not allowed');
        if (tf > 0 && t0 < 0 && tf > +0.999 * DBL_MAX + t0)
            temp = +DBL_MAX;
        else if (tf < 0 && t0 > 0 && tf < -0.999 * DBL_MAX + t0)
            temp = -DBL_MAX;
        else
            temp = tf - t0;
        if (Math.abs(dt) < 1 && Math.abs(temp) > 0.999 * DBL_MAX * Math.abs(dt)) {
            if (temp > 0 && dt > 0 || temp < 0 && dt < 0)
                temp = +DBL_MAX;
            else
                temp = 0;
        } else {
            temp = Math.floor(temp / dt) + 1;
            if (temp < 0)
                temp = 0;
        }
        xassert(temp >= 0);
        if (temp > INT_MAX - 1)
            mpl_internal_error(mpl, t0 + ' .. ' + tf + ' by ' + dt + '; set too large');
        return temp + 0.5 | 0;
    }
    function mpl_internal_arelset_member(mpl, t0, tf, dt, j) {
        xassert(1 <= j && j <= mpl_internal_arelset_size(mpl, t0, tf, dt));
        return t0 + (j - 1) * dt;
    }
    function mpl_internal_create_arelset(mpl, t0, tf, dt) {
        var set = mpl_internal_create_elemset(mpl, 1);
        var n = mpl_internal_arelset_size(mpl, t0, tf, dt);
        for (var j = 1; j <= n; j++) {
            mpl_internal_add_tuple(mpl, set, mpl_internal_expand_tuple(mpl, null, mpl_internal_create_symbol_num(mpl, mpl_internal_arelset_member(mpl, t0, tf, dt, j))));
        }
        return set;
    }
    function mpl_internal_set_union(mpl, X, Y) {
        xassert(X != null);
        xassert(X.type == A_NONE);
        xassert(X.dim > 0);
        xassert(Y != null);
        xassert(Y.type == A_NONE);
        xassert(Y.dim > 0);
        xassert(X.dim == Y.dim);
        for (var memb = Y.head; memb != null; memb = memb.next) {
            if (mpl_internal_find_tuple(mpl, X, memb.tuple) == null)
                mpl_internal_add_tuple(mpl, X, mpl_internal_copy_tuple(mpl, memb.tuple));
        }
        return X;
    }
    function mpl_internal_set_diff(mpl, X, Y) {
        xassert(X != null);
        xassert(X.type == A_NONE);
        xassert(X.dim > 0);
        xassert(Y != null);
        xassert(Y.type == A_NONE);
        xassert(Y.dim > 0);
        xassert(X.dim == Y.dim);
        var Z = mpl_internal_create_elemset(mpl, X.dim);
        for (var memb = X.head; memb != null; memb = memb.next) {
            if (mpl_internal_find_tuple(mpl, Y, memb.tuple) == null)
                mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));
        }
        return Z;
    }
    function mpl_internal_set_symdiff(mpl, X, Y) {
        var memb;
        xassert(X != null);
        xassert(X.type == A_NONE);
        xassert(X.dim > 0);
        xassert(Y != null);
        xassert(Y.type == A_NONE);
        xassert(Y.dim > 0);
        xassert(X.dim == Y.dim);
        var Z = mpl_internal_create_elemset(mpl, X.dim);
        for (memb = X.head; memb != null; memb = memb.next) {
            if (mpl_internal_find_tuple(mpl, Y, memb.tuple) == null)
                mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));
        }
        for (memb = Y.head; memb != null; memb = memb.next) {
            if (mpl_internal_find_tuple(mpl, X, memb.tuple) == null)
                mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));
        }
        return Z;
    }
    function mpl_internal_set_inter(mpl, X, Y) {
        xassert(X != null);
        xassert(X.type == A_NONE);
        xassert(X.dim > 0);
        xassert(Y != null);
        xassert(Y.type == A_NONE);
        xassert(Y.dim > 0);
        xassert(X.dim == Y.dim);
        var Z = mpl_internal_create_elemset(mpl, X.dim);
        for (var memb = X.head; memb != null; memb = memb.next) {
            if (mpl_internal_find_tuple(mpl, Y, memb.tuple) != null)
                mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));
        }
        return Z;
    }
    function mpl_internal_set_cross(mpl, X, Y) {
        var memx, memy;
        var tuple, temp;
        xassert(X != null);
        xassert(X.type == A_NONE);
        xassert(X.dim > 0);
        xassert(Y != null);
        xassert(Y.type == A_NONE);
        xassert(Y.dim > 0);
        var Z = mpl_internal_create_elemset(mpl, X.dim + Y.dim);
        for (memx = X.head; memx != null; memx = memx.next) {
            for (memy = Y.head; memy != null; memy = memy.next) {
                tuple = mpl_internal_copy_tuple(mpl, memx.tuple);
                for (temp = memy.tuple; temp != null; temp = temp.next)
                    tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl, temp.sym));
                mpl_internal_add_tuple(mpl, Z, tuple);
            }
        }
        return Z;
    }
    function mpl_internal_constant_term(mpl, coef) {
        var form;
        if (coef == 0)
            form = null;
        else {
            form = {};
            form.coef = coef;
            form.var_ = null;
            form.next = null;
        }
        return form;
    }
    function mpl_internal_single_variable(mpl, var_) {
        xassert(var_ != null);
        var form = {};
        form.coef = 1;
        form.var_ = var_;
        form.next = null;
        return form;
    }
    function mpl_internal_copy_formula(mpl, form) {
        var head, tail;
        if (form == null)
            head = null;
        else {
            head = tail = {};
            for (; form != null; form = form.next) {
                tail.coef = form.coef;
                tail.var_ = form.var_;
                if (form.next != null)
                    tail = tail.next = {};
            }
            tail.next = null;
        }
        return head;
    }
    function mpl_internal_linear_comb(mpl, a, fx, b, fy) {
        var form = null, term, temp;
        var c0 = 0;
        for (term = fx; term != null; term = term.next) {
            if (term.var_ == null)
                c0 = mpl_internal_fp_add(mpl, c0, mpl_internal_fp_mul(mpl, a, term.coef));
            else
                term.var_.temp = mpl_internal_fp_add(mpl, term.var_.temp, mpl_internal_fp_mul(mpl, a, term.coef));
        }
        for (term = fy; term != null; term = term.next) {
            if (term.var_ == null)
                c0 = mpl_internal_fp_add(mpl, c0, mpl_internal_fp_mul(mpl, b, term.coef));
            else
                term.var_.temp = mpl_internal_fp_add(mpl, term.var_.temp, mpl_internal_fp_mul(mpl, b, term.coef));
        }
        for (term = fx; term != null; term = term.next) {
            if (term.var_ != null && term.var_.temp != 0) {
                temp = {};
                temp.coef = term.var_.temp;
                temp.var_ = term.var_;
                temp.next = form;
                form = temp;
                term.var_.temp = 0;
            }
        }
        for (term = fy; term != null; term = term.next) {
            if (term.var_ != null && term.var_.temp != 0) {
                temp = {};
                temp.coef = term.var_.temp;
                temp.var_ = term.var_;
                temp.next = form;
                form = temp;
                term.var_.temp = 0;
            }
        }
        if (c0 != 0) {
            temp = {};
            temp.coef = c0;
            temp.var_ = null;
            temp.next = form;
            form = temp;
        }
        return form;
    }
    function mpl_internal_remove_constant(mpl, form, callback) {
        var head = null, temp;
        var coef = 0;
        while (form != null) {
            temp = form;
            form = form.next;
            if (temp.var_ == null) {
                coef = mpl_internal_fp_add(mpl, coef, temp.coef);
            } else {
                temp.next = head;
                head = temp;
            }
        }
        callback(coef);
        return head;
    }
    function mpl_internal_reduce_terms(mpl, form) {
        var term, next_term;
        var c0 = 0;
        for (term = form; term != null; term = term.next) {
            if (term.var_ == null)
                c0 = mpl_internal_fp_add(mpl, c0, term.coef);
            else
                term.var_.temp = mpl_internal_fp_add(mpl, term.var_.temp, term.coef);
        }
        next_term = form;
        form = null;
        for (term = next_term; term != null; term = next_term) {
            next_term = term.next;
            if (term.var_ == null && c0 != 0) {
                term.coef = c0;
                c0 = 0;
                term.next = form;
                form = term;
            } else if (term.var_ != null && term.var_.temp != 0) {
                term.coef = term.var_.temp;
                term.var_.temp = 0;
                term.next = form;
                form = term;
            }
        }
        return form;
    }
    function mpl_internal_delete_value(mpl, type, value) {
        xassert(value != null);
        switch (type) {
        case A_NONE:
            value.none = null;
            break;
        case A_NUMERIC:
            value.num = 0;
            break;
        case A_SYMBOLIC:
            value.sym = null;
            break;
        case A_LOGICAL:
            value.bit = 0;
            break;
        case A_TUPLE:
            value.tuple = null;
            break;
        case A_ELEMSET:
            value.set = null;
            break;
        case A_ELEMVAR:
            value.var_ = null;
            break;
        case A_FORMULA:
            value.form = null;
            break;
        case A_ELEMCON:
            value.con = null;
            break;
        default:
            xassert(type != type);
        }
    }
    function mpl_internal_create_array(mpl, type, dim) {
        xassert(type == A_NONE || type == A_NUMERIC || type == A_SYMBOLIC || type == A_ELEMSET || type == A_ELEMVAR || type == A_ELEMCON);
        xassert(dim >= 0);
        var array = {};
        array.type = type;
        array.dim = dim;
        array.size = 0;
        array.head = null;
        array.tail = null;
        array.tree = false;
        array.prev = null;
        array.next = mpl.a_list;
        if (array.next != null)
            array.next.prev = array;
        mpl.a_list = array;
        return array;
    }
    function mpl_internal_compare_member_tuples(info, key1, key2) {
        return mpl_internal_compare_tuples(info, key1, key2);
    }
    function mpl_internal_find_member(mpl, array, tuple) {
        var memb;
        xassert(array != null);
        xassert(mpl_internal_tuple_dimen(mpl, tuple) == array.dim);
        if (array.size > 30 && !array.tree) {
            array.tree = avl_create_tree(mpl_internal_compare_member_tuples, mpl);
            for (memb = array.head; memb != null; memb = memb.next)
                avl_set_node_link(avl_insert_node(array.tree, memb.tuple), memb);
        }
        memb = null;
        if (!array.tree) {
            for (memb = array.head; memb != null; memb = memb.next)
                if (mpl_internal_compare_tuples(mpl, memb.tuple, tuple) == 0)
                    break;
        } else {
            var node = avl_find_node(array.tree, tuple);
            memb = node == null ? null : avl_get_node_link(node);
        }
        return memb;
    }
    function mpl_internal_add_member(mpl, array, tuple) {
        xassert(array != null);
        xassert(mpl_internal_tuple_dimen(mpl, tuple) == array.dim);
        var memb = {};
        memb.tuple = tuple;
        memb.next = null;
        memb.value = {};
        array.size++;
        if (array.head == null)
            array.head = memb;
        else
            array.tail.next = memb;
        array.tail = memb;
        if (array.tree != null)
            avl_set_node_link(avl_insert_node(array.tree, memb.tuple), memb);
        return memb;
    }
    function mpl_internal_assign_dummy_index(mpl, slot, value) {
        var leaf, code;
        xassert(slot != null);
        xassert(value != null);
        if (slot.value != null) {
            if (mpl_internal_compare_symbols(mpl, slot.value, value) == 0)
                return;
            slot.value = null;
        }
        for (leaf = slot.list; leaf != null; leaf = leaf.arg.index.next) {
            xassert(leaf.op == O_INDEX);
            for (code = leaf; code != null; code = code.up) {
                if (code.valid) {
                    code.valid = 0;
                    mpl_internal_delete_value(mpl, code.type, code.value);
                }
            }
        }
        slot.value = mpl_internal_copy_symbol(mpl, value);
    }
    function mpl_internal_update_dummy_indices(mpl, block) {
        var slot;
        var temp;
        if (block.backup != null) {
            for (slot = block.list, temp = block.backup; slot != null; slot = slot.next, temp = temp.next) {
                xassert(temp != null);
                xassert(temp.sym != null);
                mpl_internal_assign_dummy_index(mpl, slot, temp.sym);
            }
        }
    }
    function mpl_internal_enter_domain_block(mpl, block, tuple, info, func) {
        var backup;
        var ret = 0;
        xassert(block.code != null);
        if (!mpl_internal_is_member(mpl, block.code, tuple)) {
            ret = 1;
            return ret;
        }
        backup = block.backup;
        block.backup = tuple;
        mpl_internal_update_dummy_indices(mpl, block);
        func(mpl, info);
        block.backup = backup;
        mpl_internal_update_dummy_indices(mpl, block);
        return ret;
    }
    function mpl_internal_eval_domain_func(mpl, my_info) {
        if (my_info.block != null) {
            var block;
            var slot;
            var tuple = null, temp = null;
            block = my_info.block;
            my_info.block = block.next;
            for (slot = block.list; slot != null; slot = slot.next) {
                if (tuple == null)
                    tuple = temp = {};
                else
                    temp = temp.next = {};
                if (slot.code == null) {
                    xassert(my_info.tuple != null);
                    temp.sym = my_info.tuple.sym;
                    xassert(temp.sym != null);
                    my_info.tuple = my_info.tuple.next;
                } else {
                    temp.sym = mpl_internal_eval_symbolic(mpl, slot.code);
                }
            }
            temp.next = null;
            if (mpl_internal_enter_domain_block(mpl, block, tuple, my_info, mpl_internal_eval_domain_func))
                my_info.failure = 1;
            for (slot = block.list; slot != null; slot = slot.next) {
                xassert(tuple != null);
                temp = tuple;
                tuple = tuple.next;
            }
        } else {
            xassert(my_info.tuple == null);
            if (my_info.domain.code != null && !mpl_internal_eval_logical(mpl, my_info.domain.code)) {
                my_info.failure = 2;
            } else {
                my_info.func(mpl, my_info.info);
            }
        }
    }
    function mpl_internal_eval_within_domain(mpl, domain, tuple, info, func) {
        var my_info = {};
        if (domain == null) {
            xassert(tuple == null);
            func(mpl, info);
            my_info.failure = 0;
        } else {
            xassert(tuple != null);
            my_info.domain = domain;
            my_info.block = domain.list;
            my_info.tuple = tuple;
            my_info.info = info;
            my_info.func = func;
            my_info.failure = 0;
            mpl_internal_eval_domain_func(mpl, my_info);
        }
        return my_info.failure;
    }
    function mpl_internal_loop_domain_func(mpl, my_info) {
        if (my_info.block != null) {
            var block;
            var slot;
            var bound;
            block = my_info.block;
            my_info.block = block.next;
            bound = null;
            for (slot = block.list; slot != null; slot = slot.next) {
                if (slot.code != null)
                    bound = mpl_internal_expand_tuple(mpl, bound, mpl_internal_eval_symbolic(mpl, slot.code));
            }
            xassert(block.code != null);
            if (block.code.op == O_DOTS) {
                var tuple;
                var n, j;
                var t0, tf, dt;
                t0 = mpl_internal_eval_numeric(mpl, block.code.arg.arg.x);
                tf = mpl_internal_eval_numeric(mpl, block.code.arg.arg.y);
                if (block.code.arg.arg.z == null)
                    dt = 1;
                else
                    dt = mpl_internal_eval_numeric(mpl, block.code.arg.arg.z);
                n = mpl_internal_arelset_size(mpl, t0, tf, dt);
                tuple = mpl_internal_expand_tuple(mpl, null, mpl_internal_create_symbol_num(mpl, 0));
                xassert(bound == null);
                for (j = 1; j <= n && my_info.looping; j++) {
                    tuple.sym.num = mpl_internal_arelset_member(mpl, t0, tf, dt, j);
                    mpl_internal_enter_domain_block(mpl, block, tuple, my_info, mpl_internal_loop_domain_func);
                }
            } else {
                var set;
                var memb;
                var temp1, temp2;
                set = mpl_internal_eval_elemset(mpl, block.code);
                for (memb = set.head; memb != null && my_info.looping; memb = memb.next) {
                    temp1 = memb.tuple;
                    temp2 = bound;
                    var found = false;
                    for (slot = block.list; slot != null; slot = slot.next) {
                        xassert(temp1 != null);
                        if (slot.code != null) {
                            xassert(temp2 != null);
                            if (mpl_internal_compare_symbols(mpl, temp1.sym, temp2.sym) != 0) {
                                found = true;
                                break;
                            }
                            temp2 = temp2.next;
                        }
                        temp1 = temp1.next;
                    }
                    if (!found) {
                        xassert(temp1 == null);
                        xassert(temp2 == null);
                        mpl_internal_enter_domain_block(mpl, block, memb.tuple, my_info, mpl_internal_loop_domain_func);
                    }
                }
            }
            my_info.block = block;
        } else {
            if (my_info.domain.code != null && !mpl_internal_eval_logical(mpl, my_info.domain.code)) {
            } else {
                my_info.looping = !my_info.func(mpl, my_info.info);
            }
        }
    }
    function mpl_internal_loop_within_domain(mpl, domain, info, func) {
        var my_info = {};
        if (domain == null)
            func(mpl, info);
        else {
            my_info.domain = domain;
            my_info.block = domain.list;
            my_info.looping = 1;
            my_info.info = info;
            my_info.func = func;
            mpl_internal_loop_domain_func(mpl, my_info);
        }
    }
    function mpl_internal_out_of_domain(mpl, name, tuple) {
        xassert(name != null);
        xassert(tuple != null);
        mpl_internal_error(mpl, name + mpl_internal_format_tuple(mpl, '[', tuple) + ' out of domain');
    }
    function mpl_internal_get_domain_tuple(mpl, domain) {
        var tuple = null;
        if (domain != null) {
            for (var block = domain.list; block != null; block = block.next) {
                for (var slot = block.list; slot != null; slot = slot.next) {
                    if (slot.code == null) {
                        xassert(slot.value != null);
                        tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl, slot.value));
                    }
                }
            }
        }
        return tuple;
    }
    function mpl_internal_check_elem_set(mpl, set, tuple, refer) {
        for (var within = set.within, eqno = 1; within != null; within = within.next, eqno++) {
            xassert(within.code != null);
            for (var memb = refer.head; memb != null; memb = memb.next) {
                if (!mpl_internal_is_member(mpl, within.code, memb.tuple)) {
                    var buf = mpl_internal_format_tuple(mpl, '(', memb.tuple);
                    xassert(buf.length < 255);
                    mpl_internal_error(mpl, set.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' contains ' + buf + ' which not within specified set; see (' + eqno + ')');
                }
            }
        }
    }
    function mpl_internal_take_member_set(mpl, set, tuple) {
        var refer;
        var memb = mpl_internal_find_member(mpl, set.array, tuple);
        function add() {
            mpl_internal_check_elem_set(mpl, set, tuple, refer);
            memb = mpl_internal_add_member(mpl, set.array, mpl_internal_copy_tuple(mpl, tuple));
            memb.value.set = refer;
        }
        if (memb != null) {
            refer = memb.value.set;
        } else if (set.assign != null) {
            refer = mpl_internal_eval_elemset(mpl, set.assign);
            add();
        } else if (set.option != null) {
            refer = mpl_internal_eval_elemset(mpl, set.option);
            add();
        } else {
            mpl_internal_error(mpl, 'no value for ' + set.name + mpl_internal_format_tuple(mpl, '[', tuple));
        }
        return refer;
    }
    function mpl_internal_eval_set_func(mpl, info) {
        if (info.memb != null) {
            mpl_internal_check_elem_set(mpl, info.set, info.memb.tuple, info.memb.value.set);
        } else {
            info.refer = mpl_internal_take_member_set(mpl, info.set, info.tuple);
        }
    }
    function mpl_internal_saturate_set(mpl, set) {
        var gadget = set.gadget;
        var data;
        var elem, memb;
        var tuple, work = new Array(20);
        var i;
        xprintf('Generating ' + set.name + '...');
        mpl_internal_eval_whole_set(mpl, gadget.set);
        xassert(gadget.set.array != null);
        xassert(gadget.set.array.head != null);
        xassert(gadget.set.array.head == gadget.set.array.tail);
        data = gadget.set.array.head.value.set;
        xassert(data.type == A_NONE);
        xassert(data.dim == gadget.set.dimen);
        for (elem = data.head; elem != null; elem = elem.next) {
            tuple = mpl_internal_copy_tuple(mpl, elem.tuple);
            for (i = 0; i < gadget.set.dimen; i++)
                work[i] = null;
            for (i = 0; tuple != null; tuple = tuple.next)
                work[gadget.ind[i++] - 1] = tuple;
            xassert(i == gadget.set.dimen);
            for (i = 0; i < gadget.set.dimen; i++) {
                xassert(work[i] != null);
                work[i].next = work[i + 1];
            }
            if (set.dim == 0)
                tuple = null;
            else {
                tuple = work[0];
                work[set.dim - 1].next = null;
            }
            memb = mpl_internal_find_member(mpl, set.array, tuple);
            if (memb == null) {
                memb = mpl_internal_add_member(mpl, set.array, tuple);
                memb.value.set = mpl_internal_create_elemset(mpl, set.dimen);
            }
            tuple = work[set.dim];
            xassert(set.dim + set.dimen == gadget.set.dimen);
            work[gadget.set.dimen - 1].next = null;
            mpl_internal_add_tuple(mpl, memb.value.set, tuple);
        }
        set.data = 1;
    }
    function mpl_internal_eval_member_set(mpl, set, tuple) {
        var info = {};
        xassert(set.dim == mpl_internal_tuple_dimen(mpl, tuple));
        info.set = set;
        info.tuple = tuple;
        if (set.gadget != null && set.data == 0) {
            mpl_internal_saturate_set(mpl, set);
        }
        if (set.data == 1) {
            var tail = set.array.tail;
            set.data = 2;
            for (info.memb = set.array.head; info.memb != null; info.memb = info.memb.next) {
                if (mpl_internal_eval_within_domain(mpl, set.domain, info.memb.tuple, info, mpl_internal_eval_set_func))
                    mpl_internal_out_of_domain(mpl, set.name, info.memb.tuple);
                if (info.memb == tail)
                    break;
            }
        }
        info.memb = null;
        if (mpl_internal_eval_within_domain(mpl, info.set.domain, info.tuple, info, mpl_internal_eval_set_func))
            mpl_internal_out_of_domain(mpl, set.name, info.tuple);
        return info.refer;
    }
    function mpl_internal_whole_set_func(mpl, info) {
        var tuple = mpl_internal_get_domain_tuple(mpl, info.domain);
        mpl_internal_eval_member_set(mpl, info, tuple);
        return 0;
    }
    function mpl_internal_eval_whole_set(mpl, set) {
        mpl_internal_loop_within_domain(mpl, set.domain, set, mpl_internal_whole_set_func);
    }
    function mpl_internal_check_value_num(mpl, par, tuple, value) {
        var cond;
        var eqno;
        switch (par.type) {
        case A_NUMERIC:
            break;
        case A_INTEGER:
            if (value != Math.floor(value))
                mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' = ' + value + ' not integer');
            break;
        case A_BINARY:
            if (!(value == 0 || value == 1))
                mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' = ' + value + ' not binary');
            break;
        default:
            xassert(par != par);
        }
        for (cond = par.cond, eqno = 1; cond != null; cond = cond.next, eqno++) {
            var bound;
            xassert(cond.code != null);
            bound = mpl_internal_eval_numeric(mpl, cond.code);
            function err(rho) {
                mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' = ' + value + ' not ' + rho + ' ' + bound + '; see (' + eqno + ')');
            }
            switch (cond.rho) {
            case O_LT:
                if (!(value < bound))
                    err('<');
                break;
            case O_LE:
                if (!(value <= bound))
                    err('<=');
                break;
            case O_EQ:
                if (!(value == bound))
                    err('=');
                break;
            case O_GE:
                if (!(value >= bound))
                    err('>=');
                break;
            case O_GT:
                if (!(value > bound))
                    err('>');
                break;
            case O_NE:
                if (!(value != bound))
                    err('<>');
                break;
            default:
                xassert(cond != cond);
            }
        }
        eqno = 1;
        for (var in_ = par.in_; in_ != null; in_ = in_.next, eqno++) {
            xassert(in_.code != null);
            xassert(in_.code.dim == 1);
            var dummy = mpl_internal_expand_tuple(mpl, null, mpl_internal_create_symbol_num(mpl, value));
            if (!mpl_internal_is_member(mpl, in_.code, dummy))
                mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' = ' + value + ' not in specified set; see (' + eqno + ')');
        }
    }
    function mpl_internal_take_member_num(mpl, par, tuple) {
        var memb = mpl_internal_find_member(mpl, par.array, tuple);
        function add(value) {
            mpl_internal_check_value_num(mpl, par, tuple, value);
            memb = mpl_internal_add_member(mpl, par.array, mpl_internal_copy_tuple(mpl, tuple));
            memb.value.num = value;
            return value;
        }
        if (memb != null)
            return memb.value.num;
        else if (par.assign != null)
            return add(mpl_internal_eval_numeric(mpl, par.assign));
        else if (par.option != null)
            return add(mpl_internal_eval_numeric(mpl, par.option));
        else if (par.defval != null) {
            if (par.defval.str != null)
                mpl_internal_error(mpl, 'cannot convert ' + mpl_internal_format_symbol(mpl, par.defval) + ' to floating-point number');
            return add(par.defval.num);
        } else
            return mpl_internal_error(mpl, 'no value for ' + par.name + mpl_internal_format_tuple(mpl, '[', tuple));
    }
    function mpl_internal_eval_num_func(mpl, info) {
        if (info.memb != null) {
            mpl_internal_check_value_num(mpl, info.par, info.memb.tuple, info.memb.value.num);
        } else {
            info.value = mpl_internal_take_member_num(mpl, info.par, info.tuple);
        }
    }
    function mpl_internal_eval_member_num(mpl, par, tuple) {
        var info = {};
        xassert(par.type == A_NUMERIC || par.type == A_INTEGER || par.type == A_BINARY);
        xassert(par.dim == mpl_internal_tuple_dimen(mpl, tuple));
        info.par = par;
        info.tuple = tuple;
        if (par.data == 1) {
            var tail = par.array.tail;
            par.data = 2;
            for (info.memb = par.array.head; info.memb != null; info.memb = info.memb.next) {
                if (mpl_internal_eval_within_domain(mpl, par.domain, info.memb.tuple, info, mpl_internal_eval_num_func))
                    mpl_internal_out_of_domain(mpl, par.name, info.memb.tuple);
                if (info.memb == tail)
                    break;
            }
        }
        info.memb = null;
        if (mpl_internal_eval_within_domain(mpl, info.par.domain, info.tuple, info, mpl_internal_eval_num_func))
            mpl_internal_out_of_domain(mpl, par.name, info.tuple);
        return info.value;
    }
    function mpl_internal_check_value_sym(mpl, par, tuple, value) {
        var in_;
        var eqno = 1;
        for (var cond = par.cond; cond != null; cond = cond.next, eqno++) {
            var buf;
            xassert(cond.code != null);
            var bound = mpl_internal_eval_symbolic(mpl, cond.code);
            switch (cond.rho) {
            case O_LT:
                if (!(mpl_internal_compare_symbols(mpl, value, bound) < 0)) {
                    buf = mpl_internal_format_symbol(mpl, bound);
                    xassert(buf.length <= 255);
                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' = ' + mpl_internal_format_symbol(mpl, value) + ' not < ' + buf);
                }
                break;
            case O_LE:
                if (!(mpl_internal_compare_symbols(mpl, value, bound) <= 0)) {
                    buf = mpl_internal_format_symbol(mpl, bound);
                    xassert(buf.length <= 255);
                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' = ' + mpl_internal_format_symbol(mpl, value) + ' not <= ' + buf);
                }
                break;
            case O_EQ:
                if (!(mpl_internal_compare_symbols(mpl, value, bound) == 0)) {
                    buf = mpl_internal_format_symbol(mpl, bound);
                    xassert(buf.length <= 255);
                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' = ' + mpl_internal_format_symbol(mpl, value) + ' not = ' + buf);
                }
                break;
            case O_GE:
                if (!(mpl_internal_compare_symbols(mpl, value, bound) >= 0)) {
                    buf = mpl_internal_format_symbol(mpl, bound);
                    xassert(buf.length <= 255);
                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' = ' + mpl_internal_format_symbol(mpl, value) + ' not >= ' + buf);
                }
                break;
            case O_GT:
                if (!(mpl_internal_compare_symbols(mpl, value, bound) > 0)) {
                    buf = mpl_internal_format_symbol(mpl, bound);
                    xassert(buf.length <= 255);
                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' = ' + mpl_internal_format_symbol(mpl, value) + ' not > ' + buf);
                }
                break;
            case O_NE:
                if (!(mpl_internal_compare_symbols(mpl, value, bound) != 0)) {
                    buf = mpl_internal_format_symbol(mpl, bound);
                    xassert(buf.length <= 255);
                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + ' <> ' + mpl_internal_format_symbol(mpl, value) + ' not > ' + buf);
                }
                break;
            default:
                xassert(cond != cond);
            }
        }
        eqno = 1;
        for (in_ = par.in_; in_ != null; in_ = in_.next, eqno++) {
            xassert(in_.code != null);
            xassert(in_.code.dim == 1);
            var dummy = mpl_internal_expand_tuple(mpl, null, mpl_internal_copy_symbol(mpl, value));
            if (!mpl_internal_is_member(mpl, in_.code, dummy))
                mpl_internal_error(mpl, par.name, mpl_internal_format_tuple(mpl, '[', tuple) + ' = ' + mpl_internal_format_symbol(mpl, value) + ' not in specified set; see (' + eqno + ')');
        }
    }
    function mpl_internal_take_member_sym(mpl, par, tuple) {
        var memb = mpl_internal_find_member(mpl, par.array, tuple);
        function add(value) {
            mpl_internal_check_value_sym(mpl, par, tuple, value);
            memb = mpl_internal_add_member(mpl, par.array, mpl_internal_copy_tuple(mpl, tuple));
            memb.value.sym = mpl_internal_copy_symbol(mpl, value);
            return value;
        }
        if (memb != null) {
            return mpl_internal_copy_symbol(mpl, memb.value.sym);
        } else if (par.assign != null)
            return add(mpl_internal_eval_symbolic(mpl, par.assign));
        else if (par.option != null)
            return add(mpl_internal_eval_symbolic(mpl, par.option));
        else if (par.defval != null)
            return mpl_internal_copy_symbol(mpl, par.defval);
        else
            return mpl_internal_error(mpl, 'no value for ' + par.name + mpl_internal_format_tuple(mpl, '[', tuple));
    }
    function mpl_internal_eval_sym_func(mpl, info) {
        if (info.memb != null) {
            mpl_internal_check_value_sym(mpl, info.par, info.memb.tuple, info.memb.value.sym);
        } else {
            info.value = mpl_internal_take_member_sym(mpl, info.par, info.tuple);
        }
    }
    function mpl_internal_eval_member_sym(mpl, par, tuple) {
        var info = {};
        xassert(par.type == A_SYMBOLIC);
        xassert(par.dim == mpl_internal_tuple_dimen(mpl, tuple));
        info.par = par;
        info.tuple = tuple;
        if (par.data == 1) {
            var tail = par.array.tail;
            par.data = 2;
            for (info.memb = par.array.head; info.memb != null; info.memb = info.memb.next) {
                if (mpl_internal_eval_within_domain(mpl, par.domain, info.memb.tuple, info, mpl_internal_eval_sym_func))
                    mpl_internal_out_of_domain(mpl, par.name, info.memb.tuple);
                if (info.memb == tail)
                    break;
            }
        }
        info.memb = null;
        if (mpl_internal_eval_within_domain(mpl, info.par.domain, info.tuple, info, mpl_internal_eval_sym_func))
            mpl_internal_out_of_domain(mpl, par.name, info.tuple);
        return info.value;
    }
    function mpl_internal_whole_par_func(mpl, par) {
        var tuple = mpl_internal_get_domain_tuple(mpl, par.domain);
        switch (par.type) {
        case A_NUMERIC:
        case A_INTEGER:
        case A_BINARY:
            mpl_internal_eval_member_num(mpl, par, tuple);
            break;
        case A_SYMBOLIC:
            mpl_internal_eval_member_sym(mpl, par, tuple);
            break;
        default:
            xassert(par != par);
        }
        return 0;
    }
    function mpl_internal_eval_whole_par(mpl, par) {
        mpl_internal_loop_within_domain(mpl, par.domain, par, mpl_internal_whole_par_func);
    }
    function mpl_internal_take_member_var(mpl, var_, tuple) {
        var refer;
        var memb = mpl_internal_find_member(mpl, var_.array, tuple);
        if (memb != null) {
            refer = memb.value.var_;
        } else {
            memb = mpl_internal_add_member(mpl, var_.array, mpl_internal_copy_tuple(mpl, tuple));
            refer = memb.value.var_ = {};
            refer.j = 0;
            refer.var_ = var_;
            refer.memb = memb;
            if (var_.lbnd == null)
                refer.lbnd = 0;
            else
                refer.lbnd = mpl_internal_eval_numeric(mpl, var_.lbnd);
            if (var_.ubnd == null)
                refer.ubnd = 0;
            else if (var_.ubnd == var_.lbnd)
                refer.ubnd = refer.lbnd;
            else
                refer.ubnd = mpl_internal_eval_numeric(mpl, var_.ubnd);
            refer.temp = 0;
            refer.stat = 0;
            refer.prim = refer.dual = 0;
        }
        return refer;
    }
    function mpl_internal_eval_var_func(mpl, info) {
        info.refer = mpl_internal_take_member_var(mpl, info.var_, info.tuple);
    }
    function mpl_internal_eval_member_var(mpl, var_, tuple) {
        var info = {};
        xassert(var_.dim == mpl_internal_tuple_dimen(mpl, tuple));
        info.var_ = var_;
        info.tuple = tuple;
        if (mpl_internal_eval_within_domain(mpl, info.var_.domain, info.tuple, info, mpl_internal_eval_var_func))
            mpl_internal_out_of_domain(mpl, var_.name, info.tuple);
        return info.refer;
    }
    function mpl_internal_whole_var_func(mpl, var_) {
        var tuple = mpl_internal_get_domain_tuple(mpl, var_.domain);
        mpl_internal_eval_member_var(mpl, var_, tuple);
        return 0;
    }
    function mpl_internal_eval_whole_var(mpl, var_) {
        mpl_internal_loop_within_domain(mpl, var_.domain, var_, mpl_internal_whole_var_func);
    }
    function mpl_internal_take_member_con(mpl, con, tuple) {
        var refer, temp = null;
        var memb = mpl_internal_find_member(mpl, con.array, tuple);
        if (memb != null) {
            refer = memb.value.con;
        } else {
            memb = mpl_internal_add_member(mpl, con.array, mpl_internal_copy_tuple(mpl, tuple));
            refer = memb.value.con = {};
            refer.i = 0;
            refer.con = con;
            refer.memb = memb;
            xassert(con.code != null);
            refer.form = mpl_internal_eval_formula(mpl, con.code);
            if (con.lbnd == null && con.ubnd == null) {
                xassert(con.type == A_MINIMIZE || con.type == A_MAXIMIZE);
                refer.form = mpl_internal_remove_constant(mpl, refer.form, function (v) {
                    temp = v;
                });
                refer.lbnd = refer.ubnd = -temp;
            } else if (con.lbnd != null && con.ubnd == null) {
                xassert(con.type == A_CONSTRAINT);
                refer.form = mpl_internal_linear_comb(mpl, +1, refer.form, -1, mpl_internal_eval_formula(mpl, con.lbnd));
                refer.form = mpl_internal_remove_constant(mpl, refer.form, function (v) {
                    temp = v;
                });
                refer.lbnd = -temp;
                refer.ubnd = 0;
            } else if (con.lbnd == null && con.ubnd != null) {
                xassert(con.type == A_CONSTRAINT);
                refer.form = mpl_internal_linear_comb(mpl, +1, refer.form, -1, mpl_internal_eval_formula(mpl, con.ubnd));
                refer.form = mpl_internal_remove_constant(mpl, refer.form, function (v) {
                    temp = v;
                });
                refer.lbnd = 0;
                refer.ubnd = -temp;
            } else if (con.lbnd == con.ubnd) {
                xassert(con.type == A_CONSTRAINT);
                refer.form = mpl_internal_linear_comb(mpl, +1, refer.form, -1, mpl_internal_eval_formula(mpl, con.lbnd));
                refer.form = mpl_internal_remove_constant(mpl, refer.form, function (v) {
                    temp = v;
                });
                refer.lbnd = refer.ubnd = -temp;
            } else {
                var temp1 = null, temp2 = null;
                xassert(con.type == A_CONSTRAINT);
                refer.form = mpl_internal_remove_constant(mpl, refer.form, function (v) {
                    temp = v;
                });
                xassert(mpl_internal_remove_constant(mpl, mpl_internal_eval_formula(mpl, con.lbnd), function (v) {
                    temp1 = v;
                }) == null);
                xassert(mpl_internal_remove_constant(mpl, mpl_internal_eval_formula(mpl, con.ubnd), function (v) {
                    temp2 = v;
                }) == null);
                refer.lbnd = mpl_internal_fp_sub(mpl, temp1, temp);
                refer.ubnd = mpl_internal_fp_sub(mpl, temp2, temp);
            }
            refer.stat = 0;
            refer.prim = refer.dual = 0;
        }
        return refer;
    }
    function mpl_internal_eval_con_func(mpl, info) {
        info.refer = mpl_internal_take_member_con(mpl, info.con, info.tuple);
    }
    function mpl_internal_eval_member_con(mpl, con, tuple) {
        var info = {};
        xassert(con.dim == mpl_internal_tuple_dimen(mpl, tuple));
        info.con = con;
        info.tuple = tuple;
        if (mpl_internal_eval_within_domain(mpl, info.con.domain, info.tuple, info, mpl_internal_eval_con_func))
            mpl_internal_out_of_domain(mpl, con.name, info.tuple);
        return info.refer;
    }
    function mpl_internal_whole_con_func(mpl, con) {
        var tuple = mpl_internal_get_domain_tuple(mpl, con.domain);
        mpl_internal_eval_member_con(mpl, con, tuple);
        return 0;
    }
    function mpl_internal_eval_whole_con(mpl, con) {
        mpl_internal_loop_within_domain(mpl, con.domain, con, mpl_internal_whole_con_func);
    }
    function mpl_internal_iter_num_func(mpl, info) {
        var temp = mpl_internal_eval_numeric(mpl, info.code.arg.loop.x);
        switch (info.code.op) {
        case O_SUM:
            info.value = mpl_internal_fp_add(mpl, info.value, temp);
            break;
        case O_PROD:
            info.value = mpl_internal_fp_mul(mpl, info.value, temp);
            break;
        case O_MINIMUM:
            if (info.value > temp)
                info.value = temp;
            break;
        case O_MAXIMUM:
            if (info.value < temp)
                info.value = temp;
            break;
        default:
            xassert(info != info);
        }
        return 0;
    }
    function mpl_internal_eval_numeric(mpl, code) {
        var value, tuple, e, sym, str, temp, info;
        xassert(code != null);
        xassert(code.type == A_NUMERIC);
        xassert(code.dim == 0);
        if (code.vflag && code.valid) {
            code.valid = 0;
            mpl_internal_delete_value(mpl, code.type, code.value);
        }
        if (code.valid) {
            return code.value.num;
        }
        switch (code.op) {
        case O_NUMBER:
            value = code.arg.num;
            break;
        case O_MEMNUM: {
                tuple = null;
                for (e = code.arg.par.list; e != null; e = e.next)
                    tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl, e.x));
                value = mpl_internal_eval_member_num(mpl, code.arg.par.par, tuple);
            }
            break;
        case O_MEMVAR: {
                var var_;
                tuple = null;
                for (e = code.arg.var_.list; e != null; e = e.next)
                    tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl, e.x));
                var_ = mpl_internal_eval_member_var(mpl, code.arg.var_.var_, tuple);
                switch (code.arg.var_.suff) {
                case DOT_LB:
                    if (var_.var_.lbnd == null)
                        value = -DBL_MAX;
                    else
                        value = var_.lbnd;
                    break;
                case DOT_UB:
                    if (var_.var_.ubnd == null)
                        value = +DBL_MAX;
                    else
                        value = var_.ubnd;
                    break;
                case DOT_STATUS:
                    value = var_.stat;
                    break;
                case DOT_VAL:
                    value = var_.prim;
                    break;
                case DOT_DUAL:
                    value = var_.dual;
                    break;
                default:
                    xassert(code != code);
                }
            }
            break;
        case O_MEMCON: {
                var con;
                tuple = null;
                for (e = code.arg.con.list; e != null; e = e.next)
                    tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl, e.x));
                con = mpl_internal_eval_member_con(mpl, code.arg.con.con, tuple);
                switch (code.arg.con.suff) {
                case DOT_LB:
                    if (con.con.lbnd == null)
                        value = -DBL_MAX;
                    else
                        value = con.lbnd;
                    break;
                case DOT_UB:
                    if (con.con.ubnd == null)
                        value = +DBL_MAX;
                    else
                        value = con.ubnd;
                    break;
                case DOT_STATUS:
                    value = con.stat;
                    break;
                case DOT_VAL:
                    value = con.prim;
                    break;
                case DOT_DUAL:
                    value = con.dual;
                    break;
                default:
                    xassert(code != code);
                }
            }
            break;
        case O_IRAND224:
            value = mpl_internal_fp_irand224(mpl);
            break;
        case O_UNIFORM01:
            value = mpl_internal_fp_uniform01(mpl);
            break;
        case O_NORMAL01:
            value = mpl_internal_fp_normal01(mpl);
            break;
        case O_GMTIME:
            value = mpl_internal_fn_gmtime(mpl);
            break;
        case O_CVTNUM: {
                sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);
                if (sym.str == null)
                    value = sym.num;
                else {
                    if (str2num(sym.str, function (v) {
                            value = v;
                        }))
                        mpl_internal_error(mpl, 'cannot convert ' + mpl_internal_format_symbol(mpl, sym) + ' to floating-point number');
                }
            }
            break;
        case O_PLUS:
            value = +mpl_internal_eval_numeric(mpl, code.arg.arg.x);
            break;
        case O_MINUS:
            value = -mpl_internal_eval_numeric(mpl, code.arg.arg.x);
            break;
        case O_ABS:
            value = Math.abs(mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_CEIL:
            value = Math.ceil(mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_FLOOR:
            value = Math.floor(mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_EXP:
            value = mpl_internal_fp_exp(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_LOG:
            value = mpl_internal_fp_log(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_LOG10:
            value = mpl_internal_fp_log10(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_SQRT:
            value = mpl_internal_fp_sqrt(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_SIN:
            value = mpl_internal_fp_sin(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_COS:
            value = mpl_internal_fp_cos(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_ATAN:
            value = mpl_internal_fp_atan(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_ATAN2:
            value = mpl_internal_fp_atan2(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_ROUND:
            value = mpl_internal_fp_round(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), 0);
            break;
        case O_ROUND2:
            value = mpl_internal_fp_round(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_TRUNC:
            value = mpl_internal_fp_trunc(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), 0);
            break;
        case O_TRUNC2:
            value = mpl_internal_fp_trunc(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_ADD:
            value = mpl_internal_fp_add(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_SUB:
            value = mpl_internal_fp_sub(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_LESS:
            value = mpl_internal_fp_less(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_MUL:
            value = mpl_internal_fp_mul(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_DIV:
            value = mpl_internal_fp_div(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_IDIV:
            value = mpl_internal_fp_idiv(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_MOD:
            value = mpl_internal_fp_mod(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_POWER:
            value = mpl_internal_fp_power(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_UNIFORM:
            value = mpl_internal_fp_uniform(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_NORMAL:
            value = mpl_internal_fp_normal(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y));
            break;
        case O_CARD: {
                var set = mpl_internal_eval_elemset(mpl, code.arg.arg.x);
                value = set.size;
            }
            break;
        case O_LENGTH: {
                sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);
                if (sym.str == null)
                    str = String(sym.num);
                else
                    str = sym.str;
                value = str.length;
            }
            break;
        case O_STR2TIME: {
                var fmt;
                sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);
                if (sym.str == null)
                    str = String(sym.num);
                else
                    str = sym.str;
                sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);
                if (sym.str == null)
                    fmt = String(sym.num);
                else
                    fmt = sym.str;
                value = mpl_internal_fn_str2time(mpl, str, fmt);
            }
            break;
        case O_FORK:
            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))
                value = mpl_internal_eval_numeric(mpl, code.arg.arg.y);
            else if (code.arg.arg.z == null)
                value = 0;
            else
                value = mpl_internal_eval_numeric(mpl, code.arg.arg.z);
            break;
        case O_MIN: {
                value = +DBL_MAX;
                for (e = code.arg.list; e != null; e = e.next) {
                    temp = mpl_internal_eval_numeric(mpl, e.x);
                    if (value > temp)
                        value = temp;
                }
            }
            break;
        case O_MAX: {
                value = -DBL_MAX;
                for (e = code.arg.list; e != null; e = e.next) {
                    temp = mpl_internal_eval_numeric(mpl, e.x);
                    if (value < temp)
                        value = temp;
                }
            }
            break;
        case O_SUM: {
                info = {};
                info.code = code;
                info.value = 0;
                mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info, mpl_internal_iter_num_func);
                value = info.value;
            }
            break;
        case O_PROD: {
                info = {};
                info.code = code;
                info.value = 1;
                mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info, mpl_internal_iter_num_func);
                value = info.value;
            }
            break;
        case O_MINIMUM: {
                info = {};
                info.code = code;
                info.value = +DBL_MAX;
                mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info, mpl_internal_iter_num_func);
                if (info.value == +DBL_MAX)
                    mpl_internal_error(mpl, 'min{} over empty set; result undefined');
                value = info.value;
            }
            break;
        case O_MAXIMUM: {
                info = {};
                info.code = code;
                info.value = -DBL_MAX;
                mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info, mpl_internal_iter_num_func);
                if (info.value == -DBL_MAX)
                    mpl_internal_error(mpl, 'max{} over empty set; result undefined');
                value = info.value;
            }
            break;
        default:
            xassert(code != code);
        }
        xassert(!code.valid);
        code.valid = 1;
        code.value.num = value;
        return value;
    }
    function mpl_internal_eval_symbolic(mpl, code) {
        var value, str;
        xassert(code != null);
        xassert(code.type == A_SYMBOLIC);
        xassert(code.dim == 0);
        if (code.vflag && code.valid) {
            code.valid = 0;
            mpl_internal_delete_value(mpl, code.type, code.value);
        }
        if (code.valid) {
            return mpl_internal_copy_symbol(mpl, code.value.sym);
        }
        switch (code.op) {
        case O_STRING:
            value = mpl_internal_create_symbol_str(mpl, code.arg.str);
            break;
        case O_INDEX:
            xassert(code.arg.index.slot.value != null);
            value = mpl_internal_copy_symbol(mpl, code.arg.index.slot.value);
            break;
        case O_MEMSYM: {
                var tuple;
                var e;
                tuple = null;
                for (e = code.arg.par.list; e != null; e = e.next)
                    tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl, e.x));
                value = mpl_internal_eval_member_sym(mpl, code.arg.par.par, tuple);
            }
            break;
        case O_CVTSYM:
            value = mpl_internal_create_symbol_num(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_CONCAT:
            value = mpl_internal_concat_symbols(mpl, mpl_internal_eval_symbolic(mpl, code.arg.arg.x), mpl_internal_eval_symbolic(mpl, code.arg.arg.y));
            break;
        case O_FORK:
            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))
                value = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);
            else if (code.arg.arg.z == null)
                value = mpl_internal_create_symbol_num(mpl, 0);
            else
                value = mpl_internal_eval_symbolic(mpl, code.arg.arg.z);
            break;
        case O_SUBSTR:
        case O_SUBSTR3: {
                var pos, len;
                value = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);
                if (value.str == null)
                    str = String(value.num);
                else
                    str = value.str;
                if (code.op == O_SUBSTR) {
                    pos = mpl_internal_eval_numeric(mpl, code.arg.arg.y);
                    if (pos != Math.floor(pos))
                        mpl_internal_error(mpl, 'substr(\'...\', ' + pos + '); non-integer second argument');
                    if (pos < 1 || pos > str.length + 1)
                        mpl_internal_error(mpl, 'substr(\'...\', ' + pos + '); substring out of range');
                } else {
                    pos = mpl_internal_eval_numeric(mpl, code.arg.arg.y);
                    len = mpl_internal_eval_numeric(mpl, code.arg.arg.z);
                    if (pos != Math.floor(pos) || len != Math.floor(len))
                        mpl_internal_error(mpl, 'substr(\'...\', ' + pos + ', ' + len + '); non-integer second and/or third argument');
                    if (pos < 1 || len < 0 || pos + len > str.length + 1)
                        mpl_internal_error(mpl, 'substr(\'...\', ' + pos + ', ' + len + '); substring out of range');
                }
                value = mpl_internal_create_symbol_str(mpl, str.slice(pos - 1, pos + len - 1));
            }
            break;
        case O_TIME2STR: {
                var num;
                var sym;
                var fmt;
                num = mpl_internal_eval_numeric(mpl, code.arg.arg.x);
                sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);
                if (sym.str == null)
                    fmt = String(sym.num);
                else
                    fmt = sym.str;
                str = mpl_internal_fn_time2str(mpl, num, fmt);
                value = mpl_internal_create_symbol_str(mpl, str);
            }
            break;
        default:
            xassert(code != code);
        }
        xassert(!code.valid);
        code.valid = 1;
        code.value.sym = mpl_internal_copy_symbol(mpl, value);
        return value;
    }
    function mpl_internal_iter_log_func(mpl, info) {
        var ret = 0;
        switch (info.code.op) {
        case O_FORALL:
            info.value &= mpl_internal_eval_logical(mpl, info.code.arg.loop.x);
            if (!info.value)
                ret = 1;
            break;
        case O_EXISTS:
            info.value |= mpl_internal_eval_logical(mpl, info.code.arg.loop.x);
            if (info.value)
                ret = 1;
            break;
        default:
            xassert(info != info);
        }
        return ret;
    }
    function mpl_internal_eval_logical(mpl, code) {
        var value, sym1, sym2, tuple, set, memb, info;
        xassert(code.type == A_LOGICAL);
        xassert(code.dim == 0);
        if (code.vflag && code.valid) {
            code.valid = 0;
            mpl_internal_delete_value(mpl, code.type, code.value);
        }
        if (code.valid) {
            return code.value.bit;
        }
        switch (code.op) {
        case O_CVTLOG:
            value = mpl_internal_eval_numeric(mpl, code.arg.arg.x) != 0;
            break;
        case O_NOT:
            value = !mpl_internal_eval_logical(mpl, code.arg.arg.x);
            break;
        case O_LT:
            xassert(code.arg.arg.x != null);
            if (code.arg.arg.x.type == A_NUMERIC)
                value = mpl_internal_eval_numeric(mpl, code.arg.arg.x) < mpl_internal_eval_numeric(mpl, code.arg.arg.y);
            else {
                sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);
                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);
                value = mpl_internal_compare_symbols(mpl, sym1, sym2) < 0;
            }
            break;
        case O_LE:
            xassert(code.arg.arg.x != null);
            if (code.arg.arg.x.type == A_NUMERIC)
                value = mpl_internal_eval_numeric(mpl, code.arg.arg.x) <= mpl_internal_eval_numeric(mpl, code.arg.arg.y);
            else {
                sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);
                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);
                value = mpl_internal_compare_symbols(mpl, sym1, sym2) <= 0;
            }
            break;
        case O_EQ:
            xassert(code.arg.arg.x != null);
            if (code.arg.arg.x.type == A_NUMERIC)
                value = mpl_internal_eval_numeric(mpl, code.arg.arg.x) == mpl_internal_eval_numeric(mpl, code.arg.arg.y);
            else {
                sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);
                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);
                value = mpl_internal_compare_symbols(mpl, sym1, sym2) == 0;
            }
            break;
        case O_GE:
            xassert(code.arg.arg.x != null);
            if (code.arg.arg.x.type == A_NUMERIC)
                value = mpl_internal_eval_numeric(mpl, code.arg.arg.x) >= mpl_internal_eval_numeric(mpl, code.arg.arg.y);
            else {
                sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);
                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);
                value = mpl_internal_compare_symbols(mpl, sym1, sym2) >= 0;
            }
            break;
        case O_GT:
            xassert(code.arg.arg.x != null);
            if (code.arg.arg.x.type == A_NUMERIC)
                value = mpl_internal_eval_numeric(mpl, code.arg.arg.x) > mpl_internal_eval_numeric(mpl, code.arg.arg.y);
            else {
                sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);
                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);
                value = mpl_internal_compare_symbols(mpl, sym1, sym2) > 0;
            }
            break;
        case O_NE:
            xassert(code.arg.arg.x != null);
            if (code.arg.arg.x.type == A_NUMERIC)
                value = mpl_internal_eval_numeric(mpl, code.arg.arg.x) != mpl_internal_eval_numeric(mpl, code.arg.arg.y);
            else {
                sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);
                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);
                value = mpl_internal_compare_symbols(mpl, sym1, sym2) != 0;
            }
            break;
        case O_AND:
            value = mpl_internal_eval_logical(mpl, code.arg.arg.x) && mpl_internal_eval_logical(mpl, code.arg.arg.y);
            break;
        case O_OR:
            value = mpl_internal_eval_logical(mpl, code.arg.arg.x) || mpl_internal_eval_logical(mpl, code.arg.arg.y);
            break;
        case O_IN: {
                tuple = mpl_internal_eval_tuple(mpl, code.arg.arg.x);
                value = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);
            }
            break;
        case O_NOTIN: {
                tuple = mpl_internal_eval_tuple(mpl, code.arg.arg.x);
                value = !mpl_internal_is_member(mpl, code.arg.arg.y, tuple);
            }
            break;
        case O_WITHIN: {
                set = mpl_internal_eval_elemset(mpl, code.arg.arg.x);
                value = 1;
                for (memb = set.head; memb != null; memb = memb.next) {
                    if (!mpl_internal_is_member(mpl, code.arg.arg.y, memb.tuple)) {
                        value = 0;
                        break;
                    }
                }
            }
            break;
        case O_NOTWITHIN: {
                set = mpl_internal_eval_elemset(mpl, code.arg.arg.x);
                value = 1;
                for (memb = set.head; memb != null; memb = memb.next) {
                    if (mpl_internal_is_member(mpl, code.arg.arg.y, memb.tuple)) {
                        value = 0;
                        break;
                    }
                }
            }
            break;
        case O_FORALL: {
                info = {};
                info.code = code;
                info.value = 1;
                mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info, mpl_internal_iter_log_func);
                value = info.value;
            }
            break;
        case O_EXISTS: {
                info = {};
                info.code = code;
                info.value = 0;
                mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info, mpl_internal_iter_log_func);
                value = info.value;
            }
            break;
        default:
            xassert(code != code);
        }
        xassert(!code.valid);
        code.valid = 1;
        code.value.bit = value;
        return value;
    }
    function mpl_internal_eval_tuple(mpl, code) {
        var value;
        xassert(code != null);
        xassert(code.type == A_TUPLE);
        xassert(code.dim > 0);
        if (code.vflag && code.valid) {
            code.valid = 0;
            mpl_internal_delete_value(mpl, code.type, code.value);
        }
        if (code.valid) {
            return mpl_internal_copy_tuple(mpl, code.value.tuple);
        }
        switch (code.op) {
        case O_TUPLE: {
                value = null;
                for (var e = code.arg.list; e != null; e = e.next)
                    value = mpl_internal_expand_tuple(mpl, value, mpl_internal_eval_symbolic(mpl, e.x));
            }
            break;
        case O_CVTTUP:
            value = mpl_internal_expand_tuple(mpl, null, mpl_internal_eval_symbolic(mpl, code.arg.arg.x));
            break;
        default:
            xassert(code != code);
        }
        xassert(!code.valid);
        code.valid = 1;
        code.value.tuple = mpl_internal_copy_tuple(mpl, value);
        return value;
    }
    function mpl_internal_iter_set_func(mpl, info) {
        var tuple;
        switch (info.code.op) {
        case O_SETOF:
            tuple = mpl_internal_eval_tuple(mpl, info.code.arg.loop.x);
            if (mpl_internal_find_tuple(mpl, info.value, tuple) == null)
                mpl_internal_add_tuple(mpl, info.value, tuple);
            break;
        case O_BUILD:
            mpl_internal_add_tuple(mpl, info.value, mpl_internal_get_domain_tuple(mpl, info.code.arg.loop.domain));
            break;
        default:
            xassert(info != info);
        }
        return 0;
    }
    function mpl_internal_eval_elemset(mpl, code) {
        var value, e, info;
        xassert(code != null);
        xassert(code.type == A_ELEMSET);
        xassert(code.dim > 0);
        if (code.vflag && code.valid) {
            code.valid = 0;
            mpl_internal_delete_value(mpl, code.type, code.value);
        }
        if (code.valid) {
            return mpl_internal_copy_elemset(mpl, code.value.set);
        }
        switch (code.op) {
        case O_MEMSET: {
                var tuple;
                tuple = null;
                for (e = code.arg.set.list; e != null; e = e.next)
                    tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl, e.x));
                value = mpl_internal_copy_elemset(mpl, mpl_internal_eval_member_set(mpl, code.arg.set.set, tuple));
            }
            break;
        case O_MAKE: {
                value = mpl_internal_create_elemset(mpl, code.dim);
                for (e = code.arg.list; e != null; e = e.next)
                    mpl_internal_check_then_add(mpl, value, mpl_internal_eval_tuple(mpl, e.x));
            }
            break;
        case O_UNION:
            value = mpl_internal_set_union(mpl, mpl_internal_eval_elemset(mpl, code.arg.arg.x), mpl_internal_eval_elemset(mpl, code.arg.arg.y));
            break;
        case O_DIFF:
            value = mpl_internal_set_diff(mpl, mpl_internal_eval_elemset(mpl, code.arg.arg.x), mpl_internal_eval_elemset(mpl, code.arg.arg.y));
            break;
        case O_SYMDIFF:
            value = mpl_internal_set_symdiff(mpl, mpl_internal_eval_elemset(mpl, code.arg.arg.x), mpl_internal_eval_elemset(mpl, code.arg.arg.y));
            break;
        case O_INTER:
            value = mpl_internal_set_inter(mpl, mpl_internal_eval_elemset(mpl, code.arg.arg.x), mpl_internal_eval_elemset(mpl, code.arg.arg.y));
            break;
        case O_CROSS:
            value = mpl_internal_set_cross(mpl, mpl_internal_eval_elemset(mpl, code.arg.arg.x), mpl_internal_eval_elemset(mpl, code.arg.arg.y));
            break;
        case O_DOTS:
            value = mpl_internal_create_arelset(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_numeric(mpl, code.arg.arg.y), code.arg.arg.z == null ? 1 : mpl_internal_eval_numeric(mpl, code.arg.arg.z));
            break;
        case O_FORK:
            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))
                value = mpl_internal_eval_elemset(mpl, code.arg.arg.y);
            else
                value = mpl_internal_eval_elemset(mpl, code.arg.arg.z);
            break;
        case O_SETOF: {
                info = {};
                info.code = code;
                info.value = mpl_internal_create_elemset(mpl, code.dim);
                mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info, mpl_internal_iter_set_func);
                value = info.value;
            }
            break;
        case O_BUILD: {
                info = {};
                info.code = code;
                info.value = mpl_internal_create_elemset(mpl, code.dim);
                mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info, mpl_internal_iter_set_func);
                value = info.value;
            }
            break;
        default:
            xassert(code != code);
        }
        xassert(!code.valid);
        code.valid = 1;
        code.value.set = mpl_internal_copy_elemset(mpl, value);
        return value;
    }
    function mpl_internal_null_func(mpl, info) {
        xassert(info == null);
    }
    function mpl_internal_is_member(mpl, code, tuple) {
        var value, e, temp, j;
        xassert(code != null);
        xassert(code.type == A_ELEMSET);
        xassert(code.dim > 0);
        xassert(tuple != null);
        switch (code.op) {
        case O_MEMSET: {
                var set;
                temp = null;
                for (e = code.arg.set.list; e != null; e = e.next)
                    temp = mpl_internal_expand_tuple(mpl, temp, mpl_internal_eval_symbolic(mpl, e.x));
                set = mpl_internal_eval_member_set(mpl, code.arg.set.set, temp);
                temp = mpl_internal_build_subtuple(mpl, tuple, set.dim);
                value = mpl_internal_find_tuple(mpl, set, temp) != null;
            }
            break;
        case O_MAKE: {
                var that;
                value = 0;
                temp = mpl_internal_build_subtuple(mpl, tuple, code.dim);
                for (e = code.arg.list; e != null; e = e.next) {
                    that = mpl_internal_eval_tuple(mpl, e.x);
                    value = mpl_internal_compare_tuples(mpl, temp, that) == 0;
                    if (value)
                        break;
                }
            }
            break;
        case O_UNION:
            value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple) || mpl_internal_is_member(mpl, code.arg.arg.y, tuple);
            break;
        case O_DIFF:
            value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple) && !mpl_internal_is_member(mpl, code.arg.arg.y, tuple);
            break;
        case O_SYMDIFF: {
                var in1 = mpl_internal_is_member(mpl, code.arg.arg.x, tuple);
                var in2 = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);
                value = in1 && !in2 || !in1 && in2;
            }
            break;
        case O_INTER:
            value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple) && mpl_internal_is_member(mpl, code.arg.arg.y, tuple);
            break;
        case O_CROSS: {
                value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple);
                if (value) {
                    for (j = 1; j <= code.arg.arg.x.dim; j++) {
                        xassert(tuple != null);
                        tuple = tuple.next;
                    }
                    value = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);
                }
            }
            break;
        case O_DOTS: {
                var x, t0, tf, dt;
                xassert(code.dim == 1);
                t0 = mpl_internal_eval_numeric(mpl, code.arg.arg.x);
                tf = mpl_internal_eval_numeric(mpl, code.arg.arg.y);
                if (code.arg.arg.z == null)
                    dt = 1;
                else
                    dt = mpl_internal_eval_numeric(mpl, code.arg.arg.z);
                mpl_internal_arelset_size(mpl, t0, tf, dt);
                xassert(tuple.sym != null);
                if (tuple.sym.str != null) {
                    value = 0;
                    break;
                }
                x = tuple.sym.num;
                if (dt > 0 && !(t0 <= x && x <= tf) || dt < 0 && !(tf <= x && x <= t0)) {
                    value = 0;
                    break;
                }
                j = ((x - t0) / dt + 0.5 | 0) + 1;
                value = mpl_internal_arelset_member(mpl, t0, tf, dt, j) == x;
            }
            break;
        case O_FORK:
            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))
                value = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);
            else
                value = mpl_internal_is_member(mpl, code.arg.arg.z, tuple);
            break;
        case O_SETOF:
            mpl_internal_error(mpl, 'implementation restriction; in/within setof{} not allowed');
            break;
        case O_BUILD: {
                temp = mpl_internal_build_subtuple(mpl, tuple, code.dim);
                value = mpl_internal_eval_within_domain(mpl, code.arg.loop.domain, temp, null, mpl_internal_null_func) == 0;
            }
            break;
        default:
            xassert(code != code);
        }
        return value;
    }
    function mpl_internal_iter_form_func(mpl, info) {
        switch (info.code.op) {
        case O_SUM: {
                var term;
                var form = mpl_internal_eval_formula(mpl, info.code.arg.loop.x);
                if (info.value == null) {
                    xassert(info.tail == null);
                    info.value = form;
                } else {
                    xassert(info.tail != null);
                    info.tail.next = form;
                }
                for (term = form; term != null; term = term.next)
                    info.tail = term;
            }
            break;
        default:
            xassert(info != info);
        }
        return 0;
    }
    function mpl_internal_eval_formula(mpl, code) {
        var value;
        xassert(code != null);
        xassert(code.type == A_FORMULA);
        xassert(code.dim == 0);
        if (code.vflag && code.valid) {
            code.valid = 0;
            mpl_internal_delete_value(mpl, code.type, code.value);
        }
        if (code.valid) {
            return mpl_internal_copy_formula(mpl, code.value.form);
        }
        switch (code.op) {
        case O_MEMVAR: {
                var e;
                var tuple = null;
                for (e = code.arg.var_.list; e != null; e = e.next)
                    tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl, e.x));
                xassert(code.arg.var_.suff == DOT_NONE);
                value = mpl_internal_single_variable(mpl, mpl_internal_eval_member_var(mpl, code.arg.var_.var_, tuple));
            }
            break;
        case O_CVTLFM:
            value = mpl_internal_constant_term(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));
            break;
        case O_PLUS:
            value = mpl_internal_linear_comb(mpl, 0, mpl_internal_constant_term(mpl, 0), +1, mpl_internal_eval_formula(mpl, code.arg.arg.x));
            break;
        case O_MINUS:
            value = mpl_internal_linear_comb(mpl, 0, mpl_internal_constant_term(mpl, 0), -1, mpl_internal_eval_formula(mpl, code.arg.arg.x));
            break;
        case O_ADD:
            value = mpl_internal_linear_comb(mpl, +1, mpl_internal_eval_formula(mpl, code.arg.arg.x), +1, mpl_internal_eval_formula(mpl, code.arg.arg.y));
            break;
        case O_SUB:
            value = mpl_internal_linear_comb(mpl, +1, mpl_internal_eval_formula(mpl, code.arg.arg.x), -1, mpl_internal_eval_formula(mpl, code.arg.arg.y));
            break;
        case O_MUL:
            xassert(code.arg.arg.x != null);
            xassert(code.arg.arg.y != null);
            if (code.arg.arg.x.type == A_NUMERIC) {
                xassert(code.arg.arg.y.type == A_FORMULA);
                value = mpl_internal_linear_comb(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x), mpl_internal_eval_formula(mpl, code.arg.arg.y), 0, mpl_internal_constant_term(mpl, 0));
            } else {
                xassert(code.arg.arg.x.type == A_FORMULA);
                xassert(code.arg.arg.y.type == A_NUMERIC);
                value = mpl_internal_linear_comb(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.y), mpl_internal_eval_formula(mpl, code.arg.arg.x), 0, mpl_internal_constant_term(mpl, 0));
            }
            break;
        case O_DIV:
            value = mpl_internal_linear_comb(mpl, mpl_internal_fp_div(mpl, 1, mpl_internal_eval_numeric(mpl, code.arg.arg.y)), mpl_internal_eval_formula(mpl, code.arg.arg.x), 0, mpl_internal_constant_term(mpl, 0));
            break;
        case O_FORK:
            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))
                value = mpl_internal_eval_formula(mpl, code.arg.arg.y);
            else if (code.arg.arg.z == null)
                value = mpl_internal_constant_term(mpl, 0);
            else
                value = mpl_internal_eval_formula(mpl, code.arg.arg.z);
            break;
        case O_SUM: {
                var info = {};
                info.code = code;
                info.value = mpl_internal_constant_term(mpl, 0);
                info.tail = null;
                mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info, mpl_internal_iter_form_func);
                value = mpl_internal_reduce_terms(mpl, info.value);
            }
            break;
        default:
            xassert(code != code);
        }
        xassert(!code.valid);
        code.valid = 1;
        code.value.form = mpl_internal_copy_formula(mpl, value);
        return value;
    }
    var mpl_tab_num_args = exports['mpl_tab_num_args'] = function (dca) {
        return dca.na;
    };
    var mpl_tab_get_arg = exports['mpl_tab_get_arg'] = function (dca, k) {
        xassert(1 <= k && k <= dca.na);
        return dca.arg[k];
    };
    var mpl_tab_get_args = exports['mpl_tab_get_args'] = function (dca, k) {
        return dca.arg;
    };
    var mpl_tab_num_flds = exports['mpl_tab_num_flds'] = function (dca) {
        return dca.nf;
    };
    var mpl_tab_get_name = exports['mpl_tab_get_name'] = function (dca, k) {
        xassert(1 <= k && k <= dca.nf);
        return dca.name[k];
    };
    var mpl_tab_get_type = exports['mpl_tab_get_type'] = function (dca, k) {
        xassert(1 <= k && k <= dca.nf);
        return dca.type[k];
    };
    var mpl_tab_get_num = exports['mpl_tab_get_num'] = function (dca, k) {
        xassert(1 <= k && k <= dca.nf);
        xassert(dca.type[k] == 'N');
        return dca.num[k];
    };
    var mpl_tab_get_str = exports['mpl_tab_get_str'] = function (dca, k) {
        xassert(1 <= k && k <= dca.nf);
        xassert(dca.type[k] == 'S');
        xassert(dca.str[k] != null);
        return dca.str[k];
    };
    var mpl_tab_set_num = exports['mpl_tab_set_num'] = function (dca, k, num) {
        xassert(1 <= k && k <= dca.nf);
        xassert(dca.type[k] == '?');
        dca.type[k] = 'N';
        dca.num[k] = num;
    };
    var mpl_tab_set_str = exports['mpl_tab_set_str'] = function (dca, k, str) {
        xassert(1 <= k && k <= dca.nf);
        xassert(dca.type[k] == '?');
        xassert(dca.str[k] != null);
        dca.type[k] = 'S';
        dca.str[k] = str;
    };
    function mpl_internal_write_func(mpl, tab) {
        var dca = mpl.dca;
        var out;
        var sym;
        var k;
        k = 0;
        for (out = tab.u.out.list; out != null; out = out.next) {
            k++;
            switch (out.code.type) {
            case A_NUMERIC:
                dca.type[k] = 'N';
                dca.num[k] = mpl_internal_eval_numeric(mpl, out.code);
                dca.str[k][0] = '\0';
                break;
            case A_SYMBOLIC:
                sym = mpl_internal_eval_symbolic(mpl, out.code);
                if (sym.str == null) {
                    dca.type[k] = 'N';
                    dca.num[k] = sym.num;
                    dca.str[k][0] = '\0';
                } else {
                    dca.type[k] = 'S';
                    dca.num[k] = 0;
                    dca.str[k] = sym.str;
                }
                break;
            default:
                xassert(out != out);
            }
        }
        mpl_tab_drv_write(mpl);
        return 0;
    }
    function mpl_internal_execute_table(mpl, tab) {
        var arg;
        var fld;
        var in_;
        var out;
        var dca;
        var set;
        var k;
        var buf;
        xassert(mpl.dca == null);
        mpl.dca = dca = {};
        dca.id = 0;
        dca.link = null;
        dca.na = 0;
        dca.arg = null;
        dca.nf = 0;
        dca.name = null;
        dca.type = null;
        dca.num = null;
        dca.str = null;
        xassert(dca.na == 0);
        for (arg = tab.arg; arg != null; arg = arg.next)
            dca.na++;
        dca.arg = new Array(1 + dca.na);
        for (k = 1; k <= dca.na; k++)
            dca.arg[k] = null;
        k = 0;
        for (arg = tab.arg; arg != null; arg = arg.next) {
            k++;
            xassert(arg.code.type == A_SYMBOLIC);
            var sym = mpl_internal_eval_symbolic(mpl, arg.code);
            if (sym.str == null)
                buf = String(sym.num);
            else
                buf = sym.str;
            dca.arg[k] = buf;
        }
        switch (tab.type) {
        case A_INPUT:
            set = tab.u.in_.set;
            if (set != null) {
                if (set.data)
                    mpl_internal_error(mpl, set.name + ' already provided with data');
                xassert(set.array.head == null);
                mpl_internal_add_member(mpl, set.array, null).value.set = mpl_internal_create_elemset(mpl, set.dimen);
                set.data = 1;
            }
            for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next) {
                if (in_.par.data)
                    mpl_internal_error(mpl, in_.par.name + ' already provided with data');
                in_.par.data = 1;
            }
            xassert(dca.nf == 0);
            for (fld = tab.u.in_.fld; fld != null; fld = fld.next)
                dca.nf++;
            for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next)
                dca.nf++;
            dca.name = new Array(1 + dca.nf);
            dca.type = new Array(1 + dca.nf);
            dca.num = new Float64Array(1 + dca.nf);
            dca.str = new Array(1 + dca.nf);
            k = 0;
            for (fld = tab.u.in_.fld; fld != null; fld = fld.next) {
                k++;
                dca.name[k] = fld.name;
                dca.type[k] = '?';
                dca.num[k] = 0;
                dca.str[k] = '';
            }
            for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next) {
                k++;
                dca.name[k] = in_.name;
                dca.type[k] = '?';
                dca.num[k] = 0;
                dca.str[k] = '';
            }
            mpl_tab_drv_open(mpl, 'R');
            for (;;) {
                var tup;
                for (k = 1; k <= dca.nf; k++)
                    dca.type[k] = '?';
                if (mpl_tab_drv_read(mpl))
                    break;
                for (k = 1; k <= dca.nf; k++) {
                    if (dca.type[k] == '?')
                        mpl_internal_error(mpl, 'field ' + dca.name[k] + ' missing in input table');
                }
                tup = null;
                k = 0;
                for (fld = tab.u.in_.fld; fld != null; fld = fld.next) {
                    k++;
                    xassert(k <= dca.nf);
                    switch (dca.type[k]) {
                    case 'N':
                        tup = mpl_internal_expand_tuple(mpl, tup, mpl_internal_create_symbol_num(mpl, dca.num[k]));
                        break;
                    case 'S':
                        tup = mpl_internal_expand_tuple(mpl, tup, mpl_internal_create_symbol_str(mpl, dca.str[k]));
                        break;
                    default:
                        xassert(dca != dca);
                    }
                }
                if (tab.u.in_.set != null)
                    mpl_internal_check_then_add(mpl, tab.u.in_.set.array.head.value.set, mpl_internal_copy_tuple(mpl, tup));
                for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next) {
                    var memb;
                    k++;
                    xassert(k <= dca.nf);
                    if (mpl_internal_find_member(mpl, in_.par.array, tup) != null)
                        mpl_internal_error(mpl, in_.par.name + mpl_internal_format_tuple(mpl, '[', tup) + ' already defined');
                    memb = mpl_internal_add_member(mpl, in_.par.array, mpl_internal_copy_tuple(mpl, tup));
                    switch (in_.par.type) {
                    case A_NUMERIC:
                    case A_INTEGER:
                    case A_BINARY:
                        if (dca.type[k] != 'N')
                            mpl_internal_error(mpl, in_.par.name + ' requires numeric data');
                        memb.value.num = dca.num[k];
                        break;
                    case A_SYMBOLIC:
                        switch (dca.type[k]) {
                        case 'N':
                            memb.value.sym = mpl_internal_create_symbol_num(mpl, dca.num[k]);
                            break;
                        case 'S':
                            memb.value.sym = mpl_internal_create_symbol_str(mpl, dca.str[k]);
                            break;
                        default:
                            xassert(dca != dca);
                        }
                        break;
                    default:
                        xassert(in_ != in_);
                    }
                }
            }
            mpl.dca = null;
            break;
        case A_OUTPUT:
            xassert(dca.nf == 0);
            for (out = tab.u.out.list; out != null; out = out.next)
                dca.nf++;
            dca.name = new Array(1 + dca.nf);
            dca.type = new Array(1 + dca.nf);
            dca.num = new Float64Array(1 + dca.nf);
            dca.str = new Array(1 + dca.nf);
            k = 0;
            for (out = tab.u.out.list; out != null; out = out.next) {
                k++;
                dca.name[k] = out.name;
                dca.type[k] = '?';
                dca.num[k] = 0;
                dca.str[k] = '';
            }
            mpl_tab_drv_open(mpl, 'W');
            mpl_internal_loop_within_domain(mpl, tab.u.out.domain, tab, mpl_internal_write_func);
            mpl_tab_drv_flush(mpl);
            mpl.dca = null;
            break;
        default:
            xassert(tab != tab);
        }
    }
    function mpl_internal_check_func(mpl, chk) {
        if (!mpl_internal_eval_logical(mpl, chk.code))
            mpl_internal_error(mpl, 'check' + mpl_internal_format_tuple(mpl, '[', mpl_internal_get_domain_tuple(mpl, chk.domain)) + ' failed');
        return 0;
    }
    function mpl_internal_execute_check(mpl, chk) {
        mpl_internal_loop_within_domain(mpl, chk.domain, chk, mpl_internal_check_func);
    }
    function mpl_internal_display_set(mpl, set, memb) {
        var s = memb.value.set;
        var m;
        mpl_internal_write_text(mpl, set.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + (s.head == null ? ' is empty' : ':'));
        for (m = s.head; m != null; m = m.next)
            mpl_internal_write_text(mpl, '   ' + mpl_internal_format_tuple(mpl, '(', m.tuple));
    }
    function mpl_internal_display_par(mpl, par, memb) {
        switch (par.type) {
        case A_NUMERIC:
        case A_INTEGER:
        case A_BINARY:
            mpl_internal_write_text(mpl, par.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + ' = ' + memb.value.num);
            break;
        case A_SYMBOLIC:
            mpl_internal_write_text(mpl, par.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + ' = ' + mpl_internal_format_symbol(mpl, memb.value.sym));
            break;
        default:
            xassert(par != par);
        }
    }
    function mpl_internal_display_var(mpl, var_, memb, suff) {
        if (suff == DOT_NONE || suff == DOT_VAL)
            mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + '.val = ' + memb.value.var_.prim);
        else if (suff == DOT_LB)
            mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + '.lb = ' + (memb.value.var_.var_.lbnd == null ? -DBL_MAX : memb.value.var_.lbnd));
        else if (suff == DOT_UB)
            mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + '.ub = ' + (memb.value.var_.var_.ubnd == null ? +DBL_MAX : memb.value.var_.ubnd));
        else if (suff == DOT_STATUS)
            mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + '.status = ' + memb.value.var_.stat);
        else if (suff == DOT_DUAL)
            mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + '.dual = ' + memb.value.var_.dual);
        else
            xassert(suff != suff);
    }
    function mpl_internal_display_con(mpl, con, memb, suff) {
        if (suff == DOT_NONE || suff == DOT_VAL)
            mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + '.val = ' + memb.value.con.prim);
        else if (suff == DOT_LB)
            mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + '.lb = ' + (memb.value.con.con.lbnd == null ? -DBL_MAX : memb.value.con.lbnd));
        else if (suff == DOT_UB)
            mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + '.ub = ' + (memb.value.con.con.ubnd == null ? +DBL_MAX : memb.value.con.ubnd));
        else if (suff == DOT_STATUS)
            mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + '.status = ' + memb.value.con.stat);
        else if (suff == DOT_DUAL)
            mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + '.dual = ' + memb.value.con.dual);
        else
            xassert(suff != suff);
    }
    function mpl_internal_display_memb(mpl, code) {
        var memb = { value: {} };
        var e;
        xassert(code.op == O_MEMNUM || code.op == O_MEMSYM || code.op == O_MEMSET || code.op == O_MEMVAR || code.op == O_MEMCON);
        memb.tuple = null;
        for (e = code.arg.par.list || code.arg.var_.list; e != null; e = e.next)
            memb.tuple = mpl_internal_expand_tuple(mpl, memb.tuple, mpl_internal_eval_symbolic(mpl, e.x));
        switch (code.op) {
        case O_MEMNUM:
            memb.value.num = mpl_internal_eval_member_num(mpl, code.arg.par.par, memb.tuple);
            mpl_internal_display_par(mpl, code.arg.par.par, memb);
            break;
        case O_MEMSYM:
            memb.value.sym = mpl_internal_eval_member_sym(mpl, code.arg.par.par, memb.tuple);
            mpl_internal_display_par(mpl, code.arg.par.par, memb);
            break;
        case O_MEMSET:
            memb.value.set = mpl_internal_eval_member_set(mpl, code.arg.set.set, memb.tuple);
            mpl_internal_display_set(mpl, code.arg.set.set, memb);
            break;
        case O_MEMVAR:
            memb.value.var_ = mpl_internal_eval_member_var(mpl, code.arg.var_.var_, memb.tuple);
            mpl_internal_display_var(mpl, code.arg.var_.var_, memb, code.arg.var_.suff);
            break;
        case O_MEMCON:
            memb.value.con = mpl_internal_eval_member_con(mpl, code.arg.con.con, memb.tuple);
            mpl_internal_display_con(mpl, code.arg.con.con, memb, code.arg.con.suff);
            break;
        default:
            xassert(code != code);
        }
    }
    function mpl_internal_display_code(mpl, code) {
        switch (code.type) {
        case A_NUMERIC: {
                var num = mpl_internal_eval_numeric(mpl, code);
                mpl_internal_write_text(mpl, String(num));
            }
            break;
        case A_SYMBOLIC: {
                var sym = mpl_internal_eval_symbolic(mpl, code);
                mpl_internal_write_text(mpl, mpl_internal_format_symbol(mpl, sym));
            }
            break;
        case A_LOGICAL: {
                var bit = mpl_internal_eval_logical(mpl, code);
                mpl_internal_write_text(mpl, bit ? 'true' : 'false');
            }
            break;
        case A_TUPLE: {
                var tuple = mpl_internal_eval_tuple(mpl, code);
                mpl_internal_write_text(mpl, mpl_internal_format_tuple(mpl, '(', tuple));
            }
            break;
        case A_ELEMSET: {
                var set = mpl_internal_eval_elemset(mpl, code);
                if (set.head == 0)
                    mpl_internal_write_text(mpl, 'set is empty');
                for (var memb = set.head; memb != null; memb = memb.next)
                    mpl_internal_write_text(mpl, '   ' + mpl_internal_format_tuple(mpl, '(', memb.tuple));
            }
            break;
        case A_FORMULA: {
                var term;
                var form = mpl_internal_eval_formula(mpl, code);
                if (form == null)
                    mpl_internal_write_text(mpl, 'linear form is empty');
                for (term = form; term != null; term = term.next) {
                    if (term.var_ == null)
                        mpl_internal_write_text(mpl, '   ' + term.coef);
                    else
                        mpl_internal_write_text(mpl, '   ' + term.coef + ' ' + term.var_.var_.name + mpl_internal_format_tuple(mpl, '[', term.var_.memb.tuple));
                }
            }
            break;
        default:
            xassert(code != code);
        }
    }
    function mpl_internal_display_func(mpl, dpy) {
        var memb;
        for (var entry = dpy.list; entry != null; entry = entry.next) {
            if (entry.type == A_INDEX) {
                var slot = entry.u.slot;
                mpl_internal_write_text(mpl, slot.name + ' = ' + mpl_internal_format_symbol(mpl, slot.value));
            } else if (entry.type == A_SET) {
                var set = entry.u.set;
                if (set.assign != null) {
                    mpl_internal_eval_whole_set(mpl, set);
                } else {
                    if (set.gadget != null && set.data == 0) {
                        mpl_internal_saturate_set(mpl, set);
                    }
                    if (set.array.head != null)
                        mpl_internal_eval_member_set(mpl, set, set.array.head.tuple);
                }
                if (set.array.head == null)
                    mpl_internal_write_text(mpl, set.name + ' has empty content');
                for (memb = set.array.head; memb != null; memb = memb.next)
                    mpl_internal_display_set(mpl, set, memb);
            } else if (entry.type == A_PARAMETER) {
                var par = entry.u.par;
                if (par.assign != null) {
                    mpl_internal_eval_whole_par(mpl, par);
                } else {
                    if (par.array.head != null) {
                        if (par.type != A_SYMBOLIC)
                            mpl_internal_eval_member_num(mpl, par, par.array.head.tuple);
                        else
                            mpl_internal_eval_member_sym(mpl, par, par.array.head.tuple);
                    }
                }
                if (par.array.head == null)
                    mpl_internal_write_text(mpl, par.name + ' has empty content');
                for (memb = par.array.head; memb != null; memb = memb.next)
                    mpl_internal_display_par(mpl, par, memb);
            } else if (entry.type == A_VARIABLE) {
                var var_ = entry.u.var_;
                xassert(mpl.flag_p);
                if (var_.array.head == null)
                    mpl_internal_write_text(mpl, var_.name + ' has empty content');
                for (memb = var_.array.head; memb != null; memb = memb.next)
                    mpl_internal_display_var(mpl, var_, memb, DOT_NONE);
            } else if (entry.type == A_CONSTRAINT) {
                var con = entry.u.con;
                xassert(mpl.flag_p);
                if (con.array.head == null)
                    mpl_internal_write_text(mpl, con.name + ' has empty content');
                for (memb = con.array.head; memb != null; memb = memb.next)
                    mpl_internal_display_con(mpl, con, memb, DOT_NONE);
            } else if (entry.type == A_EXPRESSION) {
                var code = entry.u.code;
                if (code.op == O_MEMNUM || code.op == O_MEMSYM || code.op == O_MEMSET || code.op == O_MEMVAR || code.op == O_MEMCON)
                    mpl_internal_display_memb(mpl, code);
                else
                    mpl_internal_display_code(mpl, code);
            } else
                xassert(entry != entry);
        }
        return 0;
    }
    function mpl_internal_execute_display(mpl, dpy) {
        mpl_internal_loop_within_domain(mpl, dpy.domain, dpy, mpl_internal_display_func);
    }
    function mpl_internal_print_char(mpl, c) {
        if (mpl.prt_fp == null)
            mpl_internal_write_char(mpl, c);
        else
            mpl.prt_fp(c);
    }
    function mpl_internal_print_text(mpl, buf) {
        xassert(buf.length < OUTBUF_SIZE);
        for (var c = 0; c < buf.length; c++)
            mpl_internal_print_char(mpl, buf[c]);
    }
    function mpl_internal_printf_func(mpl, prt) {
        var entry;
        var fmt;
        var from;
        var c;
        var value;
        var sym = mpl_internal_eval_symbolic(mpl, prt.fmt);
        if (sym.str == null)
            fmt = String(sym.num);
        else
            fmt = sym.str;
        entry = prt.list;
        for (c = 0; c < fmt.length; c++) {
            if (fmt[c] == '%') {
                from = c++;
                if (fmt[c] == '%') {
                    mpl_internal_print_char(mpl, '%');
                    continue;
                }
                if (entry == null)
                    break;
                while (fmt[c] == '-' || fmt[c] == '+' || fmt[c] == ' ' || fmt[c] == '#' || fmt[c] == '0')
                    c++;
                while (isdigit(fmt[c]))
                    c++;
                if (fmt[c] == '.') {
                    c++;
                    while (isdigit(fmt[c]))
                        c++;
                }
                if (fmt[c] == 'd' || fmt[c] == 'i' || fmt[c] == 'e' || fmt[c] == 'E' || fmt[c] == 'f' || fmt[c] == 'F' || fmt[c] == 'g' || fmt[c] == 'G') {
                    xassert(entry != null);
                    switch (entry.code.type) {
                    case A_NUMERIC:
                        value = mpl_internal_eval_numeric(mpl, entry.code);
                        break;
                    case A_SYMBOLIC:
                        sym = mpl_internal_eval_symbolic(mpl, entry.code);
                        if (sym.str != null)
                            mpl_internal_error(mpl, 'cannot convert ' + mpl_internal_format_symbol(mpl, sym) + ' to floating-point number');
                        value = sym.num;
                        break;
                    case A_LOGICAL:
                        if (mpl_internal_eval_logical(mpl, entry.code))
                            value = 1;
                        else
                            value = 0;
                        break;
                    default:
                        xassert(entry != entry);
                    }
                    if (fmt[c] == 'd' || fmt[c] == 'i') {
                        var int_max = INT_MAX;
                        if (!(-int_max <= value && value <= +int_max))
                            mpl_internal_error(mpl, 'cannot convert ' + value + ' to integer');
                        mpl_internal_print_text(mpl, sprintf(fmt.slice(from, c + 1), Math.floor(value + 0.5) | 0));
                    } else
                        mpl_internal_print_text(mpl, sprintf(fmt.slice(from, c + 1), value));
                } else if (fmt[c] == 's') {
                    switch (entry.code.type) {
                    case A_NUMERIC:
                        value = String(mpl_internal_eval_numeric(mpl, entry.code));
                        break;
                    case A_LOGICAL:
                        if (mpl_internal_eval_logical(mpl, entry.code))
                            value = 'T';
                        else
                            value = 'F';
                        break;
                    case A_SYMBOLIC:
                        sym = mpl_internal_eval_symbolic(mpl, entry.code);
                        if (sym.str == null)
                            value = String(sym.num);
                        else
                            value = sym.str;
                        break;
                    default:
                        xassert(entry != entry);
                    }
                    mpl_internal_print_text(mpl, sprintf(fmt.slice(from, c + 1), value));
                } else
                    mpl_internal_error(mpl, 'format specifier missing or invalid');
                entry = entry.next;
            } else if (fmt[c] == '\\') {
                c++;
                if (fmt[c] == 't')
                    mpl_internal_print_char(mpl, '\t');
                else if (fmt[c] == 'n')
                    mpl_internal_print_char(mpl, '\n');
                else if (fmt[c] == '\0') {
                    mpl_internal_error(mpl, 'invalid use of escape character \\ in format control string');
                } else
                    mpl_internal_print_char(mpl, fmt[c]);
            } else {
                mpl_internal_print_char(mpl, fmt[c]);
            }
        }
        return 0;
    }
    function mpl_internal_execute_printf(mpl, prt) {
        if (prt.fname == null) {
            mpl.prt_file = null;
        } else {
            var sym = mpl_internal_eval_symbolic(mpl, prt.fname);
            if (sym.str == null)
                mpl.prt_file = sym.num;
            else
                mpl.prt_file = sym.str;
        }
        mpl_internal_loop_within_domain(mpl, prt.domain, prt, mpl_internal_printf_func);
    }
    function mpl_internal_for_func(mpl, fur) {
        var save = mpl.stmt;
        for (var stmt = fur.list; stmt != null; stmt = stmt.next)
            mpl_internal_execute_statement(mpl, stmt);
        mpl.stmt = save;
        return 0;
    }
    function mpl_internal_execute_for(mpl, fur) {
        mpl_internal_loop_within_domain(mpl, fur.domain, fur, mpl_internal_for_func);
    }
    function mpl_internal_execute_statement(mpl, stmt) {
        mpl.stmt = stmt;
        switch (stmt.type) {
        case A_SET:
        case A_PARAMETER:
        case A_VARIABLE:
            break;
        case A_CONSTRAINT:
            xprintf('Generating ' + stmt.u.con.name + '...');
            mpl_internal_eval_whole_con(mpl, stmt.u.con);
            break;
        case A_TABLE:
            switch (stmt.u.tab.type) {
            case A_INPUT:
                xprintf('Reading ' + stmt.u.tab.name + '...');
                break;
            case A_OUTPUT:
                xprintf('Writing ' + stmt.u.tab.name + '...');
                break;
            default:
                xassert(stmt != stmt);
            }
            mpl_internal_execute_table(mpl, stmt.u.tab);
            break;
        case A_SOLVE:
            break;
        case A_CHECK:
            xprintf('Checking (line ' + stmt.line + ')...');
            mpl_internal_execute_check(mpl, stmt.u.chk);
            break;
        case A_DISPLAY:
            mpl_internal_write_text(mpl, 'Display statement at line ' + stmt.line);
            mpl_internal_execute_display(mpl, stmt.u.dpy);
            break;
        case A_PRINTF:
            mpl_internal_execute_printf(mpl, stmt.u.prt);
            break;
        case A_FOR:
            mpl_internal_execute_for(mpl, stmt.u.fur);
            break;
        default:
            xassert(stmt != stmt);
        }
    }
    function mpl_internal_alloc_content(mpl) {
        var stmt;
        for (stmt = mpl.model; stmt != null; stmt = stmt.next) {
            switch (stmt.type) {
            case A_SET:
                xassert(stmt.u.set.array == null);
                stmt.u.set.array = mpl_internal_create_array(mpl, A_ELEMSET, stmt.u.set.dim);
                break;
            case A_PARAMETER:
                xassert(stmt.u.par.array == null);
                switch (stmt.u.par.type) {
                case A_NUMERIC:
                case A_INTEGER:
                case A_BINARY:
                    stmt.u.par.array = mpl_internal_create_array(mpl, A_NUMERIC, stmt.u.par.dim);
                    break;
                case A_SYMBOLIC:
                    stmt.u.par.array = mpl_internal_create_array(mpl, A_SYMBOLIC, stmt.u.par.dim);
                    break;
                default:
                    xassert(stmt != stmt);
                }
                break;
            case A_VARIABLE:
                xassert(stmt.u.var_.array == null);
                stmt.u.var_.array = mpl_internal_create_array(mpl, A_ELEMVAR, stmt.u.var_.dim);
                break;
            case A_CONSTRAINT:
                xassert(stmt.u.con.array == null);
                stmt.u.con.array = mpl_internal_create_array(mpl, A_ELEMCON, stmt.u.con.dim);
                break;
            case A_TABLE:
            case A_SOLVE:
            case A_CHECK:
            case A_DISPLAY:
            case A_PRINTF:
            case A_FOR:
                break;
            default:
                xassert(stmt != stmt);
            }
        }
    }
    function mpl_internal_generate_model(mpl) {
        var stmt;
        xassert(!mpl.flag_p);
        for (stmt = mpl.model; stmt != null; stmt = stmt.next) {
            mpl_internal_execute_statement(mpl, stmt);
            if (mpl.stmt.type == A_SOLVE)
                break;
        }
        mpl.stmt = stmt;
    }
    function mpl_internal_build_problem(mpl) {
        var stmt;
        var memb;
        var v;
        var c;
        var t;
        var i, j;
        xassert(mpl.m == 0);
        xassert(mpl.n == 0);
        xassert(mpl.row == null);
        xassert(mpl.col == null);
        for (stmt = mpl.model; stmt != null; stmt = stmt.next) {
            if (stmt.type == A_VARIABLE) {
                v = stmt.u.var_;
                for (memb = v.array.head; memb != null; memb = memb.next)
                    xassert(memb.value.var_.j == 0);
            }
        }
        for (stmt = mpl.model; stmt != null; stmt = stmt.next) {
            if (stmt.type == A_CONSTRAINT) {
                c = stmt.u.con;
                for (memb = c.array.head; memb != null; memb = memb.next) {
                    xassert(memb.value.con.i == 0);
                    memb.value.con.i = ++mpl.m;
                    for (t = memb.value.con.form; t != null; t = t.next) {
                        xassert(t.var_ != null);
                        t.var_.memb.value.var_.j = -1;
                    }
                }
            }
        }
        for (stmt = mpl.model; stmt != null; stmt = stmt.next) {
            if (stmt.type == A_VARIABLE) {
                v = stmt.u.var_;
                for (memb = v.array.head; memb != null; memb = memb.next)
                    if (memb.value.var_.j != 0)
                        memb.value.var_.j = ++mpl.n;
            }
        }
        mpl.row = new Array(1 + mpl.m);
        for (i = 1; i <= mpl.m; i++)
            mpl.row[i] = null;
        for (stmt = mpl.model; stmt != null; stmt = stmt.next) {
            if (stmt.type == A_CONSTRAINT) {
                c = stmt.u.con;
                for (memb = c.array.head; memb != null; memb = memb.next) {
                    i = memb.value.con.i;
                    xassert(1 <= i && i <= mpl.m);
                    xassert(mpl.row[i] == null);
                    mpl.row[i] = memb.value.con;
                }
            }
        }
        for (i = 1; i <= mpl.m; i++)
            xassert(mpl.row[i] != null);
        mpl.col = new Array(1 + mpl.n);
        for (j = 1; j <= mpl.n; j++)
            mpl.col[j] = null;
        for (stmt = mpl.model; stmt != null; stmt = stmt.next) {
            if (stmt.type == A_VARIABLE) {
                v = stmt.u.var_;
                for (memb = v.array.head; memb != null; memb = memb.next) {
                    j = memb.value.var_.j;
                    if (j == 0)
                        continue;
                    xassert(1 <= j && j <= mpl.n);
                    xassert(mpl.col[j] == null);
                    mpl.col[j] = memb.value.var_;
                }
            }
        }
        for (j = 1; j <= mpl.n; j++)
            xassert(mpl.col[j] != null);
    }
    function mpl_internal_postsolve_model(mpl) {
        var stmt;
        xassert(!mpl.flag_p);
        mpl.flag_p = 1;
        for (stmt = mpl.stmt; stmt != null; stmt = stmt.next)
            mpl_internal_execute_statement(mpl, stmt);
        mpl.stmt = null;
    }
    function mpl_internal_open_input(mpl, name, callback) {
        mpl.line = 0;
        mpl.column = 0;
        mpl.c = '\n';
        mpl.token = 0;
        mpl.imlen = 0;
        mpl.image = '';
        mpl.value = 0;
        mpl.b_token = T_EOF;
        mpl.b_imlen = 0;
        mpl.b_image = '';
        mpl.b_value = 0;
        mpl.f_dots = 0;
        mpl.f_scan = 0;
        mpl.f_token = 0;
        mpl.f_imlen = 0;
        mpl.f_image = '';
        mpl.f_value = 0;
        xfillArr(mpl.context, 0, ' ', CONTEXT_SIZE);
        mpl.c_ptr = 0;
        xassert(mpl.in_fp == null);
        mpl.in_fp = callback;
        mpl.in_file = name || 'input';
        mpl_internal_get_char(mpl);
        mpl_internal_get_token(mpl);
    }
    function mpl_internal_read_char(mpl) {
        var c;
        xassert(mpl.in_fp != null);
        c = mpl.in_fp();
        if (c < 0) {
            c = MPL_EOF;
        }
        return c;
    }
    function mpl_internal_close_input(mpl) {
        xassert(mpl.in_fp != null);
        mpl.in_fp = null;
    }
    function mpl_internal_open_output(mpl, name, callback) {
        xassert(mpl.out_fp == null);
        if (callback == null) {
            mpl.out_fp = function (data) {
                xprintf(data);
            };
        } else {
            mpl.out_fp = callback;
            mpl.out_file = name;
        }
        mpl.out_buffer = '';
    }
    function mpl_internal_write_char(mpl, c) {
        xassert(mpl.out_fp != null);
        if (c == '\n') {
            mpl.out_fp(mpl.out_buffer, mpl.prt_file);
            mpl.out_buffer = '';
        } else
            mpl.out_buffer += c;
    }
    function mpl_internal_write_text(mpl, str) {
        xassert(mpl.out_fp != null);
        mpl.out_fp(str, mpl.prt_file);
    }
    function mpl_internal_flush_output(mpl) {
        xassert(mpl.out_fp != null);
        if (mpl.out_buffer.length > 0) {
            mpl.out_fp(mpl.out_buffer, mpl.prt_file);
            mpl.out_buffer = '';
        }
    }
    function mpl_internal_error(mpl, msg) {
        var error;
        switch (mpl.phase) {
        case 1:
        case 2:
            error = new Error(mpl.in_file + ':' + mpl.line + ': ' + msg);
            error['line'] = mpl.line;
            error['column'] = mpl.column;
            mpl_internal_print_context(mpl);
            break;
        case 3:
            var line = mpl.stmt == null ? 0 : mpl.stmt.line;
            var column = mpl.stmt == null ? 0 : mpl.stmt.column;
            error = new Error(line + ': ' + msg);
            error['line'] = line;
            error['column'] = column;
            break;
        default:
            xassert(mpl != mpl);
        }
        mpl.phase = 4;
        throw error;
    }
    function mpl_internal_warning(mpl, msg) {
        switch (mpl.phase) {
        case 1:
        case 2:
            xprintf(mpl.in_file + ':' + mpl.line + ': warning: ' + msg);
            break;
        case 3:
            xprintf(mpl.mod_file + ':' + (mpl.stmt == null ? 0 : mpl.stmt.line) + ': warning: ' + msg);
            break;
        default:
            xassert(mpl != mpl);
        }
    }
    var mpl_initialize = exports['mpl_initialize'] = function () {
        var mpl = {};
        mpl.line = 0;
        mpl.column = 0;
        mpl.c = 0;
        mpl.token = 0;
        mpl.imlen = 0;
        mpl.image = '';
        mpl.value = 0;
        mpl.b_token = 0;
        mpl.b_imlen = 0;
        mpl.b_image = '';
        mpl.b_value = 0;
        mpl.f_dots = 0;
        mpl.f_scan = 0;
        mpl.f_token = 0;
        mpl.f_imlen = 0;
        mpl.f_image = '';
        mpl.f_value = 0;
        mpl.context = new Array(CONTEXT_SIZE);
        xfillArr(mpl.context, 0, ' ', CONTEXT_SIZE);
        mpl.c_ptr = 0;
        mpl.flag_d = 0;
        mpl.tree = {};
        mpl.model = null;
        mpl.flag_x = 0;
        mpl.as_within = 0;
        mpl.as_in = 0;
        mpl.as_binary = 0;
        mpl.flag_s = 0;
        mpl.a_list = null;
        mpl.sym_buf = '';
        mpl.tup_buf = '';
        mpl.rand = rng_create_rand();
        mpl.flag_p = 0;
        mpl.stmt = null;
        mpl.dca = null;
        mpl.m = 0;
        mpl.n = 0;
        mpl.row = null;
        mpl.col = null;
        mpl.in_fp = null;
        mpl.in_file = null;
        mpl.out_fp = null;
        mpl.out_file = null;
        mpl.prt_fp = null;
        mpl.prt_file = null;
        mpl.phase = 0;
        mpl.mod_file = null;
        mpl.mpl_buf = '';
        return mpl;
    };
    var mpl_read_model = exports['mpl_read_model'] = function (mpl, name, callback, skip_data) {
        function skip() {
            xprintf(mpl.line + ' line' + (mpl.line == 1 ? '' : 's') + ' were read');
            mpl_internal_close_input(mpl);
            return mpl.phase;
        }
        if (mpl.phase != 0)
            xerror('mpl_read_model: invalid call sequence');
        if (callback == null)
            xerror('mpl_read_model: no input specified');
        mpl.phase = 1;
        xprintf('Reading model section from ' + name + ' ...');
        mpl_internal_open_input(mpl, name, callback);
        mpl_internal_model_section(mpl);
        if (mpl.model == null)
            mpl_internal_error(mpl, 'empty model section not allowed');
        mpl.mod_file = mpl.in_file;
        mpl_internal_alloc_content(mpl);
        if (mpl_internal_is_keyword(mpl, 'data')) {
            if (skip_data) {
                mpl_internal_warning(mpl, 'data section ignored');
                return skip();
            }
            mpl.flag_d = 1;
            mpl_internal_get_token(mpl);
            if (mpl.token != T_SEMICOLON)
                mpl_internal_error(mpl, 'semicolon missing where expected');
            mpl_internal_get_token(mpl);
            mpl.phase = 2;
            xprintf('Reading data section from ' + name + ' ...');
            mpl_internal_data_section(mpl);
        }
        mpl_internal_end_statement(mpl);
        return skip();
    };
    var mpl_read_data = exports['mpl_read_data'] = function (mpl, name, callback) {
        if (!(mpl.phase == 1 || mpl.phase == 2))
            xerror('mpl_read_data: invalid call sequence');
        if (callback == null)
            xerror('mpl_read_data: no input specified');
        mpl.phase = 2;
        xprintf('Reading data section from ' + name + ' ...');
        mpl.flag_d = 1;
        mpl_internal_open_input(mpl, name, callback);
        if (mpl_internal_is_literal(mpl, 'data')) {
            mpl_internal_get_token(mpl);
            if (mpl.token != T_SEMICOLON)
                mpl_internal_error(mpl, 'semicolon missing where expected');
            mpl_internal_get_token(mpl);
        }
        mpl_internal_data_section(mpl);
        mpl_internal_end_statement(mpl);
        xprintf(mpl.line + ' line' + (mpl.line == 1 ? '' : 's') + ' were read');
        mpl_internal_close_input(mpl);
        return mpl.phase;
    };
    var mpl_generate = exports['mpl_generate'] = function (mpl, name, callback, tablecb) {
        if (!(mpl.phase == 1 || mpl.phase == 2))
            xerror('mpl_generate: invalid call sequence');
        mpl.phase = 3;
        mpl.tablecb = tablecb;
        mpl_internal_open_output(mpl, name, callback);
        mpl_internal_generate_model(mpl);
        mpl_internal_flush_output(mpl);
        mpl_internal_build_problem(mpl);
        xprintf('Model has been successfully generated');
        return mpl.phase;
    };
    var mpl_get_prob_name = exports['mpl_get_prob_name'] = function (mpl) {
        return mpl.mod_file;
    };
    var mpl_get_num_rows = exports['mpl_get_num_rows'] = function (mpl) {
        if (mpl.phase != 3)
            xerror('mpl_get_num_rows: invalid call sequence');
        return mpl.m;
    };
    var mpl_get_num_cols = exports['mpl_get_num_cols'] = function (mpl) {
        if (mpl.phase != 3)
            xerror('mpl_get_num_cols: invalid call sequence');
        return mpl.n;
    };
    var mpl_get_row_name = exports['mpl_get_row_name'] = function (mpl, i) {
        if (mpl.phase != 3)
            xerror('mpl_get_row_name: invalid call sequence');
        if (!(1 <= i && i <= mpl.m))
            xerror('mpl_get_row_name: i = ' + i + '; row number out of range');
        var name = mpl.row[i].con.name;
        var len = name.length;
        xassert(len <= 255);
        name += mpl_internal_format_tuple(mpl, '[', mpl.row[i].memb.tuple).slice(0, 255);
        if (name.length == 255)
            name = name.slice(0, 252) + '...';
        xassert(name.length <= 255);
        return name;
    };
    var mpl_get_row_kind = exports['mpl_get_row_kind'] = function (mpl, i) {
        var kind;
        if (mpl.phase != 3)
            xerror('mpl_get_row_kind: invalid call sequence');
        if (!(1 <= i && i <= mpl.m))
            xerror('mpl_get_row_kind: i = ' + i + '; row number out of range');
        switch (mpl.row[i].con.type) {
        case A_CONSTRAINT:
            kind = MPL_ST;
            break;
        case A_MINIMIZE:
            kind = MPL_MIN;
            break;
        case A_MAXIMIZE:
            kind = MPL_MAX;
            break;
        default:
            xassert(mpl != mpl);
        }
        return kind;
    };
    var mpl_get_row_bnds = exports['mpl_get_row_bnds'] = function (mpl, i, callback) {
        var con;
        var type;
        var lb, ub;
        if (mpl.phase != 3)
            xerror('mpl_get_row_bnds: invalid call sequence');
        if (!(1 <= i && i <= mpl.m))
            xerror('mpl_get_row_bnds: i = ' + i + '; row number out of range');
        con = mpl.row[i];
        lb = con.con.lbnd == null ? -DBL_MAX : con.lbnd;
        ub = con.con.ubnd == null ? +DBL_MAX : con.ubnd;
        if (lb == -DBL_MAX && ub == +DBL_MAX) {
            type = MPL_FR;
            lb = ub = 0;
        } else if (ub == +DBL_MAX) {
            type = MPL_LO;
            ub = 0;
        } else if (lb == -DBL_MAX) {
            type = MPL_UP;
            lb = 0;
        } else if (con.con.lbnd != con.con.ubnd)
            type = MPL_DB;
        else
            type = MPL_FX;
        callback(lb, ub);
        return type;
    };
    var mpl_get_mat_row = exports['mpl_get_mat_row'] = function (mpl, i, ndx, val) {
        var term;
        var len = 0;
        if (mpl.phase != 3)
            xerror('mpl_get_mat_row: invalid call sequence');
        if (!(1 <= i && i <= mpl.m))
            xerror('mpl_get_mat_row: i = ' + i + '; row number out of range');
        for (term = mpl.row[i].form; term != null; term = term.next) {
            xassert(term.var_ != null);
            len++;
            xassert(len <= mpl.n);
            if (ndx != null)
                ndx[len] = term.var_.j;
            if (val != null)
                val[len] = term.coef;
        }
        return len;
    };
    var mpl_get_row_c0 = exports['mpl_get_row_c0'] = function (mpl, i) {
        var con;
        var c0;
        if (mpl.phase != 3)
            xerror('mpl_get_row_c0: invalid call sequence');
        if (!(1 <= i && i <= mpl.m))
            xerror('mpl_get_row_c0: i = ' + i + '; row number out of range');
        con = mpl.row[i];
        if (con.con.lbnd == null && con.con.ubnd == null)
            c0 = -con.lbnd;
        else
            c0 = 0;
        return c0;
    };
    var mpl_get_col_name = exports['mpl_get_col_name'] = function (mpl, j) {
        if (mpl.phase != 3)
            xerror('mpl_get_col_name: invalid call sequence');
        if (!(1 <= j && j <= mpl.n))
            xerror('mpl_get_col_name: j = ' + j + '; column number out of range');
        var name = mpl.col[j].var_.name;
        var len = name.length;
        xassert(len <= 255);
        name += mpl_internal_format_tuple(mpl, '[', mpl.col[j].memb.tuple);
        if (name.length == 255)
            name = name.slice(0, 252) + '...';
        xassert(name.length <= 255);
        return name;
    };
    var mpl_get_col_kind = exports['mpl_get_col_kind'] = function (mpl, j) {
        var kind;
        if (mpl.phase != 3)
            xerror('mpl_get_col_kind: invalid call sequence');
        if (!(1 <= j && j <= mpl.n))
            xerror('mpl_get_col_kind: j = ' + j + '; column number out of range');
        switch (mpl.col[j].var_.type) {
        case A_NUMERIC:
            kind = MPL_NUM;
            break;
        case A_INTEGER:
            kind = MPL_INT;
            break;
        case A_BINARY:
            kind = MPL_BIN;
            break;
        default:
            xassert(mpl != mpl);
        }
        return kind;
    };
    var mpl_get_col_bnds = exports['mpl_get_col_bnds'] = function (mpl, j, callback) {
        var var_;
        var type;
        var lb, ub;
        if (mpl.phase != 3)
            xerror('mpl_get_col_bnds: invalid call sequence');
        if (!(1 <= j && j <= mpl.n))
            xerror('mpl_get_col_bnds: j = ' + j + '; column number out of range');
        var_ = mpl.col[j];
        lb = var_.var_.lbnd == null ? -DBL_MAX : var_.lbnd;
        ub = var_.var_.ubnd == null ? +DBL_MAX : var_.ubnd;
        if (lb == -DBL_MAX && ub == +DBL_MAX) {
            type = MPL_FR;
            lb = ub = 0;
        } else if (ub == +DBL_MAX) {
            type = MPL_LO;
            ub = 0;
        } else if (lb == -DBL_MAX) {
            type = MPL_UP;
            lb = 0;
        } else if (var_.var_.lbnd != var_.var_.ubnd)
            type = MPL_DB;
        else
            type = MPL_FX;
        callback(lb, ub);
        return type;
    };
    var mpl_has_solve_stmt = exports['mpl_has_solve_stmt'] = function (mpl) {
        if (mpl.phase != 3)
            xerror('mpl_has_solve_stmt: invalid call sequence');
        return mpl.flag_s;
    };
    var mpl_put_row_soln = exports['mpl_put_row_soln'] = function (mpl, i, stat, prim, dual) {
        xassert(mpl.phase == 3);
        xassert(1 <= i && i <= mpl.m);
        mpl.row[i].stat = stat;
        mpl.row[i].prim = prim;
        mpl.row[i].dual = dual;
    };
    var mpl_put_col_soln = exports['mpl_put_col_soln'] = function (mpl, j, stat, prim, dual) {
        xassert(mpl.phase == 3);
        xassert(1 <= j && j <= mpl.n);
        mpl.col[j].stat = stat;
        mpl.col[j].prim = prim;
        mpl.col[j].dual = dual;
    };
    var mpl_postsolve = exports['mpl_postsolve'] = function (mpl) {
        if (!(mpl.phase == 3 && !mpl.flag_p))
            xerror('mpl_postsolve: invalid call sequence');
        mpl_internal_postsolve_model(mpl);
        mpl_internal_flush_output(mpl);
        xprintf('Model has been successfully processed');
        return mpl.phase;
    };
    function mpl_internal_fn_gmtime(mpl) {
        return Math.round(Date.now() / 1000);
    }
    var mpl_internal_week = [
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday',
        'Sunday'
    ];
    var mpl_internal_moon = [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
    ];
    function mpl_internal_mulstr(v, n) {
        var ret = '';
        while (n > 0) {
            ret += v;
            n--;
        }
        return ret;
    }
    function mpl_internal_error1(mpl, str, s, fmt, f, msg) {
        xprintf('Input string passed to str2time:');
        xprintf(str);
        xprintf(mpl_internal_mulstr('^', s + 1));
        xprintf('Format string passed to str2time:\n');
        xprintf(fmt);
        xprintf(mpl_internal_mulstr('^', f + 1));
        mpl_internal_error(mpl, msg);
    }
    function mpl_internal_fn_str2time(mpl, str, fmt) {
        var j, year, month, day, hh, mm, ss, zone;
        var s, f;
        function err1() {
            mpl_internal_error1(mpl, str, s, fmt, f, 'time zone offset value incomplete or invalid');
        }
        function err2() {
            mpl_internal_error1(mpl, str, s, fmt, f, 'time zone offset value out of range');
        }
        function test() {
            if (str[s] != fmt[f])
                mpl_internal_error1(mpl, str, s, fmt, f, 'character mismatch');
            s++;
        }
        year = month = day = hh = mm = ss = -1;
        zone = INT_MAX;
        s = 0;
        for (f = 0; f < fmt.length; f++) {
            if (fmt[f] == '%') {
                f++;
                if (fmt[f] == 'b' || fmt[f] == 'h') {
                    var k;
                    var name;
                    if (month >= 0)
                        mpl_internal_error1(mpl, str, s, fmt, f, 'month multiply specified');
                    while (str[s] == ' ')
                        s++;
                    for (month = 1; month <= 12; month++) {
                        name = mpl_internal_moon[month - 1];
                        var b = false;
                        for (k = 0; k <= 2; k++) {
                            if (s[k].toUpperCase() != name[k].toUpperCase()) {
                                b = true;
                                break;
                            }
                        }
                        if (b)
                            continue;
                        s += 3;
                        for (k = 3; name[k] != '\0'; k++) {
                            if (str[s].toUpperCase() != name[k].toUpperCase())
                                break;
                            s++;
                        }
                        break;
                    }
                    if (month > 12)
                        mpl_internal_error1(mpl, str, s, fmt, f, 'abbreviated month name missing or invalid');
                } else if (fmt[f] == 'd') {
                    if (day >= 0)
                        mpl_internal_error1(mpl, str, s, fmt, f, 'day multiply specified');
                    while (str[s] == ' ')
                        s++;
                    if (!('0' <= str[s] && str[s] <= '9'))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'day missing or invalid');
                    day = str[s++] - '0';
                    if ('0' <= str[s] && str[s] <= '9')
                        day = 10 * day + (str[s++] - '0');
                    if (!(1 <= day && day <= 31))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'day out of range');
                } else if (fmt[f] == 'H') {
                    if (hh >= 0)
                        mpl_internal_error1(mpl, str, s, fmt, f, 'hour multiply specified');
                    while (str[s] == ' ')
                        s++;
                    if (!('0' <= str[s] && str[s] <= '9'))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'hour missing or invalid');
                    hh = str[s++] - '0';
                    if ('0' <= str[s] && str[s] <= '9')
                        hh = 10 * hh + (str[s++] - '0');
                    if (!(0 <= hh && hh <= 23))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'hour out of range');
                } else if (fmt[f] == 'm') {
                    if (month >= 0)
                        mpl_internal_error1(mpl, str, s, fmt, f, 'month multiply specified');
                    while (str[s] == ' ')
                        s++;
                    if (!('0' <= str[s] && str[s] <= '9'))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'month missing or invalid');
                    month = str[s++] - '0';
                    if ('0' <= str[s] && str[s] <= '9')
                        month = 10 * month + (str[s++] - '0');
                    if (!(1 <= month && month <= 12))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'month out of range');
                } else if (fmt[f] == 'M') {
                    if (mm >= 0)
                        mpl_internal_error1(mpl, str, s, fmt, f, 'minute multiply specified');
                    while (str[s] == ' ')
                        s++;
                    if (!('0' <= str[s] && str[s] <= '9'))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'minute missing or invalid');
                    mm = str[s++] - '0';
                    if ('0' <= str[s] && str[s] <= '9')
                        mm = 10 * mm + (str[s++] - '0');
                    if (!(0 <= mm && mm <= 59))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'minute out of range');
                } else if (fmt[f] == 'S') {
                    if (ss >= 0)
                        mpl_internal_error1(mpl, str, s, fmt, f, 'second multiply specified');
                    while (str[s] == ' ')
                        s++;
                    if (!('0' <= str[s] && str[s] <= '9'))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'second missing or invalid');
                    ss = str[s++] - '0';
                    if ('0' <= str[s] && str[s] <= '9')
                        ss = 10 * ss + (str[s++] - '0');
                    if (!(0 <= ss && ss <= 60))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'second out of range');
                } else if (fmt[f] == 'y') {
                    if (year >= 0)
                        mpl_internal_error1(mpl, str, s, fmt, f, 'year multiply specified');
                    while (str[s] == ' ')
                        s++;
                    if (!('0' <= str[s] && str[s] <= '9'))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'year missing or invalid');
                    year = str[s++] - '0';
                    if ('0' <= str[s] && str[s] <= '9')
                        year = 10 * year + (str[s++] - '0');
                    year += year >= 69 ? 1900 : 2000;
                } else if (fmt[f] == 'Y') {
                    if (year >= 0)
                        mpl_internal_error1(mpl, str, s, fmt, f, 'year multiply specified');
                    while (str[s] == ' ')
                        s++;
                    if (!('0' <= str[s] && str[s] <= '9'))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'year missing or invalid');
                    year = 0;
                    for (j = 1; j <= 4; j++) {
                        if (!('0' <= str[s] && str[s] <= '9'))
                            break;
                        year = 10 * year + (str[s++] - '0');
                    }
                    if (!(1 <= year && year <= 4000))
                        mpl_internal_error1(mpl, str, s, fmt, f, 'year out of range');
                } else if (fmt[f] == 'z') {
                    var z;
                    if (zone != INT_MAX)
                        mpl_internal_error1(mpl, str, s, fmt, f, 'time zone offset multiply specified');
                    while (str[s] == ' ')
                        s++;
                    if (str[s] == 'Z') {
                        z = hh = mm = 0;
                        s++;
                    } else {
                        if (str[s] == '+') {
                            z = +1;
                            s++;
                        } else if (str[s] == '-') {
                            z = -1;
                            s++;
                        } else
                            mpl_internal_error1(mpl, str, s, fmt, f, 'time zone offset sign missing');
                        hh = 0;
                        for (j = 1; j <= 2; j++) {
                            if (!('0' <= str[s] && str[s] <= '9'))
                                err1();
                            hh = 10 * hh + (str[s++] - '0');
                        }
                        if (hh > 23)
                            err2();
                        if (str[s] == ':') {
                            s++;
                            if (!('0' <= str[s] && str[s] <= '9'))
                                err1();
                        }
                        mm = 0;
                        if ('0' <= str[s] && str[s] <= '9') {
                            for (j = 1; j <= 2; j++) {
                                if (!('0' <= str[s] && str[s] <= '9'))
                                    err1();
                                mm = 10 * mm + (str[s++] - '0');
                            }
                            if (mm > 59)
                                err2();
                        }
                    }
                    zone = z * (60 * hh + mm);
                } else if (fmt[f] == '%') {
                    test();
                } else
                    mpl_internal_error1(mpl, str, s, fmt, f, 'invalid conversion specifier');
            } else if (fmt[f] == ' ') {
            } else
                test();
        }
        if (year < 0)
            year = 1970;
        if (month < 0)
            month = 1;
        if (day < 0)
            day = 1;
        if (hh < 0)
            hh = 0;
        if (mm < 0)
            mm = 0;
        if (ss < 0)
            ss = 0;
        if (zone == INT_MAX)
            zone = 0;
        j = jday(day, month, year);
        xassert(j >= 0);
        return (((j - jday(1, 1, 1970)) * 24 + hh) * 60 + mm) * 60 + ss - 60 * zone;
    }
    function mpl_internal_error2(mpl, fmt, f, msg) {
        xprintf('Format string passed to time2str:');
        xprintf(fmt);
        xprintf(mpl_internal_mulstr('^', f));
        mpl_internal_error(mpl, msg);
    }
    function mpl_internal_weekday(j) {
        return (j + jday(1, 1, 1970)) % 7 + 1;
    }
    function mpl_internal_firstday(year) {
        var j;
        j = jday(1, 1, year) - jday(1, 1, 1970);
        switch (mpl_internal_weekday(j)) {
        case 1:
            j += 0;
            break;
        case 2:
            j -= 1;
            break;
        case 3:
            j -= 2;
            break;
        case 4:
            j -= 3;
            break;
        case 5:
            j += 3;
            break;
        case 6:
            j += 2;
            break;
        case 7:
            j += 1;
            break;
        default:
            xassert(j != j);
        }
        xassert(mpl_internal_weekday(j) == 1);
        return j;
    }
    function mpl_internal_fn_time2str(mpl, t, fmt) {
        var j, year = 0, month = 0, day = 0, hh, mm, ss, len;
        var temp;
        var f;
        var str = '', buf;
        if (!(-62135596800 <= t && t <= 64092211199))
            mpl_internal_error(mpl, 'time2str(' + t + ',...); argument out of range');
        t = Math.floor(t + 0.5);
        temp = Math.abs(t) / 86400;
        j = Math.floor(temp);
        if (t < 0) {
            if (temp == Math.floor(temp))
                j = -j;
            else
                j = -(j + 1);
        }
        xassert(jdate(j + jday(1, 1, 1970), function (d, m, y) {
            day = d;
            month = m;
            year = y;
        }) == 0);
        ss = t - 86400 * j | 0;
        xassert(0 <= ss && ss < 86400);
        mm = ss / 60;
        ss %= 60;
        hh = mm / 60;
        mm %= 60;
        len = 0;
        for (f = 0; f < fmt.length; f++) {
            if (fmt[f] == '%') {
                f++;
                if (fmt[f] == 'a') {
                    buf = mpl_internal_week[mpl_internal_weekday(j) - 1].slice(0, 3);
                } else if (fmt[f] == 'A') {
                    buf = mpl_internal_week[mpl_internal_weekday(j) - 1];
                } else if (fmt[f] == 'b' || fmt[f] == 'h') {
                    buf = mpl_internal_moon[month - 1].slice(0, 3);
                } else if (fmt[f] == 'B') {
                    buf = mpl_internal_moon[month - 1];
                } else if (fmt[f] == 'C') {
                    buf = String(Math.floor(year / 100));
                } else if (fmt[f] == 'd') {
                    buf = String(day);
                } else if (fmt[f] == 'D') {
                    buf = month + '/' + day + '/' + year % 100;
                } else if (fmt[f] == 'e') {
                    buf = String(day);
                } else if (fmt[f] == 'F') {
                    sprintf(buf, year + '-' + month + '-' + day);
                } else if (fmt[f] == 'g') {
                    var iso;
                    if (j < mpl_internal_firstday(year))
                        iso = year - 1;
                    else if (j < mpl_internal_firstday(year + 1))
                        iso = year;
                    else
                        iso = year + 1;
                    buf = String(iso % 100);
                } else if (fmt[f] == 'G') {
                    var iso;
                    if (j < mpl_internal_firstday(year))
                        iso = year - 1;
                    else if (j < mpl_internal_firstday(year + 1))
                        iso = year;
                    else
                        iso = year + 1;
                    buf = String(iso);
                } else if (fmt[f] == 'H') {
                    buf = String(hh);
                } else if (fmt[f] == 'I') {
                    buf = String(hh == 0 ? 12 : hh <= 12 ? hh : hh - 12);
                } else if (fmt[f] == 'j') {
                    buf = String(jday(day, month, year) - jday(1, 1, year) + 1);
                } else if (fmt[f] == 'k') {
                    buf = String(hh);
                } else if (fmt[f] == 'l') {
                    buf = String(hh == 0 ? 12 : hh <= 12 ? hh : hh - 12);
                } else if (fmt[f] == 'm') {
                    buf = String(month);
                } else if (fmt[f] == 'M') {
                    buf = String(mm);
                } else if (fmt[f] == 'p') {
                    buf = hh <= 11 ? 'AM' : 'PM';
                } else if (fmt[f] == 'P') {
                    buf = hh <= 11 ? 'am' : 'pm';
                } else if (fmt[f] == 'r') {
                    buf = (hh == 0 ? 12 : hh <= 12 ? hh : hh - 12) + ':' + mm + ':' + ss + ' ' + (hh <= 11 ? 'AM' : 'PM');
                } else if (fmt[f] == 'R') {
                    buf = hh + ':' + mm;
                } else if (fmt[f] == 'S') {
                    buf = String(ss);
                } else if (fmt[f] == 'T') {
                    buf = hh + ':' + mm + ':' + ss;
                } else if (fmt[f] == 'u') {
                    buf = String(mpl_internal_weekday(j));
                } else if (fmt[f] == 'U') {
                    var sun = jday(1, 1, year) - jday(1, 1, 1970);
                    sun += 7 - mpl_internal_weekday(sun);
                    buf = String((j + 7 - sun) / 7);
                } else if (fmt[f] == 'V') {
                    var iso;
                    if (j < mpl_internal_firstday(year))
                        iso = j - mpl_internal_firstday(year - 1);
                    else if (j < mpl_internal_firstday(year + 1))
                        iso = j - mpl_internal_firstday(year);
                    else
                        iso = j - mpl_internal_firstday(year + 1);
                    buf = String(iso / 7 + 1);
                } else if (fmt[f] == 'w') {
                    buf = String(mpl_internal_weekday(j) % 7);
                } else if (fmt[f] == 'W') {
                    var mon = jday(1, 1, year) - jday(1, 1, 1970);
                    mon += (8 - mpl_internal_weekday(mon)) % 7;
                    buf = String((j + 7 - mon) / 7);
                } else if (fmt[f] == 'y') {
                    buf = String(year % 100);
                } else if (fmt[f] == 'Y') {
                    buf = String(year);
                } else if (fmt[f] == '%') {
                    buf = '%';
                } else
                    mpl_internal_error2(mpl, fmt, f, 'invalid conversion specifier');
            } else {
                buf = fmt[f];
            }
            str += buf;
            len += buf.length;
        }
        return str;
    }
    var MPL_DRIVERS = {};
    function mpl_tab_drv_open(mpl, mode) {
        var dca = mpl.dca;
        xassert(dca.id == 0);
        xassert(dca.link == null);
        xassert(dca.na >= 1);
        var Driver = MPL_DRIVERS[dca.arg[1].toLowerCase()];
        if (Driver)
            dca.link = new Driver(dca, mode, mpl.tablecb);
        else
            mpl_internal_error(mpl, 'Invalid table driver \'' + dca.arg[1] + '\'');
        if (dca.link == null)
            mpl_internal_error(mpl, 'error on opening table ' + mpl.stmt.u.tab.name);
    }
    function mpl_tab_drv_read(mpl) {
        var dca = mpl.dca;
        var ret = dca.link['readRecord'](dca);
        if (ret > 0)
            mpl_internal_error(mpl, 'error on reading data from table ' + mpl.stmt.u.tab.name);
        return ret;
    }
    function mpl_tab_drv_write(mpl) {
        var dca = mpl.dca;
        var ret = dca.link['writeRecord'](dca);
        if (ret)
            mpl_internal_error(mpl, 'error on writing data to table ' + mpl.stmt.u.tab.name);
    }
    function mpl_tab_drv_flush(mpl) {
        var dca = mpl.dca;
        dca.link['flush'](dca);
    }
    var mpl_tab_drv_register = exports['mpl_tab_drv_register'] = function (name, driver) {
        MPL_DRIVERS[name.toLowerCase()] = driver;
    };
    function CSVDriver(dca, mode, tablecb) {
        this.mode = mode;
        this.fname = null;
        this.count = 0;
        this.c = '\n';
        this.what = 0;
        this.field = '';
        this.nf = 0;
        this.ref = [];
        this.tablecb = tablecb;
        this.CSV_EOF = 0;
        this.CSV_EOR = 1;
        this.CSV_NUM = 2;
        this.CSV_STR = 3;
        if (mpl_tab_num_args(dca) < 2)
            xerror('csv_driver: file name not specified\n');
        this.fname = mpl_tab_get_arg(dca, 2);
        var k;
        if (mode == 'R') {
            if (tablecb) {
                this.data = tablecb(dca.arg, mode);
                this.cursor = 0;
            } else
                xerror('csv_driver: unable to open ' + this.fname);
            this.nskip = 0;
            this.readField();
            xassert(this.what == this.CSV_EOR);
            xassert(this.nf == 0);
            for (;;) {
                this.readField();
                if (this.what == this.CSV_EOR)
                    break;
                if (this.what != this.CSV_STR)
                    xerror(this.fname + ':' + this.count + ': invalid field name\n');
                this.nf++;
                for (k = mpl_tab_num_flds(dca); k >= 1; k--) {
                    if (mpl_tab_get_name(dca, k) == this.field)
                        break;
                }
                this.ref[this.nf] = k;
            }
            for (k = mpl_tab_num_flds(dca); k >= 1; k--)
                if (mpl_tab_get_name(dca, k) == 'RECNO')
                    break;
            this.ref[0] = k;
        } else if (mode == 'W') {
            this.data = '';
            var nf = mpl_tab_num_flds(dca);
            for (k = 1; k <= nf; k++)
                this.data += mpl_tab_get_name(dca, k) + (k < nf ? ',' : '\n');
            this.count++;
        } else
            xassert(mode != mode);
    }
    CSVDriver.prototype.readField = function () {
        if (this.c == XEOF) {
            this.what = this.CSV_EOF;
            this.field = 'EOF';
            return;
        }
        if (this.c == '\n') {
            this.what = this.CSV_EOR;
            this.field = 'EOR';
            this.readChar();
            if (this.c == ',')
                xerror(this.fname + ':' + this.count + ': empty field not allowed\n');
            if (this.c == '\n')
                xerror(this.fname + ':' + this.count + ': empty record not allowed\n');
            if (this.c == '#' && this.count == 1) {
                while (this.c == '#') {
                    while (this.c != '\n')
                        this.readChar();
                    this.readChar();
                    this.nskip++;
                }
            }
            return;
        }
        if (this.c == ',')
            this.readChar();
        if (this.c == '\'' || this.c == '"') {
            var quote = this.c;
            this.field = '';
            this.what = this.CSV_STR;
            this.readChar();
            for (;;) {
                if (this.c == quote) {
                    this.readChar();
                    if (this.c == quote) {
                    } else if (this.c == ',' || this.c == '\n')
                        break;
                    else
                        xerror(this.fname + ':' + this.count + ': invalid field');
                }
                this.field += this.c;
                this.readChar();
            }
            if (this.field.length == 0)
                xerror(this.fname + ':' + this.count + ': empty field not allowed');
        } else {
            this.field = '';
            var temp;
            this.what = this.CSV_NUM;
            while (!(this.c == ',' || this.c == '\n')) {
                if (this.c == '\'' || this.c == '"')
                    xerror(this.fname + ':' + this.count + ': invalid use of single or double quote within field');
                this.field += this.c;
                this.readChar();
            }
            if (this.field.length == 0)
                xerror(this.fname + ':' + this.count + ': empty field not allowed');
            if (str2num(this.field, function (v) {
                    temp = v;
                }))
                this.what = this.CSV_STR;
        }
    };
    CSVDriver.prototype.readChar = function () {
        var c;
        xassert(this.c != XEOF);
        if (this.c == '\n')
            this.count++;
        while (true) {
            if (this.cursor < this.data.length)
                c = this.data[this.cursor++];
            else
                c = XEOF;
            if (c == '\r')
                continue;
            else if (c == '\n') {
            } else if (iscntrl(c)) {
                xerror(this.fname + ':' + this.count + ': invalid control character ' + c);
            }
            break;
        }
        this.c = c;
    };
    CSVDriver.prototype['readRecord'] = function (dca) {
        var k, ret = 0;
        xassert(this.mode == 'R');
        if (this.ref[0] > 0)
            mpl_tab_set_num(dca, this.ref[0], this.count - this.nskip - 1);
        for (k = 1; k <= this.nf; k++) {
            this.readField();
            if (this.what == this.CSV_EOF) {
                xassert(k == 1);
                return XEOF;
            } else if (this.what == this.CSV_EOR) {
                var lack = this.nf - k + 1;
                if (lack == 1)
                    xerror(this.fname + ':' + this.count + ': one field missing');
                else
                    xerror(this.fname + ':' + this.count + ': ' + lack + ' fields missing');
            } else if (this.what == this.CSV_NUM) {
                if (this.ref[k] > 0) {
                    var num = 0;
                    xassert(str2num(this.field, function (v) {
                        num = v;
                    }) == 0);
                    mpl_tab_set_num(dca, this.ref[k], num);
                }
            } else if (this.what == this.CSV_STR) {
                if (this.ref[k] > 0)
                    mpl_tab_set_str(dca, this.ref[k], this.field);
            } else
                xassert(this != this);
        }
        this.readField();
        xassert(this.what != this.CSV_EOF);
        if (this.what != this.CSV_EOR)
            xerror(this.fname + ':' + this.count + ': too many fields');
        return ret;
    };
    CSVDriver.prototype['writeRecord'] = function (dca) {
        var k, nf, ret = 0;
        var c, n;
        xassert(this.mode == 'W');
        nf = mpl_tab_num_flds(dca);
        for (k = 1; k <= nf; k++) {
            switch (mpl_tab_get_type(dca, k)) {
            case 'N':
                this.data += mpl_tab_get_num(dca, k);
                break;
            case 'S':
                this.data += '"';
                for (c = mpl_tab_get_str(dca, k), n = 0; c.length > n; n++) {
                    if (c[n] == '"')
                        this.data += '""';
                    else
                        this.data += c[n];
                }
                this.data += '"';
                break;
            default:
                xassert(dca != dca);
            }
            this.data += k < nf ? ',' : '\n';
        }
        this.count++;
        return ret;
    };
    CSVDriver.prototype['flush'] = function (dca) {
        this.tablecb(dca.arg, this.mode, this.data);
    };
    mpl_tab_drv_register('CSV', CSVDriver);
    function JSONDriver(dca, mode, tablecb) {
        this.mode = mode;
        this.fname = null;
        if (mpl_tab_num_args(dca) < 2)
            xerror('json driver: file name not specified');
        this.fname = mpl_tab_get_arg(dca, 2);
        var k;
        if (mode == 'R') {
            this.ref = {};
            if (tablecb) {
                this.data = tablecb(dca.arg, mode);
                if (typeof this.data == 'string')
                    this.data = JSON.parse(this.data);
                this.cursor = 1;
            } else
                xerror('json driver: unable to open ' + this.fname);
            for (var i = 0, meta = this.data[0]; i < meta.length; i++)
                this.ref[meta[i]] = i;
        } else if (mode == 'W') {
            this.tablecb = tablecb;
            var names = [];
            this.data = [names];
            var nf = mpl_tab_num_flds(dca);
            for (k = 1; k <= nf; k++)
                names.push(mpl_tab_get_name(dca, k));
        } else
            xassert(mode != mode);
    }
    JSONDriver.prototype['writeRecord'] = function (dca) {
        var k;
        xassert(this.mode == 'W');
        var nf = mpl_tab_num_flds(dca);
        var line = [];
        for (k = 1; k <= nf; k++) {
            switch (mpl_tab_get_type(dca, k)) {
            case 'N':
                line.push(mpl_tab_get_num(dca, k));
                break;
            case 'S':
                line.push(mpl_tab_get_str(dca, k));
                break;
            default:
                xassert(dca != dca);
            }
        }
        this.data.push(line);
        return 0;
    };
    JSONDriver.prototype['readRecord'] = function (dca) {
        var ret = 0;
        xassert(this.mode == 'R');
        var line = this.data[this.cursor++];
        if (line == null)
            return XEOF;
        for (var k = 1; k <= mpl_tab_num_flds(dca); k++) {
            var index = this.ref[mpl_tab_get_name(dca, k)];
            if (index != null) {
                var value = line[index];
                switch (typeof value) {
                case 'number':
                    mpl_tab_set_num(dca, k, value);
                    break;
                case 'boolean':
                    mpl_tab_set_num(dca, k, Number(value));
                    break;
                case 'string':
                    mpl_tab_set_str(dca, k, value);
                    break;
                default:
                    xerror('Unexpected data type ' + value + ' in ' + this.fname);
                }
            }
        }
        return 0;
    };
    JSONDriver.prototype['flush'] = function (dca) {
        this.tablecb(dca.arg, this.mode, this.data);
    };
    mpl_tab_drv_register('JSON', JSONDriver);
    function npp_error() {
    }
    function npp_create_wksp() {
        var npp = {};
        npp.orig_dir = 0;
        npp.orig_m = npp.orig_n = npp.orig_nnz = 0;
        npp.name = npp.obj = null;
        npp.c0 = 0;
        npp.nrows = npp.ncols = 0;
        npp.r_head = npp.r_tail = null;
        npp.c_head = npp.c_tail = null;
        npp.top = null;
        npp.m = npp.n = npp.nnz = 0;
        npp.row_ref = npp.col_ref = null;
        npp.sol = npp.scaling = 0;
        npp.p_stat = npp.d_stat = npp.t_stat = npp.i_stat = 0;
        npp.r_stat = null;
        npp.r_pi = null;
        npp.c_stat = null;
        npp.c_value = null;
        return npp;
    }
    function npp_insert_row(npp, row, where) {
        if (where == 0) {
            row.prev = null;
            row.next = npp.r_head;
            if (row.next == null)
                npp.r_tail = row;
            else
                row.next.prev = row;
            npp.r_head = row;
        } else {
            row.prev = npp.r_tail;
            row.next = null;
            if (row.prev == null)
                npp.r_head = row;
            else
                row.prev.next = row;
            npp.r_tail = row;
        }
    }
    function npp_remove_row(npp, row) {
        if (row.prev == null)
            npp.r_head = row.next;
        else
            row.prev.next = row.next;
        if (row.next == null)
            npp.r_tail = row.prev;
        else
            row.next.prev = row.prev;
    }
    function npp_activate_row(npp, row) {
        if (!row.temp) {
            row.temp = 1;
            npp_remove_row(npp, row);
            npp_insert_row(npp, row, 0);
        }
    }
    function npp_deactivate_row(npp, row) {
        if (row.temp) {
            row.temp = 0;
            npp_remove_row(npp, row);
            npp_insert_row(npp, row, 1);
        }
    }
    function npp_insert_col(npp, col, where) {
        if (where == 0) {
            col.prev = null;
            col.next = npp.c_head;
            if (col.next == null)
                npp.c_tail = col;
            else
                col.next.prev = col;
            npp.c_head = col;
        } else {
            col.prev = npp.c_tail;
            col.next = null;
            if (col.prev == null)
                npp.c_head = col;
            else
                col.prev.next = col;
            npp.c_tail = col;
        }
    }
    function npp_remove_col(npp, col) {
        if (col.prev == null)
            npp.c_head = col.next;
        else
            col.prev.next = col.next;
        if (col.next == null)
            npp.c_tail = col.prev;
        else
            col.next.prev = col.prev;
    }
    function npp_activate_col(npp, col) {
        if (!col.temp) {
            col.temp = 1;
            npp_remove_col(npp, col);
            npp_insert_col(npp, col, 0);
        }
    }
    function npp_deactivate_col(npp, col) {
        if (col.temp) {
            col.temp = 0;
            npp_remove_col(npp, col);
            npp_insert_col(npp, col, 1);
        }
    }
    function npp_add_row(npp) {
        var row = {};
        row.i = ++npp.nrows;
        row.name = null;
        row.lb = -DBL_MAX;
        row.ub = +DBL_MAX;
        row.ptr = null;
        row.temp = 0;
        npp_insert_row(npp, row, 1);
        return row;
    }
    function npp_add_col(npp) {
        var col = {};
        col.j = ++npp.ncols;
        col.name = null;
        col.is_int = 0;
        col.lb = col.ub = col.coef = 0;
        col.ptr = null;
        col.temp = 0;
        col.ll = {};
        col.uu = {};
        npp_insert_col(npp, col, 1);
        return col;
    }
    function npp_add_aij(row, col, val) {
        var aij = {};
        aij.row = row;
        aij.col = col;
        aij.val = val;
        aij.r_prev = null;
        aij.r_next = row.ptr;
        aij.c_prev = null;
        aij.c_next = col.ptr;
        if (aij.r_next != null)
            aij.r_next.r_prev = aij;
        if (aij.c_next != null)
            aij.c_next.c_prev = aij;
        row.ptr = col.ptr = aij;
        return aij;
    }
    function npp_row_nnz(row) {
        var nnz = 0;
        for (var aij = row.ptr; aij != null; aij = aij.r_next)
            nnz++;
        return nnz;
    }
    function npp_col_nnz(col) {
        var nnz = 0;
        for (var aij = col.ptr; aij != null; aij = aij.c_next)
            nnz++;
        return nnz;
    }
    function npp_push_tse(npp, func) {
        var tse;
        tse = {};
        tse.func = func;
        tse.info = {};
        tse.link = npp.top;
        npp.top = tse;
        return tse.info;
    }
    function npp_erase_row(row) {
        var aij;
        while (row.ptr != null) {
            aij = row.ptr;
            row.ptr = aij.r_next;
            if (aij.c_prev == null)
                aij.col.ptr = aij.c_next;
            else
                aij.c_prev.c_next = aij.c_next;
            if (aij.c_next != null)
                aij.c_next.c_prev = aij.c_prev;
        }
    }
    function npp_del_row(npp, row) {
        npp_erase_row(row);
        npp_remove_row(npp, row);
    }
    function npp_del_col(npp, col) {
        var aij;
        while (col.ptr != null) {
            aij = col.ptr;
            col.ptr = aij.c_next;
            if (aij.r_prev == null)
                aij.row.ptr = aij.r_next;
            else
                aij.r_prev.r_next = aij.r_next;
            if (aij.r_next != null)
                aij.r_next.r_prev = aij.r_prev;
        }
        npp_remove_col(npp, col);
    }
    function npp_del_aij(aij) {
        if (aij.r_prev == null)
            aij.row.ptr = aij.r_next;
        else
            aij.r_prev.r_next = aij.r_next;
        if (aij.r_next != null)
            aij.r_next.r_prev = aij.r_prev;
        if (aij.c_prev == null)
            aij.col.ptr = aij.c_next;
        else
            aij.c_prev.c_next = aij.c_next;
        if (aij.c_next != null)
            aij.c_next.c_prev = aij.c_prev;
    }
    function npp_load_prob(npp, orig, names, sol, scaling) {
        var m = orig.m;
        var n = orig.n;
        var link;
        var i, j;
        var dir;
        xassert(names == GLP_OFF || names == GLP_ON);
        xassert(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP);
        xassert(scaling == GLP_OFF || scaling == GLP_ON);
        if (sol == GLP_MIP)
            xassert(!scaling);
        npp.orig_dir = orig.dir;
        if (npp.orig_dir == GLP_MIN)
            dir = +1;
        else if (npp.orig_dir == GLP_MAX)
            dir = -1;
        else
            xassert(npp != npp);
        npp.orig_m = m;
        npp.orig_n = n;
        npp.orig_nnz = orig.nnz;
        if (names && orig.name != null)
            npp.name = orig.name;
        if (names && orig.obj != null)
            npp.obj = orig.obj;
        npp.c0 = dir * orig.c0;
        link = new Array(1 + m);
        for (i = 1; i <= m; i++) {
            var rrr = orig.row[i];
            var row;
            link[i] = row = npp_add_row(npp);
            xassert(row.i == i);
            if (names && rrr.name != null)
                row.name = rrr.name;
            if (!scaling) {
                if (rrr.type == GLP_FR) {
                    row.lb = -DBL_MAX;
                    row.ub = +DBL_MAX;
                } else if (rrr.type == GLP_LO) {
                    row.lb = rrr.lb;
                    row.ub = +DBL_MAX;
                } else if (rrr.type == GLP_UP) {
                    row.lb = -DBL_MAX;
                    row.ub = rrr.ub;
                } else if (rrr.type == GLP_DB) {
                    row.lb = rrr.lb;
                    row.ub = rrr.ub;
                } else if (rrr.type == GLP_FX)
                    row.lb = row.ub = rrr.lb;
                else
                    xassert(rrr != rrr);
            } else {
                var rii = rrr.rii;
                if (rrr.type == GLP_FR) {
                    row.lb = -DBL_MAX;
                    row.ub = +DBL_MAX;
                } else if (rrr.type == GLP_LO) {
                    row.lb = rrr.lb * rii;
                    row.ub = +DBL_MAX;
                } else if (rrr.type == GLP_UP) {
                    row.lb = -DBL_MAX;
                    row.ub = rrr.ub * rii;
                } else if (rrr.type == GLP_DB) {
                    row.lb = rrr.lb * rii;
                    row.ub = rrr.ub * rii;
                } else if (rrr.type == GLP_FX)
                    row.lb = row.ub = rrr.lb * rii;
                else
                    xassert(rrr != rrr);
            }
        }
        for (j = 1; j <= n; j++) {
            var ccc = orig.col[j];
            var aaa;
            var col;
            col = npp_add_col(npp);
            xassert(col.j == j);
            if (names && ccc.name != null)
                col.name = ccc.name;
            if (sol == GLP_MIP)
                col.is_int = Number(ccc.kind == GLP_IV);
            if (!scaling) {
                if (ccc.type == GLP_FR) {
                    col.lb = -DBL_MAX;
                    col.ub = +DBL_MAX;
                } else if (ccc.type == GLP_LO) {
                    col.lb = ccc.lb;
                    col.ub = +DBL_MAX;
                } else if (ccc.type == GLP_UP) {
                    col.lb = -DBL_MAX;
                    col.ub = ccc.ub;
                } else if (ccc.type == GLP_DB) {
                    col.lb = ccc.lb;
                    col.ub = ccc.ub;
                } else if (ccc.type == GLP_FX)
                    col.lb = col.ub = ccc.lb;
                else
                    xassert(ccc != ccc);
                col.coef = dir * ccc.coef;
                for (aaa = ccc.ptr; aaa != null; aaa = aaa.c_next)
                    npp_add_aij(link[aaa.row.i], col, aaa.val);
            } else {
                var sjj = ccc.sjj;
                if (ccc.type == GLP_FR) {
                    col.lb = -DBL_MAX;
                    col.ub = +DBL_MAX;
                } else if (ccc.type == GLP_LO) {
                    col.lb = ccc.lb / sjj;
                    col.ub = +DBL_MAX;
                } else if (ccc.type == GLP_UP) {
                    col.lb = -DBL_MAX;
                    col.ub = ccc.ub / sjj;
                } else if (ccc.type == GLP_DB) {
                    col.lb = ccc.lb / sjj;
                    col.ub = ccc.ub / sjj;
                } else if (ccc.type == GLP_FX)
                    col.lb = col.ub = ccc.lb / sjj;
                else
                    xassert(ccc != ccc);
                col.coef = dir * ccc.coef * sjj;
                for (aaa = ccc.ptr; aaa != null; aaa = aaa.c_next)
                    npp_add_aij(link[aaa.row.i], col, aaa.row.rii * aaa.val * sjj);
            }
        }
        npp.sol = sol;
        npp.scaling = scaling;
    }
    function npp_build_prob(npp, prob) {
        var row;
        var col;
        var aij;
        var i, j, type, len, ind;
        var dir, val;
        glp_erase_prob(prob);
        glp_set_prob_name(prob, npp.name);
        glp_set_obj_name(prob, npp.obj);
        glp_set_obj_dir(prob, npp.orig_dir);
        if (npp.orig_dir == GLP_MIN)
            dir = +1;
        else if (npp.orig_dir == GLP_MAX)
            dir = -1;
        else
            xassert(npp != npp);
        glp_set_obj_coef(prob, 0, dir * npp.c0);
        for (row = npp.r_head; row != null; row = row.next) {
            row.temp = i = glp_add_rows(prob, 1);
            glp_set_row_name(prob, i, row.name);
            if (row.lb == -DBL_MAX && row.ub == +DBL_MAX)
                type = GLP_FR;
            else if (row.ub == +DBL_MAX)
                type = GLP_LO;
            else if (row.lb == -DBL_MAX)
                type = GLP_UP;
            else if (row.lb != row.ub)
                type = GLP_DB;
            else
                type = GLP_FX;
            glp_set_row_bnds(prob, i, type, row.lb, row.ub);
        }
        ind = new Int32Array(1 + prob.m);
        val = new Float64Array(1 + prob.m);
        for (col = npp.c_head; col != null; col = col.next) {
            j = glp_add_cols(prob, 1);
            glp_set_col_name(prob, j, col.name);
            glp_set_col_kind(prob, j, col.is_int ? GLP_IV : GLP_CV);
            if (col.lb == -DBL_MAX && col.ub == +DBL_MAX)
                type = GLP_FR;
            else if (col.ub == +DBL_MAX)
                type = GLP_LO;
            else if (col.lb == -DBL_MAX)
                type = GLP_UP;
            else if (col.lb != col.ub)
                type = GLP_DB;
            else
                type = GLP_FX;
            glp_set_col_bnds(prob, j, type, col.lb, col.ub);
            glp_set_obj_coef(prob, j, dir * col.coef);
            len = 0;
            for (aij = col.ptr; aij != null; aij = aij.c_next) {
                len++;
                ind[len] = aij.row.temp;
                val[len] = aij.val;
            }
            glp_set_mat_col(prob, j, len, ind, val);
        }
        npp.m = prob.m;
        npp.n = prob.n;
        npp.nnz = prob.nnz;
        npp.row_ref = new Int32Array(1 + npp.m);
        npp.col_ref = new Int32Array(1 + npp.n);
        for (row = npp.r_head, i = 0; row != null; row = row.next)
            npp.row_ref[++i] = row.i;
        for (col = npp.c_head, j = 0; col != null; col = col.next)
            npp.col_ref[++j] = col.j;
        npp.name = npp.obj = null;
        npp.c0 = 0;
        npp.r_head = npp.r_tail = null;
        npp.c_head = npp.c_tail = null;
    }
    function npp_postprocess(npp, prob) {
        var row;
        var col;
        var tse;
        var i, j, k;
        var dir;
        xassert(npp.orig_dir == prob.dir);
        if (npp.orig_dir == GLP_MIN)
            dir = +1;
        else if (npp.orig_dir == GLP_MAX)
            dir = -1;
        else
            xassert(npp != npp);
        xassert(npp.m == prob.m);
        xassert(npp.n == prob.n);
        xassert(npp.nnz == prob.nnz);
        if (npp.sol == GLP_SOL) {
            npp.p_stat = prob.pbs_stat;
            npp.d_stat = prob.dbs_stat;
        } else if (npp.sol == GLP_IPT)
            npp.t_stat = prob.ipt_stat;
        else if (npp.sol == GLP_MIP)
            npp.i_stat = prob.mip_stat;
        else
            xassert(npp != npp);
        if (npp.sol == GLP_SOL) {
            if (npp.r_stat == null)
                npp.r_stat = new Int8Array(1 + npp.nrows);
            for (i = 1; i <= npp.nrows; i++)
                npp.r_stat[i] = 0;
            if (npp.c_stat == null)
                npp.c_stat = new Int8Array(1 + npp.ncols);
            for (j = 1; j <= npp.ncols; j++)
                npp.c_stat[j] = 0;
        }
        if (npp.c_value == null)
            npp.c_value = new Float64Array(1 + npp.ncols);
        for (j = 1; j <= npp.ncols; j++)
            npp.c_value[j] = DBL_MAX;
        if (npp.sol != GLP_MIP) {
            if (npp.r_pi == null)
                npp.r_pi = new Float64Array(1 + npp.nrows);
            for (i = 1; i <= npp.nrows; i++)
                npp.r_pi[i] = DBL_MAX;
        }
        if (npp.sol == GLP_SOL) {
            for (i = 1; i <= npp.m; i++) {
                row = prob.row[i];
                k = npp.row_ref[i];
                npp.r_stat[k] = row.stat;
                npp.r_pi[k] = dir * row.dual;
            }
            for (j = 1; j <= npp.n; j++) {
                col = prob.col[j];
                k = npp.col_ref[j];
                npp.c_stat[k] = col.stat;
                npp.c_value[k] = col.prim;
            }
        } else if (npp.sol == GLP_IPT) {
            for (i = 1; i <= npp.m; i++) {
                row = prob.row[i];
                k = npp.row_ref[i];
                npp.r_pi[k] = dir * row.dval;
            }
            for (j = 1; j <= npp.n; j++) {
                col = prob.col[j];
                k = npp.col_ref[j];
                npp.c_value[k] = col.pval;
            }
        } else if (npp.sol == GLP_MIP) {
            for (j = 1; j <= npp.n; j++) {
                col = prob.col[j];
                k = npp.col_ref[j];
                npp.c_value[k] = col.mipx;
            }
        } else
            xassert(npp != npp);
        for (tse = npp.top; tse != null; tse = tse.link) {
            xassert(tse.func != null);
            xassert(tse.func(npp, tse.info) == 0);
        }
    }
    function npp_unload_sol(npp, orig) {
        var row;
        var col;
        var i, j;
        var dir;
        var aij, temp;
        xassert(npp.orig_dir == orig.dir);
        if (npp.orig_dir == GLP_MIN)
            dir = +1;
        else if (npp.orig_dir == GLP_MAX)
            dir = -1;
        else
            xassert(npp != npp);
        xassert(npp.orig_m == orig.m);
        xassert(npp.orig_n == orig.n);
        xassert(npp.orig_nnz == orig.nnz);
        if (npp.sol == GLP_SOL) {
            orig.valid = 0;
            orig.pbs_stat = npp.p_stat;
            orig.dbs_stat = npp.d_stat;
            orig.obj_val = orig.c0;
            orig.some = 0;
            for (i = 1; i <= orig.m; i++) {
                row = orig.row[i];
                row.stat = npp.r_stat[i];
                if (!npp.scaling) {
                    row.dual = dir * npp.r_pi[i];
                } else {
                    row.dual = dir * npp.r_pi[i] * row.rii;
                }
                if (row.stat == GLP_BS)
                    row.dual = 0;
                else if (row.stat == GLP_NL) {
                    xassert(row.type == GLP_LO || row.type == GLP_DB);
                    row.prim = row.lb;
                } else if (row.stat == GLP_NU) {
                    xassert(row.type == GLP_UP || row.type == GLP_DB);
                    row.prim = row.ub;
                } else if (row.stat == GLP_NF) {
                    xassert(row.type == GLP_FR);
                    row.prim = 0;
                } else if (row.stat == GLP_NS) {
                    xassert(row.type == GLP_FX);
                    row.prim = row.lb;
                } else
                    xassert(row != row);
            }
            for (j = 1; j <= orig.n; j++) {
                col = orig.col[j];
                col.stat = npp.c_stat[j];
                if (!npp.scaling) {
                    col.prim = npp.c_value[j];
                } else {
                    col.prim = npp.c_value[j] * col.sjj;
                }
                if (col.stat == GLP_BS)
                    col.dual = 0;
                else if (col.stat == GLP_NL) {
                    xassert(col.type == GLP_LO || col.type == GLP_DB);
                    col.prim = col.lb;
                } else if (col.stat == GLP_NU) {
                    xassert(col.type == GLP_UP || col.type == GLP_DB);
                    col.prim = col.ub;
                } else if (col.stat == GLP_NF) {
                    xassert(col.type == GLP_FR);
                    col.prim = 0;
                } else if (col.stat == GLP_NS) {
                    xassert(col.type == GLP_FX);
                    col.prim = col.lb;
                } else
                    xassert(col != col);
                orig.obj_val += col.coef * col.prim;
            }
            for (i = 1; i <= orig.m; i++) {
                row = orig.row[i];
                if (row.stat == GLP_BS) {
                    temp = 0;
                    for (aij = row.ptr; aij != null; aij = aij.r_next)
                        temp += aij.val * aij.col.prim;
                    row.prim = temp;
                }
            }
            for (j = 1; j <= orig.n; j++) {
                col = orig.col[j];
                if (col.stat != GLP_BS) {
                    temp = col.coef;
                    for (aij = col.ptr; aij != null; aij = aij.c_next)
                        temp -= aij.val * aij.row.dual;
                    col.dual = temp;
                }
            }
        } else if (npp.sol == GLP_IPT) {
            orig.ipt_stat = npp.t_stat;
            orig.ipt_obj = orig.c0;
            for (i = 1; i <= orig.m; i++) {
                row = orig.row[i];
                if (!npp.scaling) {
                    row.dval = dir * npp.r_pi[i];
                } else {
                    row.dval = dir * npp.r_pi[i] * row.rii;
                }
            }
            for (j = 1; j <= orig.n; j++) {
                col = orig.col[j];
                if (!npp.scaling) {
                    col.pval = npp.c_value[j];
                } else {
                    col.pval = npp.c_value[j] * col.sjj;
                }
                orig.ipt_obj += col.coef * col.pval;
            }
            for (i = 1; i <= orig.m; i++) {
                row = orig.row[i];
                {
                    temp = 0;
                    for (aij = row.ptr; aij != null; aij = aij.r_next)
                        temp += aij.val * aij.col.pval;
                    row.pval = temp;
                }
            }
            for (j = 1; j <= orig.n; j++) {
                col = orig.col[j];
                {
                    temp = col.coef;
                    for (aij = col.ptr; aij != null; aij = aij.c_next)
                        temp -= aij.val * aij.row.dval;
                    col.dval = temp;
                }
            }
        } else if (npp.sol == GLP_MIP) {
            xassert(!npp.scaling);
            orig.mip_stat = npp.i_stat;
            orig.mip_obj = orig.c0;
            for (j = 1; j <= orig.n; j++) {
                col = orig.col[j];
                col.mipx = npp.c_value[j];
                if (col.kind == GLP_IV)
                    xassert(col.mipx == Math.floor(col.mipx));
                orig.mip_obj += col.coef * col.mipx;
            }
            for (i = 1; i <= orig.m; i++) {
                row = orig.row[i];
                {
                    temp = 0;
                    for (aij = row.ptr; aij != null; aij = aij.r_next)
                        temp += aij.val * aij.col.mipx;
                    row.mipx = temp;
                }
            }
        } else
            xassert(npp != npp);
    }
    function npp_free_row(npp, p) {
        var info;
        xassert(p.lb == -DBL_MAX && p.ub == +DBL_MAX);
        info = npp_push_tse(npp, function (npp, info) {
            if (npp.sol == GLP_SOL)
                npp.r_stat[info.p] = GLP_BS;
            if (npp.sol != GLP_MIP)
                npp.r_pi[info.p] = 0;
            return 0;
        });
        info.p = p.i;
        npp_del_row(npp, p);
    }
    function npp_geq_row(npp, p) {
        var info;
        var s;
        xassert(p.lb != -DBL_MAX);
        xassert(p.lb < p.ub);
        s = npp_add_col(npp);
        s.lb = 0;
        s.ub = p.ub == +DBL_MAX ? +DBL_MAX : p.ub - p.lb;
        npp_add_aij(p, s, -1);
        info = npp_push_tse(npp, function rcv_geq_row(npp, info) {
            if (npp.sol == GLP_SOL) {
                if (npp.r_stat[info.p] == GLP_BS) {
                    if (npp.c_stat[info.s] == GLP_BS) {
                        npp_error();
                        return 1;
                    } else if (npp.c_stat[info.s] == GLP_NL || npp.c_stat[info.s] == GLP_NU)
                        npp.r_stat[info.p] = GLP_BS;
                    else {
                        npp_error();
                        return 1;
                    }
                } else if (npp.r_stat[info.p] == GLP_NS) {
                    if (npp.c_stat[info.s] == GLP_BS)
                        npp.r_stat[info.p] = GLP_BS;
                    else if (npp.c_stat[info.s] == GLP_NL)
                        npp.r_stat[info.p] = GLP_NL;
                    else if (npp.c_stat[info.s] == GLP_NU)
                        npp.r_stat[info.p] = GLP_NU;
                    else {
                        npp_error();
                        return 1;
                    }
                } else {
                    npp_error();
                    return 1;
                }
            }
            return 0;
        });
        info.p = p.i;
        info.s = s.j;
        p.ub = p.lb;
    }
    function npp_leq_row(npp, p) {
        var info;
        var s;
        xassert(p.ub != +DBL_MAX);
        xassert(p.lb < p.ub);
        s = npp_add_col(npp);
        s.lb = 0;
        s.ub = p.lb == -DBL_MAX ? +DBL_MAX : p.ub - p.lb;
        npp_add_aij(p, s, +1);
        info = npp_push_tse(npp, function (npp, info) {
            if (npp.sol == GLP_SOL) {
                if (npp.r_stat[info.p] == GLP_BS) {
                    if (npp.c_stat[info.s] == GLP_BS) {
                        npp_error();
                        return 1;
                    } else if (npp.c_stat[info.s] == GLP_NL || npp.c_stat[info.s] == GLP_NU)
                        npp.r_stat[info.p] = GLP_BS;
                    else {
                        npp_error();
                        return 1;
                    }
                } else if (npp.r_stat[info.p] == GLP_NS) {
                    if (npp.c_stat[info.s] == GLP_BS)
                        npp.r_stat[info.p] = GLP_BS;
                    else if (npp.c_stat[info.s] == GLP_NL)
                        npp.r_stat[info.p] = GLP_NU;
                    else if (npp.c_stat[info.s] == GLP_NU)
                        npp.r_stat[info.p] = GLP_NL;
                    else {
                        npp_error();
                        return 1;
                    }
                } else {
                    npp_error();
                    return 1;
                }
            }
            return 0;
        });
        info.p = p.i;
        info.s = s.j;
        p.lb = p.ub;
    }
    function npp_free_col(npp, q) {
        var info;
        var s;
        var aij;
        xassert(q.lb == -DBL_MAX && q.ub == +DBL_MAX);
        q.lb = 0;
        q.ub = +DBL_MAX;
        s = npp_add_col(npp);
        s.is_int = q.is_int;
        s.lb = 0;
        s.ub = +DBL_MAX;
        s.coef = -q.coef;
        for (aij = q.ptr; aij != null; aij = aij.c_next)
            npp_add_aij(aij.row, s, -aij.val);
        info = npp_push_tse(npp, function (npp, info) {
            if (npp.sol == GLP_SOL) {
                if (npp.c_stat[info.q] == GLP_BS) {
                    if (npp.c_stat[info.s] == GLP_BS) {
                        npp_error();
                        return 1;
                    } else if (npp.c_stat[info.s] == GLP_NL)
                        npp.c_stat[info.q] = GLP_BS;
                    else {
                        npp_error();
                        return -1;
                    }
                } else if (npp.c_stat[info.q] == GLP_NL) {
                    if (npp.c_stat[info.s] == GLP_BS)
                        npp.c_stat[info.q] = GLP_BS;
                    else if (npp.c_stat[info.s] == GLP_NL)
                        npp.c_stat[info.q] = GLP_NF;
                    else {
                        npp_error();
                        return -1;
                    }
                } else {
                    npp_error();
                    return -1;
                }
            }
            npp.c_value[info.q] -= npp.c_value[info.s];
            return 0;
        });
        info.q = q.j;
        info.s = s.j;
    }
    function npp_lbnd_col(npp, q) {
        var info;
        var i;
        var aij;
        xassert(q.lb != 0);
        xassert(q.lb != -DBL_MAX);
        xassert(q.lb < q.ub);
        info = npp_push_tse(npp, function (npp, info) {
            if (npp.sol == GLP_SOL) {
                if (npp.c_stat[info.q] == GLP_BS || npp.c_stat[info.q] == GLP_NL || npp.c_stat[info.q] == GLP_NU)
                    npp.c_stat[info.q] = npp.c_stat[info.q];
                else {
                    npp_error();
                    return 1;
                }
            }
            npp.c_value[info.q] = info.bnd + npp.c_value[info.q];
            return 0;
        });
        info.q = q.j;
        info.bnd = q.lb;
        npp.c0 += q.coef * q.lb;
        for (aij = q.ptr; aij != null; aij = aij.c_next) {
            i = aij.row;
            if (i.lb == i.ub)
                i.ub = i.lb -= aij.val * q.lb;
            else {
                if (i.lb != -DBL_MAX)
                    i.lb -= aij.val * q.lb;
                if (i.ub != +DBL_MAX)
                    i.ub -= aij.val * q.lb;
            }
        }
        if (q.ub != +DBL_MAX)
            q.ub -= q.lb;
        q.lb = 0;
    }
    function npp_ubnd_col(npp, q) {
        var info;
        var i;
        var aij;
        xassert(q.ub != +DBL_MAX);
        xassert(q.lb < q.ub);
        info = npp_push_tse(npp, function (npp, info) {
            if (npp.sol == GLP_BS) {
                if (npp.c_stat[info.q] == GLP_BS)
                    npp.c_stat[info.q] = GLP_BS;
                else if (npp.c_stat[info.q] == GLP_NL)
                    npp.c_stat[info.q] = GLP_NU;
                else if (npp.c_stat[info.q] == GLP_NU)
                    npp.c_stat[info.q] = GLP_NL;
                else {
                    npp_error();
                    return 1;
                }
            }
            npp.c_value[info.q] = info.bnd - npp.c_value[info.q];
            return 0;
        });
        info.q = q.j;
        info.bnd = q.ub;
        npp.c0 += q.coef * q.ub;
        q.coef = -q.coef;
        for (aij = q.ptr; aij != null; aij = aij.c_next) {
            i = aij.row;
            if (i.lb == i.ub)
                i.ub = i.lb -= aij.val * q.ub;
            else {
                if (i.lb != -DBL_MAX)
                    i.lb -= aij.val * q.ub;
                if (i.ub != +DBL_MAX)
                    i.ub -= aij.val * q.ub;
            }
            aij.val = -aij.val;
        }
        if (q.lb != -DBL_MAX)
            q.ub -= q.lb;
        else
            q.ub = +DBL_MAX;
        q.lb = 0;
    }
    function npp_dbnd_col(npp, q) {
        var info;
        var p;
        var s;
        xassert(q.lb == 0);
        xassert(q.ub > 0);
        xassert(q.ub != +DBL_MAX);
        s = npp_add_col(npp);
        s.is_int = q.is_int;
        s.lb = 0;
        s.ub = +DBL_MAX;
        p = npp_add_row(npp);
        p.lb = p.ub = q.ub;
        npp_add_aij(p, q, +1);
        npp_add_aij(p, s, +1);
        info = npp_push_tse(npp, function (npp, info) {
            if (npp.sol == GLP_BS) {
                if (npp.c_stat[info.q] == GLP_BS) {
                    if (npp.c_stat[info.s] == GLP_BS)
                        npp.c_stat[info.q] = GLP_BS;
                    else if (npp.c_stat[info.s] == GLP_NL)
                        npp.c_stat[info.q] = GLP_NU;
                    else {
                        npp_error();
                        return 1;
                    }
                } else if (npp.c_stat[info.q] == GLP_NL) {
                    if (npp.c_stat[info.s] == GLP_BS || npp.c_stat[info.s] == GLP_NL)
                        npp.c_stat[info.q] = GLP_NL;
                    else {
                        npp_error();
                        return 1;
                    }
                } else {
                    npp_error();
                    return 1;
                }
            }
            return 0;
        });
        info.q = q.j;
        info.s = s.j;
        q.ub = +DBL_MAX;
    }
    function npp_fixed_col(npp, q) {
        var info;
        var i;
        var aij;
        xassert(q.lb == q.ub);
        info = npp_push_tse(npp, function (npp, info) {
            if (npp.sol == GLP_SOL)
                npp.c_stat[info.q] = GLP_NS;
            npp.c_value[info.q] = info.s;
            return 0;
        });
        info.q = q.j;
        info.s = q.lb;
        npp.c0 += q.coef * q.lb;
        for (aij = q.ptr; aij != null; aij = aij.c_next) {
            i = aij.row;
            if (i.lb == i.ub)
                i.ub = i.lb -= aij.val * q.lb;
            else {
                if (i.lb != -DBL_MAX)
                    i.lb -= aij.val * q.lb;
                if (i.ub != +DBL_MAX)
                    i.ub -= aij.val * q.lb;
            }
        }
        npp_del_col(npp, q);
    }
    function npp_make_equality(npp, p) {
        var info;
        var b, eps, nint;
        xassert(p.lb != -DBL_MAX);
        xassert(p.ub != +DBL_MAX);
        xassert(p.lb < p.ub);
        eps = 1e-9 + 1e-12 * Math.abs(p.lb);
        if (p.ub - p.lb > eps)
            return 0;
        info = npp_push_tse(npp, function (npp, info) {
            if (npp.sol == GLP_SOL) {
                if (npp.r_stat[info.p] == GLP_BS)
                    npp.r_stat[info.p] = GLP_BS;
                else if (npp.r_stat[info.p] == GLP_NS) {
                    if (npp.r_pi[info.p] >= 0)
                        npp.r_stat[info.p] = GLP_NL;
                    else
                        npp.r_stat[info.p] = GLP_NU;
                } else {
                    npp_error();
                    return 1;
                }
            }
            return 0;
        });
        info.p = p.i;
        b = 0.5 * (p.ub + p.lb);
        nint = Math.floor(b + 0.5);
        if (Math.abs(b - nint) <= eps)
            b = nint;
        p.lb = p.ub = b;
        return 1;
    }
    function npp_make_fixed(npp, q) {
        var info;
        var aij;
        var lfe;
        var s, eps, nint;
        xassert(q.lb != -DBL_MAX);
        xassert(q.ub != +DBL_MAX);
        xassert(q.lb < q.ub);
        eps = 1e-9 + 1e-12 * Math.abs(q.lb);
        if (q.ub - q.lb > eps)
            return 0;
        info = npp_push_tse(npp, function (npp, info) {
            var lfe;
            var lambda;
            if (npp.sol == GLP_SOL) {
                if (npp.c_stat[info.q] == GLP_BS)
                    npp.c_stat[info.q] = GLP_BS;
                else if (npp.c_stat[info.q] == GLP_NS) {
                    lambda = info.c;
                    for (lfe = info.ptr; lfe != null; lfe = lfe.next)
                        lambda -= lfe.val * npp.r_pi[lfe.ref];
                    if (lambda >= 0)
                        npp.c_stat[info.q] = GLP_NL;
                    else
                        npp.c_stat[info.q] = GLP_NU;
                } else {
                    npp_error();
                    return 1;
                }
            }
            return 0;
        });
        info.q = q.j;
        info.c = q.coef;
        info.ptr = null;
        if (npp.sol == GLP_SOL) {
            for (aij = q.ptr; aij != null; aij = aij.c_next) {
                lfe = {};
                lfe.ref = aij.row.i;
                lfe.val = aij.val;
                lfe.next = info.ptr;
                info.ptr = lfe;
            }
        }
        s = 0.5 * (q.ub + q.lb);
        nint = Math.floor(s + 0.5);
        if (Math.abs(s - nint) <= eps)
            s = nint;
        q.lb = q.ub = s;
        return 1;
    }
    function npp_empty_row(npp, p) {
        var eps = 0.001;
        xassert(p.ptr == null);
        if (p.lb > +eps || p.ub < -eps)
            return 1;
        p.lb = -DBL_MAX;
        p.ub = +DBL_MAX;
        npp_free_row(npp, p);
        return 0;
    }
    function npp_empty_col(npp, q) {
        var info;
        var eps = 0.001;
        xassert(q.ptr == null);
        if (q.coef > +eps && q.lb == -DBL_MAX)
            return 1;
        if (q.coef < -eps && q.ub == +DBL_MAX)
            return 1;
        info = npp_push_tse(npp, function (npp, info) {
            if (npp.sol == GLP_SOL)
                npp.c_stat[info.q] = info.stat;
            return 0;
        });
        info.q = q.j;
        function lo() {
            info.stat = GLP_NL;
            q.ub = q.lb;
        }
        function up() {
            info.stat = GLP_NU;
            q.lb = q.ub;
        }
        if (q.lb == -DBL_MAX && q.ub == +DBL_MAX) {
            info.stat = GLP_NF;
            q.lb = q.ub = 0;
        } else if (q.ub == +DBL_MAX)
            lo();
        else if (q.lb == -DBL_MAX)
            up();
        else if (q.lb != q.ub) {
            if (q.coef >= +DBL_EPSILON)
                lo();
            else if (q.coef <= -DBL_EPSILON)
                up();
            else if (Math.abs(q.lb) <= Math.abs(q.ub))
                lo();
            else
                up();
        } else {
            info.stat = GLP_NS;
        }
        npp_fixed_col(npp, q);
        return 0;
    }
    function npp_implied_value(npp, q, s) {
        var eps, nint;
        xassert(npp == npp);
        xassert(q.lb < q.ub);
        if (q.is_int) {
            nint = Math.floor(s + 0.5);
            if (Math.abs(s - nint) <= 0.00001)
                s = nint;
            else
                return 2;
        }
        if (q.lb != -DBL_MAX) {
            eps = q.is_int ? 0.00001 : 0.00001 + 1e-8 * Math.abs(q.lb);
            if (s < q.lb - eps)
                return 1;
            if (s < q.lb + 0.001 * eps) {
                q.ub = q.lb;
                return 0;
            }
        }
        if (q.ub != +DBL_MAX) {
            eps = q.is_int ? 0.00001 : 0.00001 + 1e-8 * Math.abs(q.ub);
            if (s > q.ub + eps)
                return 1;
            if (s > q.ub - 0.001 * eps) {
                q.lb = q.ub;
                return 0;
            }
        }
        q.lb = q.ub = s;
        return 0;
    }
    function npp_eq_singlet(npp, p) {
        var info;
        var q;
        var aij;
        var lfe;
        var ret;
        var s;
        xassert(p.lb == p.ub);
        xassert(p.ptr != null && p.ptr.r_next == null);
        aij = p.ptr;
        q = aij.col;
        s = p.lb / aij.val;
        ret = npp_implied_value(npp, q, s);
        xassert(0 <= ret && ret <= 2);
        if (ret != 0)
            return ret;
        info = npp_push_tse(npp, function (npp, info) {
            var lfe;
            var temp;
            if (npp.sol == GLP_SOL) {
                if (npp.c_stat[info.q] != GLP_NS) {
                    npp_error();
                    return 1;
                }
                npp.r_stat[info.p] = GLP_NS;
                npp.c_stat[info.q] = GLP_BS;
            }
            if (npp.sol != GLP_MIP) {
                temp = info.c;
                for (lfe = info.ptr; lfe != null; lfe = lfe.next)
                    temp -= lfe.val * npp.r_pi[lfe.ref];
                npp.r_pi[info.p] = temp / info.apq;
            }
            return 0;
        });
        info.p = p.i;
        info.q = q.j;
        info.apq = aij.val;
        info.c = q.coef;
        info.ptr = null;
        if (npp.sol != GLP_MIP) {
            for (aij = q.ptr; aij != null; aij = aij.c_next) {
                if (aij.row == p)
                    continue;
                lfe = {};
                lfe.ref = aij.row.i;
                lfe.val = aij.val;
                lfe.next = info.ptr;
                info.ptr = lfe;
            }
        }
        npp_del_row(npp, p);
        return 0;
    }
    function npp_implied_lower(npp, q, l) {
        var ret;
        var eps, nint;
        xassert(npp == npp);
        xassert(q.lb < q.ub);
        xassert(l != -DBL_MAX);
        if (q.is_int) {
            nint = Math.floor(l + 0.5);
            if (Math.abs(l - nint) <= 0.00001)
                l = nint;
            else
                l = Math.ceil(l);
        }
        if (q.lb != -DBL_MAX) {
            eps = q.is_int ? 0.001 : 0.001 + 0.000001 * Math.abs(q.lb);
            if (l < q.lb + eps) {
                ret = 0;
                return ret;
            }
        }
        if (q.ub != +DBL_MAX) {
            eps = q.is_int ? 0.00001 : 0.00001 + 1e-8 * Math.abs(q.ub);
            if (l > q.ub + eps) {
                ret = 4;
                return ret;
            }
            if (l > q.ub - 0.001 * eps) {
                q.lb = q.ub;
                ret = 3;
                return ret;
            }
        }
        if (q.lb == -DBL_MAX)
            ret = 2;
        else if (q.is_int && l > q.lb + 0.5)
            ret = 2;
        else if (l > q.lb + 0.3 * (1 + Math.abs(q.lb)))
            ret = 2;
        else
            ret = 1;
        q.lb = l;
        return ret;
    }
    function npp_implied_upper(npp, q, u) {
        var ret;
        var eps, nint;
        xassert(npp == npp);
        xassert(q.lb < q.ub);
        xassert(u != +DBL_MAX);
        if (q.is_int) {
            nint = Math.floor(u + 0.5);
            if (Math.abs(u - nint) <= 0.00001)
                u = nint;
            else
                u = Math.floor(u);
        }
        if (q.ub != +DBL_MAX) {
            eps = q.is_int ? 0.001 : 0.001 + 0.000001 * Math.abs(q.ub);
            if (u > q.ub - eps) {
                ret = 0;
                return ret;
            }
        }
        if (q.lb != -DBL_MAX) {
            eps = q.is_int ? 0.00001 : 0.00001 + 1e-8 * Math.abs(q.lb);
            if (u < q.lb - eps) {
                ret = 4;
                return ret;
            }
            if (u < q.lb + 0.001 * eps) {
                q.ub = q.lb;
                ret = 3;
                return ret;
            }
        }
        if (q.ub == +DBL_MAX)
            ret = 2;
        else if (q.is_int && u < q.ub - 0.5)
            ret = 2;
        else if (u < q.ub - 0.3 * (1 + Math.abs(q.ub)))
            ret = 2;
        else
            ret = 1;
        q.ub = u;
        return ret;
    }
    function npp_ineq_singlet(npp, p) {
        var info;
        var q;
        var apq, aij;
        var lfe;
        var lb_changed, ub_changed;
        var ll, uu;
        xassert(p.lb != -DBL_MAX || p.ub != +DBL_MAX);
        xassert(p.lb < p.ub);
        xassert(p.ptr != null && p.ptr.r_next == null);
        apq = p.ptr;
        q = apq.col;
        xassert(q.lb < q.ub);
        if (apq.val > 0) {
            ll = p.lb == -DBL_MAX ? -DBL_MAX : p.lb / apq.val;
            uu = p.ub == +DBL_MAX ? +DBL_MAX : p.ub / apq.val;
        } else {
            ll = p.ub == +DBL_MAX ? -DBL_MAX : p.ub / apq.val;
            uu = p.lb == -DBL_MAX ? +DBL_MAX : p.lb / apq.val;
        }
        if (ll == -DBL_MAX)
            lb_changed = 0;
        else {
            lb_changed = npp_implied_lower(npp, q, ll);
            xassert(0 <= lb_changed && lb_changed <= 4);
            if (lb_changed == 4)
                return 4;
        }
        if (uu == +DBL_MAX)
            ub_changed = 0;
        else if (lb_changed == 3) {
            ub_changed = 0;
        } else {
            ub_changed = npp_implied_upper(npp, q, uu);
            xassert(0 <= ub_changed && ub_changed <= 4);
            if (ub_changed == 4)
                return 4;
        }
        if (!lb_changed && !ub_changed) {
            p.lb = -DBL_MAX;
            p.ub = +DBL_MAX;
            npp_free_row(npp, p);
            return 0;
        }
        info = npp_push_tse(npp, function (npp, info) {
            var lfe;
            var lambda;
            if (npp.sol == GLP_MIP)
                return 0;
            lambda = info.c;
            for (lfe = info.ptr; lfe != null; lfe = lfe.next)
                lambda -= lfe.val * npp.r_pi[lfe.ref];
            if (npp.sol == GLP_SOL) {
                function nl() {
                    if (info.lb_changed) {
                        npp.r_stat[info.p] = info.apq > 0 ? GLP_NL : GLP_NU;
                        npp.c_stat[info.q] = GLP_BS;
                        npp.r_pi[info.p] = lambda / info.apq;
                    } else {
                        npp.r_stat[info.p] = GLP_BS;
                        npp.r_pi[info.p] = 0;
                    }
                    return 0;
                }
                function nu() {
                    if (info.ub_changed) {
                        npp.r_stat[info.p] = info.apq > 0 ? GLP_NU : GLP_NL;
                        npp.c_stat[info.q] = GLP_BS;
                        npp.r_pi[info.p] = lambda / info.apq;
                    } else {
                        npp.r_stat[info.p] = GLP_BS;
                        npp.r_pi[info.p] = 0;
                    }
                    return 0;
                }
                if (npp.c_stat[info.q] == GLP_BS) {
                    npp.r_stat[info.p] = GLP_BS;
                    npp.r_pi[info.p] = 0;
                } else if (npp.c_stat[info.q] == GLP_NL)
                    nl();
                else if (npp.c_stat[info.q] == GLP_NU)
                    nu();
                else if (npp.c_stat[info.q] == GLP_NS) {
                    if (lambda > +1e-7) {
                        if (info.apq > 0 && info.lb != -DBL_MAX || info.apq < 0 && info.ub != +DBL_MAX || !info.lb_changed) {
                            npp.c_stat[info.q] = GLP_NL;
                            return nl();
                        }
                    }
                    if (lambda < -1e-7) {
                        if (info.apq > 0 && info.ub != +DBL_MAX || info.apq < 0 && info.lb != -DBL_MAX || !info.ub_changed) {
                            npp.c_stat[info.q] = GLP_NU;
                            return nu();
                        }
                    }
                    if (info.lb != -DBL_MAX && info.ub == +DBL_MAX) {
                        npp.r_stat[info.p] = GLP_NL;
                    } else if (info.lb == -DBL_MAX && info.ub != +DBL_MAX) {
                        npp.r_stat[info.p] = GLP_NU;
                    } else if (info.lb != -DBL_MAX && info.ub != +DBL_MAX) {
                        if (info.apq * npp.c_value[info.q] <= 0.5 * (info.lb + info.ub))
                            npp.r_stat[info.p] = GLP_NL;
                        else
                            npp.r_stat[info.p] = GLP_NU;
                    } else {
                        npp_error();
                        return 1;
                    }
                    npp.c_stat[info.q] = GLP_BS;
                    npp.r_pi[info.p] = lambda / info.apq;
                } else {
                    npp_error();
                    return 1;
                }
            }
            if (npp.sol == GLP_IPT) {
                if (lambda > +DBL_EPSILON && info.lb_changed || lambda < -DBL_EPSILON && info.ub_changed) {
                    npp.r_pi[info.p] = lambda / info.apq;
                } else {
                    npp.r_pi[info.p] = 0;
                }
            }
            return 0;
        });
        info.p = p.i;
        info.q = q.j;
        info.apq = apq.val;
        info.c = q.coef;
        info.lb = p.lb;
        info.ub = p.ub;
        info.lb_changed = lb_changed;
        info.ub_changed = ub_changed;
        info.ptr = null;
        if (npp.sol != GLP_MIP) {
            for (aij = q.ptr; aij != null; aij = aij.c_next) {
                if (aij == apq)
                    continue;
                lfe = {};
                lfe.ref = aij.row.i;
                lfe.val = aij.val;
                lfe.next = info.ptr;
                info.ptr = lfe;
            }
        }
        npp_del_row(npp, p);
        return lb_changed >= ub_changed ? lb_changed : ub_changed;
    }
    function npp_implied_slack(npp, q) {
        var info;
        var p;
        var aij;
        var lfe;
        xassert(!q.is_int);
        xassert(q.lb < q.ub);
        xassert(q.ptr != null && q.ptr.c_next == null);
        aij = q.ptr;
        p = aij.row;
        xassert(p.lb == p.ub);
        info = npp_push_tse(npp, function (npp, info) {
            var temp;
            var lfe;
            if (npp.sol == GLP_SOL) {
                if (npp.r_stat[info.p] == GLP_BS || npp.r_stat[info.p] == GLP_NF)
                    npp.c_stat[info.q] = npp.r_stat[info.p];
                else if (npp.r_stat[info.p] == GLP_NL)
                    npp.c_stat[info.q] = info.apq > 0 ? GLP_NU : GLP_NL;
                else if (npp.r_stat[info.p] == GLP_NU)
                    npp.c_stat[info.q] = info.apq > 0 ? GLP_NL : GLP_NU;
                else {
                    npp_error();
                    return 1;
                }
                npp.r_stat[info.p] = GLP_NS;
            }
            if (npp.sol != GLP_MIP) {
                npp.r_pi[info.p] += info.c / info.apq;
            }
            temp = info.b;
            for (lfe = info.ptr; lfe != null; lfe = lfe.next)
                temp -= lfe.val * npp.c_value[lfe.ref];
            npp.c_value[info.q] = temp / info.apq;
            return 0;
        });
        info.p = p.i;
        info.q = q.j;
        info.apq = aij.val;
        info.b = p.lb;
        info.c = q.coef;
        info.ptr = null;
        for (aij = p.ptr; aij != null; aij = aij.r_next) {
            if (aij.col == q)
                continue;
            lfe = {};
            lfe.ref = aij.col.j;
            lfe.val = aij.val;
            lfe.next = info.ptr;
            info.ptr = lfe;
            aij.col.coef -= info.c * (aij.val / info.apq);
        }
        npp.c0 += info.c * (info.b / info.apq);
        if (info.apq > 0) {
            p.lb = q.ub == +DBL_MAX ? -DBL_MAX : info.b - info.apq * q.ub;
            p.ub = q.lb == -DBL_MAX ? +DBL_MAX : info.b - info.apq * q.lb;
        } else {
            p.lb = q.lb == -DBL_MAX ? -DBL_MAX : info.b - info.apq * q.lb;
            p.ub = q.ub == +DBL_MAX ? +DBL_MAX : info.b - info.apq * q.ub;
        }
        npp_del_col(npp, q);
    }
    function npp_implied_free(npp, q) {
        var info;
        var p;
        var apq, aij;
        var alfa, beta, l, u, pi, eps;
        xassert(q.lb < q.ub);
        xassert(q.ptr != null && q.ptr.c_next == null);
        apq = q.ptr;
        p = apq.row;
        xassert(p.lb != -DBL_MAX || p.ub != +DBL_MAX);
        xassert(p.lb < p.ub);
        alfa = p.lb;
        if (alfa != -DBL_MAX) {
            for (aij = p.ptr; aij != null; aij = aij.r_next) {
                if (aij == apq)
                    continue;
                if (aij.val > 0) {
                    if (aij.col.ub == +DBL_MAX) {
                        alfa = -DBL_MAX;
                        break;
                    }
                    alfa -= aij.val * aij.col.ub;
                } else {
                    if (aij.col.lb == -DBL_MAX) {
                        alfa = -DBL_MAX;
                        break;
                    }
                    alfa -= aij.val * aij.col.lb;
                }
            }
        }
        beta = p.ub;
        if (beta != +DBL_MAX) {
            for (aij = p.ptr; aij != null; aij = aij.r_next) {
                if (aij == apq)
                    continue;
                if (aij.val > 0) {
                    if (aij.col.lb == -DBL_MAX) {
                        beta = +DBL_MAX;
                        break;
                    }
                    beta -= aij.val * aij.col.lb;
                } else {
                    if (aij.col.ub == +DBL_MAX) {
                        beta = +DBL_MAX;
                        break;
                    }
                    beta -= aij.val * aij.col.ub;
                }
            }
        }
        if (apq.val > 0)
            l = alfa == -DBL_MAX ? -DBL_MAX : alfa / apq.val;
        else
            l = beta == +DBL_MAX ? -DBL_MAX : beta / apq.val;
        if (apq.val > 0)
            u = beta == +DBL_MAX ? +DBL_MAX : beta / apq.val;
        else
            u = alfa == -DBL_MAX ? +DBL_MAX : alfa / apq.val;
        if (q.lb != -DBL_MAX) {
            eps = 1e-9 + 1e-12 * Math.abs(q.lb);
            if (l < q.lb - eps)
                return 1;
        }
        if (q.ub != +DBL_MAX) {
            eps = 1e-9 + 1e-12 * Math.abs(q.ub);
            if (u > q.ub + eps)
                return 1;
        }
        q.lb = -DBL_MAX;
        q.ub = +DBL_MAX;
        info = npp_push_tse(npp, function (npp, info) {
            if (npp.sol == GLP_SOL) {
                if (npp.r_stat[info.p] == GLP_BS)
                    npp.r_stat[info.p] = GLP_BS;
                else if (npp.r_stat[info.p] == GLP_NS) {
                    xassert(info.stat == GLP_NL || info.stat == GLP_NU);
                    npp.r_stat[info.p] = info.stat;
                } else {
                    npp_error();
                    return 1;
                }
            }
            return 0;
        });
        info.p = p.i;
        info.stat = -1;
        pi = q.coef / apq.val;
        function nl() {
            info.stat = GLP_NL;
            p.ub = p.lb;
        }
        function nu() {
            info.stat = GLP_NU;
            p.lb = p.ub;
        }
        if (pi > +DBL_EPSILON) {
            if (p.lb != -DBL_MAX)
                nl();
            else {
                if (pi > +0.00001)
                    return 2;
                xassert(p.ub != +DBL_MAX);
                nu();
            }
        } else if (pi < -DBL_EPSILON) {
            if (p.ub != +DBL_MAX)
                nu();
            else {
                if (pi < -0.00001)
                    return 2;
                xassert(p.lb != -DBL_MAX);
                nl();
            }
        } else {
            if (p.ub == +DBL_MAX) {
                xassert(p.lb != -DBL_MAX);
                nl();
            } else if (p.lb == -DBL_MAX) {
                xassert(p.ub != +DBL_MAX);
                nu();
            } else {
                if (Math.abs(p.lb) <= Math.abs(p.ub))
                    nl();
                else
                    nu();
            }
        }
        return 0;
    }
    function npp_eq_doublet(npp, p) {
        var info;
        var i;
        var q, r;
        var apq, apr, aiq, air, next;
        var lfe;
        var gamma;
        xassert(p.lb == p.ub);
        xassert(p.ptr != null && p.ptr.r_next != null && p.ptr.r_next.r_next == null);
        {
            var a1, a2;
            a1 = p.ptr;
            a2 = a1.r_next;
            if (Math.abs(a2.val) < 0.001 * Math.abs(a1.val)) {
                apq = a1;
                apr = a2;
            } else if (Math.abs(a1.val) < 0.001 * Math.abs(a2.val)) {
                apq = a2;
                apr = a1;
            } else {
                if (npp_col_nnz(a1.col) <= npp_col_nnz(a2.col)) {
                    apq = a1;
                    apr = a2;
                } else {
                    apq = a2;
                    apr = a1;
                }
            }
        }
        q = apq.col;
        r = apr.col;
        info = npp_push_tse(npp, function (npp, info) {
            var lfe;
            var gamma, temp;
            if (npp.sol == GLP_SOL) {
                if (npp.r_stat[info.p] != GLP_NS) {
                    npp_error();
                    return 1;
                }
            }
            if (npp.sol != GLP_MIP) {
                temp = npp.r_pi[info.p];
                for (lfe = info.ptr; lfe != null; lfe = lfe.next) {
                    gamma = lfe.val / info.apq;
                    temp -= gamma * npp.r_pi[lfe.ref];
                }
                npp.r_pi[info.p] = temp;
            }
            return 0;
        });
        info.p = p.i;
        info.apq = apq.val;
        info.ptr = null;
        for (aiq = q.ptr; aiq != null; aiq = next) {
            next = aiq.c_next;
            if (aiq == apq)
                continue;
            i = aiq.row;
            if (npp.sol != GLP_MIP) {
                lfe = {};
                lfe.ref = i.i;
                lfe.val = aiq.val;
                lfe.next = info.ptr;
                info.ptr = lfe;
            }
            for (air = i.ptr; air != null; air = air.r_next)
                if (air.col == r)
                    break;
            if (air == null)
                air = npp_add_aij(i, r, 0);
            gamma = aiq.val / apq.val;
            npp_del_aij(aiq);
            air.val -= gamma * apr.val;
            if (Math.abs(air.val) <= 1e-10)
                npp_del_aij(air);
            if (i.lb == i.ub)
                i.lb = i.ub = i.lb - gamma * p.lb;
            else {
                if (i.lb != -DBL_MAX)
                    i.lb -= gamma * p.lb;
                if (i.ub != +DBL_MAX)
                    i.ub -= gamma * p.lb;
            }
        }
        return q;
    }
    function npp_forcing_row(npp, p, at) {
        var info;
        var col = null;
        var j;
        var apj, aij;
        var lfe;
        var big;
        xassert(at == 0 || at == 1);
        big = 1;
        for (apj = p.ptr; apj != null; apj = apj.r_next)
            if (big < Math.abs(apj.val))
                big = Math.abs(apj.val);
        for (apj = p.ptr; apj != null; apj = apj.r_next)
            if (Math.abs(apj.val) < 1e-7 * big)
                return 1;
        info = npp_push_tse(npp, function (npp, info) {
            var col, piv;
            var lfe;
            var d, big, temp;
            if (npp.sol == GLP_MIP)
                return 0;
            if (npp.sol == GLP_SOL) {
                if (npp.r_stat[info.p] != GLP_BS) {
                    npp_error();
                    return 1;
                }
                for (col = info.ptr; col != null; col = col.next) {
                    if (npp.c_stat[col.j] != GLP_NS) {
                        npp_error();
                        return 1;
                    }
                    npp.c_stat[col.j] = col.stat;
                }
            }
            for (col = info.ptr; col != null; col = col.next) {
                d = col.c;
                for (lfe = col.ptr; lfe != null; lfe = lfe.next)
                    d -= lfe.val * npp.r_pi[lfe.ref];
                col.c = d;
            }
            piv = null;
            big = 0;
            for (col = info.ptr; col != null; col = col.next) {
                d = col.c;
                temp = Math.abs(d / col.a);
                if (col.stat == GLP_NL) {
                    if (d < 0 && big < temp) {
                        piv = col;
                        big = temp;
                    }
                } else if (col.stat == GLP_NU) {
                    if (d > 0 && big < temp) {
                        piv = col;
                        big = temp;
                    }
                } else {
                    npp_error();
                    return 1;
                }
            }
            if (piv != null) {
                if (npp.sol == GLP_SOL) {
                    npp.r_stat[info.p] = info.stat;
                    npp.c_stat[piv.j] = GLP_BS;
                }
                npp.r_pi[info.p] = piv.c / piv.a;
            }
            return 0;
        });
        info.p = p.i;
        if (p.lb == p.ub) {
            info.stat = GLP_NS;
        } else if (at == 0) {
            info.stat = GLP_NL;
            xassert(p.lb != -DBL_MAX);
        } else {
            info.stat = GLP_NU;
            xassert(p.ub != +DBL_MAX);
        }
        info.ptr = null;
        for (apj = p.ptr; apj != null; apj = apj.r_next) {
            j = apj.col;
            xassert(j.lb < j.ub);
            if (npp.sol != GLP_MIP) {
                col = {};
                col.j = j.j;
                col.stat = -1;
                col.a = apj.val;
                col.c = j.coef;
                col.ptr = null;
                col.next = info.ptr;
                info.ptr = col;
            }
            if (at == 0 && apj.val < 0 || at != 0 && apj.val > 0) {
                if (npp.sol != GLP_MIP)
                    col.stat = GLP_NL;
                xassert(j.lb != -DBL_MAX);
                j.ub = j.lb;
            } else {
                if (npp.sol != GLP_MIP)
                    col.stat = GLP_NU;
                xassert(j.ub != +DBL_MAX);
                j.lb = j.ub;
            }
            if (npp.sol != GLP_MIP) {
                for (aij = j.ptr; aij != null; aij = aij.c_next) {
                    if (aij == apj)
                        continue;
                    lfe = {};
                    lfe.ref = aij.row.i;
                    lfe.val = aij.val;
                    lfe.next = col.ptr;
                    col.ptr = lfe;
                }
            }
        }
        p.lb = -DBL_MAX;
        p.ub = +DBL_MAX;
        return 0;
    }
    function npp_analyze_row(npp, p) {
        var aij;
        var ret = 0;
        var l, u, eps;
        xassert(npp == npp);
        l = 0;
        for (aij = p.ptr; aij != null; aij = aij.r_next) {
            if (aij.val > 0) {
                if (aij.col.lb == -DBL_MAX) {
                    l = -DBL_MAX;
                    break;
                }
                l += aij.val * aij.col.lb;
            } else {
                if (aij.col.ub == +DBL_MAX) {
                    l = -DBL_MAX;
                    break;
                }
                l += aij.val * aij.col.ub;
            }
        }
        u = 0;
        for (aij = p.ptr; aij != null; aij = aij.r_next) {
            if (aij.val > 0) {
                if (aij.col.ub == +DBL_MAX) {
                    u = +DBL_MAX;
                    break;
                }
                u += aij.val * aij.col.ub;
            } else {
                if (aij.col.lb == -DBL_MAX) {
                    u = +DBL_MAX;
                    break;
                }
                u += aij.val * aij.col.lb;
            }
        }
        if (p.lb != -DBL_MAX) {
            eps = 0.001 + 0.000001 * Math.abs(p.lb);
            if (p.lb - eps > u) {
                ret = 51;
                return ret;
            }
        }
        if (p.ub != +DBL_MAX) {
            eps = 0.001 + 0.000001 * Math.abs(p.ub);
            if (p.ub + eps < l) {
                ret = 51;
                return ret;
            }
        }
        if (p.lb != -DBL_MAX) {
            eps = 1e-9 + 1e-12 * Math.abs(p.lb);
            if (p.lb - eps > l) {
                if (p.lb + eps <= u)
                    ret |= 1;
                else
                    ret |= 2;
            }
        }
        if (p.ub != +DBL_MAX) {
            eps = 1e-9 + 1e-12 * Math.abs(p.ub);
            if (p.ub + eps < u) {
                if (p.ub - eps >= l)
                    ret |= 16;
                else
                    ret |= 32;
            }
        }
        return ret;
    }
    function npp_inactive_bound(npp, p, which) {
        var info;
        if (npp.sol == GLP_SOL) {
            info = npp_push_tse(npp, function (npp, info) {
                if (npp.sol != GLP_SOL) {
                    npp_error();
                    return 1;
                }
                if (npp.r_stat[info.p] == GLP_BS)
                    npp.r_stat[info.p] = GLP_BS;
                else
                    npp.r_stat[info.p] = info.stat;
                return 0;
            });
            info.p = p.i;
            if (p.ub == +DBL_MAX)
                info.stat = GLP_NL;
            else if (p.lb == -DBL_MAX)
                info.stat = GLP_NU;
            else if (p.lb != p.ub)
                info.stat = which == 0 ? GLP_NU : GLP_NL;
            else
                info.stat = GLP_NS;
        }
        if (which == 0) {
            xassert(p.lb != -DBL_MAX);
            p.lb = -DBL_MAX;
        } else if (which == 1) {
            xassert(p.ub != +DBL_MAX);
            p.ub = +DBL_MAX;
        } else
            xassert(which != which);
    }
    function npp_implied_bounds(npp, p) {
        var apj, apk;
        var big, eps, temp;
        var skip = false;
        xassert(npp == npp);
        big = 1;
        for (apj = p.ptr; apj != null; apj = apj.r_next) {
            apj.col.ll.ll = -DBL_MAX;
            apj.col.uu.uu = +DBL_MAX;
            if (big < Math.abs(apj.val))
                big = Math.abs(apj.val);
        }
        eps = 0.000001 * big;
        if (p.lb != -DBL_MAX) {
            apk = null;
            for (apj = p.ptr; apj != null; apj = apj.r_next) {
                if (apj.val > 0 && apj.col.ub == +DBL_MAX || apj.val < 0 && apj.col.lb == -DBL_MAX) {
                    if (apk == null)
                        apk = apj;
                    else {
                        skip = true;
                        break;
                    }
                }
            }
            if (!skip) {
                temp = p.lb;
                for (apj = p.ptr; apj != null; apj = apj.r_next) {
                    if (apj == apk) {
                    } else if (apj.val > 0)
                        temp -= apj.val * apj.col.ub;
                    else
                        temp -= apj.val * apj.col.lb;
                }
                if (apk == null) {
                    for (apj = p.ptr; apj != null; apj = apj.r_next) {
                        if (apj.val >= +eps) {
                            apj.col.ll.ll = apj.col.ub + temp / apj.val;
                        } else if (apj.val <= -eps) {
                            apj.col.uu.uu = apj.col.lb + temp / apj.val;
                        }
                    }
                } else {
                    if (apk.val >= +eps) {
                        apk.col.ll.ll = temp / apk.val;
                    } else if (apk.val <= -eps) {
                        apk.col.uu.uu = temp / apk.val;
                    }
                }
            }
        }
        skip = false;
        if (p.ub != +DBL_MAX) {
            apk = null;
            for (apj = p.ptr; apj != null; apj = apj.r_next) {
                if (apj.val > 0 && apj.col.lb == -DBL_MAX || apj.val < 0 && apj.col.ub == +DBL_MAX) {
                    if (apk == null)
                        apk = apj;
                    else {
                        skip = true;
                        break;
                    }
                }
            }
            if (!skip) {
                temp = p.ub;
                for (apj = p.ptr; apj != null; apj = apj.r_next) {
                    if (apj == apk) {
                    } else if (apj.val > 0)
                        temp -= apj.val * apj.col.lb;
                    else
                        temp -= apj.val * apj.col.ub;
                }
                if (apk == null) {
                    for (apj = p.ptr; apj != null; apj = apj.r_next) {
                        if (apj.val >= +eps) {
                            apj.col.uu.uu = apj.col.lb + temp / apj.val;
                        } else if (apj.val <= -eps) {
                            apj.col.ll.ll = apj.col.ub + temp / apj.val;
                        }
                    }
                } else {
                    if (apk.val >= +eps) {
                        apk.col.uu.uu = temp / apk.val;
                    } else if (apk.val <= -eps) {
                        apk.col.ll.ll = temp / apk.val;
                    }
                }
            }
        }
    }
    function npp_binarize_prob(npp) {
        var info;
        var row;
        var col, bin;
        var aij;
        var u, n, k, temp, nfails, nvars, nbins, nrows;
        nfails = nvars = nbins = nrows = 0;
        for (col = npp.c_tail; col != null; col = col.prev) {
            if (!col.is_int)
                continue;
            if (col.lb == col.ub)
                continue;
            if (col.lb == 0 && col.ub == 1)
                continue;
            if (col.lb < -1000000 || col.ub > +1000000 || col.ub - col.lb > 4095) {
                nfails++;
                continue;
            }
            nvars++;
            if (col.lb != 0)
                npp_lbnd_col(npp, col);
            xassert(col.lb == 0);
            u = col.ub | 0;
            xassert(col.ub == u);
            if (u == 1)
                continue;
            n = 2;
            temp = 4;
            while (u >= temp) {
                n++;
                temp += temp;
            }
            nbins += n;
            info = npp_push_tse(npp, function (npp, info) {
                var k, temp;
                var sum = npp.c_value[info.q];
                for (k = 1, temp = 2; k < info.n; k++, temp += temp)
                    sum += temp * npp.c_value[info.j + (k - 1)];
                npp.c_value[info.q] = sum;
                return 0;
            });
            info.q = col.j;
            info.j = 0;
            info.n = n;
            if (u < temp - 1) {
                row = npp_add_row(npp);
                nrows++;
                row.lb = -DBL_MAX;
                row.ub = u;
            } else
                row = null;
            col.ub = 1;
            if (row != null)
                npp_add_aij(row, col, 1);
            for (k = 1, temp = 2; k < n; k++, temp += temp) {
                bin = npp_add_col(npp);
                bin.is_int = 1;
                bin.lb = 0;
                bin.ub = 1;
                bin.coef = temp * col.coef;
                if (info.j == 0)
                    info.j = bin.j;
                else
                    xassert(info.j + (k - 1) == bin.j);
                for (aij = col.ptr; aij != null; aij = aij.c_next)
                    npp_add_aij(aij.row, bin, temp * aij.val);
            }
        }
        if (nvars > 0)
            xprintf(nvars + ' integer variable(s) were replaced by ' + nbins + ' binary ones');
        if (nrows > 0)
            xprintf(nrows + ' row(s) were added due to binarization');
        if (nfails > 0)
            xprintf('Binarization failed for ' + nfails + ' integer variable(s)');
        return nfails;
    }
    function copy_form(row, s) {
        var aij;
        var ptr, e;
        ptr = null;
        for (aij = row.ptr; aij != null; aij = aij.r_next) {
            e = {};
            e.aj = s * aij.val;
            e.xj = aij.col;
            e.next = ptr;
            ptr = e;
        }
        return ptr;
    }
    function npp_is_packing(npp, row) {
        var col;
        var aij;
        var b;
        xassert(npp == npp);
        if (!(row.lb == -DBL_MAX && row.ub != +DBL_MAX))
            return 0;
        b = 1;
        for (aij = row.ptr; aij != null; aij = aij.r_next) {
            col = aij.col;
            if (!(col.is_int && col.lb == 0 && col.ub == 1))
                return 0;
            if (aij.val == +1) {
            } else if (aij.val == -1)
                b--;
            else
                return 0;
        }
        if (row.ub != b)
            return 0;
        return 1;
    }
    function hidden_packing(npp, ptr, b, callback) {
        var e, ej, ek;
        var neg;
        var eps;
        xassert(npp == npp);
        for (e = ptr; e != null; e = e.next) {
            xassert(e.aj != 0);
            xassert(e.xj.is_int);
            xassert(e.xj.lb == 0 && e.xj.ub == 1);
        }
        neg = 0;
        for (e = ptr; e != null; e = e.next) {
            if (e.aj == +1) {
            } else if (e.aj == -1)
                neg++;
            else
                break;
        }
        if (e == null) {
            if (b == 1 - neg) {
                return 1;
            }
        }
        for (e = ptr; e != null; e = e.next)
            if (e.aj < 0)
                b -= e.aj;
        for (e = ptr; e != null; e = e.next)
            if (Math.abs(e.aj) > b)
                return 0;
        ej = null;
        for (e = ptr; e != null; e = e.next)
            if (ej == null || Math.abs(ej.aj) > Math.abs(e.aj))
                ej = e;
        xassert(ej != null);
        ek = null;
        for (e = ptr; e != null; e = e.next)
            if (e != ej)
                if (ek == null || Math.abs(ek.aj) > Math.abs(e.aj))
                    ek = e;
        xassert(ek != null);
        eps = 0.001 + 0.000001 * Math.abs(b);
        if (Math.abs(ej.aj) + Math.abs(ek.aj) <= b + eps)
            return 0;
        b = 1;
        for (e = ptr; e != null; e = e.next) {
            if (e.aj > 0)
                e.aj = +1;
            else {
                e.aj = -1;
                b -= 1;
            }
        }
        callback(b);
        return 2;
    }
    function npp_hidden_packing(npp, row) {
        var copy;
        var aij;
        var ptr, e;
        var kase, ret, count = 0;
        var b;
        xassert(row.lb < row.ub);
        for (kase = 0; kase <= 1; kase++) {
            if (kase == 0) {
                if (row.ub == +DBL_MAX)
                    continue;
                ptr = copy_form(row, +1);
                b = +row.ub;
            } else {
                if (row.lb == -DBL_MAX)
                    continue;
                ptr = copy_form(row, -1);
                b = -row.lb;
            }
            ret = hidden_packing(npp, ptr, b, function (v) {
                b = v;
            });
            xassert(0 <= ret && ret <= 2);
            if (kase == 1 && ret == 1 || ret == 2) {
                count++;
                if (GLP_DEBUG) {
                    xprintf('Original constraint:');
                    for (aij = row.ptr; aij != null; aij = aij.r_next)
                        xprintf(' ' + aij.val + ' x' + aij.col.j);
                    if (row.lb != -DBL_MAX)
                        xprintf(', >= ' + row.lb);
                    if (row.ub != +DBL_MAX)
                        xprintf(', <= ' + row.ub);
                    xprintf('');
                    xprintf('Equivalent packing inequality:');
                    for (e = ptr; e != null; e = e.next)
                        xprintf(' ' + (e.aj > 0 ? '+' : '-') + 'x' + e.xj.j);
                    xprintf(', <= ' + b + '');
                }
                if (row.lb == -DBL_MAX || row.ub == +DBL_MAX) {
                    copy = null;
                } else {
                    copy = npp_add_row(npp);
                    if (kase == 0) {
                        copy.lb = row.lb;
                        copy.ub = +DBL_MAX;
                    } else {
                        copy.lb = -DBL_MAX;
                        copy.ub = row.ub;
                    }
                    for (aij = row.ptr; aij != null; aij = aij.r_next)
                        npp_add_aij(copy, aij.col, aij.val);
                }
                npp_erase_row(row);
                row.lb = -DBL_MAX;
                row.ub = b;
                for (e = ptr; e != null; e = e.next)
                    npp_add_aij(row, e.xj, e.aj);
                if (copy != null)
                    row = copy;
            }
        }
        return count;
    }
    function npp_implied_packing(row, which, var_, set_) {
        var ptr, e, i, k;
        var len = 0;
        var b, eps;
        if (which == 0) {
            ptr = copy_form(row, -1);
            xassert(row.lb != -DBL_MAX);
            b = -row.lb;
        } else if (which == 1) {
            ptr = copy_form(row, +1);
            xassert(row.ub != +DBL_MAX);
            b = +row.ub;
        }
        for (e = ptr; e != null; e = e.next) {
            if (!(e.xj.is_int && e.xj.lb == 0 && e.xj.ub == 1)) {
                if (e.aj > 0) {
                    if (e.xj.lb == -DBL_MAX)
                        return len;
                    b -= e.aj * e.xj.lb;
                } else {
                    if (e.xj.ub == +DBL_MAX)
                        return len;
                    b -= e.aj * e.xj.ub;
                }
                e.aj = 0;
            }
        }
        for (e = ptr; e != null; e = e.next)
            if (e.aj < 0)
                b -= e.aj;
        if (b < 0.001)
            return len;
        eps = 0.001 + 0.000001 * b;
        i = k = null;
        for (e = ptr; e != null; e = e.next) {
            if (Math.abs(e.aj) > 0.5 * (b + eps)) {
                var_[++len] = e.xj;
                set_[len] = e.aj > 0 ? 0 : 1;
                if (i == null || Math.abs(i.aj) > Math.abs(e.aj))
                    i = e;
            } else if (Math.abs(e.aj) >= 0.001) {
                if (k == null || Math.abs(k.aj) < Math.abs(e.aj))
                    k = e;
            }
        }
        if (i != null && k != null && Math.abs(i.aj) + Math.abs(k.aj) > b + eps) {
            var_[++len] = k.xj;
            set_[len] = k.aj > 0 ? 0 : 1;
        }
        if (len < 2)
            len = 0;
        return len;
    }
    function npp_is_covering(npp, row) {
        var col;
        var aij;
        var b;
        xassert(npp == npp);
        if (!(row.lb != -DBL_MAX && row.ub == +DBL_MAX))
            return 0;
        b = 1;
        for (aij = row.ptr; aij != null; aij = aij.r_next) {
            col = aij.col;
            if (!(col.is_int && col.lb == 0 && col.ub == 1))
                return 0;
            if (aij.val == +1) {
            } else if (aij.val == -1)
                b--;
            else
                return 0;
        }
        if (row.lb != b)
            return 0;
        return 1;
    }
    function hidden_covering(npp, ptr, b, callback) {
        var e;
        var neg;
        var eps;
        xassert(npp == npp);
        for (e = ptr; e != null; e = e.next) {
            xassert(e.aj != 0);
            xassert(e.xj.is_int);
            xassert(e.xj.lb == 0 && e.xj.ub == 1);
        }
        neg = 0;
        for (e = ptr; e != null; e = e.next) {
            if (e.aj == +1) {
            } else if (e.aj == -1)
                neg++;
            else
                break;
        }
        if (e == null) {
            if (b == 1 - neg) {
                return 1;
            }
        }
        for (e = ptr; e != null; e = e.next)
            if (e.aj < 0)
                b -= e.aj;
        if (b < 0.001)
            return 0;
        eps = 1e-9 + 1e-12 * Math.abs(b);
        for (e = ptr; e != null; e = e.next)
            if (Math.abs(e.aj) < b - eps)
                return 0;
        b = 1;
        for (e = ptr; e != null; e = e.next) {
            if (e.aj > 0)
                e.aj = +1;
            else {
                e.aj = -1;
                b -= 1;
            }
        }
        callback(b);
        return 2;
    }
    function npp_hidden_covering(npp, row) {
        var copy;
        var aij;
        var ptr, e;
        var kase, ret, count = 0;
        var b;
        xassert(row.lb < row.ub);
        for (kase = 0; kase <= 1; kase++) {
            if (kase == 0) {
                if (row.lb == -DBL_MAX)
                    continue;
                ptr = copy_form(row, +1);
                b = +row.lb;
            } else {
                if (row.ub == +DBL_MAX)
                    continue;
                ptr = copy_form(row, -1);
                b = -row.ub;
            }
            ret = hidden_covering(npp, ptr, b, function (v) {
                b = v;
            });
            xassert(0 <= ret && ret <= 2);
            if (kase == 1 && ret == 1 || ret == 2) {
                count++;
                if (GLP_DEBUG) {
                    xprintf('Original constraint:');
                    for (aij = row.ptr; aij != null; aij = aij.r_next)
                        xprintf(' ' + aij.val + ' x' + aij.col.j);
                    if (row.lb != -DBL_MAX)
                        xprintf(', >= ' + row.lb);
                    if (row.ub != +DBL_MAX)
                        xprintf(', <= ' + row.ub);
                    xprintf('');
                    xprintf('Equivalent covering inequality:');
                    for (e = ptr; e != null; e = e.next)
                        xprintf(' ' + (e.aj > 0 ? '+' : '-') + 'x' + e.xj.j);
                    xprintf(', >= ' + b + '');
                }
                if (row.lb == -DBL_MAX || row.ub == +DBL_MAX) {
                    copy = null;
                } else {
                    copy = npp_add_row(npp);
                    if (kase == 0) {
                        copy.lb = -DBL_MAX;
                        copy.ub = row.ub;
                    } else {
                        copy.lb = row.lb;
                        copy.ub = +DBL_MAX;
                    }
                    for (aij = row.ptr; aij != null; aij = aij.r_next)
                        npp_add_aij(copy, aij.col, aij.val);
                }
                npp_erase_row(row);
                row.lb = b;
                row.ub = +DBL_MAX;
                for (e = ptr; e != null; e = e.next)
                    npp_add_aij(row, e.xj, e.aj);
                if (copy != null)
                    row = copy;
            }
        }
        return count;
    }
    function npp_is_partitioning(npp, row) {
        var col;
        var aij;
        var b;
        xassert(npp == npp);
        if (row.lb != row.ub)
            return 0;
        b = 1;
        for (aij = row.ptr; aij != null; aij = aij.r_next) {
            col = aij.col;
            if (!(col.is_int && col.lb == 0 && col.ub == 1))
                return 0;
            if (aij.val == +1) {
            } else if (aij.val == -1)
                b--;
            else
                return 0;
        }
        if (row.lb != b)
            return 0;
        return 1;
    }
    function reduce_ineq_coef(npp, ptr, b, callback) {
        var e;
        var count = 0;
        var h, inf_t, new_a;
        xassert(npp == npp);
        h = 0;
        for (e = ptr; e != null; e = e.next) {
            if (e.aj > 0) {
                if (e.xj.lb == -DBL_MAX)
                    return count;
                h += e.aj * e.xj.lb;
            } else {
                if (e.xj.ub == +DBL_MAX)
                    return count;
                h += e.aj * e.xj.ub;
            }
        }
        for (e = ptr; e != null; e = e.next) {
            if (!(e.xj.is_int && e.xj.lb == 0 && e.xj.ub == 1))
                continue;
            if (e.aj > 0) {
                inf_t = h;
                if (b - e.aj < inf_t && inf_t < b) {
                    new_a = b - inf_t;
                    if (new_a >= +0.001 && e.aj - new_a >= 0.01 * (1 + e.aj)) {
                        if (GLP_DEBUG) {
                            xprintf('+');
                        }
                        e.aj = new_a;
                        count++;
                    }
                }
            } else {
                inf_t = h - e.aj;
                if (b < inf_t && inf_t < b - e.aj) {
                    new_a = e.aj + (inf_t - b);
                    if (new_a <= -0.001 && new_a - e.aj >= 0.01 * (1 - e.aj)) {
                        if (GLP_DEBUG) {
                            xprintf('-');
                        }
                        e.aj = new_a;
                        h += inf_t - b;
                        b = inf_t;
                        count++;
                    }
                }
            }
        }
        callback(b);
        return count;
    }
    function npp_reduce_ineq_coef(npp, row) {
        var copy;
        var aij;
        var ptr, e;
        var kase, count = new Array(2);
        var b;
        xassert(row.lb < row.ub);
        count[0] = count[1] = 0;
        for (kase = 0; kase <= 1; kase++) {
            if (kase == 0) {
                if (row.lb == -DBL_MAX)
                    continue;
                if (GLP_DEBUG) {
                    xprintf('L');
                }
                ptr = copy_form(row, +1);
                b = +row.lb;
            } else {
                if (row.ub == +DBL_MAX)
                    continue;
                if (GLP_DEBUG) {
                    xprintf('U');
                }
                ptr = copy_form(row, -1);
                b = -row.ub;
            }
            count[kase] = reduce_ineq_coef(npp, ptr, b, function (v) {
                b = v;
            });
            if (count[kase] > 0) {
                if (row.lb == -DBL_MAX || row.ub == +DBL_MAX) {
                    copy = null;
                } else {
                    if (GLP_DEBUG) {
                        xprintf('*');
                    }
                    copy = npp_add_row(npp);
                    if (kase == 0) {
                        copy.lb = -DBL_MAX;
                        copy.ub = row.ub;
                    } else {
                        copy.lb = row.lb;
                        copy.ub = +DBL_MAX;
                    }
                    for (aij = row.ptr; aij != null; aij = aij.r_next)
                        npp_add_aij(copy, aij.col, aij.val);
                }
                npp_erase_row(row);
                row.lb = b;
                row.ub = +DBL_MAX;
                for (e = ptr; e != null; e = e.next)
                    npp_add_aij(row, e.xj, e.aj);
                if (copy != null)
                    row = copy;
            }
        }
        return count[0] + count[1];
    }
    function npp_clean_prob(npp) {
        var row, next_row;
        var col, next_col;
        var ret;
        xassert(npp == npp);
        for (row = npp.r_head; row != null; row = next_row) {
            next_row = row.next;
            if (row.lb == -DBL_MAX && row.ub == +DBL_MAX) {
                if (GLP_DEBUG) {
                    xprintf('1');
                }
                npp_free_row(npp, row);
            }
        }
        for (row = npp.r_head; row != null; row = next_row) {
            next_row = row.next;
            if (row.lb != -DBL_MAX && row.ub != +DBL_MAX && row.lb < row.ub) {
                ret = npp_make_equality(npp, row);
                if (ret == 0) {
                } else if (ret == 1) {
                    if (GLP_DEBUG) {
                        xprintf('2');
                    }
                } else
                    xassert(ret != ret);
            }
        }
        for (col = npp.c_head; col != null; col = next_col) {
            next_col = col.next;
            if (col.lb == col.ub) {
                if (GLP_DEBUG) {
                    xprintf('3');
                }
                npp_fixed_col(npp, col);
            }
        }
        for (col = npp.c_head; col != null; col = next_col) {
            next_col = col.next;
            if (col.lb != -DBL_MAX && col.ub != +DBL_MAX && col.lb < col.ub) {
                ret = npp_make_fixed(npp, col);
                if (ret == 0) {
                } else if (ret == 1) {
                    if (GLP_DEBUG) {
                        xprintf('4');
                    }
                    npp_fixed_col(npp, col);
                }
            }
        }
    }
    function npp_process_row(npp, row, hard) {
        var col;
        var aij, next_aij, aaa;
        var ret;
        xassert(!(row.lb == -DBL_MAX && row.ub == +DBL_MAX));
        if (row.ptr == null) {
            ret = npp_empty_row(npp, row);
            if (ret == 0) {
                if (GLP_DEBUG) {
                    xprintf('A');
                }
                return 0;
            } else if (ret == 1) {
                return GLP_ENOPFS;
            } else
                xassert(ret != ret);
        }
        if (row.ptr.r_next == null) {
            col = row.ptr.col;
            if (row.lb == row.ub) {
                ret = npp_eq_singlet(npp, row);
                if (ret == 0) {
                    if (GLP_DEBUG) {
                        xprintf('B');
                    }
                    for (aij = col.ptr; aij != null; aij = aij.c_next)
                        npp_activate_row(npp, aij.row);
                    npp_fixed_col(npp, col);
                    return 0;
                } else if (ret == 1 || ret == 2) {
                    return GLP_ENOPFS;
                } else
                    xassert(ret != ret);
            } else {
                ret = npp_ineq_singlet(npp, row);
                if (0 <= ret && ret <= 3) {
                    if (GLP_DEBUG) {
                        xprintf('C');
                    }
                    npp_activate_col(npp, col);
                    if (ret >= 2) {
                        for (aij = col.ptr; aij != null; aij = aij.c_next)
                            npp_activate_row(npp, aij.row);
                    }
                    if (ret == 3) {
                        if (GLP_DEBUG) {
                            xprintf('D');
                        }
                        npp_fixed_col(npp, col);
                    }
                    return 0;
                } else if (ret == 4) {
                    return GLP_ENOPFS;
                } else
                    xassert(ret != ret);
            }
        }
        ret = npp_analyze_row(npp, row);
        xassert(0 <= ret && ret <= 255);
        if (ret == 51) {
            return GLP_ENOPFS;
        }
        if ((ret & 15) == 0) {
            if (row.lb != -DBL_MAX) {
                if (GLP_DEBUG) {
                    xprintf('F');
                }
                npp_inactive_bound(npp, row, 0);
            }
        } else if ((ret & 15) == 1) {
        } else if ((ret & 15) == 2) {
            if (GLP_DEBUG) {
                xprintf('G');
            }
            if (npp_forcing_row(npp, row, 0) == 0)
                return fixup();
        } else
            xassert(ret != ret);
        if ((ret & 240) == 0) {
            if (row.ub != +DBL_MAX) {
                if (GLP_DEBUG) {
                    xprintf('I');
                }
                npp_inactive_bound(npp, row, 1);
            }
        } else if ((ret & 240) == 16) {
        } else if ((ret & 240) == 32) {
            if (GLP_DEBUG) {
                xprintf('J');
            }
            if (npp_forcing_row(npp, row, 1) == 0)
                return fixup();
        } else
            xassert(ret != ret);
        if (row.lb == -DBL_MAX && row.ub == +DBL_MAX) {
            if (GLP_DEBUG) {
                xprintf('K');
            }
            for (aij = row.ptr; aij != null; aij = aij.r_next)
                npp_activate_col(npp, aij.col);
            npp_free_row(npp, row);
            return 0;
        }
        if (npp.sol == GLP_MIP && hard) {
            if (npp_improve_bounds(npp, row, 1) < 0)
                return GLP_ENOPFS;
        }
        function fixup() {
            for (aij = row.ptr; aij != null; aij = next_aij) {
                if (GLP_DEBUG) {
                    xprintf('H');
                }
                col = aij.col;
                next_aij = aij.r_next;
                for (aaa = col.ptr; aaa != null; aaa = aaa.c_next)
                    npp_activate_row(npp, aaa.row);
                npp_fixed_col(npp, col);
            }
            npp_free_row(npp, row);
            return 0;
        }
        return 0;
    }
    function npp_improve_bounds(npp, row, flag) {
        var col;
        var aij, next_aij, aaa;
        var kase, ret, count = 0;
        var lb, ub;
        xassert(npp.sol == GLP_MIP);
        xassert(!(row.lb == -DBL_MAX && row.ub == +DBL_MAX));
        npp_implied_bounds(npp, row);
        for (aij = row.ptr; aij != null; aij = next_aij) {
            col = aij.col;
            next_aij = aij.r_next;
            for (kase = 0; kase <= 1; kase++) {
                lb = col.lb;
                ub = col.ub;
                if (kase == 0) {
                    if (col.ll.ll == -DBL_MAX)
                        continue;
                    ret = npp_implied_lower(npp, col, col.ll.ll);
                } else {
                    if (col.uu.uu == +DBL_MAX)
                        continue;
                    ret = npp_implied_upper(npp, col, col.uu.uu);
                }
                if (ret == 0 || ret == 1) {
                    col.lb = lb;
                    col.ub = ub;
                } else if (ret == 2 || ret == 3) {
                    if (GLP_DEBUG) {
                        xprintf('L');
                    }
                    count++;
                    if (flag) {
                        for (aaa = col.ptr; aaa != null; aaa = aaa.c_next) {
                            if (aaa.row != row)
                                npp_activate_row(npp, aaa.row);
                        }
                    }
                    if (ret == 3) {
                        if (GLP_DEBUG) {
                            xprintf('M');
                        }
                        npp_fixed_col(npp, col);
                        break;
                    }
                } else if (ret == 4) {
                    return -1;
                } else
                    xassert(ret != ret);
            }
        }
        return count;
    }
    function npp_process_col(npp, col) {
        var row;
        var aij;
        var ret;
        xassert(col.lb < col.ub);
        if (col.ptr == null) {
            ret = npp_empty_col(npp, col);
            if (ret == 0) {
                if (GLP_DEBUG) {
                    xprintf('N');
                }
                return 0;
            } else if (ret == 1) {
                return GLP_ENODFS;
            } else
                xassert(ret != ret);
        }
        if (col.ptr.c_next == null) {
            row = col.ptr.row;
            function slack() {
                if (GLP_DEBUG) {
                    xprintf('O');
                }
                npp_implied_slack(npp, col);
                if (row.lb == -DBL_MAX && row.ub == +DBL_MAX) {
                    if (GLP_DEBUG) {
                        xprintf('P');
                    }
                    for (aij = row.ptr; aij != null; aij = aij.r_next)
                        npp_activate_col(npp, aij.col);
                    npp_free_row(npp, row);
                } else {
                    npp_activate_row(npp, row);
                }
                return 0;
            }
            if (row.lb == row.ub) {
                if (!col.is_int)
                    return slack();
            } else {
                if (!col.is_int) {
                    ret = npp_implied_free(npp, col);
                    if (ret == 0) {
                        if (GLP_DEBUG) {
                            xprintf('Q');
                        }
                        return slack();
                    } else if (ret == 1) {
                    } else if (ret == 2) {
                        return GLP_ENODFS;
                    }
                }
            }
        }
        return 0;
    }
    function npp_process_prob(npp, hard) {
        var row;
        var col;
        var processing, ret;
        npp_clean_prob(npp);
        for (row = npp.r_head; row != null; row = row.next)
            row.temp = 1;
        for (col = npp.c_head; col != null; col = col.next)
            col.temp = 1;
        processing = 1;
        while (processing) {
            processing = 0;
            for (;;) {
                row = npp.r_head;
                if (row == null || !row.temp)
                    break;
                npp_deactivate_row(npp, row);
                ret = npp_process_row(npp, row, hard);
                if (ret != 0)
                    return done();
                processing = 1;
            }
            for (;;) {
                col = npp.c_head;
                if (col == null || !col.temp)
                    break;
                npp_deactivate_col(npp, col);
                ret = npp_process_col(npp, col);
                if (ret != 0)
                    return done();
                processing = 1;
            }
        }
        if (npp.sol == GLP_MIP && !hard) {
            for (row = npp.r_head; row != null; row = row.next) {
                if (npp_improve_bounds(npp, row, 0) < 0) {
                    ret = GLP_ENOPFS;
                    return done();
                }
            }
        }
        ret = 0;
        function done() {
            xassert(ret == 0 || ret == GLP_ENOPFS || ret == GLP_ENODFS);
            if (GLP_DEBUG) {
                xprintf('');
            }
            return ret;
        }
        return done();
    }
    function npp_simplex(npp, parm) {
        xassert(npp.sol == GLP_SOL);
        xassert(parm == parm);
        return npp_process_prob(npp, 0);
    }
    function npp_integer(npp, parm) {
        var row, prev_row;
        var col;
        var aij;
        var count, ret;
        xassert(npp.sol == GLP_MIP);
        xassert(parm == parm);
        ret = npp_process_prob(npp, 1);
        if (ret != 0)
            return ret;
        if (parm.binarize)
            npp_binarize_prob(npp);
        count = 0;
        for (row = npp.r_tail; row != null; row = prev_row) {
            prev_row = row.prev;
            if (row.lb == -DBL_MAX && row.ub == +DBL_MAX)
                continue;
            if (row.lb == row.ub)
                continue;
            if (row.ptr == null || row.ptr.r_next == null)
                continue;
            for (aij = row.ptr; aij != null; aij = aij.r_next) {
                col = aij.col;
                if (!(col.is_int && col.lb == 0 && col.ub == 1))
                    break;
            }
            if (aij != null)
                continue;
            count += npp_hidden_packing(npp, row);
        }
        if (count > 0)
            xprintf(count + ' hidden packing inequaliti(es) were detected');
        count = 0;
        for (row = npp.r_tail; row != null; row = prev_row) {
            prev_row = row.prev;
            if (row.lb == -DBL_MAX && row.ub == +DBL_MAX)
                continue;
            if (row.lb == row.ub)
                continue;
            if (row.ptr == null || row.ptr.r_next == null || row.ptr.r_next.r_next == null)
                continue;
            for (aij = row.ptr; aij != null; aij = aij.r_next) {
                col = aij.col;
                if (!(col.is_int && col.lb == 0 && col.ub == 1))
                    break;
            }
            if (aij != null)
                continue;
            count += npp_hidden_covering(npp, row);
        }
        if (count > 0)
            xprintf(count + ' hidden covering inequaliti(es) were detected');
        count = 0;
        for (row = npp.r_tail; row != null; row = prev_row) {
            prev_row = row.prev;
            if (row.lb == row.ub)
                continue;
            count += npp_reduce_ineq_coef(npp, row);
        }
        if (count > 0)
            xprintf(count + ' constraint coefficient(s) were reduced');
        ret = 0;
        return ret;
    }
    function mod_diff(x, y) {
        return x - y & 2147483647;
    }
    function flip_cycle(rand) {
        var ii, jj;
        for (ii = 1, jj = 32; jj <= 55; ii++, jj++)
            rand.A[ii] = mod_diff(rand.A[ii], rand.A[jj]);
        for (jj = 1; ii <= 55; ii++, jj++)
            rand.A[ii] = mod_diff(rand.A[ii], rand.A[jj]);
        rand.fptr = 54;
        return rand.A[55];
    }
    function rng_create_rand() {
        var rand = {};
        var i;
        rand.A = new Array(56);
        rand.A[0] = -1;
        for (i = 1; i <= 55; i++)
            rand.A[i] = 0;
        rand.fptr = 0;
        rng_init_rand(rand, 1);
        return rand;
    }
    function rng_init_rand(rand, seed) {
        var i;
        var prev = seed, next = 1;
        seed = prev = mod_diff(prev, 0);
        rand.A[55] = prev;
        for (i = 21; i; i = (i + 21) % 55) {
            rand.A[i] = next;
            next = mod_diff(prev, next);
            if (seed & 1)
                seed = 1073741824 + (seed >> 1);
            else
                seed >>= 1;
            next = mod_diff(next, seed);
            prev = rand.A[i];
        }
        flip_cycle(rand);
        flip_cycle(rand);
        flip_cycle(rand);
        flip_cycle(rand);
        flip_cycle(rand);
    }
    function rng_next_rand(rand) {
        return rand.A[rand.fptr] >= 0 ? rand.A[rand.fptr--] : flip_cycle(rand);
    }
    function rng_unif_rand(rand, m) {
        var two_to_the_31 = 2147483648;
        var t = two_to_the_31 - two_to_the_31 % m;
        var r;
        xassert(m > 0);
        do {
            r = rng_next_rand(rand);
        } while (t <= r);
        return r % m;
    }
    function rng_unif_01(rand) {
        var x = rng_next_rand(rand) / 2147483647;
        xassert(0 <= x && x <= 1);
        return x;
    }
    function rng_uniform(rand, a, b) {
        if (a >= b)
            xerror('rng_uniform: a = ' + a + ', b = ' + b + '; invalid range');
        var x = rng_unif_01(rand);
        x = a * (1 - x) + b * x;
        xassert(a <= x && x <= b);
        return x;
    }
    var SCF_TBG = 1, SCF_TGR = 2;
    var SCF_ESING = 1, SCF_ELIMIT = 2;
    var _GLPSCF_DEBUG = 0;
    var SCF_EPS = 1e-10;
    function scf_create_it(n_max) {
        if (_GLPSCF_DEBUG) {
            xprintf('scf_create_it: warning: debug mode enabled');
        }
        if (!(1 <= n_max && n_max <= 32767))
            xerror('scf_create_it: n_max = ' + n_max + '; invalid parameter');
        var scf = {};
        scf.n_max = n_max;
        scf.n = 0;
        scf.f = new Float64Array(1 + n_max * n_max);
        scf.u = new Float64Array(1 + n_max * (n_max + 1) / 2);
        scf.p = new Int32Array(1 + n_max);
        scf.t_opt = SCF_TBG;
        scf.rank = 0;
        if (_GLPSCF_DEBUG)
            scf.c = new Float64Array(1 + n_max * n_max);
        else
            scf.c = null;
        scf.w = new Float64Array(1 + n_max);
        return scf;
    }
    function f_loc(scf, i, j) {
        var n_max = scf.n_max;
        var n = scf.n;
        xassert(1 <= i && i <= n);
        xassert(1 <= j && j <= n);
        return (i - 1) * n_max + j;
    }
    function u_loc(scf, i, j) {
        var n_max = scf.n_max;
        var n = scf.n;
        xassert(1 <= i && i <= n);
        xassert(i <= j && j <= n);
        return (i - 1) * n_max + j - i * (i - 1) / 2;
    }
    function bg_transform(scf, k, un) {
        var n = scf.n;
        var f = scf.f;
        var u = scf.u;
        var j, k1, kj, kk, n1, nj;
        var t;
        xassert(1 <= k && k <= n);
        for (; k < n; k++) {
            kk = u_loc(scf, k, k);
            k1 = f_loc(scf, k, 1);
            n1 = f_loc(scf, n, 1);
            if (Math.abs(u[kk]) < Math.abs(un[k])) {
                for (j = k, kj = kk; j <= n; j++, kj++) {
                    t = u[kj];
                    u[kj] = un[j];
                    un[j] = t;
                }
                for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++) {
                    t = f[kj];
                    f[kj] = f[nj];
                    f[nj] = t;
                }
            }
            if (Math.abs(u[kk]) < SCF_EPS)
                u[kk] = un[k] = 0;
            if (un[k] == 0)
                continue;
            t = un[k] / u[kk];
            for (j = k + 1, kj = kk + 1; j <= n; j++, kj++)
                un[j] -= t * u[kj];
            for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++)
                f[nj] -= t * f[kj];
        }
        if (Math.abs(un[n]) < SCF_EPS)
            un[n] = 0;
        u[u_loc(scf, n, n)] = un[n];
    }
    function givens(a, b, callback) {
        var t, c, s;
        if (b == 0) {
            c = 1;
            s = 0;
        } else if (Math.abs(a) <= Math.abs(b)) {
            t = -a / b;
            s = 1 / Math.sqrt(1 + t * t);
            c = s * t;
        } else {
            t = -b / a;
            c = 1 / Math.sqrt(1 + t * t);
            s = c * t;
        }
        callback(c, s);
    }
    function gr_transform(scf, k, un) {
        var n = scf.n;
        var f = scf.f;
        var u = scf.u;
        var j, k1, kj, kk, n1, nj;
        xassert(1 <= k && k <= n);
        for (; k < n; k++) {
            kk = u_loc(scf, k, k);
            k1 = f_loc(scf, k, 1);
            n1 = f_loc(scf, n, 1);
            if (Math.abs(u[kk]) < SCF_EPS && Math.abs(un[k]) < SCF_EPS)
                u[kk] = un[k] = 0;
            if (un[k] == 0)
                continue;
            givens(u[kk], un[k], function (c, s) {
                for (j = k, kj = kk; j <= n; j++, kj++) {
                    var ukj = u[kj], unj = un[j];
                    u[kj] = c * ukj - s * unj;
                    un[j] = s * ukj + c * unj;
                }
                for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++) {
                    var fkj = f[kj], fnj = f[nj];
                    f[kj] = c * fkj - s * fnj;
                    f[nj] = s * fkj + c * fnj;
                }
            });
        }
        if (Math.abs(un[n]) < SCF_EPS)
            un[n] = 0;
        u[u_loc(scf, n, n)] = un[n];
    }
    function transform(scf, k, un) {
        switch (scf.t_opt) {
        case SCF_TBG:
            bg_transform(scf, k, un);
            break;
        case SCF_TGR:
            gr_transform(scf, k, un);
            break;
        default:
            xassert(scf != scf);
        }
    }
    function estimate_rank(scf) {
        var n_max = scf.n_max;
        var n = scf.n;
        var u = scf.u;
        var i, ii, inc, rank = 0;
        for (i = 1, ii = u_loc(scf, i, i), inc = n_max; i <= n; i++, ii += inc, inc--)
            if (u[ii] != 0)
                rank++;
        return rank;
    }
    if (_GLPSCF_DEBUG) {
        function check_error(scf, func) {
            var n = scf.n;
            var f = scf.f;
            var u = scf.u;
            var p = scf.p;
            var c = scf.c;
            var i, j, k;
            var d, dmax = 0, s, t;
            xassert(c != null);
            for (i = 1; i <= n; i++) {
                for (j = 1; j <= n; j++) {
                    s = 0;
                    for (k = 1; k <= n; k++)
                        s += f[f_loc(scf, i, k)] * c[f_loc(scf, k, j)];
                    k = p[j];
                    t = i <= k ? u[u_loc(scf, i, k)] : 0;
                    d = Math.abs(s - t) / (1 + Math.abs(t));
                    if (dmax < d)
                        dmax = d;
                }
            }
            if (dmax > 1e-8)
                xprintf(func + ': dmax = ' + dmax + '; relative error too large');
        }
    }
    function scf_update_exp(scf, x, idx, y, idy, z) {
        var n_max = scf.n_max;
        var n = scf.n;
        var f = scf.f;
        var u = scf.u;
        var p = scf.p;
        if (_GLPSCF_DEBUG) {
            var c = scf.c;
        }
        var un = scf.w;
        var i, ij, in_, j, k, nj, ret = 0;
        var t;
        if (n == n_max) {
            ret = SCF_ELIMIT;
            return ret;
        }
        scf.n = ++n;
        for (i = 1, in_ = f_loc(scf, i, n); i < n; i++, in_ += n_max)
            f[in_] = 0;
        for (j = 1, nj = f_loc(scf, n, j); j < n; j++, nj++)
            f[nj] = 0;
        f[f_loc(scf, n, n)] = 1;
        for (i = 1; i < n; i++) {
            t = 0;
            for (j = 1, ij = f_loc(scf, i, 1); j < n; j++, ij++)
                t += f[ij] * x[j + idx];
            u[u_loc(scf, i, n)] = t;
        }
        for (j = 1; j < n; j++)
            un[j] = y[p[j] + idy];
        un[n] = z;
        p[n] = n;
        if (_GLPSCF_DEBUG) {
            for (i = 1, in_ = f_loc(scf, i, n); i < n; i++, in_ += n_max)
                c[in_] = x[i + idx];
            for (j = 1, nj = f_loc(scf, n, j); j < n; j++, nj++)
                c[nj] = y[j + idy];
            c[f_loc(scf, n, n)] = z;
        }
        for (k = 1; k < n; k++)
            if (un[k] != 0)
                break;
        transform(scf, k, un);
        scf.rank = estimate_rank(scf);
        if (scf.rank != n)
            ret = SCF_ESING;
        if (_GLPSCF_DEBUG) {
            check_error(scf, 'scf_update_exp');
        }
        return ret;
    }
    function solve(scf, x, idx) {
        var n = scf.n;
        var f = scf.f;
        var u = scf.u;
        var p = scf.p;
        var y = scf.w;
        var i, j, ij;
        var t;
        for (i = 1; i <= n; i++) {
            t = 0;
            for (j = 1, ij = f_loc(scf, i, 1); j <= n; j++, ij++)
                t += f[ij] * x[j + idx];
            y[i] = t;
        }
        for (i = n; i >= 1; i--) {
            t = y[i];
            for (j = n, ij = u_loc(scf, i, n); j > i; j--, ij--)
                t -= u[ij] * y[j];
            y[i] = t / u[ij];
        }
        for (i = 1; i <= n; i++)
            x[p[i] + idx] = y[i];
    }
    function tsolve(scf, x, idx) {
        var n = scf.n;
        var f = scf.f;
        var u = scf.u;
        var p = scf.p;
        var y = scf.w;
        var i, j, ij;
        var t;
        for (i = 1; i <= n; i++)
            y[i] = x[p[i] + idx];
        for (i = 1; i <= n; i++) {
            ij = u_loc(scf, i, i);
            t = y[i] /= u[ij];
            for (j = i + 1, ij++; j <= n; j++, ij++)
                y[j] -= u[ij] * t;
        }
        for (j = 1; j <= n; j++)
            x[j + idx] = 0;
        for (i = 1; i <= n; i++) {
            t = y[i];
            for (j = 1, ij = f_loc(scf, i, 1); j <= n; j++, ij++)
                x[j + idx] += f[ij] * t;
        }
    }
    function scf_solve_it(scf, tr, x, idx) {
        if (scf.rank < scf.n)
            xerror('scf_solve_it: singular matrix');
        if (!tr)
            solve(scf, x, idx);
        else
            tsolve(scf, x, idx);
    }
    function scf_reset_it(scf) {
        scf.n = scf.rank = 0;
    }
    var glp_scale_prob = exports['glp_scale_prob'] = function (lp, flags) {
        function min_row_aij(lp, i, scaled) {
            var aij;
            var min_aij, temp;
            xassert(1 <= i && i <= lp.m);
            min_aij = 1;
            for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next) {
                temp = Math.abs(aij.val);
                if (scaled)
                    temp *= aij.row.rii * aij.col.sjj;
                if (aij.r_prev == null || min_aij > temp)
                    min_aij = temp;
            }
            return min_aij;
        }
        function max_row_aij(lp, i, scaled) {
            var aij;
            var max_aij, temp;
            xassert(1 <= i && i <= lp.m);
            max_aij = 1;
            for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next) {
                temp = Math.abs(aij.val);
                if (scaled)
                    temp *= aij.row.rii * aij.col.sjj;
                if (aij.r_prev == null || max_aij < temp)
                    max_aij = temp;
            }
            return max_aij;
        }
        function min_col_aij(lp, j, scaled) {
            var aij;
            var min_aij, temp;
            xassert(1 <= j && j <= lp.n);
            min_aij = 1;
            for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next) {
                temp = Math.abs(aij.val);
                if (scaled)
                    temp *= aij.row.rii * aij.col.sjj;
                if (aij.c_prev == null || min_aij > temp)
                    min_aij = temp;
            }
            return min_aij;
        }
        function max_col_aij(lp, j, scaled) {
            var aij;
            var max_aij, temp;
            xassert(1 <= j && j <= lp.n);
            max_aij = 1;
            for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next) {
                temp = Math.abs(aij.val);
                if (scaled)
                    temp *= aij.row.rii * aij.col.sjj;
                if (aij.c_prev == null || max_aij < temp)
                    max_aij = temp;
            }
            return max_aij;
        }
        function min_mat_aij(lp, scaled) {
            var i;
            var min_aij, temp;
            min_aij = 1;
            for (i = 1; i <= lp.m; i++) {
                temp = min_row_aij(lp, i, scaled);
                if (i == 1 || min_aij > temp)
                    min_aij = temp;
            }
            return min_aij;
        }
        function max_mat_aij(lp, scaled) {
            var i;
            var max_aij, temp;
            max_aij = 1;
            for (i = 1; i <= lp.m; i++) {
                temp = max_row_aij(lp, i, scaled);
                if (i == 1 || max_aij < temp)
                    max_aij = temp;
            }
            return max_aij;
        }
        function eq_scaling(lp, flag) {
            var i, j, pass;
            var temp;
            xassert(flag == 0 || flag == 1);
            for (pass = 0; pass <= 1; pass++) {
                if (pass == flag) {
                    for (i = 1; i <= lp.m; i++) {
                        temp = max_row_aij(lp, i, 1);
                        glp_set_rii(lp, i, glp_get_rii(lp, i) / temp);
                    }
                } else {
                    for (j = 1; j <= lp.n; j++) {
                        temp = max_col_aij(lp, j, 1);
                        glp_set_sjj(lp, j, glp_get_sjj(lp, j) / temp);
                    }
                }
            }
        }
        function gm_scaling(lp, flag) {
            var i, j, pass;
            var temp;
            xassert(flag == 0 || flag == 1);
            for (pass = 0; pass <= 1; pass++) {
                if (pass == flag) {
                    for (i = 1; i <= lp.m; i++) {
                        temp = min_row_aij(lp, i, 1) * max_row_aij(lp, i, 1);
                        glp_set_rii(lp, i, glp_get_rii(lp, i) / Math.sqrt(temp));
                    }
                } else {
                    for (j = 1; j <= lp.n; j++) {
                        temp = min_col_aij(lp, j, 1) * max_col_aij(lp, j, 1);
                        glp_set_sjj(lp, j, glp_get_sjj(lp, j) / Math.sqrt(temp));
                    }
                }
            }
        }
        function max_row_ratio(lp) {
            var i;
            var ratio, temp;
            ratio = 1;
            for (i = 1; i <= lp.m; i++) {
                temp = max_row_aij(lp, i, 1) / min_row_aij(lp, i, 1);
                if (i == 1 || ratio < temp)
                    ratio = temp;
            }
            return ratio;
        }
        function max_col_ratio(lp) {
            var j;
            var ratio, temp;
            ratio = 1;
            for (j = 1; j <= lp.n; j++) {
                temp = max_col_aij(lp, j, 1) / min_col_aij(lp, j, 1);
                if (j == 1 || ratio < temp)
                    ratio = temp;
            }
            return ratio;
        }
        function gm_iterate(lp, it_max, tau) {
            var k, flag;
            var ratio = 0, r_old;
            flag = max_row_ratio(lp) > max_col_ratio(lp);
            for (k = 1; k <= it_max; k++) {
                r_old = ratio;
                ratio = max_mat_aij(lp, 1) / min_mat_aij(lp, 1);
                if (k > 1 && ratio > tau * r_old)
                    break;
                gm_scaling(lp, flag);
            }
        }
        function scale_prob(lp, flags) {
            function fmt(a, b, c, d) {
                return a + ': min|aij| = ' + b + '  max|aij| = ' + c + '  ratio = ' + d + '';
            }
            var min_aij, max_aij, ratio;
            xprintf('Scaling...');
            glp_unscale_prob(lp);
            min_aij = min_mat_aij(lp, 1);
            max_aij = max_mat_aij(lp, 1);
            ratio = max_aij / min_aij;
            xprintf(fmt(' A', min_aij, max_aij, ratio));
            if (min_aij >= 0.1 && max_aij <= 10) {
                xprintf('Problem data seem to be well scaled');
                if (flags & GLP_SF_SKIP)
                    return;
            }
            if (flags & GLP_SF_GM) {
                gm_iterate(lp, 15, 0.9);
                min_aij = min_mat_aij(lp, 1);
                max_aij = max_mat_aij(lp, 1);
                ratio = max_aij / min_aij;
                xprintf(fmt('GM', min_aij, max_aij, ratio));
            }
            if (flags & GLP_SF_EQ) {
                eq_scaling(lp, max_row_ratio(lp) > max_col_ratio(lp));
                min_aij = min_mat_aij(lp, 1);
                max_aij = max_mat_aij(lp, 1);
                ratio = max_aij / min_aij;
                xprintf(fmt('EQ', min_aij, max_aij, ratio));
            }
            if (flags & GLP_SF_2N) {
                var i, j;
                for (i = 1; i <= lp.m; i++)
                    glp_set_rii(lp, i, round2n(glp_get_rii(lp, i)));
                for (j = 1; j <= lp.n; j++)
                    glp_set_sjj(lp, j, round2n(glp_get_sjj(lp, j)));
                min_aij = min_mat_aij(lp, 1);
                max_aij = max_mat_aij(lp, 1);
                ratio = max_aij / min_aij;
                xprintf(fmt('2N', min_aij, max_aij, ratio));
            }
        }
        if (flags & ~(GLP_SF_GM | GLP_SF_EQ | GLP_SF_2N | GLP_SF_SKIP | GLP_SF_AUTO))
            xerror('glp_scale_prob: flags = ' + flags + '; invalid scaling options');
        if (flags & GLP_SF_AUTO)
            flags = GLP_SF_GM | GLP_SF_EQ | GLP_SF_SKIP;
        scale_prob(lp, flags);
    };
    function spx_primal(lp, parm) {
        var kappa = 0.1;
        function alloc_csa(lp) {
            var m = lp.m;
            var n = lp.n;
            var nnz = lp.nnz;
            var csa = {};
            xassert(m > 0 && n > 0);
            csa.m = m;
            csa.n = n;
            csa.type = new Int8Array(1 + m + n);
            csa.lb = new Float64Array(1 + m + n);
            csa.ub = new Float64Array(1 + m + n);
            csa.coef = new Float64Array(1 + m + n);
            csa.obj = new Float64Array(1 + n);
            csa.A_ptr = new Int32Array(1 + n + 1);
            csa.A_ind = new Int32Array(1 + nnz);
            csa.A_val = new Float64Array(1 + nnz);
            csa.head = new Int32Array(1 + m + n);
            csa.stat = new Int8Array(1 + n);
            csa.N_ptr = new Int32Array(1 + m + 1);
            csa.N_len = new Int32Array(1 + m);
            csa.N_ind = null;
            csa.N_val = null;
            csa.bbar = new Float64Array(1 + m);
            csa.cbar = new Float64Array(1 + n);
            csa.refsp = new Int8Array(1 + m + n);
            csa.gamma = new Float64Array(1 + n);
            csa.tcol_ind = new Int32Array(1 + m);
            csa.tcol_vec = new Float64Array(1 + m);
            csa.trow_ind = new Int32Array(1 + n);
            csa.trow_vec = new Float64Array(1 + n);
            csa.work1 = new Float64Array(1 + m);
            csa.work2 = new Float64Array(1 + m);
            csa.work3 = new Float64Array(1 + m);
            csa.work4 = new Float64Array(1 + m);
            return csa;
        }
        function init_csa(csa, lp) {
            var m = csa.m;
            var n = csa.n;
            var type = csa.type;
            var lb = csa.lb;
            var ub = csa.ub;
            var coef = csa.coef;
            var obj = csa.obj;
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var head = csa.head;
            var stat = csa.stat;
            var refsp = csa.refsp;
            var gamma = csa.gamma;
            var i, j, k, loc;
            var cmax;
            var row, col;
            for (i = 1; i <= m; i++) {
                row = lp.row[i];
                type[i] = row.type;
                lb[i] = row.lb * row.rii;
                ub[i] = row.ub * row.rii;
                coef[i] = 0;
            }
            for (j = 1; j <= n; j++) {
                col = lp.col[j];
                type[m + j] = col.type;
                lb[m + j] = col.lb / col.sjj;
                ub[m + j] = col.ub / col.sjj;
                coef[m + j] = col.coef * col.sjj;
            }
            obj[0] = lp.c0;
            xcopyArr(obj, 1, coef, m + 1, n);
            cmax = 0;
            for (j = 1; j <= n; j++)
                if (cmax < Math.abs(obj[j]))
                    cmax = Math.abs(obj[j]);
            if (cmax == 0)
                cmax = 1;
            switch (lp.dir) {
            case GLP_MIN:
                csa.zeta = +1 / cmax;
                break;
            case GLP_MAX:
                csa.zeta = -1 / cmax;
                break;
            default:
                xassert(lp != lp);
            }
            if (Math.abs(csa.zeta) < 1)
                csa.zeta *= 1000;
            loc = 1;
            for (j = 1; j <= n; j++) {
                A_ptr[j] = loc;
                for (var aij = lp.col[j].ptr; aij != null; aij = aij.c_next) {
                    A_ind[loc] = aij.row.i;
                    A_val[loc] = aij.row.rii * aij.val * aij.col.sjj;
                    loc++;
                }
            }
            A_ptr[n + 1] = loc;
            xassert(loc == lp.nnz + 1);
            xassert(lp.valid);
            xcopyArr(head, 1, lp.head, 1, m);
            k = 0;
            for (i = 1; i <= m; i++) {
                row = lp.row[i];
                if (row.stat != GLP_BS) {
                    k++;
                    xassert(k <= n);
                    head[m + k] = i;
                    stat[k] = row.stat;
                }
            }
            for (j = 1; j <= n; j++) {
                col = lp.col[j];
                if (col.stat != GLP_BS) {
                    k++;
                    xassert(k <= n);
                    head[m + k] = m + j;
                    stat[k] = col.stat;
                }
            }
            xassert(k == n);
            csa.valid = 1;
            lp.valid = 0;
            csa.bfd = lp.bfd;
            lp.bfd = null;
            alloc_N(csa);
            build_N(csa);
            csa.phase = 0;
            csa.tm_beg = xtime();
            csa.it_beg = csa.it_cnt = lp.it_cnt;
            csa.it_dpy = -1;
            csa.refct = 0;
            xfillArr(refsp, 1, 0, m + n);
            for (j = 1; j <= n; j++)
                gamma[j] = 1;
        }
        function inv_col(csa, i, ind, val) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var head = csa.head;
            var k, len, ptr, t;
            if (GLP_DEBUG) {
                xassert(1 <= i && i <= m);
            }
            k = head[i];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            if (k <= m) {
                len = 1;
                ind[1] = k;
                val[1] = 1;
            } else {
                ptr = A_ptr[k - m];
                len = A_ptr[k - m + 1] - ptr;
                xcopyArr(ind, 1, A_ind, ptr, len);
                xcopyArr(val, 1, A_val, ptr, len);
                for (t = 1; t <= len; t++)
                    val[t] = -val[t];
            }
            return len;
        }
        function invert_B(csa) {
            var ret = bfd_factorize(csa.bfd, csa.m, null, inv_col, csa);
            csa.valid = ret == 0;
            return ret;
        }
        function update_B(csa, i, k) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var val, ret;
            if (GLP_DEBUG) {
                xassert(1 <= i && i <= m);
                xassert(1 <= k && k <= m + n);
            }
            if (k <= m) {
                var ind = new Array(1 + 1);
                val = new Array(1 + 1);
                ind[1] = k;
                val[1] = 1;
                xassert(csa.valid);
                ret = bfd_update_it(csa.bfd, i, 0, 1, ind, 0, val);
            } else {
                var A_ptr = csa.A_ptr;
                var A_ind = csa.A_ind;
                var A_val = csa.A_val;
                val = csa.work1;
                var beg, end, ptr, len;
                beg = A_ptr[k - m];
                end = A_ptr[k - m + 1];
                len = 0;
                for (ptr = beg; ptr < end; ptr++)
                    val[++len] = -A_val[ptr];
                xassert(csa.valid);
                ret = bfd_update_it(csa.bfd, i, 0, len, A_ind, beg - 1, val);
            }
            csa.valid = ret == 0;
            return ret;
        }
        function error_ftran(csa, h, x, r) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var head = csa.head;
            var i, k, beg, end, ptr;
            var temp;
            xcopyArr(r, 1, h, 1, m);
            for (i = 1; i <= m; i++) {
                temp = x[i];
                if (temp == 0)
                    continue;
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (k <= m) {
                    r[k] -= temp;
                } else {
                    beg = A_ptr[k - m];
                    end = A_ptr[k - m + 1];
                    for (ptr = beg; ptr < end; ptr++)
                        r[A_ind[ptr]] += A_val[ptr] * temp;
                }
            }
        }
        function refine_ftran(csa, h, x) {
            var m = csa.m;
            var r = csa.work1;
            var d = csa.work1;
            var i;
            error_ftran(csa, h, x, r);
            xassert(csa.valid);
            bfd_ftran(csa.bfd, d);
            for (i = 1; i <= m; i++)
                x[i] += d[i];
        }
        function error_btran(csa, h, x, r) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var head = csa.head;
            var i, k, beg, end, ptr;
            var temp;
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                temp = h[i];
                if (k <= m) {
                    temp -= x[k];
                } else {
                    beg = A_ptr[k - m];
                    end = A_ptr[k - m + 1];
                    for (ptr = beg; ptr < end; ptr++)
                        temp += A_val[ptr] * x[A_ind[ptr]];
                }
                r[i] = temp;
            }
        }
        function refine_btran(csa, h, x) {
            var m = csa.m;
            var r = csa.work1;
            var d = csa.work1;
            var i;
            error_btran(csa, h, x, r);
            xassert(csa.valid);
            bfd_btran(csa.bfd, d);
            for (i = 1; i <= m; i++)
                x[i] += d[i];
        }
        function alloc_N(csa) {
            var m = csa.m;
            var n = csa.n;
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var N_ptr = csa.N_ptr;
            var N_len = csa.N_len;
            var i, j, beg, end, ptr;
            for (i = 1; i <= m; i++)
                N_len[i] = 1;
            for (j = 1; j <= n; j++) {
                beg = A_ptr[j];
                end = A_ptr[j + 1];
                for (ptr = beg; ptr < end; ptr++)
                    N_len[A_ind[ptr]]++;
            }
            N_ptr[1] = 1;
            for (i = 1; i <= m; i++) {
                if (N_len[i] > n)
                    N_len[i] = n;
                N_ptr[i + 1] = N_ptr[i] + N_len[i];
            }
            csa.N_ind = new Int32Array(N_ptr[m + 1]);
            csa.N_val = new Float64Array(N_ptr[m + 1]);
        }
        function add_N_col(csa, j, k) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var N_ptr = csa.N_ptr;
            var N_len = csa.N_len;
            var N_ind = csa.N_ind;
            var N_val = csa.N_val;
            var pos;
            if (GLP_DEBUG) {
                xassert(1 <= j && j <= n);
                xassert(1 <= k && k <= m + n);
            }
            if (k <= m) {
                pos = N_ptr[k] + N_len[k]++;
                if (GLP_DEBUG) {
                    xassert(pos < N_ptr[k + 1]);
                }
                N_ind[pos] = j;
                N_val[pos] = 1;
            } else {
                var A_ptr = csa.A_ptr;
                var A_ind = csa.A_ind;
                var A_val = csa.A_val;
                var i, beg, end, ptr;
                beg = A_ptr[k - m];
                end = A_ptr[k - m + 1];
                for (ptr = beg; ptr < end; ptr++) {
                    i = A_ind[ptr];
                    pos = N_ptr[i] + N_len[i]++;
                    if (GLP_DEBUG) {
                        xassert(pos < N_ptr[i + 1]);
                    }
                    N_ind[pos] = j;
                    N_val[pos] = -A_val[ptr];
                }
            }
        }
        function del_N_col(csa, j, k) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var N_ptr = csa.N_ptr;
            var N_len = csa.N_len;
            var N_ind = csa.N_ind;
            var N_val = csa.N_val;
            var pos, head, tail;
            if (GLP_DEBUG) {
                xassert(1 <= j && j <= n);
                xassert(1 <= k && k <= m + n);
            }
            if (k <= m) {
                head = N_ptr[k];
                for (pos = head; N_ind[pos] != j; pos++) {
                }
                tail = head + --N_len[k];
                if (GLP_DEBUG) {
                    xassert(pos <= tail);
                }
                N_ind[pos] = N_ind[tail];
                N_val[pos] = N_val[tail];
            } else {
                var A_ptr = csa.A_ptr;
                var A_ind = csa.A_ind;
                var i, beg, end, ptr;
                beg = A_ptr[k - m];
                end = A_ptr[k - m + 1];
                for (ptr = beg; ptr < end; ptr++) {
                    i = A_ind[ptr];
                    head = N_ptr[i];
                    for (pos = head; N_ind[pos] != j; pos++) {
                    }
                    tail = head + --N_len[i];
                    if (GLP_DEBUG) {
                        xassert(pos <= tail);
                    }
                    N_ind[pos] = N_ind[tail];
                    N_val[pos] = N_val[tail];
                }
            }
        }
        function build_N(csa) {
            var m = csa.m;
            var n = csa.n;
            var head = csa.head;
            var stat = csa.stat;
            var N_len = csa.N_len;
            var j, k;
            xfillArr(N_len, 1, 0, m);
            for (j = 1; j <= n; j++) {
                if (stat[j] != GLP_NS) {
                    k = head[m + j];
                    if (GLP_DEBUG) {
                        xassert(1 <= k && k <= m + n);
                    }
                    add_N_col(csa, j, k);
                }
            }
        }
        function get_xN(csa, j) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var lb = csa.lb;
            var ub = csa.ub;
            var head = csa.head;
            var stat = csa.stat;
            var k;
            var xN;
            if (GLP_DEBUG) {
                xassert(1 <= j && j <= n);
            }
            k = head[m + j];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            switch (stat[j]) {
            case GLP_NL:
                xN = lb[k];
                break;
            case GLP_NU:
                xN = ub[k];
                break;
            case GLP_NF:
                xN = 0;
                break;
            case GLP_NS:
                xN = lb[k];
                break;
            default:
                xassert(stat != stat);
            }
            return xN;
        }
        function eval_beta(csa, beta) {
            var m = csa.m;
            var n = csa.n;
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var head = csa.head;
            var h = csa.work2;
            var i, j, k, beg, end, ptr;
            var xN;
            for (i = 1; i <= m; i++)
                h[i] = 0;
            for (j = 1; j <= n; j++) {
                k = head[m + j];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                xN = get_xN(csa, j);
                if (xN == 0)
                    continue;
                if (k <= m) {
                    h[k] -= xN;
                } else {
                    beg = A_ptr[k - m];
                    end = A_ptr[k - m + 1];
                    for (ptr = beg; ptr < end; ptr++)
                        h[A_ind[ptr]] += xN * A_val[ptr];
                }
            }
            xcopyArr(beta, 1, h, 1, m);
            xassert(csa.valid);
            bfd_ftran(csa.bfd, beta);
            refine_ftran(csa, h, beta);
        }
        function eval_pi(csa, pi) {
            var m = csa.m;
            var c = csa.coef;
            var head = csa.head;
            var cB = csa.work2;
            var i;
            for (i = 1; i <= m; i++)
                cB[i] = c[head[i]];
            xcopyArr(pi, 1, cB, 1, m);
            xassert(csa.valid);
            bfd_btran(csa.bfd, pi);
            refine_btran(csa, cB, pi);
        }
        function eval_cost(csa, pi, j) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var coef = csa.coef;
            var head = csa.head;
            var k;
            var dj;
            if (GLP_DEBUG) {
                xassert(1 <= j && j <= n);
            }
            k = head[m + j];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            dj = coef[k];
            if (k <= m) {
                dj -= pi[k];
            } else {
                var A_ptr = csa.A_ptr;
                var A_ind = csa.A_ind;
                var A_val = csa.A_val;
                var beg, end, ptr;
                beg = A_ptr[k - m];
                end = A_ptr[k - m + 1];
                for (ptr = beg; ptr < end; ptr++)
                    dj += A_val[ptr] * pi[A_ind[ptr]];
            }
            return dj;
        }
        function eval_bbar(csa) {
            eval_beta(csa, csa.bbar);
        }
        function eval_cbar(csa) {
            if (GLP_DEBUG) {
                var m = csa.m;
            }
            var n = csa.n;
            if (GLP_DEBUG) {
                var head = csa.head;
            }
            var cbar = csa.cbar;
            var pi = csa.work3;
            var j;
            if (GLP_DEBUG) {
                var k;
            }
            eval_pi(csa, pi);
            for (j = 1; j <= n; j++) {
                if (GLP_DEBUG) {
                    k = head[m + j];
                    xassert(1 <= k && k <= m + n);
                }
                cbar[j] = eval_cost(csa, pi, j);
            }
        }
        function reset_refsp(csa) {
            var m = csa.m;
            var n = csa.n;
            var head = csa.head;
            var refsp = csa.refsp;
            var gamma = csa.gamma;
            var j, k;
            xassert(csa.refct == 0);
            csa.refct = 1000;
            xfillArr(refsp, 1, 0, m + n);
            for (j = 1; j <= n; j++) {
                k = head[m + j];
                refsp[k] = 1;
                gamma[j] = 1;
            }
        }
        function eval_gamma(csa, j) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var head = csa.head;
            var refsp = csa.refsp;
            var alfa = csa.work3;
            var h = csa.work3;
            var i, k;
            var gamma;
            if (GLP_DEBUG) {
                xassert(1 <= j && j <= n);
            }
            k = head[m + j];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            for (i = 1; i <= m; i++)
                h[i] = 0;
            if (k <= m) {
                h[k] = -1;
            } else {
                var A_ptr = csa.A_ptr;
                var A_ind = csa.A_ind;
                var A_val = csa.A_val;
                var beg, end, ptr;
                beg = A_ptr[k - m];
                end = A_ptr[k - m + 1];
                for (ptr = beg; ptr < end; ptr++)
                    h[A_ind[ptr]] = A_val[ptr];
            }
            xassert(csa.valid);
            bfd_ftran(csa.bfd, alfa);
            gamma = refsp[k] ? 1 : 0;
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (refsp[k])
                    gamma += alfa[i] * alfa[i];
            }
            return gamma;
        }
        function chuzc(csa, tol_dj) {
            var n = csa.n;
            var stat = csa.stat;
            var cbar = csa.cbar;
            var gamma = csa.gamma;
            var j, q;
            var dj, best, temp;
            q = 0;
            best = 0;
            for (j = 1; j <= n; j++) {
                dj = cbar[j];
                switch (stat[j]) {
                case GLP_NL:
                    if (dj >= -tol_dj)
                        continue;
                    break;
                case GLP_NU:
                    if (dj <= +tol_dj)
                        continue;
                    break;
                case GLP_NF:
                    if (-tol_dj <= dj && dj <= +tol_dj)
                        continue;
                    break;
                case GLP_NS:
                    continue;
                default:
                    xassert(stat != stat);
                }
                if (GLP_DEBUG) {
                    xassert(gamma[j] > 0);
                }
                temp = dj * dj / gamma[j];
                if (best < temp) {
                    q = j;
                    best = temp;
                }
            }
            csa.q = q;
        }
        function eval_tcol(csa) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var head = csa.head;
            var q = csa.q;
            var tcol_ind = csa.tcol_ind;
            var tcol_vec = csa.tcol_vec;
            var h = csa.tcol_vec;
            var i, k, nnz;
            if (GLP_DEBUG) {
                xassert(1 <= q && q <= n);
            }
            k = head[m + q];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            for (i = 1; i <= m; i++)
                h[i] = 0;
            if (k <= m) {
                h[k] = -1;
            } else {
                var A_ptr = csa.A_ptr;
                var A_ind = csa.A_ind;
                var A_val = csa.A_val;
                var beg, end, ptr;
                beg = A_ptr[k - m];
                end = A_ptr[k - m + 1];
                for (ptr = beg; ptr < end; ptr++)
                    h[A_ind[ptr]] = A_val[ptr];
            }
            xassert(csa.valid);
            bfd_ftran(csa.bfd, tcol_vec);
            nnz = 0;
            for (i = 1; i <= m; i++) {
                if (tcol_vec[i] != 0)
                    tcol_ind[++nnz] = i;
            }
            csa.tcol_nnz = nnz;
        }
        function refine_tcol(csa) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var head = csa.head;
            var q = csa.q;
            var tcol_ind = csa.tcol_ind;
            var tcol_vec = csa.tcol_vec;
            var h = csa.work3;
            var i, k, nnz;
            if (GLP_DEBUG) {
                xassert(1 <= q && q <= n);
            }
            k = head[m + q];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            for (i = 1; i <= m; i++)
                h[i] = 0;
            if (k <= m) {
                h[k] = -1;
            } else {
                var A_ptr = csa.A_ptr;
                var A_ind = csa.A_ind;
                var A_val = csa.A_val;
                var beg, end, ptr;
                beg = A_ptr[k - m];
                end = A_ptr[k - m + 1];
                for (ptr = beg; ptr < end; ptr++)
                    h[A_ind[ptr]] = A_val[ptr];
            }
            refine_ftran(csa, h, tcol_vec);
            nnz = 0;
            for (i = 1; i <= m; i++) {
                if (tcol_vec[i] != 0)
                    tcol_ind[++nnz] = i;
            }
            csa.tcol_nnz = nnz;
        }
        function sort_tcol(csa, tol_piv) {
            if (GLP_DEBUG) {
                var m = csa.m;
            }
            var nnz = csa.tcol_nnz;
            var tcol_ind = csa.tcol_ind;
            var tcol_vec = csa.tcol_vec;
            var i, num, pos;
            var big, eps, temp;
            big = 0;
            for (pos = 1; pos <= nnz; pos++) {
                if (GLP_DEBUG) {
                    i = tcol_ind[pos];
                    xassert(1 <= i && i <= m);
                }
                temp = Math.abs(tcol_vec[tcol_ind[pos]]);
                if (big < temp)
                    big = temp;
            }
            csa.tcol_max = big;
            eps = tol_piv * (1 + 0.01 * big);
            for (num = 0; num < nnz;) {
                i = tcol_ind[nnz];
                if (Math.abs(tcol_vec[i]) < eps)
                    nnz--;
                else {
                    num++;
                    tcol_ind[nnz] = tcol_ind[num];
                    tcol_ind[num] = i;
                }
            }
            csa.tcol_num = num;
        }
        function chuzr(csa, rtol) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var type = csa.type;
            var lb = csa.lb;
            var ub = csa.ub;
            var coef = csa.coef;
            var head = csa.head;
            var phase = csa.phase;
            var bbar = csa.bbar;
            var cbar = csa.cbar;
            var q = csa.q;
            var tcol_ind = csa.tcol_ind;
            var tcol_vec = csa.tcol_vec;
            var tcol_num = csa.tcol_num;
            var i, i_stat, k, p, p_stat, pos;
            var alfa, big, delta, s, t, teta, tmax;
            if (GLP_DEBUG) {
                xassert(1 <= q && q <= n);
            }
            if (GLP_DEBUG) {
                xassert(cbar[q] != 0);
            }
            s = cbar[q] > 0 ? -1 : +1;
            k = head[m + q];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            if (type[k] == GLP_DB) {
                p = -1;
                p_stat = 0;
                teta = ub[k] - lb[k];
                big = 1;
            } else {
                p = 0;
                p_stat = 0;
                teta = DBL_MAX;
                big = 0;
            }
            for (pos = 1; pos <= tcol_num; pos++) {
                i = tcol_ind[pos];
                if (GLP_DEBUG) {
                    xassert(1 <= i && i <= m);
                }
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                alfa = s * tcol_vec[i];
                if (GLP_DEBUG) {
                    xassert(alfa != 0);
                }
                if (alfa > 0) {
                    if (phase == 1 && coef[k] < 0) {
                        delta = rtol * (1 + kappa * Math.abs(lb[k]));
                        t = (lb[k] + delta - bbar[i]) / alfa;
                        i_stat = GLP_NL;
                    } else if (phase == 1 && coef[k] > 0) {
                        continue;
                    } else if (type[k] == GLP_UP || type[k] == GLP_DB || type[k] == GLP_FX) {
                        delta = rtol * (1 + kappa * Math.abs(ub[k]));
                        t = (ub[k] + delta - bbar[i]) / alfa;
                        i_stat = GLP_NU;
                    } else {
                        continue;
                    }
                } else {
                    if (phase == 1 && coef[k] > 0) {
                        delta = rtol * (1 + kappa * Math.abs(ub[k]));
                        t = (ub[k] - delta - bbar[i]) / alfa;
                        i_stat = GLP_NU;
                    } else if (phase == 1 && coef[k] < 0) {
                        continue;
                    } else if (type[k] == GLP_LO || type[k] == GLP_DB || type[k] == GLP_FX) {
                        delta = rtol * (1 + kappa * Math.abs(lb[k]));
                        t = (lb[k] - delta - bbar[i]) / alfa;
                        i_stat = GLP_NL;
                    } else {
                        continue;
                    }
                }
                if (t < 0)
                    t = 0;
                if (teta > t || teta == t && big < Math.abs(alfa)) {
                    p = i;
                    p_stat = i_stat;
                    teta = t;
                    big = Math.abs(alfa);
                }
            }
            if (rtol == 0)
                return done();
            if (p <= 0)
                return done();
            if (teta == 0)
                return done();
            tmax = teta;
            p = 0;
            p_stat = 0;
            teta = DBL_MAX;
            big = 0;
            for (pos = 1; pos <= tcol_num; pos++) {
                i = tcol_ind[pos];
                if (GLP_DEBUG) {
                    xassert(1 <= i && i <= m);
                }
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                alfa = s * tcol_vec[i];
                if (GLP_DEBUG) {
                    xassert(alfa != 0);
                }
                if (alfa > 0) {
                    if (phase == 1 && coef[k] < 0) {
                        t = (lb[k] - bbar[i]) / alfa;
                        i_stat = GLP_NL;
                    } else if (phase == 1 && coef[k] > 0) {
                        continue;
                    } else if (type[k] == GLP_UP || type[k] == GLP_DB || type[k] == GLP_FX) {
                        t = (ub[k] - bbar[i]) / alfa;
                        i_stat = GLP_NU;
                    } else {
                        continue;
                    }
                } else {
                    if (phase == 1 && coef[k] > 0) {
                        t = (ub[k] - bbar[i]) / alfa;
                        i_stat = GLP_NU;
                    } else if (phase == 1 && coef[k] < 0) {
                        continue;
                    } else if (type[k] == GLP_LO || type[k] == GLP_DB || type[k] == GLP_FX) {
                        t = (lb[k] - bbar[i]) / alfa;
                        i_stat = GLP_NL;
                    } else {
                        continue;
                    }
                }
                if (t < 0)
                    t = 0;
                if (t <= tmax && big < Math.abs(alfa)) {
                    p = i;
                    p_stat = i_stat;
                    teta = t;
                    big = Math.abs(alfa);
                }
            }
            xassert(p != 0);
            function done() {
                csa.p = p;
                if (p > 0 && type[head[p]] == GLP_FX)
                    csa.p_stat = GLP_NS;
                else
                    csa.p_stat = p_stat;
                if (GLP_DEBUG) {
                    xassert(teta >= 0);
                }
                csa.teta = s * teta;
            }
            done();
        }
        function eval_rho(csa, rho) {
            var m = csa.m;
            var p = csa.p;
            var i;
            if (GLP_DEBUG) {
                xassert(1 <= p && p <= m);
            }
            for (i = 1; i <= m; i++)
                rho[i] = 0;
            rho[p] = 1;
            xassert(csa.valid);
            bfd_btran(csa.bfd, rho);
        }
        function refine_rho(csa, rho) {
            var m = csa.m;
            var p = csa.p;
            var e = csa.work3;
            var i;
            if (GLP_DEBUG) {
                xassert(1 <= p && p <= m);
            }
            for (i = 1; i <= m; i++)
                e[i] = 0;
            e[p] = 1;
            refine_btran(csa, e, rho);
        }
        function eval_trow(csa, rho) {
            var m = csa.m;
            var n = csa.n;
            if (GLP_DEBUG) {
                var stat = csa.stat;
            }
            var N_ptr = csa.N_ptr;
            var N_len = csa.N_len;
            var N_ind = csa.N_ind;
            var N_val = csa.N_val;
            var trow_ind = csa.trow_ind;
            var trow_vec = csa.trow_vec;
            var i, j, beg, end, ptr, nnz;
            var temp;
            for (j = 1; j <= n; j++)
                trow_vec[j] = 0;
            for (i = 1; i <= m; i++) {
                temp = rho[i];
                if (temp == 0)
                    continue;
                beg = N_ptr[i];
                end = beg + N_len[i];
                for (ptr = beg; ptr < end; ptr++) {
                    if (GLP_DEBUG) {
                        j = N_ind[ptr];
                        xassert(1 <= j && j <= n);
                        xassert(stat[j] != GLP_NS);
                    }
                    trow_vec[N_ind[ptr]] -= temp * N_val[ptr];
                }
            }
            nnz = 0;
            for (j = 1; j <= n; j++) {
                if (trow_vec[j] != 0)
                    trow_ind[++nnz] = j;
            }
            csa.trow_nnz = nnz;
        }
        function update_bbar(csa) {
            if (GLP_DEBUG) {
                var m = csa.m;
                var n = csa.n;
            }
            var bbar = csa.bbar;
            var q = csa.q;
            var tcol_nnz = csa.tcol_nnz;
            var tcol_ind = csa.tcol_ind;
            var tcol_vec = csa.tcol_vec;
            var p = csa.p;
            var teta = csa.teta;
            var i, pos;
            if (GLP_DEBUG) {
                xassert(1 <= q && q <= n);
                xassert(p < 0 || 1 <= p && p <= m);
            }
            if (p > 0)
                bbar[p] = get_xN(csa, q) + teta;
            if (teta == 0)
                return;
            for (pos = 1; pos <= tcol_nnz; pos++) {
                i = tcol_ind[pos];
                if (i == p)
                    continue;
                bbar[i] += tcol_vec[i] * teta;
            }
        }
        function reeval_cost(csa) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var coef = csa.coef;
            var head = csa.head;
            var q = csa.q;
            var tcol_nnz = csa.tcol_nnz;
            var tcol_ind = csa.tcol_ind;
            var tcol_vec = csa.tcol_vec;
            var i, pos;
            var dq;
            if (GLP_DEBUG) {
                xassert(1 <= q && q <= n);
            }
            dq = coef[head[m + q]];
            for (pos = 1; pos <= tcol_nnz; pos++) {
                i = tcol_ind[pos];
                if (GLP_DEBUG) {
                    xassert(1 <= i && i <= m);
                }
                dq += coef[head[i]] * tcol_vec[i];
            }
            return dq;
        }
        function update_cbar(csa) {
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var cbar = csa.cbar;
            var q = csa.q;
            var trow_nnz = csa.trow_nnz;
            var trow_ind = csa.trow_ind;
            var trow_vec = csa.trow_vec;
            var j, pos;
            var new_dq;
            if (GLP_DEBUG) {
                xassert(1 <= q && q <= n);
            }
            if (GLP_DEBUG) {
                xassert(trow_vec[q] != 0);
            }
            new_dq = cbar[q] /= trow_vec[q];
            for (pos = 1; pos <= trow_nnz; pos++) {
                j = trow_ind[pos];
                if (j == q)
                    continue;
                cbar[j] -= trow_vec[j] * new_dq;
            }
        }
        function update_gamma(csa) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var type = csa.type;
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var head = csa.head;
            var refsp = csa.refsp;
            var gamma = csa.gamma;
            var q = csa.q;
            var tcol_nnz = csa.tcol_nnz;
            var tcol_ind = csa.tcol_ind;
            var tcol_vec = csa.tcol_vec;
            var p = csa.p;
            var trow_nnz = csa.trow_nnz;
            var trow_ind = csa.trow_ind;
            var trow_vec = csa.trow_vec;
            var u = csa.work3;
            var i, j, k, pos, beg, end, ptr;
            var gamma_q, delta_q, pivot, s, t, t1, t2;
            if (GLP_DEBUG) {
                xassert(1 <= p && p <= m);
                xassert(1 <= q && q <= n);
            }
            xassert(csa.refct > 0);
            csa.refct--;
            gamma_q = delta_q = refsp[head[m + q]] ? 1 : 0;
            for (i = 1; i <= m; i++)
                u[i] = 0;
            for (pos = 1; pos <= tcol_nnz; pos++) {
                i = tcol_ind[pos];
                if (refsp[head[i]]) {
                    u[i] = t = tcol_vec[i];
                    gamma_q += t * t;
                } else
                    u[i] = 0;
            }
            xassert(csa.valid);
            bfd_btran(csa.bfd, u);
            pivot = trow_vec[q];
            if (GLP_DEBUG) {
                xassert(pivot != 0);
            }
            for (pos = 1; pos <= trow_nnz; pos++) {
                j = trow_ind[pos];
                if (j == q)
                    continue;
                t = trow_vec[j] / pivot;
                k = head[m + j];
                if (k <= m)
                    s = u[k];
                else {
                    s = 0;
                    beg = A_ptr[k - m];
                    end = A_ptr[k - m + 1];
                    for (ptr = beg; ptr < end; ptr++)
                        s -= A_val[ptr] * u[A_ind[ptr]];
                }
                t1 = gamma[j] + t * t * gamma_q + 2 * t * s;
                t2 = (refsp[k] ? 1 : 0) + delta_q * t * t;
                gamma[j] = t1 >= t2 ? t1 : t2;
                if (gamma[j] < DBL_EPSILON)
                    gamma[j] = DBL_EPSILON;
            }
            if (type[head[p]] == GLP_FX)
                gamma[q] = 1;
            else {
                gamma[q] = gamma_q / (pivot * pivot);
                if (gamma[q] < DBL_EPSILON)
                    gamma[q] = DBL_EPSILON;
            }
        }
        function err_in_bbar(csa) {
            var m = csa.m;
            var bbar = csa.bbar;
            var i;
            var e, emax, beta;
            beta = new Float64Array(1 + m);
            eval_beta(csa, beta);
            emax = 0;
            for (i = 1; i <= m; i++) {
                e = Math.abs(beta[i] - bbar[i]) / (1 + Math.abs(beta[i]));
                if (emax < e)
                    emax = e;
            }
            return emax;
        }
        function err_in_cbar(csa) {
            var m = csa.m;
            var n = csa.n;
            var stat = csa.stat;
            var cbar = csa.cbar;
            var j;
            var e, emax, cost, pi;
            pi = new Float64Array(1 + m);
            eval_pi(csa, pi);
            emax = 0;
            for (j = 1; j <= n; j++) {
                if (stat[j] == GLP_NS)
                    continue;
                cost = eval_cost(csa, pi, j);
                e = Math.abs(cost - cbar[j]) / (1 + Math.abs(cost));
                if (emax < e)
                    emax = e;
            }
            return emax;
        }
        function err_in_gamma(csa) {
            var n = csa.n;
            var stat = csa.stat;
            var gamma = csa.gamma;
            var j;
            var e, emax, temp;
            emax = 0;
            for (j = 1; j <= n; j++) {
                if (stat[j] == GLP_NS) {
                    xassert(gamma[j] == 1);
                    continue;
                }
                temp = eval_gamma(csa, j);
                e = Math.abs(temp - gamma[j]) / (1 + Math.abs(temp));
                if (emax < e)
                    emax = e;
            }
            return emax;
        }
        function change_basis(csa) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
                var type = csa.type;
            }
            var head = csa.head;
            var stat = csa.stat;
            var q = csa.q;
            var p = csa.p;
            var p_stat = csa.p_stat;
            var k;
            if (GLP_DEBUG) {
                xassert(1 <= q && q <= n);
            }
            if (p < 0) {
                if (GLP_DEBUG) {
                    k = head[m + q];
                    xassert(1 <= k && k <= m + n);
                    xassert(type[k] == GLP_DB);
                }
                switch (stat[q]) {
                case GLP_NL:
                    stat[q] = GLP_NU;
                    break;
                case GLP_NU:
                    stat[q] = GLP_NL;
                    break;
                default:
                    xassert(stat != stat);
                }
            } else {
                if (GLP_DEBUG) {
                    xassert(1 <= p && p <= m);
                    k = head[p];
                    switch (p_stat) {
                    case GLP_NL:
                        xassert(type[k] == GLP_LO || type[k] == GLP_DB);
                        break;
                    case GLP_NU:
                        xassert(type[k] == GLP_UP || type[k] == GLP_DB);
                        break;
                    case GLP_NS:
                        xassert(type[k] == GLP_NS);
                        break;
                    default:
                        xassert(p_stat != p_stat);
                    }
                }
                k = head[p];
                head[p] = head[m + q];
                head[m + q] = k;
                stat[q] = p_stat;
            }
        }
        function set_aux_obj(csa, tol_bnd) {
            var m = csa.m;
            var n = csa.n;
            var type = csa.type;
            var lb = csa.lb;
            var ub = csa.ub;
            var coef = csa.coef;
            var head = csa.head;
            var bbar = csa.bbar;
            var i, k, cnt = 0;
            var eps;
            tol_bnd *= 0.9;
            for (k = 1; k <= m + n; k++)
                coef[k] = 0;
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (type[k] == GLP_LO || type[k] == GLP_DB || type[k] == GLP_FX) {
                    eps = tol_bnd * (1 + kappa * Math.abs(lb[k]));
                    if (bbar[i] < lb[k] - eps) {
                        coef[k] = -1;
                        cnt++;
                    }
                }
                if (type[k] == GLP_UP || type[k] == GLP_DB || type[k] == GLP_FX) {
                    eps = tol_bnd * (1 + kappa * Math.abs(ub[k]));
                    if (bbar[i] > ub[k] + eps) {
                        coef[k] = +1;
                        cnt++;
                    }
                }
            }
            return cnt;
        }
        function set_orig_obj(csa) {
            var m = csa.m;
            var n = csa.n;
            var coef = csa.coef;
            var obj = csa.obj;
            var zeta = csa.zeta;
            var i, j;
            for (i = 1; i <= m; i++)
                coef[i] = 0;
            for (j = 1; j <= n; j++)
                coef[m + j] = zeta * obj[j];
        }
        function check_stab(csa, tol_bnd) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var type = csa.type;
            var lb = csa.lb;
            var ub = csa.ub;
            var coef = csa.coef;
            var head = csa.head;
            var phase = csa.phase;
            var bbar = csa.bbar;
            var i, k;
            var eps;
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (phase == 1 && coef[k] < 0) {
                    if (GLP_DEBUG) {
                        xassert(type[k] == GLP_LO || type[k] == GLP_DB || type[k] == GLP_FX);
                    }
                    eps = tol_bnd * (1 + kappa * Math.abs(lb[k]));
                    if (bbar[i] > lb[k] + eps)
                        return 1;
                } else if (phase == 1 && coef[k] > 0) {
                    if (GLP_DEBUG) {
                        xassert(type[k] == GLP_UP || type[k] == GLP_DB || type[k] == GLP_FX);
                    }
                    eps = tol_bnd * (1 + kappa * Math.abs(ub[k]));
                    if (bbar[i] < ub[k] - eps)
                        return 1;
                } else {
                    if (type[k] == GLP_LO || type[k] == GLP_DB || type[k] == GLP_FX) {
                        eps = tol_bnd * (1 + kappa * Math.abs(lb[k]));
                        if (bbar[i] < lb[k] - eps)
                            return 1;
                    }
                    if (type[k] == GLP_UP || type[k] == GLP_DB || type[k] == GLP_FX) {
                        eps = tol_bnd * (1 + kappa * Math.abs(ub[k]));
                        if (bbar[i] > ub[k] + eps)
                            return 1;
                    }
                }
            }
            return 0;
        }
        function check_feas(csa, tol_bnd) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
                var type = csa.type;
            }
            var lb = csa.lb;
            var ub = csa.ub;
            var coef = csa.coef;
            var head = csa.head;
            var bbar = csa.bbar;
            var i, k;
            var eps;
            xassert(csa.phase == 1);
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (coef[k] < 0) {
                    if (GLP_DEBUG) {
                        xassert(type[k] == GLP_LO || type[k] == GLP_DB || type[k] == GLP_FX);
                    }
                    eps = tol_bnd * (1 + kappa * Math.abs(lb[k]));
                    if (bbar[i] < lb[k] - eps)
                        return 1;
                } else if (coef[k] > 0) {
                    if (GLP_DEBUG) {
                        xassert(type[k] == GLP_UP || type[k] == GLP_DB || type[k] == GLP_FX);
                    }
                    eps = tol_bnd * (1 + kappa * Math.abs(ub[k]));
                    if (bbar[i] > ub[k] + eps)
                        return 1;
                }
            }
            return 0;
        }
        function eval_obj(csa) {
            var m = csa.m;
            var n = csa.n;
            var obj = csa.obj;
            var head = csa.head;
            var bbar = csa.bbar;
            var i, j, k;
            var sum;
            sum = obj[0];
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (k > m)
                    sum += obj[k - m] * bbar[i];
            }
            for (j = 1; j <= n; j++) {
                k = head[m + j];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (k > m)
                    sum += obj[k - m] * get_xN(csa, j);
            }
            return sum;
        }
        function display(csa, parm, spec) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var type = csa.type;
            var lb = csa.lb;
            var ub = csa.ub;
            var phase = csa.phase;
            var head = csa.head;
            var bbar = csa.bbar;
            var i, k, cnt;
            var sum;
            if (parm.msg_lev < GLP_MSG_ON)
                return;
            if (parm.out_dly > 0 && 1000 * xdifftime(xtime(), csa.tm_beg) < parm.out_dly)
                return;
            if (csa.it_cnt == csa.it_dpy)
                return;
            if (!spec && csa.it_cnt % parm.out_frq != 0)
                return;
            sum = 0;
            cnt = 0;
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (type[k] == GLP_LO || type[k] == GLP_DB || type[k] == GLP_FX) {
                    if (bbar[i] < lb[k])
                        sum += lb[k] - bbar[i];
                }
                if (type[k] == GLP_UP || type[k] == GLP_DB || type[k] == GLP_FX) {
                    if (bbar[i] > ub[k])
                        sum += bbar[i] - ub[k];
                }
                if (type[k] == GLP_FX)
                    cnt++;
            }
            xprintf((phase == 1 ? ' ' : '*') + csa.it_cnt + ': obj = ' + eval_obj(csa) + '  infeas = ' + sum + ' (' + cnt + ')');
            csa.it_dpy = csa.it_cnt;
        }
        function store_sol(csa, lp, p_stat, d_stat, ray) {
            var m = csa.m;
            var n = csa.n;
            var zeta = csa.zeta;
            var head = csa.head;
            var stat = csa.stat;
            var bbar = csa.bbar;
            var cbar = csa.cbar;
            var i, j, k;
            var row, col;
            if (GLP_DEBUG) {
                xassert(lp.m == m);
                xassert(lp.n == n);
                xassert(!lp.valid && lp.bfd == null);
                xassert(csa.valid && csa.bfd != null);
            }
            lp.valid = 1;
            csa.valid = 0;
            lp.bfd = csa.bfd;
            csa.bfd = null;
            xcopyArr(lp.head, 1, head, 1, m);
            lp.pbs_stat = p_stat;
            lp.dbs_stat = d_stat;
            lp.obj_val = eval_obj(csa);
            lp.it_cnt = csa.it_cnt;
            lp.some = ray;
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (k <= m) {
                    row = lp.row[k];
                    row.stat = GLP_BS;
                    row.bind = i;
                    row.prim = bbar[i] / row.rii;
                    row.dual = 0;
                } else {
                    col = lp.col[k - m];
                    col.stat = GLP_BS;
                    col.bind = i;
                    col.prim = bbar[i] * col.sjj;
                    col.dual = 0;
                }
            }
            for (j = 1; j <= n; j++) {
                k = head[m + j];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (k <= m) {
                    row = lp.row[k];
                    row.stat = stat[j];
                    row.bind = 0;
                    switch (stat[j]) {
                    case GLP_NL:
                        row.prim = row.lb;
                        break;
                    case GLP_NU:
                        row.prim = row.ub;
                        break;
                    case GLP_NF:
                        row.prim = 0;
                        break;
                    case GLP_NS:
                        row.prim = row.lb;
                        break;
                    default:
                        xassert(stat != stat);
                    }
                    row.dual = cbar[j] * row.rii / zeta;
                } else {
                    col = lp.col[k - m];
                    col.stat = stat[j];
                    col.bind = 0;
                    switch (stat[j]) {
                    case GLP_NL:
                        col.prim = col.lb;
                        break;
                    case GLP_NU:
                        col.prim = col.ub;
                        break;
                    case GLP_NF:
                        col.prim = 0;
                        break;
                    case GLP_NS:
                        col.prim = col.lb;
                        break;
                    default:
                        xassert(stat != stat);
                    }
                    col.dual = cbar[j] / col.sjj / zeta;
                }
            }
        }
        var csa;
        var binv_st = 2;
        var bbar_st = 0;
        var cbar_st = 0;
        var rigorous = 0;
        var check = 0;
        var p_stat, d_stat, ret;
        csa = alloc_csa(lp);
        init_csa(csa, lp);
        if (parm.msg_lev >= GLP_MSG_DBG)
            xprintf('Objective scale factor = ' + csa.zeta + '');
        while (true) {
            if (binv_st == 0) {
                ret = invert_B(csa);
                if (ret != 0) {
                    if (parm.msg_lev >= GLP_MSG_ERR) {
                        xprintf('Error: unable to factorize the basis matrix (' + ret + ')');
                        xprintf('Sorry, basis recovery procedure not implemented yet');
                    }
                    xassert(!lp.valid && lp.bfd == null);
                    lp.bfd = csa.bfd;
                    csa.bfd = null;
                    lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;
                    lp.obj_val = 0;
                    lp.it_cnt = csa.it_cnt;
                    lp.some = 0;
                    ret = GLP_EFAIL;
                    return ret;
                }
                csa.valid = 1;
                binv_st = 1;
                bbar_st = cbar_st = 0;
            }
            if (bbar_st == 0) {
                eval_bbar(csa);
                bbar_st = 1;
                if (csa.phase == 0) {
                    if (set_aux_obj(csa, parm.tol_bnd) > 0) {
                        csa.phase = 1;
                    } else {
                        set_orig_obj(csa);
                        csa.phase = 2;
                    }
                    xassert(check_stab(csa, parm.tol_bnd) == 0);
                    cbar_st = 0;
                    display(csa, parm, 1);
                }
                if (check_stab(csa, parm.tol_bnd)) {
                    if (parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('Warning: numerical instability (primal simplex, phase ' + (csa.phase == 1 ? 'I' : 'II') + ')');
                    csa.phase = 0;
                    binv_st = 0;
                    rigorous = 5;
                    continue;
                }
            }
            xassert(csa.phase == 1 || csa.phase == 2);
            if (csa.phase == 1 && !check_feas(csa, parm.tol_bnd)) {
                csa.phase = 2;
                set_orig_obj(csa);
                cbar_st = 0;
                display(csa, parm, 1);
            }
            if (cbar_st == 0) {
                eval_cbar(csa);
                cbar_st = 1;
            }
            switch (parm.pricing) {
            case GLP_PT_STD:
                break;
            case GLP_PT_PSE:
                if (csa.refct == 0)
                    reset_refsp(csa);
                break;
            default:
                xassert(parm != parm);
            }
            xassert(binv_st && bbar_st && cbar_st);
            if (check) {
                var e_bbar = err_in_bbar(csa);
                var e_cbar = err_in_cbar(csa);
                var e_gamma = parm.pricing == GLP_PT_PSE ? err_in_gamma(csa) : 0;
                xprintf('e_bbar = ' + e_bbar + '; e_cbar = ' + e_cbar + '; e_gamma = ' + e_gamma + '');
                xassert(e_bbar <= 0.00001 && e_cbar <= 0.00001 && e_gamma <= 0.001);
            }
            if (parm.it_lim < INT_MAX && csa.it_cnt - csa.it_beg >= parm.it_lim) {
                if (bbar_st != 1 || csa.phase == 2 && cbar_st != 1) {
                    if (bbar_st != 1)
                        bbar_st = 0;
                    if (csa.phase == 2 && cbar_st != 1)
                        cbar_st = 0;
                    continue;
                }
                display(csa, parm, 1);
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('ITERATION LIMIT EXCEEDED; SEARCH TERMINATED');
                switch (csa.phase) {
                case 1:
                    p_stat = GLP_INFEAS;
                    set_orig_obj(csa);
                    eval_cbar(csa);
                    break;
                case 2:
                    p_stat = GLP_FEAS;
                    break;
                default:
                    xassert(csa != csa);
                }
                chuzc(csa, parm.tol_dj);
                d_stat = csa.q == 0 ? GLP_FEAS : GLP_INFEAS;
                store_sol(csa, lp, p_stat, d_stat, 0);
                ret = GLP_EITLIM;
                return ret;
            }
            if (parm.tm_lim < INT_MAX && 1000 * xdifftime(xtime(), csa.tm_beg) >= parm.tm_lim) {
                if (bbar_st != 1 || csa.phase == 2 && cbar_st != 1) {
                    if (bbar_st != 1)
                        bbar_st = 0;
                    if (csa.phase == 2 && cbar_st != 1)
                        cbar_st = 0;
                    continue;
                }
                display(csa, parm, 1);
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('TIME LIMIT EXCEEDED; SEARCH TERMINATED');
                switch (csa.phase) {
                case 1:
                    p_stat = GLP_INFEAS;
                    set_orig_obj(csa);
                    eval_cbar(csa);
                    break;
                case 2:
                    p_stat = GLP_FEAS;
                    break;
                default:
                    xassert(csa != csa);
                }
                chuzc(csa, parm.tol_dj);
                d_stat = csa.q == 0 ? GLP_FEAS : GLP_INFEAS;
                store_sol(csa, lp, p_stat, d_stat, 0);
                ret = GLP_ETMLIM;
                return ret;
            }
            display(csa, parm, 0);
            chuzc(csa, parm.tol_dj);
            if (csa.q == 0) {
                if (bbar_st != 1 || cbar_st != 1) {
                    if (bbar_st != 1)
                        bbar_st = 0;
                    if (cbar_st != 1)
                        cbar_st = 0;
                    continue;
                }
                display(csa, parm, 1);
                switch (csa.phase) {
                case 1:
                    if (parm.msg_lev >= GLP_MSG_ALL)
                        xprintf('PROBLEM HAS NO FEASIBLE SOLUTION');
                    p_stat = GLP_NOFEAS;
                    set_orig_obj(csa);
                    eval_cbar(csa);
                    chuzc(csa, parm.tol_dj);
                    d_stat = csa.q == 0 ? GLP_FEAS : GLP_INFEAS;
                    break;
                case 2:
                    if (parm.msg_lev >= GLP_MSG_ALL)
                        xprintf('OPTIMAL SOLUTION FOUND');
                    p_stat = d_stat = GLP_FEAS;
                    break;
                default:
                    xassert(csa != csa);
                }
                store_sol(csa, lp, p_stat, d_stat, 0);
                ret = 0;
                return ret;
            }
            eval_tcol(csa);
            if (rigorous)
                refine_tcol(csa);
            sort_tcol(csa, parm.tol_piv);
            {
                var d1 = csa.cbar[csa.q];
                var d2 = reeval_cost(csa);
                xassert(d1 != 0);
                if (Math.abs(d1 - d2) > 0.00001 * (1 + Math.abs(d2)) || !(d1 < 0 && d2 < 0 || d1 > 0 && d2 > 0)) {
                    if (parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('d1 = ' + d1 + '; d2 = ' + d2 + '');
                    if (cbar_st != 1 || !rigorous) {
                        if (cbar_st != 1)
                            cbar_st = 0;
                        rigorous = 5;
                        continue;
                    }
                }
                if (d1 > 0)
                    csa.cbar[csa.q] = d2 > 0 ? d2 : +DBL_EPSILON;
                else
                    csa.cbar[csa.q] = d2 < 0 ? d2 : -DBL_EPSILON;
            }
            switch (parm.r_test) {
            case GLP_RT_STD:
                chuzr(csa, 0);
                break;
            case GLP_RT_HAR:
                chuzr(csa, 0.3 * parm.tol_bnd);
                break;
            default:
                xassert(parm != parm);
            }
            if (csa.p == 0) {
                if (bbar_st != 1 || cbar_st != 1 || !rigorous) {
                    if (bbar_st != 1)
                        bbar_st = 0;
                    if (cbar_st != 1)
                        cbar_st = 0;
                    rigorous = 1;
                    continue;
                }
                display(csa, parm, 1);
                switch (csa.phase) {
                case 1:
                    if (parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('Error: unable to choose basic variable on phase I');
                    xassert(!lp.valid && lp.bfd == null);
                    lp.bfd = csa.bfd;
                    csa.bfd = null;
                    lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;
                    lp.obj_val = 0;
                    lp.it_cnt = csa.it_cnt;
                    lp.some = 0;
                    ret = GLP_EFAIL;
                    break;
                case 2:
                    if (parm.msg_lev >= GLP_MSG_ALL)
                        xprintf('PROBLEM HAS UNBOUNDED SOLUTION');
                    store_sol(csa, lp, GLP_FEAS, GLP_NOFEAS, csa.head[csa.m + csa.q]);
                    ret = 0;
                    break;
                default:
                    xassert(csa != csa);
                }
                return ret;
            }
            if (csa.p > 0) {
                var piv = csa.tcol_vec[csa.p];
                var eps = 0.00001 * (1 + 0.01 * csa.tcol_max);
                if (Math.abs(piv) < eps) {
                    if (parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('piv = ' + piv + '; eps = ' + eps + '');
                    if (!rigorous) {
                        rigorous = 5;
                        continue;
                    }
                }
            }
            if (csa.p > 0) {
                var rho = csa.work4;
                eval_rho(csa, rho);
                if (rigorous)
                    refine_rho(csa, rho);
                eval_trow(csa, rho);
            }
            if (csa.p > 0) {
                var piv1 = csa.tcol_vec[csa.p];
                var piv2 = csa.trow_vec[csa.q];
                xassert(piv1 != 0);
                if (Math.abs(piv1 - piv2) > 1e-8 * (1 + Math.abs(piv1)) || !(piv1 > 0 && piv2 > 0 || piv1 < 0 && piv2 < 0)) {
                    if (parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('piv1 = ' + piv1 + '; piv2 = ' + piv2 + '');
                    if (binv_st != 1 || !rigorous) {
                        if (binv_st != 1)
                            binv_st = 0;
                        rigorous = 5;
                        continue;
                    }
                    if (csa.trow_vec[csa.q] == 0) {
                        csa.trow_nnz++;
                        xassert(csa.trow_nnz <= csa.n);
                        csa.trow_ind[csa.trow_nnz] = csa.q;
                    }
                    csa.trow_vec[csa.q] = piv1;
                }
            }
            update_bbar(csa);
            bbar_st = 2;
            if (csa.p > 0) {
                update_cbar(csa);
                cbar_st = 2;
                if (csa.phase == 1) {
                    var k = csa.head[csa.p];
                    csa.cbar[csa.q] -= csa.coef[k];
                    csa.coef[k] = 0;
                }
            }
            if (csa.p > 0) {
                switch (parm.pricing) {
                case GLP_PT_STD:
                    break;
                case GLP_PT_PSE:
                    if (csa.refct > 0)
                        update_gamma(csa);
                    break;
                default:
                    xassert(parm != parm);
                }
            }
            if (csa.p > 0) {
                ret = update_B(csa, csa.p, csa.head[csa.m + csa.q]);
                if (ret == 0)
                    binv_st = 2;
                else {
                    csa.valid = 0;
                    binv_st = 0;
                }
            }
            if (csa.p > 0) {
                del_N_col(csa, csa.q, csa.head[csa.m + csa.q]);
                if (csa.type[csa.head[csa.p]] != GLP_FX)
                    add_N_col(csa, csa.q, csa.head[csa.p]);
            }
            change_basis(csa);
            csa.it_cnt++;
            if (rigorous > 0)
                rigorous--;
            continue;
        }
    }
    function spx_dual(lp, parm) {
        var kappa = 0.1;
        function alloc_csa(lp) {
            var m = lp.m;
            var n = lp.n;
            var nnz = lp.nnz;
            var csa = {};
            xassert(m > 0 && n > 0);
            csa.m = m;
            csa.n = n;
            csa.type = new Int8Array(1 + m + n);
            csa.lb = new Float64Array(1 + m + n);
            csa.ub = new Float64Array(1 + m + n);
            csa.coef = new Float64Array(1 + m + n);
            csa.orig_type = new Int8Array(1 + m + n);
            csa.orig_lb = new Float64Array(1 + m + n);
            csa.orig_ub = new Float64Array(1 + m + n);
            csa.obj = new Float64Array(1 + n);
            csa.A_ptr = new Int32Array(1 + n + 1);
            csa.A_ind = new Int32Array(1 + nnz);
            csa.A_val = new Float64Array(1 + nnz);
            csa.AT_ptr = new Int32Array(1 + m + 1);
            csa.AT_ind = new Int32Array(1 + nnz);
            csa.AT_val = new Float64Array(1 + nnz);
            csa.head = new Int32Array(1 + m + n);
            csa.bind = new Int32Array(1 + m + n);
            csa.stat = new Int8Array(1 + n);
            csa.bbar = new Float64Array(1 + m);
            csa.cbar = new Float64Array(1 + n);
            csa.refsp = new Int8Array(1 + m + n);
            csa.gamma = new Float64Array(1 + m);
            csa.trow_ind = new Int32Array(1 + n);
            csa.trow_vec = new Float64Array(1 + n);
            csa.tcol_ind = new Int32Array(1 + m);
            csa.tcol_vec = new Float64Array(1 + m);
            csa.work1 = new Float64Array(1 + m);
            csa.work2 = new Float64Array(1 + m);
            csa.work3 = new Float64Array(1 + m);
            csa.work4 = new Float64Array(1 + m);
            return csa;
        }
        this['chrome_workaround_1'] = function (csa, lp) {
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var n = csa.n;
            var aij, loc, j;
            loc = 1;
            for (j = 1; j <= n; j++) {
                A_ptr[j] = loc;
                for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next) {
                    A_ind[loc] = aij.row.i;
                    A_val[loc] = aij.row.rii * aij.val * aij.col.sjj;
                    loc++;
                }
            }
            A_ptr[n + 1] = loc;
            xassert(loc - 1 == lp.nnz);
        };
        this['chrome_workaround_2'] = function (csa, lp) {
            var loc, i, aij;
            var AT_ptr = csa.AT_ptr;
            var AT_ind = csa.AT_ind;
            var AT_val = csa.AT_val;
            var m = csa.m;
            loc = 1;
            for (i = 1; i <= m; i++) {
                AT_ptr[i] = loc;
                for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next) {
                    AT_ind[loc] = aij.col.j;
                    AT_val[loc] = aij.row.rii * aij.val * aij.col.sjj;
                    loc++;
                }
            }
            AT_ptr[m + 1] = loc;
            xassert(loc - 1 == lp.nnz);
        };
        function init_csa(csa, lp) {
            var m = csa.m;
            var n = csa.n;
            var type = csa.type;
            var lb = csa.lb;
            var ub = csa.ub;
            var coef = csa.coef;
            var orig_type = csa.orig_type;
            var orig_lb = csa.orig_lb;
            var orig_ub = csa.orig_ub;
            var obj = csa.obj;
            var head = csa.head;
            var bind = csa.bind;
            var stat = csa.stat;
            var refsp = csa.refsp;
            var gamma = csa.gamma;
            var i, j, k, loc;
            var cmax, aij, row, col;
            for (i = 1; i <= m; i++) {
                row = lp.row[i];
                type[i] = row.type;
                lb[i] = row.lb * row.rii;
                ub[i] = row.ub * row.rii;
                coef[i] = 0;
            }
            for (j = 1; j <= n; j++) {
                col = lp.col[j];
                type[m + j] = col.type;
                lb[m + j] = col.lb / col.sjj;
                ub[m + j] = col.ub / col.sjj;
                coef[m + j] = col.coef * col.sjj;
            }
            xcopyArr(orig_type, 1, type, 1, m + n);
            xcopyArr(orig_lb, 1, lb, 1, m + n);
            xcopyArr(orig_ub, 1, ub, 1, m + n);
            obj[0] = lp.c0;
            xcopyArr(obj, 1, coef, m + 1, n);
            cmax = 0;
            for (j = 1; j <= n; j++)
                if (cmax < Math.abs(obj[j]))
                    cmax = Math.abs(obj[j]);
            if (cmax == 0)
                cmax = 1;
            switch (lp.dir) {
            case GLP_MIN:
                csa.zeta = +1 / cmax;
                break;
            case GLP_MAX:
                csa.zeta = -1 / cmax;
                break;
            default:
                xassert(lp != lp);
            }
            if (Math.abs(csa.zeta) < 1)
                csa.zeta *= 1000;
            for (j = 1; j <= n; j++)
                coef[m + j] *= csa.zeta;
            chrome_workaround_1(csa, lp);
            chrome_workaround_2(csa, lp);
            xassert(lp.valid);
            xcopyArr(head, 1, lp.head, 1, m);
            k = 0;
            for (i = 1; i <= m; i++) {
                row = lp.row[i];
                if (row.stat != GLP_BS) {
                    k++;
                    xassert(k <= n);
                    head[m + k] = i;
                    stat[k] = row.stat;
                }
            }
            for (j = 1; j <= n; j++) {
                col = lp.col[j];
                if (col.stat != GLP_BS) {
                    k++;
                    xassert(k <= n);
                    head[m + k] = m + j;
                    stat[k] = col.stat;
                }
            }
            xassert(k == n);
            for (k = 1; k <= m + n; k++)
                bind[head[k]] = k;
            csa.valid = 1;
            lp.valid = 0;
            csa.bfd = lp.bfd;
            lp.bfd = null;
            csa.phase = 0;
            csa.tm_beg = xtime();
            csa.it_beg = csa.it_cnt = lp.it_cnt;
            csa.it_dpy = -1;
            csa.refct = 0;
            xfillArr(refsp, 1, 0, m + n);
            for (i = 1; i <= m; i++)
                gamma[i] = 1;
        }
        function inv_col(csa, i, ind, val) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var head = csa.head;
            var k, len, ptr, t;
            if (GLP_DEBUG) {
                xassert(1 <= i && i <= m);
            }
            k = head[i];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            if (k <= m) {
                len = 1;
                ind[1] = k;
                val[1] = 1;
            } else {
                ptr = A_ptr[k - m];
                len = A_ptr[k - m + 1] - ptr;
                xcopyArr(ind, 1, A_ind, ptr, len);
                xcopyArr(val, 1, A_val, ptr, len);
                for (t = 1; t <= len; t++)
                    val[t] = -val[t];
            }
            return len;
        }
        function invert_B(csa) {
            var ret = bfd_factorize(csa.bfd, csa.m, null, inv_col, csa);
            csa.valid = ret == 0;
            return ret;
        }
        function update_B(csa, i, k) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var ret, val;
            if (GLP_DEBUG) {
                xassert(1 <= i && i <= m);
                xassert(1 <= k && k <= m + n);
            }
            if (k <= m) {
                var ind = new Array(1 + 1);
                val = new Array(1 + 1);
                ind[1] = k;
                val[1] = 1;
                xassert(csa.valid);
                ret = bfd_update_it(csa.bfd, i, 0, 1, ind, 0, val);
            } else {
                var A_ptr = csa.A_ptr;
                var A_ind = csa.A_ind;
                var A_val = csa.A_val;
                val = csa.work1;
                var beg, end, ptr, len;
                beg = A_ptr[k - m];
                end = A_ptr[k - m + 1];
                len = 0;
                for (ptr = beg; ptr < end; ptr++)
                    val[++len] = -A_val[ptr];
                xassert(csa.valid);
                ret = bfd_update_it(csa.bfd, i, 0, len, A_ind, beg - 1, val);
            }
            csa.valid = ret == 0;
            return ret;
        }
        function error_ftran(csa, h, x, r) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var head = csa.head;
            var i, k, beg, end, ptr;
            var temp;
            xcopyArr(r, 1, h, 1, m);
            for (i = 1; i <= m; i++) {
                temp = x[i];
                if (temp == 0)
                    continue;
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (k <= m) {
                    r[k] -= temp;
                } else {
                    beg = A_ptr[k - m];
                    end = A_ptr[k - m + 1];
                    for (ptr = beg; ptr < end; ptr++)
                        r[A_ind[ptr]] += A_val[ptr] * temp;
                }
            }
        }
        function refine_ftran(csa, h, x) {
            var m = csa.m;
            var r = csa.work1;
            var d = csa.work1;
            var i;
            error_ftran(csa, h, x, r);
            xassert(csa.valid);
            bfd_ftran(csa.bfd, d);
            for (i = 1; i <= m; i++)
                x[i] += d[i];
        }
        function error_btran(csa, h, x, r) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var head = csa.head;
            var i, k, beg, end, ptr;
            var temp;
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                temp = h[i];
                if (k <= m) {
                    temp -= x[k];
                } else {
                    beg = A_ptr[k - m];
                    end = A_ptr[k - m + 1];
                    for (ptr = beg; ptr < end; ptr++)
                        temp += A_val[ptr] * x[A_ind[ptr]];
                }
                r[i] = temp;
            }
        }
        function refine_btran(csa, h, x) {
            var m = csa.m;
            var r = csa.work1;
            var d = csa.work1;
            var i;
            error_btran(csa, h, x, r);
            xassert(csa.valid);
            bfd_btran(csa.bfd, d);
            for (i = 1; i <= m; i++)
                x[i] += d[i];
        }
        function get_xN(csa, j) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var lb = csa.lb;
            var ub = csa.ub;
            var head = csa.head;
            var stat = csa.stat;
            var k;
            var xN;
            if (GLP_DEBUG) {
                xassert(1 <= j && j <= n);
            }
            k = head[m + j];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            switch (stat[j]) {
            case GLP_NL:
                xN = lb[k];
                break;
            case GLP_NU:
                xN = ub[k];
                break;
            case GLP_NF:
                xN = 0;
                break;
            case GLP_NS:
                xN = lb[k];
                break;
            default:
                xassert(stat != stat);
            }
            return xN;
        }
        function eval_beta(csa, beta) {
            var m = csa.m;
            var n = csa.n;
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var head = csa.head;
            var h = csa.work2;
            var i, j, k, beg, end, ptr;
            var xN;
            for (i = 1; i <= m; i++)
                h[i] = 0;
            for (j = 1; j <= n; j++) {
                k = head[m + j];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                xN = get_xN(csa, j);
                if (xN == 0)
                    continue;
                if (k <= m) {
                    h[k] -= xN;
                } else {
                    beg = A_ptr[k - m];
                    end = A_ptr[k - m + 1];
                    for (ptr = beg; ptr < end; ptr++)
                        h[A_ind[ptr]] += xN * A_val[ptr];
                }
            }
            xcopyArr(beta, 1, h, 1, m);
            xassert(csa.valid);
            bfd_ftran(csa.bfd, beta);
            refine_ftran(csa, h, beta);
        }
        function eval_pi(csa, pi) {
            var m = csa.m;
            var c = csa.coef;
            var head = csa.head;
            var cB = csa.work2;
            var i;
            for (i = 1; i <= m; i++)
                cB[i] = c[head[i]];
            xcopyArr(pi, 1, cB, 1, m);
            xassert(csa.valid);
            bfd_btran(csa.bfd, pi);
            refine_btran(csa, cB, pi);
        }
        function eval_cost(csa, pi, j) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var coef = csa.coef;
            var head = csa.head;
            var k;
            var dj;
            if (GLP_DEBUG) {
                xassert(1 <= j && j <= n);
            }
            k = head[m + j];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            dj = coef[k];
            if (k <= m) {
                dj -= pi[k];
            } else {
                var A_ptr = csa.A_ptr;
                var A_ind = csa.A_ind;
                var A_val = csa.A_val;
                var beg, end, ptr;
                beg = A_ptr[k - m];
                end = A_ptr[k - m + 1];
                for (ptr = beg; ptr < end; ptr++)
                    dj += A_val[ptr] * pi[A_ind[ptr]];
            }
            return dj;
        }
        function eval_bbar(csa) {
            eval_beta(csa, csa.bbar);
        }
        function eval_cbar(csa) {
            if (GLP_DEBUG) {
                var m = csa.m;
            }
            var n = csa.n;
            if (GLP_DEBUG) {
                var head = csa.head;
            }
            var cbar = csa.cbar;
            var pi = csa.work3;
            var j;
            if (GLP_DEBUG) {
                var k;
            }
            eval_pi(csa, pi);
            for (j = 1; j <= n; j++) {
                if (GLP_DEBUG) {
                    k = head[m + j];
                    xassert(1 <= k && k <= m + n);
                }
                cbar[j] = eval_cost(csa, pi, j);
            }
        }
        function reset_refsp(csa) {
            var m = csa.m;
            var n = csa.n;
            var head = csa.head;
            var refsp = csa.refsp;
            var gamma = csa.gamma;
            var i, k;
            xassert(csa.refct == 0);
            csa.refct = 1000;
            xfillArr(refsp, 1, 0, m + n);
            for (i = 1; i <= m; i++) {
                k = head[i];
                refsp[k] = 1;
                gamma[i] = 1;
            }
        }
        function eval_gamma(csa, gamma) {
            var m = csa.m;
            var n = csa.n;
            var type = csa.type;
            var head = csa.head;
            var refsp = csa.refsp;
            var alfa = csa.work3;
            var h = csa.work3;
            var i, j, k;
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (type[k] == GLP_FR)
                    gamma[i] = 1;
                else
                    gamma[i] = refsp[k] ? 1 : 0;
            }
            for (j = 1; j <= n; j++) {
                k = head[m + j];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (!refsp[k])
                    continue;
                if (GLP_DEBUG) {
                    xassert(type[k] != GLP_FX);
                }
                for (i = 1; i <= m; i++)
                    h[i] = 0;
                if (k <= m) {
                    h[k] = -1;
                } else {
                    var A_ptr = csa.A_ptr;
                    var A_ind = csa.A_ind;
                    var A_val = csa.A_val;
                    var beg, end, ptr;
                    beg = A_ptr[k - m];
                    end = A_ptr[k - m + 1];
                    for (ptr = beg; ptr < end; ptr++)
                        h[A_ind[ptr]] = A_val[ptr];
                }
                xassert(csa.valid);
                bfd_ftran(csa.bfd, alfa);
                for (i = 1; i <= m; i++) {
                    k = head[i];
                    if (type[k] != GLP_FR)
                        gamma[i] += alfa[i] * alfa[i];
                }
            }
        }
        function chuzr(csa, tol_bnd) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var type = csa.type;
            var lb = csa.lb;
            var ub = csa.ub;
            var head = csa.head;
            var bbar = csa.bbar;
            var gamma = csa.gamma;
            var i, k, p;
            var delta, best, eps, ri, temp;
            p = 0;
            delta = 0;
            best = 0;
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                ri = 0;
                if (type[k] == GLP_LO || type[k] == GLP_DB || type[k] == GLP_FX) {
                    eps = tol_bnd * (1 + kappa * Math.abs(lb[k]));
                    if (bbar[i] < lb[k] - eps) {
                        ri = lb[k] - bbar[i];
                    }
                }
                if (type[k] == GLP_UP || type[k] == GLP_DB || type[k] == GLP_FX) {
                    eps = tol_bnd * (1 + kappa * Math.abs(ub[k]));
                    if (bbar[i] > ub[k] + eps) {
                        ri = ub[k] - bbar[i];
                    }
                }
                if (ri == 0)
                    continue;
                if (GLP_DEBUG) {
                    xassert(gamma[i] >= 0);
                }
                temp = gamma[i];
                if (temp < DBL_EPSILON)
                    temp = DBL_EPSILON;
                temp = ri * ri / temp;
                if (best < temp) {
                    p = i;
                    delta = ri;
                    best = temp;
                }
            }
            csa.p = p;
            csa.delta = delta;
        }
        function eval_rho(csa, e) {
            var m = csa.m;
            var p = csa.p;
            var i;
            if (GLP_DEBUG) {
                xassert(1 <= p && p <= m);
            }
            for (i = 1; i <= m; i++)
                e[i] = 0;
            e[p] = 1;
            xassert(csa.valid);
            bfd_btran(csa.bfd, rho);
        }
        function refine_rho(csa, rho) {
            var m = csa.m;
            var p = csa.p;
            var e = csa.work3;
            var i;
            if (GLP_DEBUG) {
                xassert(1 <= p && p <= m);
            }
            for (i = 1; i <= m; i++)
                e[i] = 0;
            e[p] = 1;
            refine_btran(csa, e, rho);
        }
        function eval_trow1(csa, rho) {
            var m = csa.m;
            var n = csa.n;
            var A_ptr = csa.A_ptr;
            var A_ind = csa.A_ind;
            var A_val = csa.A_val;
            var head = csa.head;
            var stat = csa.stat;
            var trow_ind = csa.trow_ind;
            var trow_vec = csa.trow_vec;
            var j, k, beg, end, ptr, nnz;
            var temp;
            nnz = 0;
            for (j = 1; j <= n; j++) {
                if (stat[j] == GLP_NS) {
                    trow_vec[j] = 0;
                    continue;
                }
                k = head[m + j];
                if (k <= m) {
                    temp = -rho[k];
                } else {
                    beg = A_ptr[k - m];
                    end = A_ptr[k - m + 1];
                    temp = 0;
                    for (ptr = beg; ptr < end; ptr++)
                        temp += rho[A_ind[ptr]] * A_val[ptr];
                }
                if (temp != 0)
                    trow_ind[++nnz] = j;
                trow_vec[j] = temp;
            }
            csa.trow_nnz = nnz;
        }
        function eval_trow2(csa, rho) {
            var m = csa.m;
            var n = csa.n;
            var AT_ptr = csa.AT_ptr;
            var AT_ind = csa.AT_ind;
            var AT_val = csa.AT_val;
            var bind = csa.bind;
            var stat = csa.stat;
            var trow_ind = csa.trow_ind;
            var trow_vec = csa.trow_vec;
            var i, j, beg, end, ptr, nnz;
            var temp;
            for (j = 1; j <= n; j++)
                trow_vec[j] = 0;
            for (i = 1; i <= m; i++) {
                temp = rho[i];
                if (temp == 0)
                    continue;
                j = bind[i] - m;
                if (j >= 1 && stat[j] != GLP_NS)
                    trow_vec[j] -= temp;
                beg = AT_ptr[i];
                end = AT_ptr[i + 1];
                for (ptr = beg; ptr < end; ptr++) {
                    j = bind[m + AT_ind[ptr]] - m;
                    if (j >= 1 && stat[j] != GLP_NS)
                        trow_vec[j] += temp * AT_val[ptr];
                }
            }
            nnz = 0;
            for (j = 1; j <= n; j++) {
                if (trow_vec[j] != 0)
                    trow_ind[++nnz] = j;
            }
            csa.trow_nnz = nnz;
        }
        function eval_trow(csa, rho) {
            var m = csa.m;
            var i, nnz;
            var dens;
            nnz = 0;
            for (i = 1; i <= m; i++)
                if (rho[i] != 0)
                    nnz++;
            dens = nnz / m;
            if (dens >= 0.2) {
                eval_trow1(csa, rho);
            } else {
                eval_trow2(csa, rho);
            }
        }
        function sort_trow(csa, tol_piv) {
            if (GLP_DEBUG) {
                var n = csa.n;
                var stat = csa.stat;
            }
            var nnz = csa.trow_nnz;
            var trow_ind = csa.trow_ind;
            var trow_vec = csa.trow_vec;
            var j, num, pos;
            var big, eps, temp;
            big = 0;
            for (pos = 1; pos <= nnz; pos++) {
                if (GLP_DEBUG) {
                    j = trow_ind[pos];
                    xassert(1 <= j && j <= n);
                    xassert(stat[j] != GLP_NS);
                }
                temp = Math.abs(trow_vec[trow_ind[pos]]);
                if (big < temp)
                    big = temp;
            }
            csa.trow_max = big;
            eps = tol_piv * (1 + 0.01 * big);
            for (num = 0; num < nnz;) {
                j = trow_ind[nnz];
                if (Math.abs(trow_vec[j]) < eps)
                    nnz--;
                else {
                    num++;
                    trow_ind[nnz] = trow_ind[num];
                    trow_ind[num] = j;
                }
            }
            csa.trow_num = num;
        }
        function chuzc(csa, rtol) {
            if (GLP_DEBUG) {
                var m = csa.m;
                var n = csa.n;
            }
            var stat = csa.stat;
            var cbar = csa.cbar;
            if (GLP_DEBUG) {
                var p = csa.p;
            }
            var delta = csa.delta;
            var trow_ind = csa.trow_ind;
            var trow_vec = csa.trow_vec;
            var trow_num = csa.trow_num;
            var j, pos, q;
            var alfa, big, s, t, teta, tmax;
            if (GLP_DEBUG) {
                xassert(1 <= p && p <= m);
            }
            if (GLP_DEBUG) {
                xassert(delta != 0);
            }
            s = delta > 0 ? +1 : -1;
            q = 0;
            teta = DBL_MAX;
            big = 0;
            for (pos = 1; pos <= trow_num; pos++) {
                j = trow_ind[pos];
                if (GLP_DEBUG) {
                    xassert(1 <= j && j <= n);
                }
                alfa = s * trow_vec[j];
                if (GLP_DEBUG) {
                    xassert(alfa != 0);
                }
                if (alfa > 0) {
                    if (stat[j] == GLP_NL || stat[j] == GLP_NF) {
                        t = (cbar[j] + rtol) / alfa;
                    } else {
                        continue;
                    }
                } else {
                    if (stat[j] == GLP_NU || stat[j] == GLP_NF) {
                        t = (cbar[j] - rtol) / alfa;
                    } else {
                        continue;
                    }
                }
                if (t < 0)
                    t = 0;
                if (teta > t || teta == t && big < Math.abs(alfa)) {
                    q = j;
                    teta = t;
                    big = Math.abs(alfa);
                }
            }
            if (rtol == 0)
                return done();
            if (q == 0)
                return done();
            if (teta == 0)
                return done();
            tmax = teta;
            q = 0;
            teta = DBL_MAX;
            big = 0;
            for (pos = 1; pos <= trow_num; pos++) {
                j = trow_ind[pos];
                if (GLP_DEBUG) {
                    xassert(1 <= j && j <= n);
                }
                alfa = s * trow_vec[j];
                if (GLP_DEBUG) {
                    xassert(alfa != 0);
                }
                if (alfa > 0) {
                    if (stat[j] == GLP_NL || stat[j] == GLP_NF) {
                        t = cbar[j] / alfa;
                    } else {
                        continue;
                    }
                } else {
                    if (stat[j] == GLP_NU || stat[j] == GLP_NF) {
                        t = cbar[j] / alfa;
                    } else {
                        continue;
                    }
                }
                if (t < 0)
                    t = 0;
                if (t <= tmax && big < Math.abs(alfa)) {
                    q = j;
                    teta = t;
                    big = Math.abs(alfa);
                }
            }
            xassert(q != 0);
            function done() {
                csa.q = q;
                csa.new_dq = s * teta;
            }
            done();
        }
        function eval_tcol(csa) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var head = csa.head;
            var q = csa.q;
            var tcol_ind = csa.tcol_ind;
            var tcol_vec = csa.tcol_vec;
            var h = csa.tcol_vec;
            var i, k, nnz;
            if (GLP_DEBUG) {
                xassert(1 <= q && q <= n);
            }
            k = head[m + q];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            for (i = 1; i <= m; i++)
                h[i] = 0;
            if (k <= m) {
                h[k] = -1;
            } else {
                var A_ptr = csa.A_ptr;
                var A_ind = csa.A_ind;
                var A_val = csa.A_val;
                var beg, end, ptr;
                beg = A_ptr[k - m];
                end = A_ptr[k - m + 1];
                for (ptr = beg; ptr < end; ptr++)
                    h[A_ind[ptr]] = A_val[ptr];
            }
            xassert(csa.valid);
            bfd_ftran(csa.bfd, tcol_vec);
            nnz = 0;
            for (i = 1; i <= m; i++) {
                if (tcol_vec[i] != 0)
                    tcol_ind[++nnz] = i;
            }
            csa.tcol_nnz = nnz;
        }
        function refine_tcol(csa) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var head = csa.head;
            var q = csa.q;
            var tcol_ind = csa.tcol_ind;
            var tcol_vec = csa.tcol_vec;
            var h = csa.work3;
            var i, k, nnz;
            if (GLP_DEBUG) {
                xassert(1 <= q && q <= n);
            }
            k = head[m + q];
            if (GLP_DEBUG) {
                xassert(1 <= k && k <= m + n);
            }
            for (i = 1; i <= m; i++)
                h[i] = 0;
            if (k <= m) {
                h[k] = -1;
            } else {
                var A_ptr = csa.A_ptr;
                var A_ind = csa.A_ind;
                var A_val = csa.A_val;
                var beg, end, ptr;
                beg = A_ptr[k - m];
                end = A_ptr[k - m + 1];
                for (ptr = beg; ptr < end; ptr++)
                    h[A_ind[ptr]] = A_val[ptr];
            }
            refine_ftran(csa, h, tcol_vec);
            nnz = 0;
            for (i = 1; i <= m; i++) {
                if (tcol_vec[i] != 0)
                    tcol_ind[++nnz] = i;
            }
            csa.tcol_nnz = nnz;
        }
        function update_cbar(csa) {
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var cbar = csa.cbar;
            var trow_nnz = csa.trow_nnz;
            var trow_ind = csa.trow_ind;
            var trow_vec = csa.trow_vec;
            var q = csa.q;
            var new_dq = csa.new_dq;
            var j, pos;
            if (GLP_DEBUG) {
                xassert(1 <= q && q <= n);
            }
            cbar[q] = new_dq;
            if (new_dq == 0)
                return;
            for (pos = 1; pos <= trow_nnz; pos++) {
                j = trow_ind[pos];
                if (GLP_DEBUG) {
                    xassert(1 <= j && j <= n);
                }
                if (j != q)
                    cbar[j] -= trow_vec[j] * new_dq;
            }
        }
        function update_bbar(csa) {
            if (GLP_DEBUG) {
                var m = csa.m;
                var n = csa.n;
            }
            var bbar = csa.bbar;
            var p = csa.p;
            var delta = csa.delta;
            var q = csa.q;
            var tcol_nnz = csa.tcol_nnz;
            var tcol_ind = csa.tcol_ind;
            var tcol_vec = csa.tcol_vec;
            var i, pos;
            var teta;
            if (GLP_DEBUG) {
                xassert(1 <= p && p <= m);
                xassert(1 <= q && q <= n);
                xassert(tcol_vec[p] != 0);
            }
            teta = delta / tcol_vec[p];
            bbar[p] = get_xN(csa, q) + teta;
            if (teta == 0)
                return;
            for (pos = 1; pos <= tcol_nnz; pos++) {
                i = tcol_ind[pos];
                if (GLP_DEBUG) {
                    xassert(1 <= i && i <= m);
                }
                if (i != p)
                    bbar[i] += tcol_vec[i] * teta;
            }
        }
        function update_gamma(csa) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var type = csa.type;
            var head = csa.head;
            var refsp = csa.refsp;
            var gamma = csa.gamma;
            var p = csa.p;
            var trow_nnz = csa.trow_nnz;
            var trow_ind = csa.trow_ind;
            var trow_vec = csa.trow_vec;
            var q = csa.q;
            var tcol_nnz = csa.tcol_nnz;
            var tcol_ind = csa.tcol_ind;
            var tcol_vec = csa.tcol_vec;
            var u = csa.work3;
            var i, j, k, pos;
            var gamma_p, eta_p, pivot, t, t1, t2;
            if (GLP_DEBUG) {
                xassert(1 <= p && p <= m);
                xassert(1 <= q && q <= n);
            }
            xassert(csa.refct > 0);
            csa.refct--;
            if (GLP_DEBUG) {
                xassert(type[head[p]] != GLP_FR);
            }
            gamma_p = eta_p = refsp[head[p]] ? 1 : 0;
            for (i = 1; i <= m; i++)
                u[i] = 0;
            for (pos = 1; pos <= trow_nnz; pos++) {
                j = trow_ind[pos];
                if (GLP_DEBUG) {
                    xassert(1 <= j && j <= n);
                }
                k = head[m + j];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                    xassert(type[k] != GLP_FX);
                }
                if (!refsp[k])
                    continue;
                t = trow_vec[j];
                gamma_p += t * t;
                if (k <= m) {
                    u[k] += t;
                } else {
                    var A_ptr = csa.A_ptr;
                    var A_ind = csa.A_ind;
                    var A_val = csa.A_val;
                    var beg, end, ptr;
                    beg = A_ptr[k - m];
                    end = A_ptr[k - m + 1];
                    for (ptr = beg; ptr < end; ptr++)
                        u[A_ind[ptr]] -= t * A_val[ptr];
                }
            }
            xassert(csa.valid);
            bfd_ftran(csa.bfd, u);
            pivot = tcol_vec[p];
            if (GLP_DEBUG) {
                xassert(pivot != 0);
            }
            for (pos = 1; pos <= tcol_nnz; pos++) {
                i = tcol_ind[pos];
                if (GLP_DEBUG) {
                    xassert(1 <= i && i <= m);
                }
                k = head[i];
                if (GLP_DEBUG) {
                    xassert(1 <= k && k <= m + n);
                }
                if (i == p)
                    continue;
                if (type[head[i]] == GLP_FR) {
                    if (GLP_DEBUG) {
                        xassert(gamma[i] == 1);
                    }
                    continue;
                }
                t = tcol_vec[i] / pivot;
                t1 = gamma[i] + t * t * gamma_p + 2 * t * u[i];
                t2 = (refsp[k] ? 1 : 0) + eta_p * t * t;
                gamma[i] = t1 >= t2 ? t1 : t2;
                if (gamma[i] < DBL_EPSILON)
                    gamma[i] = DBL_EPSILON;
            }
            if (type[head[m + q]] == GLP_FR)
                gamma[p] = 1;
            else {
                gamma[p] = gamma_p / (pivot * pivot);
                if (gamma[p] < DBL_EPSILON)
                    gamma[p] = DBL_EPSILON;
            }
            k = head[p];
            if (type[k] == GLP_FX && refsp[k]) {
                refsp[k] = 0;
                for (pos = 1; pos <= tcol_nnz; pos++) {
                    i = tcol_ind[pos];
                    if (i == p) {
                        if (type[head[m + q]] == GLP_FR)
                            continue;
                        t = 1 / tcol_vec[p];
                    } else {
                        if (type[head[i]] == GLP_FR)
                            continue;
                        t = tcol_vec[i] / tcol_vec[p];
                    }
                    gamma[i] -= t * t;
                    if (gamma[i] < DBL_EPSILON)
                        gamma[i] = DBL_EPSILON;
                }
            }
        }
        function err_in_bbar(csa) {
            var m = csa.m;
            var bbar = csa.bbar;
            var i;
            var e, emax;
            var beta = new Float64Array(1 + m);
            eval_beta(csa, beta);
            emax = 0;
            for (i = 1; i <= m; i++) {
                e = Math.abs(beta[i] - bbar[i]) / (1 + Math.abs(beta[i]));
                if (emax < e)
                    emax = e;
            }
            return emax;
        }
        function err_in_cbar(csa) {
            var m = csa.m;
            var n = csa.n;
            var stat = csa.stat;
            var cbar = csa.cbar;
            var j;
            var e, emax, cost;
            var pi = new Float64Array(1 + m);
            eval_pi(csa, pi);
            emax = 0;
            for (j = 1; j <= n; j++) {
                if (stat[j] == GLP_NS)
                    continue;
                cost = eval_cost(csa, pi, j);
                e = Math.abs(cost - cbar[j]) / (1 + Math.abs(cost));
                if (emax < e)
                    emax = e;
            }
            return emax;
        }
        function err_in_gamma(csa) {
            var m = csa.m;
            var type = csa.type;
            var head = csa.head;
            var gamma = csa.gamma;
            var exact = csa.work4;
            var i;
            var e, emax, temp;
            eval_gamma(csa, exact);
            emax = 0;
            for (i = 1; i <= m; i++) {
                if (type[head[i]] == GLP_FR) {
                    xassert(gamma[i] == 1);
                    xassert(exact[i] == 1);
                    continue;
                }
                temp = exact[i];
                e = Math.abs(temp - gamma[i]) / (1 + Math.abs(temp));
                if (emax < e)
                    emax = e;
            }
            return emax;
        }
        function change_basis(csa) {
            var m = csa.m;
            if (GLP_DEBUG) {
                var n = csa.n;
            }
            var type = csa.type;
            var head = csa.head;
            var bind = csa.bind;
            var stat = csa.stat;
            var p = csa.p;
            var delta = csa.delta;
            var q = csa.q;
            var k;
            if (GLP_DEBUG) {
                xassert(1 <= p && p <= m);
                xassert(1 <= q && q <= n);
            }
            k = head[p];
            head[p] = head[m + q];
            head[m + q] = k;
            bind[head[p]] = p;
            bind[head[m + q]] = m + q;
            if (type[k] == GLP_FX)
                stat[q] = GLP_NS;
            else if (delta > 0) {
                if (GLP_DEBUG) {
                    xassert(type[k] == GLP_LO || type[k] == GLP_DB);
                }
                stat[q] = GLP_NL;
            } else {
                if (GLP_DEBUG)
                    xassert(type[k] == GLP_UP || type[k] == GLP_DB);
                stat[q] = GLP_NU;
            }
        }
        function check_feas(csa, tol_dj) {
            var m = csa.m;
            var n = csa.n;
            var orig_type = csa.orig_type;
            var head = csa.head;
            var cbar = csa.cbar;
            var j, k;
            for (j = 1; j <= n; j++) {
                k = head[m + j];
                if (GLP_DEBUG)
                    xassert(1 <= k && k <= m + n);
                if (cbar[j] < -tol_dj)
                    if (orig_type[k] == GLP_LO || orig_type[k] == GLP_FR)
                        return 1;
                if (cbar[j] > +tol_dj)
                    if (orig_type[k] == GLP_UP || orig_type[k] == GLP_FR)
                        return 1;
            }
            return 0;
        }
        function set_aux_bnds(csa) {
            var m = csa.m;
            var n = csa.n;
            var type = csa.type;
            var lb = csa.lb;
            var ub = csa.ub;
            var orig_type = csa.orig_type;
            var head = csa.head;
            var stat = csa.stat;
            var cbar = csa.cbar;
            var j, k;
            for (k = 1; k <= m + n; k++) {
                switch (orig_type[k]) {
                case GLP_FR:
                    type[k] = GLP_DB;
                    lb[k] = -1000;
                    ub[k] = +1000;
                    break;
                case GLP_LO:
                    type[k] = GLP_DB;
                    lb[k] = 0;
                    ub[k] = +1;
                    break;
                case GLP_UP:
                    type[k] = GLP_DB;
                    lb[k] = -1;
                    ub[k] = 0;
                    break;
                case GLP_DB:
                case GLP_FX:
                    type[k] = GLP_FX;
                    lb[k] = ub[k] = 0;
                    break;
                default:
                    xassert(orig_type != orig_type);
                }
            }
            for (j = 1; j <= n; j++) {
                k = head[m + j];
                if (GLP_DEBUG)
                    xassert(1 <= k && k <= m + n);
                if (type[k] == GLP_FX)
                    stat[j] = GLP_NS;
                else if (cbar[j] >= 0)
                    stat[j] = GLP_NL;
                else
                    stat[j] = GLP_NU;
            }
        }
        function set_orig_bnds(csa) {
            var m = csa.m;
            var n = csa.n;
            var type = csa.type;
            var lb = csa.lb;
            var ub = csa.ub;
            var orig_type = csa.orig_type;
            var orig_lb = csa.orig_lb;
            var orig_ub = csa.orig_ub;
            var head = csa.head;
            var stat = csa.stat;
            var cbar = csa.cbar;
            var j, k;
            xcopyArr(type, 1, orig_type, 1, m + n);
            xcopyArr(lb, 1, orig_lb, 1, m + n);
            xcopyArr(ub, 1, orig_ub, 1, m + n);
            for (j = 1; j <= n; j++) {
                k = head[m + j];
                if (GLP_DEBUG)
                    xassert(1 <= k && k <= m + n);
                switch (type[k]) {
                case GLP_FR:
                    stat[j] = GLP_NF;
                    break;
                case GLP_LO:
                    stat[j] = GLP_NL;
                    break;
                case GLP_UP:
                    stat[j] = GLP_NU;
                    break;
                case GLP_DB:
                    if (cbar[j] >= +DBL_EPSILON)
                        stat[j] = GLP_NL;
                    else if (cbar[j] <= -DBL_EPSILON)
                        stat[j] = GLP_NU;
                    else if (Math.abs(lb[k]) <= Math.abs(ub[k]))
                        stat[j] = GLP_NL;
                    else
                        stat[j] = GLP_NU;
                    break;
                case GLP_FX:
                    stat[j] = GLP_NS;
                    break;
                default:
                    xassert(type != type);
                }
            }
        }
        function check_stab(csa, tol_dj) {
            var n = csa.n;
            var stat = csa.stat;
            var cbar = csa.cbar;
            var j;
            for (j = 1; j <= n; j++) {
                if (cbar[j] < -tol_dj)
                    if (stat[j] == GLP_NL || stat[j] == GLP_NF)
                        return 1;
                if (cbar[j] > +tol_dj)
                    if (stat[j] == GLP_NU || stat[j] == GLP_NF)
                        return 1;
            }
            return 0;
        }
        function eval_obj(csa) {
            var m = csa.m;
            var n = csa.n;
            var obj = csa.obj;
            var head = csa.head;
            var bbar = csa.bbar;
            var i, j, k;
            var sum;
            sum = obj[0];
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG)
                    xassert(1 <= k && k <= m + n);
                if (k > m)
                    sum += obj[k - m] * bbar[i];
            }
            for (j = 1; j <= n; j++) {
                k = head[m + j];
                if (GLP_DEBUG)
                    xassert(1 <= k && k <= m + n);
                if (k > m)
                    sum += obj[k - m] * get_xN(csa, j);
            }
            return sum;
        }
        function display(csa, parm, spec) {
            var m = csa.m;
            var n = csa.n;
            var coef = csa.coef;
            var orig_type = csa.orig_type;
            var head = csa.head;
            var stat = csa.stat;
            var phase = csa.phase;
            var bbar = csa.bbar;
            var cbar = csa.cbar;
            var i, j, cnt;
            var sum;
            if (parm.msg_lev < GLP_MSG_ON)
                return;
            if (parm.out_dly > 0 && 1000 * xdifftime(xtime(), csa.tm_beg) < parm.out_dly)
                return;
            if (csa.it_cnt == csa.it_dpy)
                return;
            if (!spec && csa.it_cnt % parm.out_frq != 0)
                return;
            sum = 0;
            if (phase == 1) {
                for (i = 1; i <= m; i++)
                    sum -= coef[head[i]] * bbar[i];
                for (j = 1; j <= n; j++)
                    sum -= coef[head[m + j]] * get_xN(csa, j);
            } else {
                for (j = 1; j <= n; j++) {
                    if (cbar[j] < 0)
                        if (stat[j] == GLP_NL || stat[j] == GLP_NF)
                            sum -= cbar[j];
                    if (cbar[j] > 0)
                        if (stat[j] == GLP_NU || stat[j] == GLP_NF)
                            sum += cbar[j];
                }
            }
            cnt = 0;
            for (i = 1; i <= m; i++)
                if (orig_type[head[i]] == GLP_FX)
                    cnt++;
            if (csa.phase == 1)
                xprintf(' ' + csa.it_cnt + ':  infeas = ' + sum + ' (' + cnt + ')');
            else
                xprintf('|' + csa.it_cnt + ': obj = ' + eval_obj(csa) + '  infeas = ' + sum + ' (' + cnt + ')');
            csa.it_dpy = csa.it_cnt;
        }
        function store_sol(csa, lp, p_stat, d_stat, ray) {
            var m = csa.m;
            var n = csa.n;
            var zeta = csa.zeta;
            var head = csa.head;
            var stat = csa.stat;
            var bbar = csa.bbar;
            var cbar = csa.cbar;
            var i, j, k;
            var col, row;
            if (GLP_DEBUG) {
                xassert(lp.m == m);
                xassert(lp.n == n);
                xassert(!lp.valid && lp.bfd == null);
                xassert(csa.valid && csa.bfd != null);
            }
            lp.valid = 1;
            csa.valid = 0;
            lp.bfd = csa.bfd;
            csa.bfd = null;
            xcopyArr(lp.head, 1, head, 1, m);
            lp.pbs_stat = p_stat;
            lp.dbs_stat = d_stat;
            lp.obj_val = eval_obj(csa);
            lp.it_cnt = csa.it_cnt;
            lp.some = ray;
            for (i = 1; i <= m; i++) {
                k = head[i];
                if (GLP_DEBUG)
                    xassert(1 <= k && k <= m + n);
                if (k <= m) {
                    row = lp.row[k];
                    row.stat = GLP_BS;
                    row.bind = i;
                    row.prim = bbar[i] / row.rii;
                    row.dual = 0;
                } else {
                    col = lp.col[k - m];
                    col.stat = GLP_BS;
                    col.bind = i;
                    col.prim = bbar[i] * col.sjj;
                    col.dual = 0;
                }
            }
            for (j = 1; j <= n; j++) {
                k = head[m + j];
                if (GLP_DEBUG)
                    xassert(1 <= k && k <= m + n);
                if (k <= m) {
                    row = lp.row[k];
                    row.stat = stat[j];
                    row.bind = 0;
                    switch (stat[j]) {
                    case GLP_NL:
                        row.prim = row.lb;
                        break;
                    case GLP_NU:
                        row.prim = row.ub;
                        break;
                    case GLP_NF:
                        row.prim = 0;
                        break;
                    case GLP_NS:
                        row.prim = row.lb;
                        break;
                    default:
                        xassert(stat != stat);
                    }
                    row.dual = cbar[j] * row.rii / zeta;
                } else {
                    col = lp.col[k - m];
                    col.stat = stat[j];
                    col.bind = 0;
                    switch (stat[j]) {
                    case GLP_NL:
                        col.prim = col.lb;
                        break;
                    case GLP_NU:
                        col.prim = col.ub;
                        break;
                    case GLP_NF:
                        col.prim = 0;
                        break;
                    case GLP_NS:
                        col.prim = col.lb;
                        break;
                    default:
                        xassert(stat != stat);
                    }
                    col.dual = cbar[j] / col.sjj / zeta;
                }
            }
        }
        var csa;
        var binv_st = 2;
        var bbar_st = 0;
        var cbar_st = 0;
        var rigorous = 0;
        var check = 0;
        var p_stat, d_stat, ret;
        csa = alloc_csa(lp);
        init_csa(csa, lp);
        if (parm.msg_lev >= GLP_MSG_DBG)
            xprintf('Objective scale factor = ' + csa.zeta + '');
        while (true) {
            if (binv_st == 0) {
                ret = invert_B(csa);
                if (ret != 0) {
                    if (parm.msg_lev >= GLP_MSG_ERR) {
                        xprintf('Error: unable to factorize the basis matrix (' + ret + ')');
                        xprintf('Sorry, basis recovery procedure not implemented yet');
                    }
                    xassert(!lp.valid && lp.bfd == null);
                    lp.bfd = csa.bfd;
                    csa.bfd = null;
                    lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;
                    lp.obj_val = 0;
                    lp.it_cnt = csa.it_cnt;
                    lp.some = 0;
                    ret = GLP_EFAIL;
                    return ret;
                }
                csa.valid = 1;
                binv_st = 1;
                bbar_st = cbar_st = 0;
            }
            if (cbar_st == 0) {
                eval_cbar(csa);
                cbar_st = 1;
                if (csa.phase == 0) {
                    if (check_feas(csa, 0.9 * parm.tol_dj) != 0) {
                        csa.phase = 1;
                        set_aux_bnds(csa);
                    } else {
                        csa.phase = 2;
                        set_orig_bnds(csa);
                    }
                    xassert(check_stab(csa, parm.tol_dj) == 0);
                    csa.refct = 0;
                    bbar_st = 0;
                }
                if (check_stab(csa, parm.tol_dj) != 0) {
                    if (parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('Warning: numerical instability (dual simplex, phase ' + (csa.phase == 1 ? 'I' : 'II') + ')');
                    if (parm.meth == GLP_DUALP) {
                        store_sol(csa, lp, GLP_UNDEF, GLP_UNDEF, 0);
                        ret = GLP_EFAIL;
                        return ret;
                    }
                    csa.phase = 0;
                    binv_st = 0;
                    rigorous = 5;
                    continue;
                }
            }
            xassert(csa.phase == 1 || csa.phase == 2);
            if (csa.phase == 1 && check_feas(csa, parm.tol_dj) == 0) {
                display(csa, parm, 1);
                csa.phase = 2;
                if (cbar_st != 1) {
                    eval_cbar(csa);
                    cbar_st = 1;
                }
                set_orig_bnds(csa);
                csa.refct = 0;
                bbar_st = 0;
            }
            if (bbar_st == 0) {
                eval_bbar(csa);
                if (csa.phase == 2)
                    csa.bbar[0] = eval_obj(csa);
                bbar_st = 1;
            }
            switch (parm.pricing) {
            case GLP_PT_STD:
                break;
            case GLP_PT_PSE:
                if (csa.refct == 0)
                    reset_refsp(csa);
                break;
            default:
                xassert(parm != parm);
            }
            xassert(binv_st && bbar_st && cbar_st);
            if (check) {
                var e_bbar = err_in_bbar(csa);
                var e_cbar = err_in_cbar(csa);
                var e_gamma = parm.pricing == GLP_PT_PSE ? err_in_gamma(csa) : 0;
                xprintf('e_bbar = ' + e_bbar + '; e_cbar = ' + e_cbar + '; e_gamma = ' + e_gamma + '');
                xassert(e_bbar <= 0.00001 && e_cbar <= 0.00001 && e_gamma <= 0.001);
            }
            if (csa.phase == 2 && csa.zeta < 0 && parm.obj_ll > -DBL_MAX && csa.bbar[0] <= parm.obj_ll) {
                if (bbar_st != 1 || cbar_st != 1) {
                    if (bbar_st != 1)
                        bbar_st = 0;
                    if (cbar_st != 1)
                        cbar_st = 0;
                    continue;
                }
                display(csa, parm, 1);
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('OBJECTIVE LOWER LIMIT REACHED; SEARCH TERMINATED');
                store_sol(csa, lp, GLP_INFEAS, GLP_FEAS, 0);
                ret = GLP_EOBJLL;
                return ret;
            }
            if (csa.phase == 2 && csa.zeta > 0 && parm.obj_ul < +DBL_MAX && csa.bbar[0] >= parm.obj_ul) {
                if (bbar_st != 1 || cbar_st != 1) {
                    if (bbar_st != 1)
                        bbar_st = 0;
                    if (cbar_st != 1)
                        cbar_st = 0;
                    continue;
                }
                display(csa, parm, 1);
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('OBJECTIVE UPPER LIMIT REACHED; SEARCH TERMINATED');
                store_sol(csa, lp, GLP_INFEAS, GLP_FEAS, 0);
                ret = GLP_EOBJUL;
                return ret;
            }
            if (parm.it_lim < INT_MAX && csa.it_cnt - csa.it_beg >= parm.it_lim) {
                if (csa.phase == 2 && bbar_st != 1 || cbar_st != 1) {
                    if (csa.phase == 2 && bbar_st != 1)
                        bbar_st = 0;
                    if (cbar_st != 1)
                        cbar_st = 0;
                    continue;
                }
                display(csa, parm, 1);
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('ITERATION LIMIT EXCEEDED; SEARCH TERMINATED');
                switch (csa.phase) {
                case 1:
                    d_stat = GLP_INFEAS;
                    set_orig_bnds(csa);
                    eval_bbar(csa);
                    break;
                case 2:
                    d_stat = GLP_FEAS;
                    break;
                default:
                    xassert(csa != csa);
                }
                store_sol(csa, lp, GLP_INFEAS, d_stat, 0);
                ret = GLP_EITLIM;
                return ret;
            }
            if (parm.tm_lim < INT_MAX && 1000 * xdifftime(xtime(), csa.tm_beg) >= parm.tm_lim) {
                if (csa.phase == 2 && bbar_st != 1 || cbar_st != 1) {
                    if (csa.phase == 2 && bbar_st != 1)
                        bbar_st = 0;
                    if (cbar_st != 1)
                        cbar_st = 0;
                    continue;
                }
                display(csa, parm, 1);
                if (parm.msg_lev >= GLP_MSG_ALL)
                    xprintf('TIME LIMIT EXCEEDED; SEARCH TERMINATED');
                switch (csa.phase) {
                case 1:
                    d_stat = GLP_INFEAS;
                    set_orig_bnds(csa);
                    eval_bbar(csa);
                    break;
                case 2:
                    d_stat = GLP_FEAS;
                    break;
                default:
                    xassert(csa != csa);
                }
                store_sol(csa, lp, GLP_INFEAS, d_stat, 0);
                ret = GLP_ETMLIM;
                return ret;
            }
            display(csa, parm, 0);
            chuzr(csa, parm.tol_bnd);
            if (csa.p == 0) {
                if (bbar_st != 1 || cbar_st != 1) {
                    if (bbar_st != 1)
                        bbar_st = 0;
                    if (cbar_st != 1)
                        cbar_st = 0;
                    continue;
                }
                display(csa, parm, 1);
                switch (csa.phase) {
                case 1:
                    if (parm.msg_lev >= GLP_MSG_ALL)
                        xprintf('PROBLEM HAS NO DUAL FEASIBLE SOLUTION');
                    set_orig_bnds(csa);
                    eval_bbar(csa);
                    p_stat = GLP_INFEAS;
                    d_stat = GLP_NOFEAS;
                    break;
                case 2:
                    if (parm.msg_lev >= GLP_MSG_ALL)
                        xprintf('OPTIMAL SOLUTION FOUND');
                    p_stat = d_stat = GLP_FEAS;
                    break;
                default:
                    xassert(csa != csa);
                }
                store_sol(csa, lp, p_stat, d_stat, 0);
                ret = 0;
                return ret;
            }
            {
                var rho = csa.work4;
                eval_rho(csa, rho);
                if (rigorous)
                    refine_rho(csa, rho);
                eval_trow(csa, rho);
                sort_trow(csa, parm.tol_bnd);
            }
            switch (parm.r_test) {
            case GLP_RT_STD:
                chuzc(csa, 0);
                break;
            case GLP_RT_HAR:
                chuzc(csa, 0.3 * parm.tol_dj);
                break;
            default:
                xassert(parm != parm);
            }
            if (csa.q == 0) {
                if (bbar_st != 1 || cbar_st != 1 || !rigorous) {
                    if (bbar_st != 1)
                        bbar_st = 0;
                    if (cbar_st != 1)
                        cbar_st = 0;
                    rigorous = 1;
                    continue;
                }
                display(csa, parm, 1);
                switch (csa.phase) {
                case 1:
                    if (parm.msg_lev >= GLP_MSG_ERR)
                        xprintf('Error: unable to choose basic variable on phase I');
                    xassert(!lp.valid && lp.bfd == null);
                    lp.bfd = csa.bfd;
                    csa.bfd = null;
                    lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;
                    lp.obj_val = 0;
                    lp.it_cnt = csa.it_cnt;
                    lp.some = 0;
                    ret = GLP_EFAIL;
                    break;
                case 2:
                    if (parm.msg_lev >= GLP_MSG_ALL)
                        xprintf('PROBLEM HAS NO FEASIBLE SOLUTION');
                    store_sol(csa, lp, GLP_NOFEAS, GLP_FEAS, csa.head[csa.p]);
                    ret = 0;
                    break;
                default:
                    xassert(csa != csa);
                }
                return ret;
            }
            {
                var piv = csa.trow_vec[csa.q];
                var eps = 0.00001 * (1 + 0.01 * csa.trow_max);
                if (Math.abs(piv) < eps) {
                    if (parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('piv = ' + piv + '; eps = ' + eps + '');
                    if (!rigorous) {
                        rigorous = 5;
                        continue;
                    }
                }
            }
            eval_tcol(csa);
            if (rigorous)
                refine_tcol(csa);
            {
                var piv1 = csa.tcol_vec[csa.p];
                var piv2 = csa.trow_vec[csa.q];
                xassert(piv1 != 0);
                if (Math.abs(piv1 - piv2) > 1e-8 * (1 + Math.abs(piv1)) || !(piv1 > 0 && piv2 > 0 || piv1 < 0 && piv2 < 0)) {
                    if (parm.msg_lev >= GLP_MSG_DBG)
                        xprintf('piv1 = ' + piv1 + '; piv2 = ' + piv2 + '');
                    if (binv_st != 1 || !rigorous) {
                        if (binv_st != 1)
                            binv_st = 0;
                        rigorous = 5;
                        continue;
                    }
                    if (csa.tcol_vec[csa.p] == 0) {
                        csa.tcol_nnz++;
                        xassert(csa.tcol_nnz <= csa.m);
                        csa.tcol_ind[csa.tcol_nnz] = csa.p;
                    }
                    csa.tcol_vec[csa.p] = piv2;
                }
            }
            update_bbar(csa);
            if (csa.phase == 2)
                csa.bbar[0] += csa.cbar[csa.q] / csa.zeta * (csa.delta / csa.tcol_vec[csa.p]);
            bbar_st = 2;
            update_cbar(csa);
            cbar_st = 2;
            switch (parm.pricing) {
            case GLP_PT_STD:
                break;
            case GLP_PT_PSE:
                if (csa.refct > 0)
                    update_gamma(csa);
                break;
            default:
                xassert(parm != parm);
            }
            ret = update_B(csa, csa.p, csa.head[csa.m + csa.q]);
            if (ret == 0)
                binv_st = 2;
            else {
                csa.valid = 0;
                binv_st = 0;
            }
            change_basis(csa);
            csa.it_cnt++;
            if (rigorous > 0)
                rigorous--;
        }
    }
}(typeof exports === 'object' && exports || this));
},{}],64:[function(require,module,exports){
module.exports = CollectingHandler;
function CollectingHandler(cbs) {
    this._cbs = cbs || {};
    this.events = [];
}
var EVENTS = require(71).EVENTS;
Object.keys(EVENTS).forEach(function (name) {
    if (EVENTS[name] === 0) {
        name = 'on' + name;
        CollectingHandler.prototype[name] = function () {
            this.events.push([name]);
            if (this._cbs[name])
                this._cbs[name]();
        };
    } else if (EVENTS[name] === 1) {
        name = 'on' + name;
        CollectingHandler.prototype[name] = function (a) {
            this.events.push([
                name,
                a
            ]);
            if (this._cbs[name])
                this._cbs[name](a);
        };
    } else if (EVENTS[name] === 2) {
        name = 'on' + name;
        CollectingHandler.prototype[name] = function (a, b) {
            this.events.push([
                name,
                a,
                b
            ]);
            if (this._cbs[name])
                this._cbs[name](a, b);
        };
    } else {
        throw Error('wrong number of arguments');
    }
});
CollectingHandler.prototype.onreset = function () {
    this.events = [];
    if (this._cbs.onreset)
        this._cbs.onreset();
};
CollectingHandler.prototype.restart = function () {
    if (this._cbs.onreset)
        this._cbs.onreset();
    for (var i = 0, len = this.events.length; i < len; i++) {
        if (this._cbs[this.events[i][0]]) {
            var num = this.events[i].length;
            if (num === 1) {
                this._cbs[this.events[i][0]]();
            } else if (num === 2) {
                this._cbs[this.events[i][0]](this.events[i][1]);
            } else {
                this._cbs[this.events[i][0]](this.events[i][1], this.events[i][2]);
            }
        }
    }
};
},{"71":71}],65:[function(require,module,exports){
var index = require(71), DomHandler = index.DomHandler, DomUtils = index.DomUtils;
function FeedHandler(callback, options) {
    this.init(callback, options);
}
require(73)(FeedHandler, DomHandler);
FeedHandler.prototype.init = DomHandler;
function getElements(what, where) {
    return DomUtils.getElementsByTagName(what, where, true);
}
function getOneElement(what, where) {
    return DomUtils.getElementsByTagName(what, where, true, 1)[0];
}
function fetch(what, where, recurse) {
    return DomUtils.getText(DomUtils.getElementsByTagName(what, where, recurse, 1)).trim();
}
function addConditionally(obj, prop, what, where, recurse) {
    var tmp = fetch(what, where, recurse);
    if (tmp)
        obj[prop] = tmp;
}
var isValidFeed = function (value) {
    return value === 'rss' || value === 'feed' || value === 'rdf:RDF';
};
FeedHandler.prototype.onend = function () {
    var feed = {}, feedRoot = getOneElement(isValidFeed, this.dom), tmp, childs;
    if (feedRoot) {
        if (feedRoot.name === 'feed') {
            childs = feedRoot.children;
            feed.type = 'atom';
            addConditionally(feed, 'id', 'id', childs);
            addConditionally(feed, 'title', 'title', childs);
            if ((tmp = getOneElement('link', childs)) && (tmp = tmp.attribs) && (tmp = tmp.href))
                feed.link = tmp;
            addConditionally(feed, 'description', 'subtitle', childs);
            if (tmp = fetch('updated', childs))
                feed.updated = new Date(tmp);
            addConditionally(feed, 'author', 'email', childs, true);
            feed.items = getElements('entry', childs).map(function (item) {
                var entry = {}, tmp;
                item = item.children;
                addConditionally(entry, 'id', 'id', item);
                addConditionally(entry, 'title', 'title', item);
                if ((tmp = getOneElement('link', item)) && (tmp = tmp.attribs) && (tmp = tmp.href))
                    entry.link = tmp;
                if (tmp = fetch('summary', item) || fetch('content', item))
                    entry.description = tmp;
                if (tmp = fetch('updated', item))
                    entry.pubDate = new Date(tmp);
                return entry;
            });
        } else {
            childs = getOneElement('channel', feedRoot.children).children;
            feed.type = feedRoot.name.substr(0, 3);
            feed.id = '';
            addConditionally(feed, 'title', 'title', childs);
            addConditionally(feed, 'link', 'link', childs);
            addConditionally(feed, 'description', 'description', childs);
            if (tmp = fetch('lastBuildDate', childs))
                feed.updated = new Date(tmp);
            addConditionally(feed, 'author', 'managingEditor', childs, true);
            feed.items = getElements('item', feedRoot.children).map(function (item) {
                var entry = {}, tmp;
                item = item.children;
                addConditionally(entry, 'id', 'guid', item);
                addConditionally(entry, 'title', 'title', item);
                addConditionally(entry, 'link', 'link', item);
                addConditionally(entry, 'description', 'description', item);
                if (tmp = fetch('pubDate', item))
                    entry.pubDate = new Date(tmp);
                return entry;
            });
        }
    }
    this.dom = feed;
    DomHandler.prototype._handleCallback.call(this, feedRoot ? null : Error('couldn\'t find root of feed'));
};
module.exports = FeedHandler;
},{"71":71,"73":73}],66:[function(require,module,exports){
var Tokenizer = require(69);
var formTags = {
    input: true,
    option: true,
    optgroup: true,
    select: true,
    button: true,
    datalist: true,
    textarea: true
};
var openImpliesClose = {
    tr: {
        tr: true,
        th: true,
        td: true
    },
    th: { th: true },
    td: {
        thead: true,
        th: true,
        td: true
    },
    body: {
        head: true,
        link: true,
        script: true
    },
    li: { li: true },
    p: { p: true },
    h1: { p: true },
    h2: { p: true },
    h3: { p: true },
    h4: { p: true },
    h5: { p: true },
    h6: { p: true },
    select: formTags,
    input: formTags,
    output: formTags,
    button: formTags,
    datalist: formTags,
    textarea: formTags,
    option: { option: true },
    optgroup: { optgroup: true }
};
var voidElements = {
    __proto__: null,
    area: true,
    base: true,
    basefont: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    isindex: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true,
    path: true,
    circle: true,
    ellipse: true,
    line: true,
    rect: true,
    use: true,
    stop: true,
    polyline: true,
    polygon: true
};
var re_nameEnd = /\s|\//;
function Parser(cbs, options) {
    this._options = options || {};
    this._cbs = cbs || {};
    this._tagname = '';
    this._attribname = '';
    this._attribvalue = '';
    this._attribs = null;
    this._stack = [];
    this.startIndex = 0;
    this.endIndex = null;
    this._lowerCaseTagNames = 'lowerCaseTags' in this._options ? !!this._options.lowerCaseTags : !this._options.xmlMode;
    this._lowerCaseAttributeNames = 'lowerCaseAttributeNames' in this._options ? !!this._options.lowerCaseAttributeNames : !this._options.xmlMode;
    if (this._options.Tokenizer) {
        Tokenizer = this._options.Tokenizer;
    }
    this._tokenizer = new Tokenizer(this._options, this);
    if (this._cbs.onparserinit)
        this._cbs.onparserinit(this);
}
require(73)(Parser, require(58).EventEmitter);
Parser.prototype._updatePosition = function (initialOffset) {
    if (this.endIndex === null) {
        if (this._tokenizer._sectionStart <= initialOffset) {
            this.startIndex = 0;
        } else {
            this.startIndex = this._tokenizer._sectionStart - initialOffset;
        }
    } else
        this.startIndex = this.endIndex + 1;
    this.endIndex = this._tokenizer.getAbsoluteIndex();
};
Parser.prototype.ontext = function (data) {
    this._updatePosition(1);
    this.endIndex--;
    if (this._cbs.ontext)
        this._cbs.ontext(data);
};
Parser.prototype.onopentagname = function (name) {
    if (this._lowerCaseTagNames) {
        name = name.toLowerCase();
    }
    this._tagname = name;
    if (!this._options.xmlMode && name in openImpliesClose) {
        for (var el; (el = this._stack[this._stack.length - 1]) in openImpliesClose[name]; this.onclosetag(el));
    }
    if (this._options.xmlMode || !(name in voidElements)) {
        this._stack.push(name);
    }
    if (this._cbs.onopentagname)
        this._cbs.onopentagname(name);
    if (this._cbs.onopentag)
        this._attribs = {};
};
Parser.prototype.onopentagend = function () {
    this._updatePosition(1);
    if (this._attribs) {
        if (this._cbs.onopentag)
            this._cbs.onopentag(this._tagname, this._attribs);
        this._attribs = null;
    }
    if (!this._options.xmlMode && this._cbs.onclosetag && this._tagname in voidElements) {
        this._cbs.onclosetag(this._tagname);
    }
    this._tagname = '';
};
Parser.prototype.onclosetag = function (name) {
    this._updatePosition(1);
    if (this._lowerCaseTagNames) {
        name = name.toLowerCase();
    }
    if (this._stack.length && (!(name in voidElements) || this._options.xmlMode)) {
        var pos = this._stack.lastIndexOf(name);
        if (pos !== -1) {
            if (this._cbs.onclosetag) {
                pos = this._stack.length - pos;
                while (pos--)
                    this._cbs.onclosetag(this._stack.pop());
            } else
                this._stack.length = pos;
        } else if (name === 'p' && !this._options.xmlMode) {
            this.onopentagname(name);
            this._closeCurrentTag();
        }
    } else if (!this._options.xmlMode && (name === 'br' || name === 'p')) {
        this.onopentagname(name);
        this._closeCurrentTag();
    }
};
Parser.prototype.onselfclosingtag = function () {
    if (this._options.xmlMode || this._options.recognizeSelfClosing) {
        this._closeCurrentTag();
    } else {
        this.onopentagend();
    }
};
Parser.prototype._closeCurrentTag = function () {
    var name = this._tagname;
    this.onopentagend();
    if (this._stack[this._stack.length - 1] === name) {
        if (this._cbs.onclosetag) {
            this._cbs.onclosetag(name);
        }
        this._stack.pop();
    }
};
Parser.prototype.onattribname = function (name) {
    if (this._lowerCaseAttributeNames) {
        name = name.toLowerCase();
    }
    this._attribname = name;
};
Parser.prototype.onattribdata = function (value) {
    this._attribvalue += value;
};
Parser.prototype.onattribend = function () {
    if (this._cbs.onattribute)
        this._cbs.onattribute(this._attribname, this._attribvalue);
    if (this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)) {
        this._attribs[this._attribname] = this._attribvalue;
    }
    this._attribname = '';
    this._attribvalue = '';
};
Parser.prototype._getInstructionName = function (value) {
    var idx = value.search(re_nameEnd), name = idx < 0 ? value : value.substr(0, idx);
    if (this._lowerCaseTagNames) {
        name = name.toLowerCase();
    }
    return name;
};
Parser.prototype.ondeclaration = function (value) {
    if (this._cbs.onprocessinginstruction) {
        var name = this._getInstructionName(value);
        this._cbs.onprocessinginstruction('!' + name, '!' + value);
    }
};
Parser.prototype.onprocessinginstruction = function (value) {
    if (this._cbs.onprocessinginstruction) {
        var name = this._getInstructionName(value);
        this._cbs.onprocessinginstruction('?' + name, '?' + value);
    }
};
Parser.prototype.oncomment = function (value) {
    this._updatePosition(4);
    if (this._cbs.oncomment)
        this._cbs.oncomment(value);
    if (this._cbs.oncommentend)
        this._cbs.oncommentend();
};
Parser.prototype.oncdata = function (value) {
    this._updatePosition(1);
    if (this._options.xmlMode || this._options.recognizeCDATA) {
        if (this._cbs.oncdatastart)
            this._cbs.oncdatastart();
        if (this._cbs.ontext)
            this._cbs.ontext(value);
        if (this._cbs.oncdataend)
            this._cbs.oncdataend();
    } else {
        this.oncomment('[CDATA[' + value + ']]');
    }
};
Parser.prototype.onerror = function (err) {
    if (this._cbs.onerror)
        this._cbs.onerror(err);
};
Parser.prototype.onend = function () {
    if (this._cbs.onclosetag) {
        for (var i = this._stack.length; i > 0; this._cbs.onclosetag(this._stack[--i]));
    }
    if (this._cbs.onend)
        this._cbs.onend();
};
Parser.prototype.reset = function () {
    if (this._cbs.onreset)
        this._cbs.onreset();
    this._tokenizer.reset();
    this._tagname = '';
    this._attribname = '';
    this._attribs = null;
    this._stack = [];
    if (this._cbs.onparserinit)
        this._cbs.onparserinit(this);
};
Parser.prototype.parseComplete = function (data) {
    this.reset();
    this.end(data);
};
Parser.prototype.write = function (chunk) {
    this._tokenizer.write(chunk);
};
Parser.prototype.end = function (chunk) {
    this._tokenizer.end(chunk);
};
Parser.prototype.pause = function () {
    this._tokenizer.pause();
};
Parser.prototype.resume = function () {
    this._tokenizer.resume();
};
Parser.prototype.parseChunk = Parser.prototype.write;
Parser.prototype.done = Parser.prototype.end;
module.exports = Parser;
},{"58":58,"69":69,"73":73}],67:[function(require,module,exports){
module.exports = ProxyHandler;
function ProxyHandler(cbs) {
    this._cbs = cbs || {};
}
var EVENTS = require(71).EVENTS;
Object.keys(EVENTS).forEach(function (name) {
    if (EVENTS[name] === 0) {
        name = 'on' + name;
        ProxyHandler.prototype[name] = function () {
            if (this._cbs[name])
                this._cbs[name]();
        };
    } else if (EVENTS[name] === 1) {
        name = 'on' + name;
        ProxyHandler.prototype[name] = function (a) {
            if (this._cbs[name])
                this._cbs[name](a);
        };
    } else if (EVENTS[name] === 2) {
        name = 'on' + name;
        ProxyHandler.prototype[name] = function (a, b) {
            if (this._cbs[name])
                this._cbs[name](a, b);
        };
    } else {
        throw Error('wrong number of arguments');
    }
});
},{"71":71}],68:[function(require,module,exports){
module.exports = Stream;
var Parser = require(70);
function Stream(options) {
    Parser.call(this, new Cbs(this), options);
}
require(73)(Stream, Parser);
Stream.prototype.readable = true;
function Cbs(scope) {
    this.scope = scope;
}
var EVENTS = require(71).EVENTS;
Object.keys(EVENTS).forEach(function (name) {
    if (EVENTS[name] === 0) {
        Cbs.prototype['on' + name] = function () {
            this.scope.emit(name);
        };
    } else if (EVENTS[name] === 1) {
        Cbs.prototype['on' + name] = function (a) {
            this.scope.emit(name, a);
        };
    } else if (EVENTS[name] === 2) {
        Cbs.prototype['on' + name] = function (a, b) {
            this.scope.emit(name, a, b);
        };
    } else {
        throw Error('wrong number of arguments!');
    }
});
},{"70":70,"71":71,"73":73}],69:[function(require,module,exports){
module.exports = Tokenizer;
var decodeCodePoint = require(52), entityMap = require(55), legacyMap = require(56), xmlMap = require(57), i = 0, TEXT = i++, BEFORE_TAG_NAME = i++, IN_TAG_NAME = i++, IN_SELF_CLOSING_TAG = i++, BEFORE_CLOSING_TAG_NAME = i++, IN_CLOSING_TAG_NAME = i++, AFTER_CLOSING_TAG_NAME = i++, BEFORE_ATTRIBUTE_NAME = i++, IN_ATTRIBUTE_NAME = i++, AFTER_ATTRIBUTE_NAME = i++, BEFORE_ATTRIBUTE_VALUE = i++, IN_ATTRIBUTE_VALUE_DQ = i++, IN_ATTRIBUTE_VALUE_SQ = i++, IN_ATTRIBUTE_VALUE_NQ = i++, BEFORE_DECLARATION = i++, IN_DECLARATION = i++, IN_PROCESSING_INSTRUCTION = i++, BEFORE_COMMENT = i++, IN_COMMENT = i++, AFTER_COMMENT_1 = i++, AFTER_COMMENT_2 = i++, BEFORE_CDATA_1 = i++, BEFORE_CDATA_2 = i++, BEFORE_CDATA_3 = i++, BEFORE_CDATA_4 = i++, BEFORE_CDATA_5 = i++, BEFORE_CDATA_6 = i++, IN_CDATA = i++, AFTER_CDATA_1 = i++, AFTER_CDATA_2 = i++, BEFORE_SPECIAL = i++, BEFORE_SPECIAL_END = i++, BEFORE_SCRIPT_1 = i++, BEFORE_SCRIPT_2 = i++, BEFORE_SCRIPT_3 = i++, BEFORE_SCRIPT_4 = i++, BEFORE_SCRIPT_5 = i++, AFTER_SCRIPT_1 = i++, AFTER_SCRIPT_2 = i++, AFTER_SCRIPT_3 = i++, AFTER_SCRIPT_4 = i++, AFTER_SCRIPT_5 = i++, BEFORE_STYLE_1 = i++, BEFORE_STYLE_2 = i++, BEFORE_STYLE_3 = i++, BEFORE_STYLE_4 = i++, AFTER_STYLE_1 = i++, AFTER_STYLE_2 = i++, AFTER_STYLE_3 = i++, AFTER_STYLE_4 = i++, BEFORE_ENTITY = i++, BEFORE_NUMERIC_ENTITY = i++, IN_NAMED_ENTITY = i++, IN_NUMERIC_ENTITY = i++, IN_HEX_ENTITY = i++, j = 0, SPECIAL_NONE = j++, SPECIAL_SCRIPT = j++, SPECIAL_STYLE = j++;
function whitespace(c) {
    return c === ' ' || c === '\n' || c === '\t' || c === '\f' || c === '\r';
}
function characterState(char, SUCCESS) {
    return function (c) {
        if (c === char)
            this._state = SUCCESS;
    };
}
function ifElseState(upper, SUCCESS, FAILURE) {
    var lower = upper.toLowerCase();
    if (upper === lower) {
        return function (c) {
            if (c === lower) {
                this._state = SUCCESS;
            } else {
                this._state = FAILURE;
                this._index--;
            }
        };
    } else {
        return function (c) {
            if (c === lower || c === upper) {
                this._state = SUCCESS;
            } else {
                this._state = FAILURE;
                this._index--;
            }
        };
    }
}
function consumeSpecialNameChar(upper, NEXT_STATE) {
    var lower = upper.toLowerCase();
    return function (c) {
        if (c === lower || c === upper) {
            this._state = NEXT_STATE;
        } else {
            this._state = IN_TAG_NAME;
            this._index--;
        }
    };
}
function Tokenizer(options, cbs) {
    this._state = TEXT;
    this._buffer = '';
    this._sectionStart = 0;
    this._index = 0;
    this._bufferOffset = 0;
    this._baseState = TEXT;
    this._special = SPECIAL_NONE;
    this._cbs = cbs;
    this._running = true;
    this._ended = false;
    this._xmlMode = !!(options && options.xmlMode);
    this._decodeEntities = !!(options && options.decodeEntities);
}
Tokenizer.prototype._stateText = function (c) {
    if (c === '<') {
        if (this._index > this._sectionStart) {
            this._cbs.ontext(this._getSection());
        }
        this._state = BEFORE_TAG_NAME;
        this._sectionStart = this._index;
    } else if (this._decodeEntities && this._special === SPECIAL_NONE && c === '&') {
        if (this._index > this._sectionStart) {
            this._cbs.ontext(this._getSection());
        }
        this._baseState = TEXT;
        this._state = BEFORE_ENTITY;
        this._sectionStart = this._index;
    }
};
Tokenizer.prototype._stateBeforeTagName = function (c) {
    if (c === '/') {
        this._state = BEFORE_CLOSING_TAG_NAME;
    } else if (c === '<') {
        this._cbs.ontext(this._getSection());
        this._sectionStart = this._index;
    } else if (c === '>' || this._special !== SPECIAL_NONE || whitespace(c)) {
        this._state = TEXT;
    } else if (c === '!') {
        this._state = BEFORE_DECLARATION;
        this._sectionStart = this._index + 1;
    } else if (c === '?') {
        this._state = IN_PROCESSING_INSTRUCTION;
        this._sectionStart = this._index + 1;
    } else {
        this._state = !this._xmlMode && (c === 's' || c === 'S') ? BEFORE_SPECIAL : IN_TAG_NAME;
        this._sectionStart = this._index;
    }
};
Tokenizer.prototype._stateInTagName = function (c) {
    if (c === '/' || c === '>' || whitespace(c)) {
        this._emitToken('onopentagname');
        this._state = BEFORE_ATTRIBUTE_NAME;
        this._index--;
    }
};
Tokenizer.prototype._stateBeforeCloseingTagName = function (c) {
    if (whitespace(c));
    else if (c === '>') {
        this._state = TEXT;
    } else if (this._special !== SPECIAL_NONE) {
        if (c === 's' || c === 'S') {
            this._state = BEFORE_SPECIAL_END;
        } else {
            this._state = TEXT;
            this._index--;
        }
    } else {
        this._state = IN_CLOSING_TAG_NAME;
        this._sectionStart = this._index;
    }
};
Tokenizer.prototype._stateInCloseingTagName = function (c) {
    if (c === '>' || whitespace(c)) {
        this._emitToken('onclosetag');
        this._state = AFTER_CLOSING_TAG_NAME;
        this._index--;
    }
};
Tokenizer.prototype._stateAfterCloseingTagName = function (c) {
    if (c === '>') {
        this._state = TEXT;
        this._sectionStart = this._index + 1;
    }
};
Tokenizer.prototype._stateBeforeAttributeName = function (c) {
    if (c === '>') {
        this._cbs.onopentagend();
        this._state = TEXT;
        this._sectionStart = this._index + 1;
    } else if (c === '/') {
        this._state = IN_SELF_CLOSING_TAG;
    } else if (!whitespace(c)) {
        this._state = IN_ATTRIBUTE_NAME;
        this._sectionStart = this._index;
    }
};
Tokenizer.prototype._stateInSelfClosingTag = function (c) {
    if (c === '>') {
        this._cbs.onselfclosingtag();
        this._state = TEXT;
        this._sectionStart = this._index + 1;
    } else if (!whitespace(c)) {
        this._state = BEFORE_ATTRIBUTE_NAME;
        this._index--;
    }
};
Tokenizer.prototype._stateInAttributeName = function (c) {
    if (c === '=' || c === '/' || c === '>' || whitespace(c)) {
        this._cbs.onattribname(this._getSection());
        this._sectionStart = -1;
        this._state = AFTER_ATTRIBUTE_NAME;
        this._index--;
    }
};
Tokenizer.prototype._stateAfterAttributeName = function (c) {
    if (c === '=') {
        this._state = BEFORE_ATTRIBUTE_VALUE;
    } else if (c === '/' || c === '>') {
        this._cbs.onattribend();
        this._state = BEFORE_ATTRIBUTE_NAME;
        this._index--;
    } else if (!whitespace(c)) {
        this._cbs.onattribend();
        this._state = IN_ATTRIBUTE_NAME;
        this._sectionStart = this._index;
    }
};
Tokenizer.prototype._stateBeforeAttributeValue = function (c) {
    if (c === '"') {
        this._state = IN_ATTRIBUTE_VALUE_DQ;
        this._sectionStart = this._index + 1;
    } else if (c === '\'') {
        this._state = IN_ATTRIBUTE_VALUE_SQ;
        this._sectionStart = this._index + 1;
    } else if (!whitespace(c)) {
        this._state = IN_ATTRIBUTE_VALUE_NQ;
        this._sectionStart = this._index;
        this._index--;
    }
};
Tokenizer.prototype._stateInAttributeValueDoubleQuotes = function (c) {
    if (c === '"') {
        this._emitToken('onattribdata');
        this._cbs.onattribend();
        this._state = BEFORE_ATTRIBUTE_NAME;
    } else if (this._decodeEntities && c === '&') {
        this._emitToken('onattribdata');
        this._baseState = this._state;
        this._state = BEFORE_ENTITY;
        this._sectionStart = this._index;
    }
};
Tokenizer.prototype._stateInAttributeValueSingleQuotes = function (c) {
    if (c === '\'') {
        this._emitToken('onattribdata');
        this._cbs.onattribend();
        this._state = BEFORE_ATTRIBUTE_NAME;
    } else if (this._decodeEntities && c === '&') {
        this._emitToken('onattribdata');
        this._baseState = this._state;
        this._state = BEFORE_ENTITY;
        this._sectionStart = this._index;
    }
};
Tokenizer.prototype._stateInAttributeValueNoQuotes = function (c) {
    if (whitespace(c) || c === '>') {
        this._emitToken('onattribdata');
        this._cbs.onattribend();
        this._state = BEFORE_ATTRIBUTE_NAME;
        this._index--;
    } else if (this._decodeEntities && c === '&') {
        this._emitToken('onattribdata');
        this._baseState = this._state;
        this._state = BEFORE_ENTITY;
        this._sectionStart = this._index;
    }
};
Tokenizer.prototype._stateBeforeDeclaration = function (c) {
    this._state = c === '[' ? BEFORE_CDATA_1 : c === '-' ? BEFORE_COMMENT : IN_DECLARATION;
};
Tokenizer.prototype._stateInDeclaration = function (c) {
    if (c === '>') {
        this._cbs.ondeclaration(this._getSection());
        this._state = TEXT;
        this._sectionStart = this._index + 1;
    }
};
Tokenizer.prototype._stateInProcessingInstruction = function (c) {
    if (c === '>') {
        this._cbs.onprocessinginstruction(this._getSection());
        this._state = TEXT;
        this._sectionStart = this._index + 1;
    }
};
Tokenizer.prototype._stateBeforeComment = function (c) {
    if (c === '-') {
        this._state = IN_COMMENT;
        this._sectionStart = this._index + 1;
    } else {
        this._state = IN_DECLARATION;
    }
};
Tokenizer.prototype._stateInComment = function (c) {
    if (c === '-')
        this._state = AFTER_COMMENT_1;
};
Tokenizer.prototype._stateAfterComment1 = function (c) {
    if (c === '-') {
        this._state = AFTER_COMMENT_2;
    } else {
        this._state = IN_COMMENT;
    }
};
Tokenizer.prototype._stateAfterComment2 = function (c) {
    if (c === '>') {
        this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2));
        this._state = TEXT;
        this._sectionStart = this._index + 1;
    } else if (c !== '-') {
        this._state = IN_COMMENT;
    }
};
Tokenizer.prototype._stateBeforeCdata1 = ifElseState('C', BEFORE_CDATA_2, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata2 = ifElseState('D', BEFORE_CDATA_3, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata3 = ifElseState('A', BEFORE_CDATA_4, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata4 = ifElseState('T', BEFORE_CDATA_5, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata5 = ifElseState('A', BEFORE_CDATA_6, IN_DECLARATION);
Tokenizer.prototype._stateBeforeCdata6 = function (c) {
    if (c === '[') {
        this._state = IN_CDATA;
        this._sectionStart = this._index + 1;
    } else {
        this._state = IN_DECLARATION;
        this._index--;
    }
};
Tokenizer.prototype._stateInCdata = function (c) {
    if (c === ']')
        this._state = AFTER_CDATA_1;
};
Tokenizer.prototype._stateAfterCdata1 = characterState(']', AFTER_CDATA_2);
Tokenizer.prototype._stateAfterCdata2 = function (c) {
    if (c === '>') {
        this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2));
        this._state = TEXT;
        this._sectionStart = this._index + 1;
    } else if (c !== ']') {
        this._state = IN_CDATA;
    }
};
Tokenizer.prototype._stateBeforeSpecial = function (c) {
    if (c === 'c' || c === 'C') {
        this._state = BEFORE_SCRIPT_1;
    } else if (c === 't' || c === 'T') {
        this._state = BEFORE_STYLE_1;
    } else {
        this._state = IN_TAG_NAME;
        this._index--;
    }
};
Tokenizer.prototype._stateBeforeSpecialEnd = function (c) {
    if (this._special === SPECIAL_SCRIPT && (c === 'c' || c === 'C')) {
        this._state = AFTER_SCRIPT_1;
    } else if (this._special === SPECIAL_STYLE && (c === 't' || c === 'T')) {
        this._state = AFTER_STYLE_1;
    } else
        this._state = TEXT;
};
Tokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar('R', BEFORE_SCRIPT_2);
Tokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar('I', BEFORE_SCRIPT_3);
Tokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar('P', BEFORE_SCRIPT_4);
Tokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar('T', BEFORE_SCRIPT_5);
Tokenizer.prototype._stateBeforeScript5 = function (c) {
    if (c === '/' || c === '>' || whitespace(c)) {
        this._special = SPECIAL_SCRIPT;
    }
    this._state = IN_TAG_NAME;
    this._index--;
};
Tokenizer.prototype._stateAfterScript1 = ifElseState('R', AFTER_SCRIPT_2, TEXT);
Tokenizer.prototype._stateAfterScript2 = ifElseState('I', AFTER_SCRIPT_3, TEXT);
Tokenizer.prototype._stateAfterScript3 = ifElseState('P', AFTER_SCRIPT_4, TEXT);
Tokenizer.prototype._stateAfterScript4 = ifElseState('T', AFTER_SCRIPT_5, TEXT);
Tokenizer.prototype._stateAfterScript5 = function (c) {
    if (c === '>' || whitespace(c)) {
        this._special = SPECIAL_NONE;
        this._state = IN_CLOSING_TAG_NAME;
        this._sectionStart = this._index - 6;
        this._index--;
    } else
        this._state = TEXT;
};
Tokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar('Y', BEFORE_STYLE_2);
Tokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar('L', BEFORE_STYLE_3);
Tokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar('E', BEFORE_STYLE_4);
Tokenizer.prototype._stateBeforeStyle4 = function (c) {
    if (c === '/' || c === '>' || whitespace(c)) {
        this._special = SPECIAL_STYLE;
    }
    this._state = IN_TAG_NAME;
    this._index--;
};
Tokenizer.prototype._stateAfterStyle1 = ifElseState('Y', AFTER_STYLE_2, TEXT);
Tokenizer.prototype._stateAfterStyle2 = ifElseState('L', AFTER_STYLE_3, TEXT);
Tokenizer.prototype._stateAfterStyle3 = ifElseState('E', AFTER_STYLE_4, TEXT);
Tokenizer.prototype._stateAfterStyle4 = function (c) {
    if (c === '>' || whitespace(c)) {
        this._special = SPECIAL_NONE;
        this._state = IN_CLOSING_TAG_NAME;
        this._sectionStart = this._index - 5;
        this._index--;
    } else
        this._state = TEXT;
};
Tokenizer.prototype._stateBeforeEntity = ifElseState('#', BEFORE_NUMERIC_ENTITY, IN_NAMED_ENTITY);
Tokenizer.prototype._stateBeforeNumericEntity = ifElseState('X', IN_HEX_ENTITY, IN_NUMERIC_ENTITY);
Tokenizer.prototype._parseNamedEntityStrict = function () {
    if (this._sectionStart + 1 < this._index) {
        var entity = this._buffer.substring(this._sectionStart + 1, this._index), map = this._xmlMode ? xmlMap : entityMap;
        if (map.hasOwnProperty(entity)) {
            this._emitPartial(map[entity]);
            this._sectionStart = this._index + 1;
        }
    }
};
Tokenizer.prototype._parseLegacyEntity = function () {
    var start = this._sectionStart + 1, limit = this._index - start;
    if (limit > 6)
        limit = 6;
    while (limit >= 2) {
        var entity = this._buffer.substr(start, limit);
        if (legacyMap.hasOwnProperty(entity)) {
            this._emitPartial(legacyMap[entity]);
            this._sectionStart += limit + 1;
            return;
        } else {
            limit--;
        }
    }
};
Tokenizer.prototype._stateInNamedEntity = function (c) {
    if (c === ';') {
        this._parseNamedEntityStrict();
        if (this._sectionStart + 1 < this._index && !this._xmlMode) {
            this._parseLegacyEntity();
        }
        this._state = this._baseState;
    } else if ((c < 'a' || c > 'z') && (c < 'A' || c > 'Z') && (c < '0' || c > '9')) {
        if (this._xmlMode);
        else if (this._sectionStart + 1 === this._index);
        else if (this._baseState !== TEXT) {
            if (c !== '=') {
                this._parseNamedEntityStrict();
            }
        } else {
            this._parseLegacyEntity();
        }
        this._state = this._baseState;
        this._index--;
    }
};
Tokenizer.prototype._decodeNumericEntity = function (offset, base) {
    var sectionStart = this._sectionStart + offset;
    if (sectionStart !== this._index) {
        var entity = this._buffer.substring(sectionStart, this._index);
        var parsed = parseInt(entity, base);
        this._emitPartial(decodeCodePoint(parsed));
        this._sectionStart = this._index;
    } else {
        this._sectionStart--;
    }
    this._state = this._baseState;
};
Tokenizer.prototype._stateInNumericEntity = function (c) {
    if (c === ';') {
        this._decodeNumericEntity(2, 10);
        this._sectionStart++;
    } else if (c < '0' || c > '9') {
        if (!this._xmlMode) {
            this._decodeNumericEntity(2, 10);
        } else {
            this._state = this._baseState;
        }
        this._index--;
    }
};
Tokenizer.prototype._stateInHexEntity = function (c) {
    if (c === ';') {
        this._decodeNumericEntity(3, 16);
        this._sectionStart++;
    } else if ((c < 'a' || c > 'f') && (c < 'A' || c > 'F') && (c < '0' || c > '9')) {
        if (!this._xmlMode) {
            this._decodeNumericEntity(3, 16);
        } else {
            this._state = this._baseState;
        }
        this._index--;
    }
};
Tokenizer.prototype._cleanup = function () {
    if (this._sectionStart < 0) {
        this._buffer = '';
        this._bufferOffset += this._index;
        this._index = 0;
    } else if (this._running) {
        if (this._state === TEXT) {
            if (this._sectionStart !== this._index) {
                this._cbs.ontext(this._buffer.substr(this._sectionStart));
            }
            this._buffer = '';
            this._bufferOffset += this._index;
            this._index = 0;
        } else if (this._sectionStart === this._index) {
            this._buffer = '';
            this._bufferOffset += this._index;
            this._index = 0;
        } else {
            this._buffer = this._buffer.substr(this._sectionStart);
            this._index -= this._sectionStart;
            this._bufferOffset += this._sectionStart;
        }
        this._sectionStart = 0;
    }
};
Tokenizer.prototype.write = function (chunk) {
    if (this._ended)
        this._cbs.onerror(Error('.write() after done!'));
    this._buffer += chunk;
    this._parse();
};
Tokenizer.prototype._parse = function () {
    while (this._index < this._buffer.length && this._running) {
        var c = this._buffer.charAt(this._index);
        if (this._state === TEXT) {
            this._stateText(c);
        } else if (this._state === BEFORE_TAG_NAME) {
            this._stateBeforeTagName(c);
        } else if (this._state === IN_TAG_NAME) {
            this._stateInTagName(c);
        } else if (this._state === BEFORE_CLOSING_TAG_NAME) {
            this._stateBeforeCloseingTagName(c);
        } else if (this._state === IN_CLOSING_TAG_NAME) {
            this._stateInCloseingTagName(c);
        } else if (this._state === AFTER_CLOSING_TAG_NAME) {
            this._stateAfterCloseingTagName(c);
        } else if (this._state === IN_SELF_CLOSING_TAG) {
            this._stateInSelfClosingTag(c);
        } else if (this._state === BEFORE_ATTRIBUTE_NAME) {
            this._stateBeforeAttributeName(c);
        } else if (this._state === IN_ATTRIBUTE_NAME) {
            this._stateInAttributeName(c);
        } else if (this._state === AFTER_ATTRIBUTE_NAME) {
            this._stateAfterAttributeName(c);
        } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {
            this._stateBeforeAttributeValue(c);
        } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {
            this._stateInAttributeValueDoubleQuotes(c);
        } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {
            this._stateInAttributeValueSingleQuotes(c);
        } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {
            this._stateInAttributeValueNoQuotes(c);
        } else if (this._state === BEFORE_DECLARATION) {
            this._stateBeforeDeclaration(c);
        } else if (this._state === IN_DECLARATION) {
            this._stateInDeclaration(c);
        } else if (this._state === IN_PROCESSING_INSTRUCTION) {
            this._stateInProcessingInstruction(c);
        } else if (this._state === BEFORE_COMMENT) {
            this._stateBeforeComment(c);
        } else if (this._state === IN_COMMENT) {
            this._stateInComment(c);
        } else if (this._state === AFTER_COMMENT_1) {
            this._stateAfterComment1(c);
        } else if (this._state === AFTER_COMMENT_2) {
            this._stateAfterComment2(c);
        } else if (this._state === BEFORE_CDATA_1) {
            this._stateBeforeCdata1(c);
        } else if (this._state === BEFORE_CDATA_2) {
            this._stateBeforeCdata2(c);
        } else if (this._state === BEFORE_CDATA_3) {
            this._stateBeforeCdata3(c);
        } else if (this._state === BEFORE_CDATA_4) {
            this._stateBeforeCdata4(c);
        } else if (this._state === BEFORE_CDATA_5) {
            this._stateBeforeCdata5(c);
        } else if (this._state === BEFORE_CDATA_6) {
            this._stateBeforeCdata6(c);
        } else if (this._state === IN_CDATA) {
            this._stateInCdata(c);
        } else if (this._state === AFTER_CDATA_1) {
            this._stateAfterCdata1(c);
        } else if (this._state === AFTER_CDATA_2) {
            this._stateAfterCdata2(c);
        } else if (this._state === BEFORE_SPECIAL) {
            this._stateBeforeSpecial(c);
        } else if (this._state === BEFORE_SPECIAL_END) {
            this._stateBeforeSpecialEnd(c);
        } else if (this._state === BEFORE_SCRIPT_1) {
            this._stateBeforeScript1(c);
        } else if (this._state === BEFORE_SCRIPT_2) {
            this._stateBeforeScript2(c);
        } else if (this._state === BEFORE_SCRIPT_3) {
            this._stateBeforeScript3(c);
        } else if (this._state === BEFORE_SCRIPT_4) {
            this._stateBeforeScript4(c);
        } else if (this._state === BEFORE_SCRIPT_5) {
            this._stateBeforeScript5(c);
        } else if (this._state === AFTER_SCRIPT_1) {
            this._stateAfterScript1(c);
        } else if (this._state === AFTER_SCRIPT_2) {
            this._stateAfterScript2(c);
        } else if (this._state === AFTER_SCRIPT_3) {
            this._stateAfterScript3(c);
        } else if (this._state === AFTER_SCRIPT_4) {
            this._stateAfterScript4(c);
        } else if (this._state === AFTER_SCRIPT_5) {
            this._stateAfterScript5(c);
        } else if (this._state === BEFORE_STYLE_1) {
            this._stateBeforeStyle1(c);
        } else if (this._state === BEFORE_STYLE_2) {
            this._stateBeforeStyle2(c);
        } else if (this._state === BEFORE_STYLE_3) {
            this._stateBeforeStyle3(c);
        } else if (this._state === BEFORE_STYLE_4) {
            this._stateBeforeStyle4(c);
        } else if (this._state === AFTER_STYLE_1) {
            this._stateAfterStyle1(c);
        } else if (this._state === AFTER_STYLE_2) {
            this._stateAfterStyle2(c);
        } else if (this._state === AFTER_STYLE_3) {
            this._stateAfterStyle3(c);
        } else if (this._state === AFTER_STYLE_4) {
            this._stateAfterStyle4(c);
        } else if (this._state === BEFORE_ENTITY) {
            this._stateBeforeEntity(c);
        } else if (this._state === BEFORE_NUMERIC_ENTITY) {
            this._stateBeforeNumericEntity(c);
        } else if (this._state === IN_NAMED_ENTITY) {
            this._stateInNamedEntity(c);
        } else if (this._state === IN_NUMERIC_ENTITY) {
            this._stateInNumericEntity(c);
        } else if (this._state === IN_HEX_ENTITY) {
            this._stateInHexEntity(c);
        } else {
            this._cbs.onerror(Error('unknown _state'), this._state);
        }
        this._index++;
    }
    this._cleanup();
};
Tokenizer.prototype.pause = function () {
    this._running = false;
};
Tokenizer.prototype.resume = function () {
    this._running = true;
    if (this._index < this._buffer.length) {
        this._parse();
    }
    if (this._ended) {
        this._finish();
    }
};
Tokenizer.prototype.end = function (chunk) {
    if (this._ended)
        this._cbs.onerror(Error('.end() after done!'));
    if (chunk)
        this.write(chunk);
    this._ended = true;
    if (this._running)
        this._finish();
};
Tokenizer.prototype._finish = function () {
    if (this._sectionStart < this._index) {
        this._handleTrailingData();
    }
    this._cbs.onend();
};
Tokenizer.prototype._handleTrailingData = function () {
    var data = this._buffer.substr(this._sectionStart);
    if (this._state === IN_CDATA || this._state === AFTER_CDATA_1 || this._state === AFTER_CDATA_2) {
        this._cbs.oncdata(data);
    } else if (this._state === IN_COMMENT || this._state === AFTER_COMMENT_1 || this._state === AFTER_COMMENT_2) {
        this._cbs.oncomment(data);
    } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {
        this._parseLegacyEntity();
        if (this._sectionStart < this._index) {
            this._state = this._baseState;
            this._handleTrailingData();
        }
    } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {
        this._decodeNumericEntity(2, 10);
        if (this._sectionStart < this._index) {
            this._state = this._baseState;
            this._handleTrailingData();
        }
    } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {
        this._decodeNumericEntity(3, 16);
        if (this._sectionStart < this._index) {
            this._state = this._baseState;
            this._handleTrailingData();
        }
    } else if (this._state !== IN_TAG_NAME && this._state !== BEFORE_ATTRIBUTE_NAME && this._state !== BEFORE_ATTRIBUTE_VALUE && this._state !== AFTER_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_NAME && this._state !== IN_ATTRIBUTE_VALUE_SQ && this._state !== IN_ATTRIBUTE_VALUE_DQ && this._state !== IN_ATTRIBUTE_VALUE_NQ && this._state !== IN_CLOSING_TAG_NAME) {
        this._cbs.ontext(data);
    }
};
Tokenizer.prototype.reset = function () {
    Tokenizer.call(this, {
        xmlMode: this._xmlMode,
        decodeEntities: this._decodeEntities
    }, this._cbs);
};
Tokenizer.prototype.getAbsoluteIndex = function () {
    return this._bufferOffset + this._index;
};
Tokenizer.prototype._getSection = function () {
    return this._buffer.substring(this._sectionStart, this._index);
};
Tokenizer.prototype._emitToken = function (name) {
    this._cbs[name](this._getSection());
    this._sectionStart = -1;
};
Tokenizer.prototype._emitPartial = function (value) {
    if (this._baseState !== TEXT) {
        this._cbs.onattribdata(value);
    } else {
        this._cbs.ontext(value);
    }
};
},{"52":52,"55":55,"56":56,"57":57}],70:[function(require,module,exports){
module.exports = Stream;
var Parser = require(66), WritableStream = require(268).Writable || require(5).Writable, StringDecoder = require(269).StringDecoder, Buffer = require(7).Buffer;
function Stream(cbs, options) {
    var parser = this._parser = new Parser(cbs, options);
    var decoder = this._decoder = new StringDecoder();
    WritableStream.call(this, { decodeStrings: false });
    this.once('finish', function () {
        parser.end(decoder.end());
    });
}
require(73)(Stream, WritableStream);
WritableStream.prototype._write = function (chunk, encoding, cb) {
    if (chunk instanceof Buffer)
        chunk = this._decoder.write(chunk);
    this._parser.write(chunk);
    cb();
};
},{"268":268,"269":269,"5":5,"66":66,"7":7,"73":73}],71:[function(require,module,exports){
var Parser = require(66), DomHandler = require(39);
function defineProp(name, value) {
    delete module.exports[name];
    module.exports[name] = value;
    return value;
}
module.exports = {
    Parser: Parser,
    Tokenizer: require(69),
    ElementType: require(38),
    DomHandler: DomHandler,
    get FeedHandler() {
        return defineProp('FeedHandler', require(65));
    },
    get Stream() {
        return defineProp('Stream', require(68));
    },
    get WritableStream() {
        return defineProp('WritableStream', require(70));
    },
    get ProxyHandler() {
        return defineProp('ProxyHandler', require(67));
    },
    get DomUtils() {
        return defineProp('DomUtils', require(42));
    },
    get CollectingHandler() {
        return defineProp('CollectingHandler', require(64));
    },
    DefaultHandler: DomHandler,
    get RssHandler() {
        return defineProp('RssHandler', this.FeedHandler);
    },
    parseDOM: function (data, options) {
        var handler = new DomHandler(options);
        new Parser(handler, options).end(data);
        return handler.dom;
    },
    parseFeed: function (feed, options) {
        var handler = new module.exports.FeedHandler(options);
        new Parser(handler, options).end(feed);
        return handler.dom;
    },
    createDomStream: function (cb, options, elementCb) {
        var handler = new DomHandler(cb, options, elementCb);
        return new Parser(handler, options);
    },
    EVENTS: {
        attribute: 2,
        cdatastart: 0,
        cdataend: 0,
        text: 1,
        processinginstruction: 2,
        comment: 1,
        commentend: 0,
        closetag: 1,
        opentag: 2,
        opentagname: 1,
        error: 1,
        end: 0
    }
};
},{"38":38,"39":39,"42":42,"64":64,"65":65,"66":66,"67":67,"68":68,"69":69,"70":70}],72:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
        e = 1 - eBias;
    } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) {
            value += rt / c;
        } else {
            value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i - d] |= s * 128;
};
},{}],73:[function(require,module,exports){
if (typeof Object.create === 'function') {
    module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    };
} else {
    module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    };
}
},{}],74:[function(require,module,exports){
var containers = [];
var styleElements = [];
var usage = 'insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).';
function insertCss(css, options) {
    options = options || {};
    if (css === undefined) {
        throw new Error(usage);
    }
    var position = options.prepend === true ? 'prepend' : 'append';
    var container = options.container !== undefined ? options.container : document.querySelector('head');
    var containerId = containers.indexOf(container);
    if (containerId === -1) {
        containerId = containers.push(container) - 1;
        styleElements[containerId] = {};
    }
    var styleElement;
    if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {
        styleElement = styleElements[containerId][position];
    } else {
        styleElement = styleElements[containerId][position] = createStyleElement();
        if (position === 'prepend') {
            container.insertBefore(styleElement, container.childNodes[0]);
        } else {
            container.appendChild(styleElement);
        }
    }
    if (css.charCodeAt(0) === 65279) {
        css = css.substr(1, css.length);
    }
    if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText += css;
    } else {
        styleElement.textContent += css;
    }
    return styleElement;
}
;
function createStyleElement() {
    var styleElement = document.createElement('style');
    styleElement.setAttribute('type', 'text/css');
    return styleElement;
}
module.exports = insertCss;
module.exports.insertCss = insertCss;
},{}],75:[function(require,module,exports){
'use strict';
function iota(n) {
    var result = new Array(n);
    for (var i = 0; i < n; ++i) {
        result[i] = i;
    }
    return result;
}
module.exports = iota;
},{}],76:[function(require,module,exports){
module.exports = function (obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}
},{}],77:[function(require,module,exports){
'use strict';
module.exports = function isPrimitive(value) {
    return value == null || typeof value !== 'function' && typeof value !== 'object';
};
},{}],78:[function(require,module,exports){
module.exports = isTypedArray;
isTypedArray.strict = isStrictTypedArray;
isTypedArray.loose = isLooseTypedArray;
var toString = Object.prototype.toString;
var names = {
    '[object Int8Array]': true,
    '[object Int16Array]': true,
    '[object Int32Array]': true,
    '[object Uint8Array]': true,
    '[object Uint8ClampedArray]': true,
    '[object Uint16Array]': true,
    '[object Uint32Array]': true,
    '[object Float32Array]': true,
    '[object Float64Array]': true
};
function isTypedArray(arr) {
    return isStrictTypedArray(arr) || isLooseTypedArray(arr);
}
function isStrictTypedArray(arr) {
    return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
}
function isLooseTypedArray(arr) {
    return names[toString.call(arr)];
}
},{}],79:[function(require,module,exports){
(function (Buffer){
var isBuffer = require(76);
var toString = Object.prototype.toString;
module.exports = function kindOf(val) {
    if (typeof val === 'undefined') {
        return 'undefined';
    }
    if (val === null) {
        return 'null';
    }
    if (val === true || val === false || val instanceof Boolean) {
        return 'boolean';
    }
    if (typeof val === 'string' || val instanceof String) {
        return 'string';
    }
    if (typeof val === 'number' || val instanceof Number) {
        return 'number';
    }
    if (typeof val === 'function' || val instanceof Function) {
        return 'function';
    }
    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
        return 'array';
    }
    if (val instanceof RegExp) {
        return 'regexp';
    }
    if (val instanceof Date) {
        return 'date';
    }
    var type = toString.call(val);
    if (type === '[object RegExp]') {
        return 'regexp';
    }
    if (type === '[object Date]') {
        return 'date';
    }
    if (type === '[object Arguments]') {
        return 'arguments';
    }
    if (type === '[object Error]') {
        return 'error';
    }
    if (typeof Buffer !== 'undefined' && isBuffer(val)) {
        return 'buffer';
    }
    if (type === '[object Set]') {
        return 'set';
    }
    if (type === '[object WeakSet]') {
        return 'weakset';
    }
    if (type === '[object Map]') {
        return 'map';
    }
    if (type === '[object WeakMap]') {
        return 'weakmap';
    }
    if (type === '[object Symbol]') {
        return 'symbol';
    }
    if (type === '[object Int8Array]') {
        return 'int8array';
    }
    if (type === '[object Uint8Array]') {
        return 'uint8array';
    }
    if (type === '[object Uint8ClampedArray]') {
        return 'uint8clampedarray';
    }
    if (type === '[object Int16Array]') {
        return 'int16array';
    }
    if (type === '[object Uint16Array]') {
        return 'uint16array';
    }
    if (type === '[object Int32Array]') {
        return 'int32array';
    }
    if (type === '[object Uint32Array]') {
        return 'uint32array';
    }
    if (type === '[object Float32Array]') {
        return 'float32array';
    }
    if (type === '[object Float64Array]') {
        return 'float64array';
    }
    return 'object';
};
}).call(this,require(7).Buffer)
},{"7":7,"76":76}],80:[function(require,module,exports){
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]';
var reIsUint = /^(?:0|[1-9]\d*)$/;
function apply(func, thisArg, args) {
    switch (args.length) {
    case 0:
        return func.call(thisArg);
    case 1:
        return func.call(thisArg, args[0]);
    case 2:
        return func.call(thisArg, args[0], args[1]);
    case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
        result[index] = iteratee(index);
    }
    return result;
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var propertyIsEnumerable = objectProto.propertyIsEnumerable;
var nativeMax = Math.max;
function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        object[key] = value;
    }
}
function baseKeysIn(object) {
    if (!isObject(object)) {
        return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
        }
    }
    return result;
}
function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
            array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
            otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
}
function createAssigner(assigner) {
    return baseRest(function (object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
        customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer;
            length = 1;
        }
        object = Object(object);
        while (++index < length) {
            var source = sources[index];
            if (source) {
                assigner(object, source, index, customizer);
            }
        }
        return object;
    });
}
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
        return false;
    }
    var type = typeof index;
    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
        return eq(object[index], value);
    }
    return false;
}
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
        for (var key in Object(object)) {
            result.push(key);
        }
    }
    return result;
}
function eq(value, other) {
    return value === other || value !== value && other !== other;
}
function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
var assignIn = createAssigner(function (object, source) {
    copyObject(source, keysIn(source), object);
});
function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
module.exports = assignIn;
},{}],81:[function(require,module,exports){
(function (global){
var FUNC_ERROR_TEXT = 'Expected a function';
var PLACEHOLDER = '__lodash_placeholder__';
var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256, FLIP_FLAG = 512;
var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
var wrapFlags = [
    [
        'ary',
        ARY_FLAG
    ],
    [
        'bind',
        BIND_FLAG
    ],
    [
        'bindKey',
        BIND_KEY_FLAG
    ],
    [
        'curry',
        CURRY_FLAG
    ],
    [
        'curryRight',
        CURRY_RIGHT_FLAG
    ],
    [
        'flip',
        FLIP_FLAG
    ],
    [
        'partial',
        PARTIAL_FLAG
    ],
    [
        'partialRight',
        PARTIAL_RIGHT_FLAG
    ],
    [
        'rearg',
        REARG_FLAG
    ]
];
var funcTag = '[object Function]', genTag = '[object GeneratorFunction]', symbolTag = '[object Symbol]';
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reTrim = /^\s+|\s+$/g;
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var reIsOctal = /^0o[0-7]+$/i;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var freeParseInt = parseInt;
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
function apply(func, thisArg, args) {
    switch (args.length) {
    case 0:
        return func.call(thisArg);
    case 1:
        return func.call(thisArg, args[0]);
    case 2:
        return func.call(thisArg, args[0], args[1]);
    case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
            break;
        }
    }
    return array;
}
function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
            return index;
        }
    }
    return -1;
}
function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
        if (array[index] === value) {
            return index;
        }
    }
    return -1;
}
function baseIsNaN(value) {
    return value !== value;
}
function countHolders(array, placeholder) {
    var length = array.length, result = 0;
    while (length--) {
        if (array[length] === placeholder) {
            result++;
        }
    }
    return result;
}
function getValue(object, key) {
    return object == null ? undefined : object[key];
}
function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
        try {
            result = !!(value + '');
        } catch (e) {
        }
    }
    return result;
}
function replaceHolders(array, placeholder) {
    var index = -1, length = array.length, resIndex = 0, result = [];
    while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
        }
    }
    return result;
}
var funcProto = Function.prototype, objectProto = Object.prototype;
var coreJsData = root['__core-js_shared__'];
var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
var objectCreate = Object.create;
var nativeMax = Math.max, nativeMin = Math.min;
var defineProperty = function () {
    var func = getNative(Object, 'defineProperty'), name = getNative.name;
    return name && name.length > 2 ? func : undefined;
}();
function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
}
function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
            array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
            otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
function composeArgs(args, partials, holders, isCurried) {
    var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
    while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
    }
    while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
            result[holders[argsIndex]] = args[argsIndex];
        }
    }
    while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
    }
    return result;
}
function composeArgsRight(args, partials, holders, isCurried) {
    var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
    while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
    }
    var offset = argsIndex;
    while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
    }
    while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
            result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
    }
    return result;
}
function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
        array[index] = source[index];
    }
    return array;
}
function createBind(func, bitmask, thisArg) {
    var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
    function wrapper() {
        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
    }
    return wrapper;
}
function createCtor(Ctor) {
    return function () {
        var args = arguments;
        switch (args.length) {
        case 0:
            return new Ctor();
        case 1:
            return new Ctor(args[0]);
        case 2:
            return new Ctor(args[0], args[1]);
        case 3:
            return new Ctor(args[0], args[1], args[2]);
        case 4:
            return new Ctor(args[0], args[1], args[2], args[3]);
        case 5:
            return new Ctor(args[0], args[1], args[2], args[3], args[4]);
        case 6:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
        case 7:
            return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
        return isObject(result) ? result : thisBinding;
    };
}
function createCurry(func, bitmask, arity) {
    var Ctor = createCtor(func);
    function wrapper() {
        var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
        while (index--) {
            args[index] = arguments[index];
        }
        var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
        length -= holders.length;
        if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
        }
        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        return apply(fn, this, args);
    }
    return wrapper;
}
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
    var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG), isFlip = bitmask & FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);
    function wrapper() {
        var length = arguments.length, args = Array(length), index = length;
        while (index--) {
            args[index] = arguments[index];
        }
        if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
        }
        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
        length = args.length;
        if (argPos) {
            args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
            args.reverse();
        }
        if (isAry && ary < length) {
            args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
    }
    return wrapper;
}
function createPartial(func, bitmask, thisArg, partials) {
    var isBind = bitmask & BIND_FLAG, Ctor = createCtor(func);
    function wrapper() {
        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
        while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
    }
    return wrapper;
}
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
    var isCurry = bitmask & CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
    bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
    bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
    if (!(bitmask & CURRY_BOUND_FLAG)) {
        bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
    }
    var result = wrapFunc(func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity);
    result.placeholder = placeholder;
    return setWrapToString(result, func, bitmask);
}
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
    var isBindKey = bitmask & BIND_KEY_FLAG;
    if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var length = partials ? partials.length : 0;
    if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
    }
    ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
    arity = arity === undefined ? arity : toInteger(arity);
    length -= holders ? holders.length : 0;
    if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials, holdersRight = holders;
        partials = holders = undefined;
    }
    var newData = [
        func,
        bitmask,
        thisArg,
        partials,
        holders,
        partialsRight,
        holdersRight,
        argPos,
        ary,
        arity
    ];
    func = newData[0];
    bitmask = newData[1];
    thisArg = newData[2];
    partials = newData[3];
    holders = newData[4];
    arity = newData[9] = newData[9] == null ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
    if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
        bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
    }
    if (!bitmask || bitmask == BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
    } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
    } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
    } else {
        result = createHybrid.apply(undefined, newData);
    }
    return setWrapToString(result, func, bitmask);
}
function getHolder(func) {
    var object = func;
    return object.placeholder;
}
function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
function getWrapDetails(source) {
    var match = source.match(reWrapDetails);
    return match ? match[1].split(reSplitDetails) : [];
}
function insertWrapDetails(source, details) {
    var length = details.length, lastIndex = length - 1;
    details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
    details = details.join(length > 2 ? ', ' : ' ');
    return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
}
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
function reorder(array, indexes) {
    var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
    while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
    }
    return array;
}
var setWrapToString = !defineProperty ? identity : function (wrapper, reference, bitmask) {
    var source = reference + '';
    return defineProperty(wrapper, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))
    });
};
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e) {
        }
    }
    return '';
}
function updateWrapDetails(details, bitmask) {
    arrayEach(wrapFlags, function (pair) {
        var value = '_.' + pair[0];
        if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
        }
    });
    return details.sort();
}
var bind = baseRest(function (func, thisArg, partials) {
    var bitmask = BIND_FLAG;
    if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= PARTIAL_FLAG;
    }
    return createWrap(func, bitmask, thisArg, partials, holders);
});
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
function toFinite(value) {
    if (!value) {
        return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
}
function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
}
function toNumber(value) {
    if (typeof value == 'number') {
        return value;
    }
    if (isSymbol(value)) {
        return NAN;
    }
    if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
        return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
function constant(value) {
    return function () {
        return value;
    };
}
function identity(value) {
    return value;
}
bind.placeholder = {};
module.exports = bind;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],82:[function(require,module,exports){
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]';
var reIsUint = /^(?:0|[1-9]\d*)$/;
function apply(func, thisArg, args) {
    switch (args.length) {
    case 0:
        return func.call(thisArg);
    case 1:
        return func.call(thisArg, args[0]);
    case 2:
        return func.call(thisArg, args[0], args[1]);
    case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
        result[index] = iteratee(index);
    }
    return result;
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var propertyIsEnumerable = objectProto.propertyIsEnumerable;
var nativeMax = Math.max;
function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
function assignInDefaults(objValue, srcValue, key, object) {
    if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        return srcValue;
    }
    return objValue;
}
function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        object[key] = value;
    }
}
function baseKeysIn(object) {
    if (!isObject(object)) {
        return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
        }
    }
    return result;
}
function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
            array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
            otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
}
function createAssigner(assigner) {
    return baseRest(function (object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
        customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer;
            length = 1;
        }
        object = Object(object);
        while (++index < length) {
            var source = sources[index];
            if (source) {
                assigner(object, source, index, customizer);
            }
        }
        return object;
    });
}
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
        return false;
    }
    var type = typeof index;
    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
        return eq(object[index], value);
    }
    return false;
}
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
        for (var key in Object(object)) {
            result.push(key);
        }
    }
    return result;
}
function eq(value, other) {
    return value === other || value !== value && other !== other;
}
function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object, customizer);
});
var defaults = baseRest(function (args) {
    args.push(undefined, assignInDefaults);
    return apply(assignInWith, undefined, args);
});
function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
module.exports = defaults;
},{}],83:[function(require,module,exports){
(function (global){
var LARGE_ARRAY_SIZE = 200;
var FUNC_ERROR_TEXT = 'Expected a function';
var HASH_UNDEFINED = '__lodash_hash_undefined__';
var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar = /\\(\\)?/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function () {
    try {
        return freeProcess && freeProcess.binding('util');
    } catch (e) {
    }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
function arrayFilter(array, predicate) {
    var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
    while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
            result[resIndex++] = value;
        }
    }
    return result;
}
function arraySome(array, predicate) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
        if (predicate(array[index], index, array)) {
            return true;
        }
    }
    return false;
}
function baseProperty(key) {
    return function (object) {
        return object == null ? undefined : object[key];
    };
}
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
        result[index] = iteratee(index);
    }
    return result;
}
function baseUnary(func) {
    return function (value) {
        return func(value);
    };
}
function getValue(object, key) {
    return object == null ? undefined : object[key];
}
function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
        try {
            result = !!(value + '');
        } catch (e) {
        }
    }
    return result;
}
function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function (value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
function overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
        result[++index] = value;
    });
    return result;
}
var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
var coreJsData = root['__core-js_shared__'];
var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
var Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
var nativeKeys = overArg(Object.keys, Object);
var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function listCacheClear() {
    this.__data__ = [];
}
function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    return true;
}
function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
    };
}
function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
        this.add(values[index]);
    }
}
function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
function setCacheHas(value) {
    return this.__data__.has(value);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
function stackClear() {
    this.__data__ = new ListCache();
}
function stackDelete(key) {
    return this.__data__['delete'](key);
}
function stackGet(key) {
    return this.__data__.get(key);
}
function stackHas(key) {
    return this.__data__.has(key);
}
function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
var baseEach = createBaseEach(baseForOwn);
function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function (value, index, collection) {
        if (predicate(value, index, collection)) {
            result.push(value);
        }
    });
    return result;
}
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
}
function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0, length = path.length;
    while (object != null && index < length) {
        object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
}
function baseGetTag(value) {
    return objectToString.call(value);
}
function baseHasIn(object, key) {
    return object != null && key in Object(object);
}
function baseIsEqual(value, other, customizer, bitmask, stack) {
    if (value === other) {
        return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
    if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
    }
    if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
    }
    var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
    }
    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
    }
    if (!isSameTag) {
        return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}
function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
        return !length;
    }
    object = Object(object);
    while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
        }
    }
    while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) {
                return false;
            }
        } else {
            var stack = new Stack();
            if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                return false;
            }
        }
    }
    return true;
}
function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}
function baseIteratee(value) {
    if (typeof value == 'function') {
        return value;
    }
    if (value == null) {
        return identity;
    }
    if (typeof value == 'object') {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
}
function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function (object) {
        return object === source || baseIsMatch(object, source, matchData);
    };
}
function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
    }
    return function (object) {
        var objValue = get(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
    };
}
function basePropertyDeep(path) {
    return function (object) {
        return baseGet(object, path);
    };
}
function baseToString(value) {
    if (typeof value == 'string') {
        return value;
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
}
function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
        if (collection == null) {
            return collection;
        }
        if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
                break;
            }
        }
        return collection;
    };
}
function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
                break;
            }
        }
        return object;
    };
}
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
            if (compared) {
                continue;
            }
            result = false;
            break;
        }
        if (seen) {
            if (!arraySome(other, function (othValue, othIndex) {
                    if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                        return seen.add(othIndex);
                    }
                })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
            result = false;
            break;
        }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
}
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
    switch (tag) {
    case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
        }
        object = object.buffer;
        other = other.buffer;
    case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
        }
        return true;
    case boolTag:
    case dateTag:
    case numberTag:
        return eq(+object, +other);
    case errorTag:
        return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
        return object == other + '';
    case mapTag:
        var convert = mapToArray;
    case setTag:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
            return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
            return stacked == other;
        }
        bitmask |= UNORDERED_COMPARE_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
        stack['delete'](object);
        return result;
    case symbolTag:
        if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
}
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
        return false;
    }
    var index = objLength;
    while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
        }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            result = false;
        }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
}
function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
        var key = result[length], value = object[key];
        result[length] = [
            key,
            value,
            isStrictComparable(value)
        ];
    }
    return result;
}
function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function (value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
        if (ctorString) {
            switch (ctorString) {
            case dataViewCtorString:
                return dataViewTag;
            case mapCtorString:
                return mapTag;
            case promiseCtorString:
                return promiseTag;
            case setCtorString:
                return setTag;
            case weakMapCtorString:
                return weakMapTag;
            }
        }
        return result;
    };
}
function hasPath(object, path, hasFunc) {
    path = isKey(path, object) ? [path] : castPath(path);
    var result, index = -1, length = path.length;
    while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
            break;
        }
        object = object[key];
    }
    if (result) {
        return result;
    }
    var length = object ? object.length : 0;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isKey(value, object) {
    if (isArray(value)) {
        return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
function isStrictComparable(value) {
    return value === value && !isObject(value);
}
function matchesStrictComparable(key, srcValue) {
    return function (object) {
        if (object == null) {
            return false;
        }
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
}
var stringToPath = memoize(function (string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
        result.push('');
    }
    string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
});
function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
        return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e) {
        }
    }
    return '';
}
function filter(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, baseIteratee(predicate, 3));
}
function memoize(func, resolver) {
    if (typeof func != 'function' || resolver && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
}
memoize.Cache = MapCache;
function eq(value, other) {
    return value === other || value !== value && other !== other;
}
function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
function toString(value) {
    return value == null ? '' : baseToString(value);
}
function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
}
function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
}
function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function identity(value) {
    return value;
}
function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
module.exports = filter;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],84:[function(require,module,exports){
(function (global){
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]';
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
        array[offset + index] = values[index];
    }
    return array;
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var Symbol = root.Symbol, propertyIsEnumerable = objectProto.propertyIsEnumerable, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
                arrayPush(result, value);
            }
        } else if (!isStrict) {
            result[result.length] = value;
        }
    }
    return result;
}
function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function flatten(array) {
    var length = array ? array.length : 0;
    return length ? baseFlatten(array, 1) : [];
}
function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
module.exports = flatten;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],85:[function(require,module,exports){
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]';
var reIsUint = /^(?:0|[1-9]\d*)$/;
function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
            break;
        }
    }
    return array;
}
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
        result[index] = iteratee(index);
    }
    return result;
}
function overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var propertyIsEnumerable = objectProto.propertyIsEnumerable;
var nativeKeys = overArg(Object.keys, Object);
function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
var baseEach = createBaseEach(baseForOwn);
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
}
function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
        if (collection == null) {
            return collection;
        }
        if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
                break;
            }
        }
        return collection;
    };
}
function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
                break;
            }
        }
        return object;
    };
}
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
function forEach(collection, iteratee) {
    var func = isArray(collection) ? arrayEach : baseEach;
    return func(collection, typeof iteratee == 'function' ? iteratee : identity);
}
function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function identity(value) {
    return value;
}
module.exports = forEach;
},{}],86:[function(require,module,exports){
(function (global){
var LARGE_ARRAY_SIZE = 200;
var FUNC_ERROR_TEXT = 'Expected a function';
var HASH_UNDEFINED = '__lodash_hash_undefined__';
var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar = /\\(\\)?/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function () {
    try {
        return freeProcess && freeProcess.binding('util');
    } catch (e) {
    }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while (++index < length) {
        result[index] = iteratee(array[index], index, array);
    }
    return result;
}
function arraySome(array, predicate) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
        if (predicate(array[index], index, array)) {
            return true;
        }
    }
    return false;
}
function baseProperty(key) {
    return function (object) {
        return object == null ? undefined : object[key];
    };
}
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
        result[index] = iteratee(index);
    }
    return result;
}
function baseUnary(func) {
    return function (value) {
        return func(value);
    };
}
function getValue(object, key) {
    return object == null ? undefined : object[key];
}
function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
        try {
            result = !!(value + '');
        } catch (e) {
        }
    }
    return result;
}
function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function (value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
function overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
        result[++index] = value;
    });
    return result;
}
var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
var coreJsData = root['__core-js_shared__'];
var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
var Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
var nativeKeys = overArg(Object.keys, Object);
var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function listCacheClear() {
    this.__data__ = [];
}
function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    return true;
}
function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
    };
}
function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
        this.add(values[index]);
    }
}
function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
function setCacheHas(value) {
    return this.__data__.has(value);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
function stackClear() {
    this.__data__ = new ListCache();
}
function stackDelete(key) {
    return this.__data__['delete'](key);
}
function stackGet(key) {
    return this.__data__.get(key);
}
function stackHas(key) {
    return this.__data__.has(key);
}
function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
var baseEach = createBaseEach(baseForOwn);
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
}
function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0, length = path.length;
    while (object != null && index < length) {
        object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
}
function baseGetTag(value) {
    return objectToString.call(value);
}
function baseHasIn(object, key) {
    return object != null && key in Object(object);
}
function baseIsEqual(value, other, customizer, bitmask, stack) {
    if (value === other) {
        return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
    if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
    }
    if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
    }
    var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
    }
    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
    }
    if (!isSameTag) {
        return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}
function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
        return !length;
    }
    object = Object(object);
    while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
        }
    }
    while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) {
                return false;
            }
        } else {
            var stack = new Stack();
            if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                return false;
            }
        }
    }
    return true;
}
function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}
function baseIteratee(value) {
    if (typeof value == 'function') {
        return value;
    }
    if (value == null) {
        return identity;
    }
    if (typeof value == 'object') {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
}
function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
function baseMap(collection, iteratee) {
    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function (value, key, collection) {
        result[++index] = iteratee(value, key, collection);
    });
    return result;
}
function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function (object) {
        return object === source || baseIsMatch(object, source, matchData);
    };
}
function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
    }
    return function (object) {
        var objValue = get(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
    };
}
function basePropertyDeep(path) {
    return function (object) {
        return baseGet(object, path);
    };
}
function baseToString(value) {
    if (typeof value == 'string') {
        return value;
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
}
function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
        if (collection == null) {
            return collection;
        }
        if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
                break;
            }
        }
        return collection;
    };
}
function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
                break;
            }
        }
        return object;
    };
}
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
            if (compared) {
                continue;
            }
            result = false;
            break;
        }
        if (seen) {
            if (!arraySome(other, function (othValue, othIndex) {
                    if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                        return seen.add(othIndex);
                    }
                })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
            result = false;
            break;
        }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
}
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
    switch (tag) {
    case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
        }
        object = object.buffer;
        other = other.buffer;
    case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
        }
        return true;
    case boolTag:
    case dateTag:
    case numberTag:
        return eq(+object, +other);
    case errorTag:
        return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
        return object == other + '';
    case mapTag:
        var convert = mapToArray;
    case setTag:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
            return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
            return stacked == other;
        }
        bitmask |= UNORDERED_COMPARE_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
        stack['delete'](object);
        return result;
    case symbolTag:
        if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
}
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
        return false;
    }
    var index = objLength;
    while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
        }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            result = false;
        }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
}
function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
        var key = result[length], value = object[key];
        result[length] = [
            key,
            value,
            isStrictComparable(value)
        ];
    }
    return result;
}
function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function (value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
        if (ctorString) {
            switch (ctorString) {
            case dataViewCtorString:
                return dataViewTag;
            case mapCtorString:
                return mapTag;
            case promiseCtorString:
                return promiseTag;
            case setCtorString:
                return setTag;
            case weakMapCtorString:
                return weakMapTag;
            }
        }
        return result;
    };
}
function hasPath(object, path, hasFunc) {
    path = isKey(path, object) ? [path] : castPath(path);
    var result, index = -1, length = path.length;
    while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
            break;
        }
        object = object[key];
    }
    if (result) {
        return result;
    }
    var length = object ? object.length : 0;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isKey(value, object) {
    if (isArray(value)) {
        return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
function isStrictComparable(value) {
    return value === value && !isObject(value);
}
function matchesStrictComparable(key, srcValue) {
    return function (object) {
        if (object == null) {
            return false;
        }
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
}
var stringToPath = memoize(function (string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
        result.push('');
    }
    string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
});
function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
        return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e) {
        }
    }
    return '';
}
function map(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee, 3));
}
function memoize(func, resolver) {
    if (typeof func != 'function' || resolver && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
}
memoize.Cache = MapCache;
function eq(value, other) {
    return value === other || value !== value && other !== other;
}
function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
function toString(value) {
    return value == null ? '' : baseToString(value);
}
function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
}
function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
}
function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function identity(value) {
    return value;
}
function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
module.exports = map;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],87:[function(require,module,exports){
(function (global){
var LARGE_ARRAY_SIZE = 200;
var HASH_UNDEFINED = '__lodash_hash_undefined__';
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reFlags = /\w*$/;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function () {
    try {
        return freeProcess && freeProcess.binding('util');
    } catch (e) {
    }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
function addMapEntry(map, pair) {
    map.set(pair[0], pair[1]);
    return map;
}
function addSetEntry(set, value) {
    set.add(value);
    return set;
}
function apply(func, thisArg, args) {
    switch (args.length) {
    case 0:
        return func.call(thisArg);
    case 1:
        return func.call(thisArg, args[0]);
    case 2:
        return func.call(thisArg, args[0], args[1]);
    case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
            break;
        }
    }
    return array;
}
function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
        array[offset + index] = values[index];
    }
    return array;
}
function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
        accumulator = array[++index];
    }
    while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
}
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
        result[index] = iteratee(index);
    }
    return result;
}
function baseUnary(func) {
    return function (value) {
        return func(value);
    };
}
function getValue(object, key) {
    return object == null ? undefined : object[key];
}
function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
        try {
            result = !!(value + '');
        } catch (e) {
        }
    }
    return result;
}
function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function (value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
function overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
        result[++index] = value;
    });
    return result;
}
var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
var coreJsData = root['__core-js_shared__'];
var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
var objectToString = objectProto.toString;
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max;
var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function listCacheClear() {
    this.__data__ = [];
}
function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    return true;
}
function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
    };
}
function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
function stackClear() {
    this.__data__ = new ListCache();
}
function stackDelete(key) {
    return this.__data__['delete'](key);
}
function stackGet(key) {
    return this.__data__.get(key);
}
function stackHas(key) {
    return this.__data__.has(key);
}
function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
function assignMergeValue(object, key, value) {
    if (value !== undefined && !eq(object[key], value) || typeof key == 'number' && value === undefined && !(key in object)) {
        object[key] = value;
    }
}
function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        object[key] = value;
    }
}
function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
}
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
        return result;
    }
    if (!isObject(value)) {
        return value;
    }
    var isArr = isArray(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
            return copyArray(value, result);
        }
    } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
            if (isHostObject(value)) {
                return object ? value : {};
            }
            result = initCloneObject(isFunc ? {} : value);
            if (!isDeep) {
                return copySymbols(value, baseAssign(result, value));
            }
        } else {
            if (!cloneableTags[tag]) {
                return object ? value : {};
            }
            result = initCloneByTag(value, tag, baseClone, isDeep);
        }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
        return stacked;
    }
    stack.set(value, result);
    if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
    }
    arrayEach(props || value, function (subValue, key) {
        if (props) {
            key = subValue;
            subValue = value[key];
        }
        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
}
function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
function baseGetTag(value) {
    return objectToString.call(value);
}
function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}
function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
function baseKeysIn(object) {
    if (!isObject(object)) {
        return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
        }
    }
    return result;
}
function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
        return;
    }
    if (!(isArray(source) || isTypedArray(source))) {
        var props = baseKeysIn(source);
    }
    arrayEach(props || source, function (srcValue, key) {
        if (props) {
            key = srcValue;
            srcValue = source[key];
        }
        if (isObject(srcValue)) {
            stack || (stack = new Stack());
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
            var newValue = customizer ? customizer(object[key], srcValue, key + '', object, source, stack) : undefined;
            if (newValue === undefined) {
                newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
        }
    });
}
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
    if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
    var isCommon = newValue === undefined;
    if (isCommon) {
        newValue = srcValue;
        if (isArray(srcValue) || isTypedArray(srcValue)) {
            if (isArray(objValue)) {
                newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
            } else {
                isCommon = false;
                newValue = baseClone(srcValue, true);
            }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || srcIndex && isFunction(objValue)) {
                isCommon = false;
                newValue = baseClone(srcValue, true);
            } else {
                newValue = objValue;
            }
        } else {
            isCommon = false;
        }
    }
    if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
    }
    assignMergeValue(object, key, newValue);
}
function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
            array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
            otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
        return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
}
function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
}
function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor());
}
function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
}
function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor());
}
function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
        array[index] = source[index];
    }
    return array;
}
function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
}
function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
}
function createAssigner(assigner) {
    return baseRest(function (object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
        customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined : customizer;
            length = 1;
        }
        object = Object(object);
        while (++index < length) {
            var source = sources[index];
            if (source) {
                assigner(object, source, index, customizer);
            }
        }
        return object;
    });
}
function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function (value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
        if (ctorString) {
            switch (ctorString) {
            case dataViewCtorString:
                return dataViewTag;
            case mapCtorString:
                return mapTag;
            case promiseCtorString:
                return promiseTag;
            case setCtorString:
                return setTag;
            case weakMapCtorString:
                return weakMapTag;
            }
        }
        return result;
    };
}
function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
}
function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
    case arrayBufferTag:
        return cloneArrayBuffer(object);
    case boolTag:
    case dateTag:
        return new Ctor(+object);
    case dataViewTag:
        return cloneDataView(object, isDeep);
    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
        return cloneTypedArray(object, isDeep);
    case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
    case numberTag:
    case stringTag:
        return new Ctor(object);
    case regexpTag:
        return cloneRegExp(object);
    case setTag:
        return cloneSet(object, isDeep, cloneFunc);
    case symbolTag:
        return cloneSymbol(object);
    }
}
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
        return false;
    }
    var type = typeof index;
    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
        return eq(object[index], value);
    }
    return false;
}
function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
        for (var key in Object(object)) {
            result.push(key);
        }
    }
    return result;
}
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e) {
        }
    }
    return '';
}
function eq(value, other) {
    return value === other || value !== value && other !== other;
}
function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
var isBuffer = nativeIsBuffer || stubFalse;
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
function toPlainObject(value) {
    return copyObject(value, keysIn(value));
}
function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var merge = createAssigner(function (object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
});
function stubArray() {
    return [];
}
function stubFalse() {
    return false;
}
module.exports = merge;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],88:[function(require,module,exports){
(function (global){
var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', symbolTag = '[object Symbol]';
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
function apply(func, thisArg, args) {
    switch (args.length) {
    case 0:
        return func.call(thisArg);
    case 1:
        return func.call(thisArg, args[0]);
    case 2:
        return func.call(thisArg, args[0], args[1]);
    case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while (++index < length) {
        result[index] = iteratee(array[index], index, array);
    }
    return result;
}
function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
        array[offset + index] = values[index];
    }
    return array;
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var Symbol = root.Symbol, propertyIsEnumerable = objectProto.propertyIsEnumerable, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
var nativeMax = Math.max;
function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
                arrayPush(result, value);
            }
        } else if (!isStrict) {
            result[result.length] = value;
        }
    }
    return result;
}
function basePick(object, props) {
    object = Object(object);
    return basePickBy(object, props, function (value, key) {
        return key in object;
    });
}
function basePickBy(object, props, predicate) {
    var index = -1, length = props.length, result = {};
    while (++index < length) {
        var key = props[index], value = object[key];
        if (predicate(value, key)) {
            result[key] = value;
        }
    }
    return result;
}
function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
            array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
            otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
        return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
var pick = baseRest(function (object, props) {
    return object == null ? {} : basePick(object, arrayMap(baseFlatten(props, 1), toKey));
});
module.exports = pick;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],89:[function(require,module,exports){
(function (global){
var LARGE_ARRAY_SIZE = 200;
var FUNC_ERROR_TEXT = 'Expected a function';
var HASH_UNDEFINED = '__lodash_hash_undefined__';
var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar = /\\(\\)?/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function () {
    try {
        return freeProcess && freeProcess.binding('util');
    } catch (e) {
    }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
        accumulator = array[++index];
    }
    while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
}
function arraySome(array, predicate) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
        if (predicate(array[index], index, array)) {
            return true;
        }
    }
    return false;
}
function baseProperty(key) {
    return function (object) {
        return object == null ? undefined : object[key];
    };
}
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function (value, index, collection) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
}
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
        result[index] = iteratee(index);
    }
    return result;
}
function baseUnary(func) {
    return function (value) {
        return func(value);
    };
}
function getValue(object, key) {
    return object == null ? undefined : object[key];
}
function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
        try {
            result = !!(value + '');
        } catch (e) {
        }
    }
    return result;
}
function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function (value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
function overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
        result[++index] = value;
    });
    return result;
}
var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
var coreJsData = root['__core-js_shared__'];
var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
var Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
var nativeKeys = overArg(Object.keys, Object);
var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function listCacheClear() {
    this.__data__ = [];
}
function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    return true;
}
function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
    };
}
function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
        this.add(values[index]);
    }
}
function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
function setCacheHas(value) {
    return this.__data__.has(value);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
function stackClear() {
    this.__data__ = new ListCache();
}
function stackDelete(key) {
    return this.__data__['delete'](key);
}
function stackGet(key) {
    return this.__data__.get(key);
}
function stackHas(key) {
    return this.__data__.has(key);
}
function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
var baseEach = createBaseEach(baseForOwn);
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
}
function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0, length = path.length;
    while (object != null && index < length) {
        object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
}
function baseGetTag(value) {
    return objectToString.call(value);
}
function baseHasIn(object, key) {
    return object != null && key in Object(object);
}
function baseIsEqual(value, other, customizer, bitmask, stack) {
    if (value === other) {
        return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
    if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
    }
    if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
    }
    var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
    }
    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
    }
    if (!isSameTag) {
        return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}
function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
        return !length;
    }
    object = Object(object);
    while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
        }
    }
    while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) {
                return false;
            }
        } else {
            var stack = new Stack();
            if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                return false;
            }
        }
    }
    return true;
}
function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}
function baseIteratee(value) {
    if (typeof value == 'function') {
        return value;
    }
    if (value == null) {
        return identity;
    }
    if (typeof value == 'object') {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
}
function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function (object) {
        return object === source || baseIsMatch(object, source, matchData);
    };
}
function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
    }
    return function (object) {
        var objValue = get(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
    };
}
function basePropertyDeep(path) {
    return function (object) {
        return baseGet(object, path);
    };
}
function baseToString(value) {
    if (typeof value == 'string') {
        return value;
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
}
function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
        if (collection == null) {
            return collection;
        }
        if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
                break;
            }
        }
        return collection;
    };
}
function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
                break;
            }
        }
        return object;
    };
}
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
            if (compared) {
                continue;
            }
            result = false;
            break;
        }
        if (seen) {
            if (!arraySome(other, function (othValue, othIndex) {
                    if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                        return seen.add(othIndex);
                    }
                })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
            result = false;
            break;
        }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
}
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
    switch (tag) {
    case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
        }
        object = object.buffer;
        other = other.buffer;
    case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
        }
        return true;
    case boolTag:
    case dateTag:
    case numberTag:
        return eq(+object, +other);
    case errorTag:
        return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
        return object == other + '';
    case mapTag:
        var convert = mapToArray;
    case setTag:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
            return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
            return stacked == other;
        }
        bitmask |= UNORDERED_COMPARE_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
        stack['delete'](object);
        return result;
    case symbolTag:
        if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
}
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
        return false;
    }
    var index = objLength;
    while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
        }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            result = false;
        }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
}
function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
        var key = result[length], value = object[key];
        result[length] = [
            key,
            value,
            isStrictComparable(value)
        ];
    }
    return result;
}
function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function (value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
        if (ctorString) {
            switch (ctorString) {
            case dataViewCtorString:
                return dataViewTag;
            case mapCtorString:
                return mapTag;
            case promiseCtorString:
                return promiseTag;
            case setCtorString:
                return setTag;
            case weakMapCtorString:
                return weakMapTag;
            }
        }
        return result;
    };
}
function hasPath(object, path, hasFunc) {
    path = isKey(path, object) ? [path] : castPath(path);
    var result, index = -1, length = path.length;
    while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
            break;
        }
        object = object[key];
    }
    if (result) {
        return result;
    }
    var length = object ? object.length : 0;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isKey(value, object) {
    if (isArray(value)) {
        return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
function isStrictComparable(value) {
    return value === value && !isObject(value);
}
function matchesStrictComparable(key, srcValue) {
    return function (object) {
        if (object == null) {
            return false;
        }
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
}
var stringToPath = memoize(function (string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
        result.push('');
    }
    string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
});
function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
        return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e) {
        }
    }
    return '';
}
function reduce(collection, iteratee, accumulator) {
    var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
    return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}
function memoize(func, resolver) {
    if (typeof func != 'function' || resolver && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
}
memoize.Cache = MapCache;
function eq(value, other) {
    return value === other || value !== value && other !== other;
}
function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
function toString(value) {
    return value == null ? '' : baseToString(value);
}
function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
}
function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
}
function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function identity(value) {
    return value;
}
function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
module.exports = reduce;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],90:[function(require,module,exports){
(function (global){
var LARGE_ARRAY_SIZE = 200;
var FUNC_ERROR_TEXT = 'Expected a function';
var HASH_UNDEFINED = '__lodash_hash_undefined__';
var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar = /\\(\\)?/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function () {
    try {
        return freeProcess && freeProcess.binding('util');
    } catch (e) {
    }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
function arrayFilter(array, predicate) {
    var index = -1, length = array ? array.length : 0, resIndex = 0, result = [];
    while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
            result[resIndex++] = value;
        }
    }
    return result;
}
function arraySome(array, predicate) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
        if (predicate(array[index], index, array)) {
            return true;
        }
    }
    return false;
}
function baseProperty(key) {
    return function (object) {
        return object == null ? undefined : object[key];
    };
}
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
        result[index] = iteratee(index);
    }
    return result;
}
function baseUnary(func) {
    return function (value) {
        return func(value);
    };
}
function getValue(object, key) {
    return object == null ? undefined : object[key];
}
function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
        try {
            result = !!(value + '');
        } catch (e) {
        }
    }
    return result;
}
function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function (value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
function overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
        result[++index] = value;
    });
    return result;
}
var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
var coreJsData = root['__core-js_shared__'];
var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
var Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
var nativeKeys = overArg(Object.keys, Object);
var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function listCacheClear() {
    this.__data__ = [];
}
function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    return true;
}
function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
    };
}
function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
        this.add(values[index]);
    }
}
function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
function setCacheHas(value) {
    return this.__data__.has(value);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
function stackClear() {
    this.__data__ = new ListCache();
}
function stackDelete(key) {
    return this.__data__['delete'](key);
}
function stackGet(key) {
    return this.__data__.get(key);
}
function stackHas(key) {
    return this.__data__.has(key);
}
function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
var baseEach = createBaseEach(baseForOwn);
function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function (value, index, collection) {
        if (predicate(value, index, collection)) {
            result.push(value);
        }
    });
    return result;
}
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
}
function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0, length = path.length;
    while (object != null && index < length) {
        object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
}
function baseGetTag(value) {
    return objectToString.call(value);
}
function baseHasIn(object, key) {
    return object != null && key in Object(object);
}
function baseIsEqual(value, other, customizer, bitmask, stack) {
    if (value === other) {
        return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
    if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
    }
    if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
    }
    var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
    }
    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
    }
    if (!isSameTag) {
        return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}
function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
        return !length;
    }
    object = Object(object);
    while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
        }
    }
    while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) {
                return false;
            }
        } else {
            var stack = new Stack();
            if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                return false;
            }
        }
    }
    return true;
}
function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}
function baseIteratee(value) {
    if (typeof value == 'function') {
        return value;
    }
    if (value == null) {
        return identity;
    }
    if (typeof value == 'object') {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
}
function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function (object) {
        return object === source || baseIsMatch(object, source, matchData);
    };
}
function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
    }
    return function (object) {
        var objValue = get(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
    };
}
function basePropertyDeep(path) {
    return function (object) {
        return baseGet(object, path);
    };
}
function baseToString(value) {
    if (typeof value == 'string') {
        return value;
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
}
function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
        if (collection == null) {
            return collection;
        }
        if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
                break;
            }
        }
        return collection;
    };
}
function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
                break;
            }
        }
        return object;
    };
}
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
            if (compared) {
                continue;
            }
            result = false;
            break;
        }
        if (seen) {
            if (!arraySome(other, function (othValue, othIndex) {
                    if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                        return seen.add(othIndex);
                    }
                })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
            result = false;
            break;
        }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
}
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
    switch (tag) {
    case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
        }
        object = object.buffer;
        other = other.buffer;
    case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
        }
        return true;
    case boolTag:
    case dateTag:
    case numberTag:
        return eq(+object, +other);
    case errorTag:
        return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
        return object == other + '';
    case mapTag:
        var convert = mapToArray;
    case setTag:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
            return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
            return stacked == other;
        }
        bitmask |= UNORDERED_COMPARE_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
        stack['delete'](object);
        return result;
    case symbolTag:
        if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
}
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
        return false;
    }
    var index = objLength;
    while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
        }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            result = false;
        }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
}
function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
        var key = result[length], value = object[key];
        result[length] = [
            key,
            value,
            isStrictComparable(value)
        ];
    }
    return result;
}
function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function (value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
        if (ctorString) {
            switch (ctorString) {
            case dataViewCtorString:
                return dataViewTag;
            case mapCtorString:
                return mapTag;
            case promiseCtorString:
                return promiseTag;
            case setCtorString:
                return setTag;
            case weakMapCtorString:
                return weakMapTag;
            }
        }
        return result;
    };
}
function hasPath(object, path, hasFunc) {
    path = isKey(path, object) ? [path] : castPath(path);
    var result, index = -1, length = path.length;
    while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
            break;
        }
        object = object[key];
    }
    if (result) {
        return result;
    }
    var length = object ? object.length : 0;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isKey(value, object) {
    if (isArray(value)) {
        return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
function isStrictComparable(value) {
    return value === value && !isObject(value);
}
function matchesStrictComparable(key, srcValue) {
    return function (object) {
        if (object == null) {
            return false;
        }
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
}
var stringToPath = memoize(function (string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
        result.push('');
    }
    string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
});
function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
        return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e) {
        }
    }
    return '';
}
function reject(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, negate(baseIteratee(predicate, 3)));
}
function memoize(func, resolver) {
    if (typeof func != 'function' || resolver && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
}
memoize.Cache = MapCache;
function negate(predicate) {
    if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    return function () {
        var args = arguments;
        switch (args.length) {
        case 0:
            return !predicate.call(this);
        case 1:
            return !predicate.call(this, args[0]);
        case 2:
            return !predicate.call(this, args[0], args[1]);
        case 3:
            return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
    };
}
function eq(value, other) {
    return value === other || value !== value && other !== other;
}
function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
function toString(value) {
    return value == null ? '' : baseToString(value);
}
function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
}
function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
}
function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function identity(value) {
    return value;
}
function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
module.exports = reject;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],91:[function(require,module,exports){
(function (global){
var LARGE_ARRAY_SIZE = 200;
var FUNC_ERROR_TEXT = 'Expected a function';
var HASH_UNDEFINED = '__lodash_hash_undefined__';
var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reEscapeChar = /\\(\\)?/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function () {
    try {
        return freeProcess && freeProcess.binding('util');
    } catch (e) {
    }
}();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
function arraySome(array, predicate) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
        if (predicate(array[index], index, array)) {
            return true;
        }
    }
    return false;
}
function baseProperty(key) {
    return function (object) {
        return object == null ? undefined : object[key];
    };
}
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
        result[index] = iteratee(index);
    }
    return result;
}
function baseUnary(func) {
    return function (value) {
        return func(value);
    };
}
function getValue(object, key) {
    return object == null ? undefined : object[key];
}
function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != 'function') {
        try {
            result = !!(value + '');
        } catch (e) {
        }
    }
    return result;
}
function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function (value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
function overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
        result[++index] = value;
    });
    return result;
}
var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
var coreJsData = root['__core-js_shared__'];
var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
var Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
var nativeKeys = overArg(Object.keys, Object);
var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function listCacheClear() {
    this.__data__ = [];
}
function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    return true;
}
function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
    };
}
function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
        this.add(values[index]);
    }
}
function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
function setCacheHas(value) {
    return this.__data__.has(value);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
function stackClear() {
    this.__data__ = new ListCache();
}
function stackDelete(key) {
    return this.__data__['delete'](key);
}
function stackGet(key) {
    return this.__data__.get(key);
}
function stackHas(key) {
    return this.__data__.has(key);
}
function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
var baseEach = createBaseEach(baseForOwn);
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
}
function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0, length = path.length;
    while (object != null && index < length) {
        object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
}
function baseGetTag(value) {
    return objectToString.call(value);
}
function baseHasIn(object, key) {
    return object != null && key in Object(object);
}
function baseIsEqual(value, other, customizer, bitmask, stack) {
    if (value === other) {
        return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
    if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
    }
    if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
    }
    var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
    }
    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
    }
    if (!isSameTag) {
        return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}
function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
        return !length;
    }
    object = Object(object);
    while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
        }
    }
    while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === undefined && !(key in object)) {
                return false;
            }
        } else {
            var stack = new Stack();
            if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                return false;
            }
        }
    }
    return true;
}
function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}
function baseIteratee(value) {
    if (typeof value == 'function') {
        return value;
    }
    if (value == null) {
        return identity;
    }
    if (typeof value == 'object') {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
}
function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function (object) {
        return object === source || baseIsMatch(object, source, matchData);
    };
}
function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
    }
    return function (object) {
        var objValue = get(object, path);
        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
    };
}
function basePropertyDeep(path) {
    return function (object) {
        return baseGet(object, path);
    };
}
function baseSome(collection, predicate) {
    var result;
    baseEach(collection, function (value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
    });
    return !!result;
}
function baseToString(value) {
    if (typeof value == 'string') {
        return value;
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
}
function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
        if (collection == null) {
            return collection;
        }
        if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
                break;
            }
        }
        return collection;
    };
}
function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
                break;
            }
        }
        return object;
    };
}
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
            if (compared) {
                continue;
            }
            result = false;
            break;
        }
        if (seen) {
            if (!arraySome(other, function (othValue, othIndex) {
                    if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
                        return seen.add(othIndex);
                    }
                })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
            result = false;
            break;
        }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
}
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
    switch (tag) {
    case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
        }
        object = object.buffer;
        other = other.buffer;
    case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
        }
        return true;
    case boolTag:
    case dateTag:
    case numberTag:
        return eq(+object, +other);
    case errorTag:
        return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
        return object == other + '';
    case mapTag:
        var convert = mapToArray;
    case setTag:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
            return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
            return stacked == other;
        }
        bitmask |= UNORDERED_COMPARE_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
        stack['delete'](object);
        return result;
    case symbolTag:
        if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
}
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
        return false;
    }
    var index = objLength;
    while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
        }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            result = false;
        }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
}
function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
        var key = result[length], value = object[key];
        result[length] = [
            key,
            value,
            isStrictComparable(value)
        ];
    }
    return result;
}
function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function (value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
        if (ctorString) {
            switch (ctorString) {
            case dataViewCtorString:
                return dataViewTag;
            case mapCtorString:
                return mapTag;
            case promiseCtorString:
                return promiseTag;
            case setCtorString:
                return setTag;
            case weakMapCtorString:
                return weakMapTag;
            }
        }
        return result;
    };
}
function hasPath(object, path, hasFunc) {
    path = isKey(path, object) ? [path] : castPath(path);
    var result, index = -1, length = path.length;
    while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
            break;
        }
        object = object[key];
    }
    if (result) {
        return result;
    }
    var length = object ? object.length : 0;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
        return false;
    }
    var type = typeof index;
    if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
        return eq(object[index], value);
    }
    return false;
}
function isKey(value, object) {
    if (isArray(value)) {
        return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
function isStrictComparable(value) {
    return value === value && !isObject(value);
}
function matchesStrictComparable(key, srcValue) {
    return function (object) {
        if (object == null) {
            return false;
        }
        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
}
var stringToPath = memoize(function (string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
        result.push('');
    }
    string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
});
function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
        return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e) {
        }
    }
    return '';
}
function some(collection, predicate, guard) {
    var func = isArray(collection) ? arraySome : baseSome;
    if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
    }
    return func(collection, baseIteratee(predicate, 3));
}
function memoize(func, resolver) {
    if (typeof func != 'function' || resolver && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
}
memoize.Cache = MapCache;
function eq(value, other) {
    return value === other || value !== value && other !== other;
}
function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
function toString(value) {
    return value == null ? '' : baseToString(value);
}
function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
}
function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
}
function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function identity(value) {
    return value;
}
function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
module.exports = some;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],92:[function(require,module,exports){
var getNative = require(155), root = require(196);
var DataView = getNative(root, 'DataView');
module.exports = DataView;
},{"155":155,"196":196}],93:[function(require,module,exports){
var hashClear = require(162), hashDelete = require(163), hashGet = require(164), hashHas = require(165), hashSet = require(166);
function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;
},{"162":162,"163":163,"164":164,"165":165,"166":166}],94:[function(require,module,exports){
var listCacheClear = require(176), listCacheDelete = require(177), listCacheGet = require(178), listCacheHas = require(179), listCacheSet = require(180);
function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;
},{"176":176,"177":177,"178":178,"179":179,"180":180}],95:[function(require,module,exports){
var getNative = require(155), root = require(196);
var Map = getNative(root, 'Map');
module.exports = Map;
},{"155":155,"196":196}],96:[function(require,module,exports){
var mapCacheClear = require(181), mapCacheDelete = require(182), mapCacheGet = require(183), mapCacheHas = require(184), mapCacheSet = require(185);
function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;
},{"181":181,"182":182,"183":183,"184":184,"185":185}],97:[function(require,module,exports){
var getNative = require(155), root = require(196);
var Promise = getNative(root, 'Promise');
module.exports = Promise;
},{"155":155,"196":196}],98:[function(require,module,exports){
var getNative = require(155), root = require(196);
var Set = getNative(root, 'Set');
module.exports = Set;
},{"155":155,"196":196}],99:[function(require,module,exports){
var ListCache = require(94), stackClear = require(200), stackDelete = require(201), stackGet = require(202), stackHas = require(203), stackSet = require(204);
function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;
},{"200":200,"201":201,"202":202,"203":203,"204":204,"94":94}],100:[function(require,module,exports){
var root = require(196);
var Symbol = root.Symbol;
module.exports = Symbol;
},{"196":196}],101:[function(require,module,exports){
var root = require(196);
var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;
},{"196":196}],102:[function(require,module,exports){
var getNative = require(155), root = require(196);
var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;
},{"155":155,"196":196}],103:[function(require,module,exports){
function addMapEntry(map, pair) {
    map.set(pair[0], pair[1]);
    return map;
}
module.exports = addMapEntry;
},{}],104:[function(require,module,exports){
function addSetEntry(set, value) {
    set.add(value);
    return set;
}
module.exports = addSetEntry;
},{}],105:[function(require,module,exports){
function apply(func, thisArg, args) {
    switch (args.length) {
    case 0:
        return func.call(thisArg);
    case 1:
        return func.call(thisArg, args[0]);
    case 2:
        return func.call(thisArg, args[0], args[1]);
    case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
module.exports = apply;
},{}],106:[function(require,module,exports){
function arrayEach(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
            break;
        }
    }
    return array;
}
module.exports = arrayEach;
},{}],107:[function(require,module,exports){
function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
            result[resIndex++] = value;
        }
    }
    return result;
}
module.exports = arrayFilter;
},{}],108:[function(require,module,exports){
var baseTimes = require(130), isArguments = require(212), isArray = require(213), isBuffer = require(215), isIndex = require(171), isTypedArray = require(222);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
module.exports = arrayLikeKeys;
},{"130":130,"171":171,"212":212,"213":213,"215":215,"222":222}],109:[function(require,module,exports){
function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
        result[index] = iteratee(array[index], index, array);
    }
    return result;
}
module.exports = arrayMap;
},{}],110:[function(require,module,exports){
function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
        array[offset + index] = values[index];
    }
    return array;
}
module.exports = arrayPush;
},{}],111:[function(require,module,exports){
function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array == null ? 0 : array.length;
    if (initAccum && length) {
        accumulator = array[++index];
    }
    while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
}
module.exports = arrayReduce;
},{}],112:[function(require,module,exports){
var baseAssignValue = require(116), eq = require(209);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
        baseAssignValue(object, key, value);
    }
}
module.exports = assignValue;
},{"116":116,"209":209}],113:[function(require,module,exports){
var eq = require(209);
function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
module.exports = assocIndexOf;
},{"209":209}],114:[function(require,module,exports){
var copyObject = require(144), keys = require(223);
function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
}
module.exports = baseAssign;
},{"144":144,"223":223}],115:[function(require,module,exports){
var copyObject = require(144), keysIn = require(224);
function baseAssignIn(object, source) {
    return object && copyObject(source, keysIn(source), object);
}
module.exports = baseAssignIn;
},{"144":144,"224":224}],116:[function(require,module,exports){
var defineProperty = require(149);
function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
            'configurable': true,
            'enumerable': true,
            'value': value,
            'writable': true
        });
    } else {
        object[key] = value;
    }
}
module.exports = baseAssignValue;
},{"149":149}],117:[function(require,module,exports){
var Stack = require(99), arrayEach = require(106), assignValue = require(112), baseAssign = require(114), baseAssignIn = require(115), cloneBuffer = require(136), copyArray = require(143), copySymbols = require(145), copySymbolsIn = require(146), getAllKeys = require(152), getAllKeysIn = require(153), getTag = require(160), initCloneArray = require(167), initCloneByTag = require(168), initCloneObject = require(169), isArray = require(213), isBuffer = require(215), isObject = require(218), keys = require(223);
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
        return result;
    }
    if (!isObject(value)) {
        return value;
    }
    var isArr = isArray(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
            return copyArray(value, result);
        }
    } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
        } else {
            if (!cloneableTags[tag]) {
                return object ? value : {};
            }
            result = initCloneByTag(value, tag, baseClone, isDeep);
        }
    }
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
        return stacked;
    }
    stack.set(value, result);
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function (subValue, key) {
        if (props) {
            key = subValue;
            subValue = value[key];
        }
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
}
module.exports = baseClone;
},{"106":106,"112":112,"114":114,"115":115,"136":136,"143":143,"145":145,"146":146,"152":152,"153":153,"160":160,"167":167,"168":168,"169":169,"213":213,"215":215,"218":218,"223":223,"99":99}],118:[function(require,module,exports){
var isObject = require(218);
var objectCreate = Object.create;
var baseCreate = function () {
    function object() {
    }
    return function (proto) {
        if (!isObject(proto)) {
            return {};
        }
        if (objectCreate) {
            return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = undefined;
        return result;
    };
}();
module.exports = baseCreate;
},{"218":218}],119:[function(require,module,exports){
var arrayPush = require(110), isFlattenable = require(170);
function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
                arrayPush(result, value);
            }
        } else if (!isStrict) {
            result[result.length] = value;
        }
    }
    return result;
}
module.exports = baseFlatten;
},{"110":110,"170":170}],120:[function(require,module,exports){
var castPath = require(134), toKey = require(206);
function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
        object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
}
module.exports = baseGet;
},{"134":134,"206":206}],121:[function(require,module,exports){
var arrayPush = require(110), isArray = require(213);
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
module.exports = baseGetAllKeys;
},{"110":110,"213":213}],122:[function(require,module,exports){
var Symbol = require(100), getRawTag = require(157), objectToString = require(192);
var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
module.exports = baseGetTag;
},{"100":100,"157":157,"192":192}],123:[function(require,module,exports){
var baseGetTag = require(122), isObjectLike = require(219);
var argsTag = '[object Arguments]';
function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
}
module.exports = baseIsArguments;
},{"122":122,"219":219}],124:[function(require,module,exports){
var isFunction = require(216), isMasked = require(174), isObject = require(218), toSource = require(207);
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
module.exports = baseIsNative;
},{"174":174,"207":207,"216":216,"218":218}],125:[function(require,module,exports){
var baseGetTag = require(122), isLength = require(217), isObjectLike = require(219);
var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
module.exports = baseIsTypedArray;
},{"122":122,"217":217,"219":219}],126:[function(require,module,exports){
var isPrototype = require(175), nativeKeys = require(189);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
module.exports = baseKeys;
},{"175":175,"189":189}],127:[function(require,module,exports){
var isObject = require(218), isPrototype = require(175), nativeKeysIn = require(190);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseKeysIn(object) {
    if (!isObject(object)) {
        return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
        }
    }
    return result;
}
module.exports = baseKeysIn;
},{"175":175,"190":190,"218":218}],128:[function(require,module,exports){
var constant = require(208), defineProperty = require(149), identity = require(211);
var baseSetToString = !defineProperty ? identity : function (func, string) {
    return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
    });
};
module.exports = baseSetToString;
},{"149":149,"208":208,"211":211}],129:[function(require,module,exports){
function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) {
        start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
        end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
        result[index] = array[index + start];
    }
    return result;
}
module.exports = baseSlice;
},{}],130:[function(require,module,exports){
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
        result[index] = iteratee(index);
    }
    return result;
}
module.exports = baseTimes;
},{}],131:[function(require,module,exports){
var Symbol = require(100), arrayMap = require(109), isArray = require(213), isSymbol = require(221);
var INFINITY = 1 / 0;
var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
function baseToString(value) {
    if (typeof value == 'string') {
        return value;
    }
    if (isArray(value)) {
        return arrayMap(value, baseToString) + '';
    }
    if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
module.exports = baseToString;
},{"100":100,"109":109,"213":213,"221":221}],132:[function(require,module,exports){
function baseUnary(func) {
    return function (value) {
        return func(value);
    };
}
module.exports = baseUnary;
},{}],133:[function(require,module,exports){
var castPath = require(134), last = require(225), parent = require(195), toKey = require(206);
function baseUnset(object, path) {
    path = castPath(path, object);
    object = parent(object, path);
    return object == null || delete object[toKey(last(path))];
}
module.exports = baseUnset;
},{"134":134,"195":195,"206":206,"225":225}],134:[function(require,module,exports){
var isArray = require(213), isKey = require(172), stringToPath = require(205), toString = require(230);
function castPath(value, object) {
    if (isArray(value)) {
        return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
}
module.exports = castPath;
},{"172":172,"205":205,"213":213,"230":230}],135:[function(require,module,exports){
var Uint8Array = require(101);
function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
}
module.exports = cloneArrayBuffer;
},{"101":101}],136:[function(require,module,exports){
var root = require(196);
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
        return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
}
module.exports = cloneBuffer;
},{"196":196}],137:[function(require,module,exports){
var cloneArrayBuffer = require(135);
function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
module.exports = cloneDataView;
},{"135":135}],138:[function(require,module,exports){
var addMapEntry = require(103), arrayReduce = require(111), mapToArray = require(186);
var CLONE_DEEP_FLAG = 1;
function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor());
}
module.exports = cloneMap;
},{"103":103,"111":111,"186":186}],139:[function(require,module,exports){
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
}
module.exports = cloneRegExp;
},{}],140:[function(require,module,exports){
var addSetEntry = require(104), arrayReduce = require(111), setToArray = require(197);
var CLONE_DEEP_FLAG = 1;
function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor());
}
module.exports = cloneSet;
},{"104":104,"111":111,"197":197}],141:[function(require,module,exports){
var Symbol = require(100);
var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
module.exports = cloneSymbol;
},{"100":100}],142:[function(require,module,exports){
var cloneArrayBuffer = require(135);
function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
module.exports = cloneTypedArray;
},{"135":135}],143:[function(require,module,exports){
function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
        array[index] = source[index];
    }
    return array;
}
module.exports = copyArray;
},{}],144:[function(require,module,exports){
var assignValue = require(112), baseAssignValue = require(116);
function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        if (newValue === undefined) {
            newValue = source[key];
        }
        if (isNew) {
            baseAssignValue(object, key, newValue);
        } else {
            assignValue(object, key, newValue);
        }
    }
    return object;
}
module.exports = copyObject;
},{"112":112,"116":116}],145:[function(require,module,exports){
var copyObject = require(144), getSymbols = require(158);
function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
}
module.exports = copySymbols;
},{"144":144,"158":158}],146:[function(require,module,exports){
var copyObject = require(144), getSymbolsIn = require(159);
function copySymbolsIn(source, object) {
    return copyObject(source, getSymbolsIn(source), object);
}
module.exports = copySymbolsIn;
},{"144":144,"159":159}],147:[function(require,module,exports){
var root = require(196);
var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;
},{"196":196}],148:[function(require,module,exports){
var isPlainObject = require(220);
function customOmitClone(value) {
    return isPlainObject(value) ? undefined : value;
}
module.exports = customOmitClone;
},{"220":220}],149:[function(require,module,exports){
var getNative = require(155);
var defineProperty = function () {
    try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
    } catch (e) {
    }
}();
module.exports = defineProperty;
},{"155":155}],150:[function(require,module,exports){
var flatten = require(210), overRest = require(194), setToString = require(198);
function flatRest(func) {
    return setToString(overRest(func, undefined, flatten), func + '');
}
module.exports = flatRest;
},{"194":194,"198":198,"210":210}],151:[function(require,module,exports){
(function (global){
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],152:[function(require,module,exports){
var baseGetAllKeys = require(121), getSymbols = require(158), keys = require(223);
function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
module.exports = getAllKeys;
},{"121":121,"158":158,"223":223}],153:[function(require,module,exports){
var baseGetAllKeys = require(121), getSymbolsIn = require(159), keysIn = require(224);
function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
}
module.exports = getAllKeysIn;
},{"121":121,"159":159,"224":224}],154:[function(require,module,exports){
var isKeyable = require(173);
function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
module.exports = getMapData;
},{"173":173}],155:[function(require,module,exports){
var baseIsNative = require(124), getValue = require(161);
function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
module.exports = getNative;
},{"124":124,"161":161}],156:[function(require,module,exports){
var overArg = require(193);
var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;
},{"193":193}],157:[function(require,module,exports){
var Symbol = require(100);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;
function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        } else {
            delete value[symToStringTag];
        }
    }
    return result;
}
module.exports = getRawTag;
},{"100":100}],158:[function(require,module,exports){
var arrayFilter = require(107), stubArray = require(228);
var objectProto = Object.prototype;
var propertyIsEnumerable = objectProto.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
    if (object == null) {
        return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function (symbol) {
        return propertyIsEnumerable.call(object, symbol);
    });
};
module.exports = getSymbols;
},{"107":107,"228":228}],159:[function(require,module,exports){
var arrayPush = require(110), getPrototype = require(156), getSymbols = require(158), stubArray = require(228);
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
    var result = [];
    while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
    }
    return result;
};
module.exports = getSymbolsIn;
},{"110":110,"156":156,"158":158,"228":228}],160:[function(require,module,exports){
var DataView = require(92), Map = require(95), Promise = require(97), Set = require(98), WeakMap = require(102), baseGetTag = require(122), toSource = require(207);
var mapTag = '[object Map]', objectTag = '[object Object]', promiseTag = '[object Promise]', setTag = '[object Set]', weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
var getTag = baseGetTag;
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function (value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : '';
        if (ctorString) {
            switch (ctorString) {
            case dataViewCtorString:
                return dataViewTag;
            case mapCtorString:
                return mapTag;
            case promiseCtorString:
                return promiseTag;
            case setCtorString:
                return setTag;
            case weakMapCtorString:
                return weakMapTag;
            }
        }
        return result;
    };
}
module.exports = getTag;
},{"102":102,"122":122,"207":207,"92":92,"95":95,"97":97,"98":98}],161:[function(require,module,exports){
function getValue(object, key) {
    return object == null ? undefined : object[key];
}
module.exports = getValue;
},{}],162:[function(require,module,exports){
var nativeCreate = require(188);
function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
}
module.exports = hashClear;
},{"188":188}],163:[function(require,module,exports){
function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
module.exports = hashDelete;
},{}],164:[function(require,module,exports){
var nativeCreate = require(188);
var HASH_UNDEFINED = '__lodash_hash_undefined__';
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
module.exports = hashGet;
},{"188":188}],165:[function(require,module,exports){
var nativeCreate = require(188);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
module.exports = hashHas;
},{"188":188}],166:[function(require,module,exports){
var nativeCreate = require(188);
var HASH_UNDEFINED = '__lodash_hash_undefined__';
function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
module.exports = hashSet;
},{"188":188}],167:[function(require,module,exports){
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
}
module.exports = initCloneArray;
},{}],168:[function(require,module,exports){
var cloneArrayBuffer = require(135), cloneDataView = require(137), cloneMap = require(138), cloneRegExp = require(139), cloneSet = require(140), cloneSymbol = require(141), cloneTypedArray = require(142);
var boolTag = '[object Boolean]', dateTag = '[object Date]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
    case arrayBufferTag:
        return cloneArrayBuffer(object);
    case boolTag:
    case dateTag:
        return new Ctor(+object);
    case dataViewTag:
        return cloneDataView(object, isDeep);
    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
        return cloneTypedArray(object, isDeep);
    case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
    case numberTag:
    case stringTag:
        return new Ctor(object);
    case regexpTag:
        return cloneRegExp(object);
    case setTag:
        return cloneSet(object, isDeep, cloneFunc);
    case symbolTag:
        return cloneSymbol(object);
    }
}
module.exports = initCloneByTag;
},{"135":135,"137":137,"138":138,"139":139,"140":140,"141":141,"142":142}],169:[function(require,module,exports){
var baseCreate = require(118), getPrototype = require(156), isPrototype = require(175);
function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
module.exports = initCloneObject;
},{"118":118,"156":156,"175":175}],170:[function(require,module,exports){
var Symbol = require(100), isArguments = require(212), isArray = require(213);
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
module.exports = isFlattenable;
},{"100":100,"212":212,"213":213}],171:[function(require,module,exports){
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
module.exports = isIndex;
},{}],172:[function(require,module,exports){
var isArray = require(213), isSymbol = require(221);
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
    if (isArray(value)) {
        return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
module.exports = isKey;
},{"213":213,"221":221}],173:[function(require,module,exports){
function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
module.exports = isKeyable;
},{}],174:[function(require,module,exports){
var coreJsData = require(147);
var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
module.exports = isMasked;
},{"147":147}],175:[function(require,module,exports){
var objectProto = Object.prototype;
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
module.exports = isPrototype;
},{}],176:[function(require,module,exports){
function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
module.exports = listCacheClear;
},{}],177:[function(require,module,exports){
var assocIndexOf = require(113);
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    --this.size;
    return true;
}
module.exports = listCacheDelete;
},{"113":113}],178:[function(require,module,exports){
var assocIndexOf = require(113);
function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
module.exports = listCacheGet;
},{"113":113}],179:[function(require,module,exports){
var assocIndexOf = require(113);
function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
module.exports = listCacheHas;
},{"113":113}],180:[function(require,module,exports){
var assocIndexOf = require(113);
function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
module.exports = listCacheSet;
},{"113":113}],181:[function(require,module,exports){
var Hash = require(93), ListCache = require(94), Map = require(95);
function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
    };
}
module.exports = mapCacheClear;
},{"93":93,"94":94,"95":95}],182:[function(require,module,exports){
var getMapData = require(154);
function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
}
module.exports = mapCacheDelete;
},{"154":154}],183:[function(require,module,exports){
var getMapData = require(154);
function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
module.exports = mapCacheGet;
},{"154":154}],184:[function(require,module,exports){
var getMapData = require(154);
function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
module.exports = mapCacheHas;
},{"154":154}],185:[function(require,module,exports){
var getMapData = require(154);
function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
module.exports = mapCacheSet;
},{"154":154}],186:[function(require,module,exports){
function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function (value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
module.exports = mapToArray;
},{}],187:[function(require,module,exports){
var memoize = require(226);
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
    var result = memoize(func, function (key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
        }
        return key;
    });
    var cache = result.cache;
    return result;
}
module.exports = memoizeCapped;
},{"226":226}],188:[function(require,module,exports){
var getNative = require(155);
var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;
},{"155":155}],189:[function(require,module,exports){
var overArg = require(193);
var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;
},{"193":193}],190:[function(require,module,exports){
function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
        for (var key in Object(object)) {
            result.push(key);
        }
    }
    return result;
}
module.exports = nativeKeysIn;
},{}],191:[function(require,module,exports){
var freeGlobal = require(151);
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal.process;
var nodeUtil = function () {
    try {
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {
    }
}();
module.exports = nodeUtil;
},{"151":151}],192:[function(require,module,exports){
var objectProto = Object.prototype;
var nativeObjectToString = objectProto.toString;
function objectToString(value) {
    return nativeObjectToString.call(value);
}
module.exports = objectToString;
},{}],193:[function(require,module,exports){
function overArg(func, transform) {
    return function (arg) {
        return func(transform(arg));
    };
}
module.exports = overArg;
},{}],194:[function(require,module,exports){
var apply = require(105);
var nativeMax = Math.max;
function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
            array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
            otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
    };
}
module.exports = overRest;
},{"105":105}],195:[function(require,module,exports){
var baseGet = require(120), baseSlice = require(129);
function parent(object, path) {
    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}
module.exports = parent;
},{"120":120,"129":129}],196:[function(require,module,exports){
var freeGlobal = require(151);
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;
},{"151":151}],197:[function(require,module,exports){
function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function (value) {
        result[++index] = value;
    });
    return result;
}
module.exports = setToArray;
},{}],198:[function(require,module,exports){
var baseSetToString = require(128), shortOut = require(199);
var setToString = shortOut(baseSetToString);
module.exports = setToString;
},{"128":128,"199":199}],199:[function(require,module,exports){
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function () {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
            if (++count >= HOT_COUNT) {
                return arguments[0];
            }
        } else {
            count = 0;
        }
        return func.apply(undefined, arguments);
    };
}
module.exports = shortOut;
},{}],200:[function(require,module,exports){
var ListCache = require(94);
function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
}
module.exports = stackClear;
},{"94":94}],201:[function(require,module,exports){
function stackDelete(key) {
    var data = this.__data__, result = data['delete'](key);
    this.size = data.size;
    return result;
}
module.exports = stackDelete;
},{}],202:[function(require,module,exports){
function stackGet(key) {
    return this.__data__.get(key);
}
module.exports = stackGet;
},{}],203:[function(require,module,exports){
function stackHas(key) {
    return this.__data__.has(key);
}
module.exports = stackHas;
},{}],204:[function(require,module,exports){
var ListCache = require(94), Map = require(95), MapCache = require(96);
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            this.size = ++data.size;
            return this;
        }
        data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
}
module.exports = stackSet;
},{"94":94,"95":95,"96":96}],205:[function(require,module,exports){
var memoizeCapped = require(187);
var reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function (string) {
    var result = [];
    if (reLeadingDot.test(string)) {
        result.push('');
    }
    string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
});
module.exports = stringToPath;
},{"187":187}],206:[function(require,module,exports){
var isSymbol = require(221);
var INFINITY = 1 / 0;
function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
        return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
module.exports = toKey;
},{"221":221}],207:[function(require,module,exports){
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e) {
        }
    }
    return '';
}
module.exports = toSource;
},{}],208:[function(require,module,exports){
function constant(value) {
    return function () {
        return value;
    };
}
module.exports = constant;
},{}],209:[function(require,module,exports){
function eq(value, other) {
    return value === other || value !== value && other !== other;
}
module.exports = eq;
},{}],210:[function(require,module,exports){
var baseFlatten = require(119);
function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
}
module.exports = flatten;
},{"119":119}],211:[function(require,module,exports){
function identity(value) {
    return value;
}
module.exports = identity;
},{}],212:[function(require,module,exports){
var baseIsArguments = require(123), isObjectLike = require(219);
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var propertyIsEnumerable = objectProto.propertyIsEnumerable;
var isArguments = baseIsArguments(function () {
    return arguments;
}()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;
},{"123":123,"219":219}],213:[function(require,module,exports){
var isArray = Array.isArray;
module.exports = isArray;
},{}],214:[function(require,module,exports){
var isFunction = require(216), isLength = require(217);
function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
module.exports = isArrayLike;
},{"216":216,"217":217}],215:[function(require,module,exports){
var root = require(196), stubFalse = require(229);
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root.Buffer : undefined;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
},{"196":196,"229":229}],216:[function(require,module,exports){
var baseGetTag = require(122), isObject = require(218);
var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
module.exports = isFunction;
},{"122":122,"218":218}],217:[function(require,module,exports){
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
module.exports = isLength;
},{}],218:[function(require,module,exports){
function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}
module.exports = isObject;
},{}],219:[function(require,module,exports){
function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
module.exports = isObjectLike;
},{}],220:[function(require,module,exports){
var baseGetTag = require(122), getPrototype = require(156), isObjectLike = require(219);
var objectTag = '[object Object]';
var funcProto = Function.prototype, objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
module.exports = isPlainObject;
},{"122":122,"156":156,"219":219}],221:[function(require,module,exports){
var baseGetTag = require(122), isObjectLike = require(219);
var symbolTag = '[object Symbol]';
function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
module.exports = isSymbol;
},{"122":122,"219":219}],222:[function(require,module,exports){
var baseIsTypedArray = require(125), baseUnary = require(132), nodeUtil = require(191);
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;
},{"125":125,"132":132,"191":191}],223:[function(require,module,exports){
var arrayLikeKeys = require(108), baseKeys = require(126), isArrayLike = require(214);
function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
module.exports = keys;
},{"108":108,"126":126,"214":214}],224:[function(require,module,exports){
var arrayLikeKeys = require(108), baseKeysIn = require(127), isArrayLike = require(214);
function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
module.exports = keysIn;
},{"108":108,"127":127,"214":214}],225:[function(require,module,exports){
function last(array) {
    var length = array == null ? 0 : array.length;
    return length ? array[length - 1] : undefined;
}
module.exports = last;
},{}],226:[function(require,module,exports){
var MapCache = require(96);
var FUNC_ERROR_TEXT = 'Expected a function';
function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function () {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
}
memoize.Cache = MapCache;
module.exports = memoize;
},{"96":96}],227:[function(require,module,exports){
var arrayMap = require(109), baseClone = require(117), baseUnset = require(133), castPath = require(134), copyObject = require(144), customOmitClone = require(148), flatRest = require(150), getAllKeysIn = require(153);
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var omit = flatRest(function (object, paths) {
    var result = {};
    if (object == null) {
        return result;
    }
    var isDeep = false;
    paths = arrayMap(paths, function (path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
    });
    copyObject(object, getAllKeysIn(object), result);
    if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
    }
    var length = paths.length;
    while (length--) {
        baseUnset(result, paths[length]);
    }
    return result;
});
module.exports = omit;
},{"109":109,"117":117,"133":133,"134":134,"144":144,"148":148,"150":150,"153":153}],228:[function(require,module,exports){
function stubArray() {
    return [];
}
module.exports = stubArray;
},{}],229:[function(require,module,exports){
function stubFalse() {
    return false;
}
module.exports = stubFalse;
},{}],230:[function(require,module,exports){
var baseToString = require(131);
function toString(value) {
    return value == null ? '' : baseToString(value);
}
module.exports = toString;
},{"131":131}],231:[function(require,module,exports){
(function (process){
var duplexer = require(49);
var PassThrough = require(268).PassThrough;
var Readable = require(268).PassThrough;
var objectAssign = require(248);
var slice = [].slice;
var defaultOpts = {
    bubbleErrors: false,
    objectMode: true
};
module.exports = pipe;
function pipe(streams, opts, cb) {
    if (!Array.isArray(streams)) {
        streams = slice.call(arguments);
        opts = null;
        cb = null;
    }
    var lastArg = streams[streams.length - 1];
    if ('function' == typeof lastArg) {
        cb = streams.splice(-1)[0];
        lastArg = streams[streams.length - 1];
    }
    if ('object' == typeof lastArg && typeof lastArg.pipe != 'function') {
        opts = streams.splice(-1)[0];
    }
    var first = streams[0];
    var last = streams[streams.length - 1];
    var ret;
    opts = objectAssign({}, defaultOpts, opts);
    if (!first) {
        if (cb)
            process.nextTick(cb);
        return new PassThrough(opts);
    }
    if (first.writable && last.readable)
        ret = duplexer(opts, first, last);
    else if (streams.length == 1)
        ret = new Readable(opts).wrap(streams[0]);
    else if (first.writable)
        ret = first;
    else if (last.readable)
        ret = last;
    else
        ret = new PassThrough(opts);
    streams.forEach(function (stream, i) {
        var next = streams[i + 1];
        if (next)
            stream.pipe(next);
        if (stream != ret)
            stream.on('error', ret.emit.bind(ret, 'error'));
    });
    if (cb) {
        var ended = false;
        ret.on('error', end);
        last.on('finish', function () {
            end();
        });
        last.on('close', function () {
            end();
        });
        function end(err) {
            if (ended)
                return;
            ended = true;
            cb(err);
        }
    }
    return ret;
}
}).call(this,require(251))
},{"248":248,"251":251,"268":268,"49":49}],232:[function(require,module,exports){
module.exports = Nanobus;
function Nanobus() {
    if (!(this instanceof Nanobus))
        return new Nanobus();
    this._starListeners = [];
    this._listeners = {};
}
Nanobus.prototype.emit = function (eventName, data) {
    var listeners = this._listeners[eventName];
    if (listeners && listeners.length > 0) {
        this._emit(this.listeners(eventName), data);
    }
    if (this._starListeners.length > 0) {
        this._emit(this.listeners('*'), eventName, data);
    }
    return this;
};
Nanobus.prototype.on = Nanobus.prototype.addListener = function (eventName, listener) {
    if (eventName === '*') {
        this._starListeners.push(listener);
    } else {
        if (!this._listeners[eventName])
            this._listeners[eventName] = [];
        this._listeners[eventName].push(listener);
    }
    return this;
};
Nanobus.prototype.prependListener = function (eventName, listener) {
    if (eventName === '*') {
        this._starListeners.unshift(listener);
    } else {
        if (!this._listeners[eventName])
            this._listeners[eventName] = [];
        this._listeners[eventName].unshift(listener);
    }
    return this;
};
Nanobus.prototype.once = function (eventName, listener) {
    var self = this;
    this.on(eventName, once);
    function once() {
        listener.apply(self, arguments);
        self.removeListener(eventName, once);
    }
    return this;
};
Nanobus.prototype.prependOnceListener = function (eventName, listener) {
    var self = this;
    this.prependListener(eventName, once);
    function once() {
        listener.apply(self, arguments);
        self.removeListener(eventName, once);
    }
    return this;
};
Nanobus.prototype.removeListener = function (eventName, listener) {
    if (eventName === '*') {
        if (remove(this._starListeners, listener))
            return this;
    } else {
        if (remove(this._listeners[eventName], listener))
            return this;
    }
    function remove(arr, listener) {
        if (!arr)
            return;
        var index = arr.indexOf(listener);
        if (index !== -1) {
            arr.splice(index, 1);
            return true;
        }
    }
};
Nanobus.prototype.removeAllListeners = function (eventName) {
    if (eventName) {
        if (eventName === '*') {
            this._starListeners = [];
        } else {
            this._listeners[eventName] = [];
        }
    } else {
        this._starListeners = [];
        this._listeners = {};
    }
    return this;
};
Nanobus.prototype.listeners = function (eventName) {
    var listeners = eventName !== '*' ? this._listeners[eventName] : this._starListeners;
    var ret = [];
    if (listeners) {
        var ilength = listeners.length;
        for (var i = 0; i < ilength; i++)
            ret.push(listeners[i]);
    }
    return ret;
};
Nanobus.prototype._emit = function (arr, eventName, data) {
    if (!data) {
        data = eventName;
        eventName = null;
    }
    var length = arr.length;
    for (var i = 0; i < length; i++) {
        var listener = arr[i];
        if (eventName)
            listener(eventName, data);
        else
            listener(data);
    }
};
},{}],233:[function(require,module,exports){
module.exports = history;
function history(cb) {
    window.onpopstate = function () {
        cb(document.location);
    };
}
},{}],234:[function(require,module,exports){
module.exports = href;
var noRoutingAttrName = 'data-no-routing';
function href(cb, root) {
    root = root || window.document;
    window.onclick = function (e) {
        if (e.button && e.button !== 0 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey)
            return;
        var node = function traverse(node) {
            if (!node || node === root)
                return;
            if (node.localName !== 'a')
                return traverse(node.parentNode);
            if (node.href === undefined)
                return traverse(node.parentNode);
            if (window.location.host !== node.host)
                return traverse(node.parentNode);
            return node;
        }(e.target);
        if (!node)
            return;
        var isRoutingDisabled = node.hasAttribute(noRoutingAttrName);
        if (isRoutingDisabled)
            return;
        e.preventDefault();
        cb(node);
    };
}
},{}],235:[function(require,module,exports){
var morph = require(237);
var rootLabelRegex = /^data-onloadid/;
var ELEMENT_NODE = 1;
module.exports = nanomorph;
function nanomorph(oldTree, newTree) {
    persistStatefulRoot(newTree, oldTree);
    var tree = walk(newTree, oldTree);
    return tree;
}
function walk(newNode, oldNode) {
    if (!oldNode) {
        return newNode;
    } else if (!newNode) {
        return null;
    } else if (newNode.isSameNode && newNode.isSameNode(oldNode)) {
        return oldNode;
    } else if (newNode.tagName !== oldNode.tagName) {
        return newNode;
    } else {
        morph(newNode, oldNode);
        updateChildren(newNode, oldNode);
        return oldNode;
    }
}
function updateChildren(newNode, oldNode) {
    if (!newNode.childNodes || !oldNode.childNodes)
        return;
    var newLength = newNode.childNodes.length;
    var oldLength = oldNode.childNodes.length;
    var length = Math.max(oldLength, newLength);
    var iNew = 0;
    var iOld = 0;
    for (var i = 0; i < length; i++, iNew++, iOld++) {
        var newChildNode = newNode.childNodes[iNew];
        var oldChildNode = oldNode.childNodes[iOld];
        var retChildNode = walk(newChildNode, oldChildNode);
        if (!retChildNode) {
            if (oldChildNode) {
                oldNode.removeChild(oldChildNode);
                iOld--;
            }
        } else if (!oldChildNode) {
            if (retChildNode) {
                oldNode.appendChild(retChildNode);
                iNew--;
            }
        } else if (retChildNode !== oldChildNode) {
            oldNode.replaceChild(retChildNode, oldChildNode);
            iNew--;
        }
    }
}
function persistStatefulRoot(newNode, oldNode) {
    if (!newNode || !oldNode || oldNode.nodeType !== ELEMENT_NODE || newNode.nodeType !== ELEMENT_NODE)
        return;
    var oldAttrs = oldNode.attributes;
    var attr, name;
    for (var i = 0, len = oldAttrs.length; i < len; i++) {
        attr = oldAttrs[i];
        name = attr.name;
        if (rootLabelRegex.test(name)) {
            newNode.setAttribute(name, attr.value);
            break;
        }
    }
}
},{"237":237}],236:[function(require,module,exports){
module.exports = [
    'onclick',
    'ondblclick',
    'onmousedown',
    'onmouseup',
    'onmouseover',
    'onmousemove',
    'onmouseout',
    'ondragstart',
    'ondrag',
    'ondragenter',
    'ondragleave',
    'ondragover',
    'ondrop',
    'ondragend',
    'onkeydown',
    'onkeypress',
    'onkeyup',
    'onunload',
    'onabort',
    'onerror',
    'onresize',
    'onscroll',
    'onselect',
    'onchange',
    'onsubmit',
    'onreset',
    'onfocus',
    'onblur',
    'oninput',
    'oncontextmenu',
    'onfocusin',
    'onfocusout'
];
},{}],237:[function(require,module,exports){
var events = require(236);
var eventsLength = events.length;
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
module.exports = morph;
function morph(newNode, oldNode) {
    var nodeType = newNode.nodeType;
    var nodeName = newNode.nodeName;
    if (nodeType === ELEMENT_NODE) {
        copyAttrs(newNode, oldNode);
    }
    if (nodeType === TEXT_NODE || nodeType === COMMENT_NODE) {
        oldNode.nodeValue = newNode.nodeValue;
    }
    if (nodeName === 'INPUT')
        updateInput(newNode, oldNode);
    else if (nodeName === 'OPTION')
        updateOption(newNode, oldNode);
    else if (nodeName === 'TEXTAREA')
        updateTextarea(newNode, oldNode);
    else if (nodeName === 'SELECT')
        updateSelect(newNode, oldNode);
    copyEvents(newNode, oldNode);
}
function copyAttrs(newNode, oldNode) {
    var oldAttrs = oldNode.attributes;
    var newAttrs = newNode.attributes;
    var attrNamespaceURI = null;
    var attrValue = null;
    var fromValue = null;
    var attrName = null;
    var attr = null;
    for (var i = newAttrs.length - 1; i >= 0; --i) {
        attr = newAttrs[i];
        attrName = attr.name;
        attrNamespaceURI = attr.namespaceURI;
        attrValue = attr.value;
        if (attrNamespaceURI) {
            attrName = attr.localName || attrName;
            fromValue = oldNode.getAttributeNS(attrNamespaceURI, attrName);
            if (fromValue !== attrValue) {
                oldNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
            }
        } else {
            fromValue = oldNode.getAttribute(attrName);
            if (fromValue !== attrValue) {
                if (attrValue === 'null' || attrValue === 'undefined') {
                    oldNode.removeAttribute(attrName);
                } else {
                    oldNode.setAttribute(attrName, attrValue);
                }
            }
        }
    }
    for (var j = oldAttrs.length - 1; j >= 0; --j) {
        attr = oldAttrs[j];
        if (attr.specified !== false) {
            attrName = attr.name;
            attrNamespaceURI = attr.namespaceURI;
            if (attrNamespaceURI) {
                attrName = attr.localName || attrName;
                if (!newNode.hasAttributeNS(attrNamespaceURI, attrName)) {
                    oldNode.removeAttributeNS(attrNamespaceURI, attrName);
                }
            } else {
                if (!newNode.hasAttributeNS(null, attrName)) {
                    oldNode.removeAttribute(attrName);
                }
            }
        }
    }
}
function copyEvents(newNode, oldNode) {
    for (var i = 0; i < eventsLength; i++) {
        var ev = events[i];
        if (newNode[ev]) {
            oldNode[ev] = newNode[ev];
        } else if (oldNode[ev]) {
            oldNode[ev] = undefined;
        }
    }
}
function updateOption(newNode, oldNode) {
    updateAttribute(newNode, oldNode, 'selected');
}
function updateInput(newNode, oldNode) {
    var newValue = newNode.value;
    var oldValue = oldNode.value;
    updateAttribute(newNode, oldNode, 'checked');
    updateAttribute(newNode, oldNode, 'disabled');
    if (!newNode.hasAttributeNS(null, 'value') || newValue === 'null') {
        oldNode.value = '';
        oldNode.removeAttribute('value');
    } else if (newValue !== oldValue) {
        oldNode.setAttribute('value', newValue);
        oldNode.value = newValue;
    } else if (oldNode.type === 'range') {
        oldNode.value = newValue;
    }
}
function updateTextarea(newNode, oldNode) {
    var newValue = newNode.value;
    if (newValue !== oldNode.value) {
        oldNode.value = newValue;
    }
    if (oldNode.firstChild) {
        if (newValue === '' && oldNode.firstChild.nodeValue === oldNode.placeholder) {
            return;
        }
        oldNode.firstChild.nodeValue = newValue;
    }
}
function updateSelect(newNode, oldNode) {
    if (!oldNode.hasAttributeNS(null, 'multiple')) {
        var i = 0;
        var curChild = oldNode.firstChild;
        while (curChild) {
            var nodeName = curChild.nodeName;
            if (nodeName && nodeName.toUpperCase() === 'OPTION') {
                if (curChild.hasAttributeNS(null, 'selected'))
                    break;
                i++;
            }
            curChild = curChild.nextSibling;
        }
        newNode.selectedIndex = i;
    }
}
function updateAttribute(newNode, oldNode, name) {
    if (newNode[name] !== oldNode[name]) {
        oldNode[name] = newNode[name];
        if (newNode[name]) {
            oldNode.setAttribute(name, '');
        } else {
            oldNode.removeAttribute(name, '');
        }
    }
}
},{"236":236}],238:[function(require,module,exports){
var nanomorph = require(235);
module.exports = nanomount;
function nanomount(target, newTree) {
    if (target.nodeName === 'BODY') {
        var children = target.childNodes;
        for (var i = 0; i < children.length; i++) {
            if (children[i].nodeName === 'SCRIPT') {
                newTree.appendChild(children[i].cloneNode(true));
            }
        }
    }
    var tree = nanomorph(target, newTree);
}
},{"235":235}],239:[function(require,module,exports){
'use strict';
module.exports = nanoraf;
function nanoraf(render, raf) {
    if (!raf)
        raf = window.requestAnimationFrame;
    var redrawScheduled = false;
    var args = null;
    return function frame() {
        if (args === null && !redrawScheduled) {
            redrawScheduled = true;
            raf(function redraw() {
                redrawScheduled = false;
                var length = args.length;
                var _args = new Array(length);
                for (var i = 0; i < length; i++)
                    _args[i] = args[i];
                render.apply(render, _args);
                args = null;
            });
        }
        args = arguments;
    };
}
},{}],240:[function(require,module,exports){
var wayfarer = require(278);
var isLocalFile = /file:\/\//.test(typeof window === 'object' && window.location && window.location.origin);
var electron = '^(file://|/)(.*.html?/?)?';
var protocol = '^(http(s)?(://))?(www.)?';
var domain = '[a-zA-Z0-9-_.]+(:[0-9]{1,5})?(/{1})?';
var qs = '[?].*$';
var stripElectron = new RegExp(electron);
var prefix = new RegExp(protocol + domain);
var normalize = new RegExp('#');
var suffix = new RegExp(qs);
module.exports = Nanorouter;
function Nanorouter(opts) {
    opts = opts || {};
    var router = wayfarer(opts.default || '/404');
    var curry = opts.curry || false;
    var prevCallback = null;
    var prevRoute = null;
    emit.on = on;
    return emit;
    function on(routename, listener) {
        routename = routename.replace(/^[#\/]/, '');
        router.on(routename, listener);
    }
    function emit(route) {
        if (!curry) {
            return router(route);
        } else {
            route = pathname(route, isLocalFile);
            if (route === prevRoute) {
                return prevCallback();
            } else {
                prevRoute = route;
                prevCallback = router(route);
                return prevCallback();
            }
        }
    }
}
function pathname(route, isElectron) {
    if (isElectron)
        route = route.replace(stripElectron, '');
    else
        route = route.replace(prefix, '');
    return route.replace(suffix, '').replace(normalize, '/');
}
},{"278":278}],241:[function(require,module,exports){
'use strict';
var fill = require(33)({
    'args': [
        'index',
        'array',
        'scalar'
    ],
    'pre': {
        'body': '{}',
        'args': [],
        'thisVars': [],
        'localVars': []
    },
    'body': {
        'body': '{_inline_1_arg1_=_inline_1_arg2_.apply(void 0,_inline_1_arg0_)}',
        'args': [
            {
                'name': '_inline_1_arg0_',
                'lvalue': false,
                'rvalue': true,
                'count': 1
            },
            {
                'name': '_inline_1_arg1_',
                'lvalue': true,
                'rvalue': false,
                'count': 1
            },
            {
                'name': '_inline_1_arg2_',
                'lvalue': false,
                'rvalue': true,
                'count': 1
            }
        ],
        'thisVars': [],
        'localVars': []
    },
    'post': {
        'body': '{}',
        'args': [],
        'thisVars': [],
        'localVars': []
    },
    'debug': false,
    'funcName': 'cwise',
    'blockSize': 64
});
module.exports = function (array, f) {
    fill(array, f);
    return array;
};
},{"33":33}],242:[function(require,module,exports){
'use strict';
var compile = require(30);
var EmptyProc = {
    body: '',
    args: [],
    thisVars: [],
    localVars: []
};
function fixup(x) {
    if (!x) {
        return EmptyProc;
    }
    for (var i = 0; i < x.args.length; ++i) {
        var a = x.args[i];
        if (i === 0) {
            x.args[i] = {
                name: a,
                lvalue: true,
                rvalue: !!x.rvalue,
                count: x.count || 1
            };
        } else {
            x.args[i] = {
                name: a,
                lvalue: false,
                rvalue: true,
                count: 1
            };
        }
    }
    if (!x.thisVars) {
        x.thisVars = [];
    }
    if (!x.localVars) {
        x.localVars = [];
    }
    return x;
}
function pcompile(user_args) {
    return compile({
        args: user_args.args,
        pre: fixup(user_args.pre),
        body: fixup(user_args.body),
        post: fixup(user_args.proc),
        funcName: user_args.funcName
    });
}
function makeOp(user_args) {
    var args = [];
    for (var i = 0; i < user_args.args.length; ++i) {
        args.push('a' + i);
    }
    var wrapper = new Function('P', [
        'return function ',
        user_args.funcName,
        '_ndarrayops(',
        args.join(','),
        ') {P(',
        args.join(','),
        ');return a0}'
    ].join(''));
    return wrapper(pcompile(user_args));
}
var assign_ops = {
    add: '+',
    sub: '-',
    mul: '*',
    div: '/',
    mod: '%',
    band: '&',
    bor: '|',
    bxor: '^',
    lshift: '<<',
    rshift: '>>',
    rrshift: '>>>'
};
(function () {
    for (var id in assign_ops) {
        var op = assign_ops[id];
        exports[id] = makeOp({
            args: [
                'array',
                'array',
                'array'
            ],
            body: {
                args: [
                    'a',
                    'b',
                    'c'
                ],
                body: 'a=b' + op + 'c'
            },
            funcName: id
        });
        exports[id + 'eq'] = makeOp({
            args: [
                'array',
                'array'
            ],
            body: {
                args: [
                    'a',
                    'b'
                ],
                body: 'a' + op + '=b'
            },
            rvalue: true,
            funcName: id + 'eq'
        });
        exports[id + 's'] = makeOp({
            args: [
                'array',
                'array',
                'scalar'
            ],
            body: {
                args: [
                    'a',
                    'b',
                    's'
                ],
                body: 'a=b' + op + 's'
            },
            funcName: id + 's'
        });
        exports[id + 'seq'] = makeOp({
            args: [
                'array',
                'scalar'
            ],
            body: {
                args: [
                    'a',
                    's'
                ],
                body: 'a' + op + '=s'
            },
            rvalue: true,
            funcName: id + 'seq'
        });
    }
}());
var unary_ops = {
    not: '!',
    bnot: '~',
    neg: '-',
    recip: '1.0/'
};
(function () {
    for (var id in unary_ops) {
        var op = unary_ops[id];
        exports[id] = makeOp({
            args: [
                'array',
                'array'
            ],
            body: {
                args: [
                    'a',
                    'b'
                ],
                body: 'a=' + op + 'b'
            },
            funcName: id
        });
        exports[id + 'eq'] = makeOp({
            args: ['array'],
            body: {
                args: ['a'],
                body: 'a=' + op + 'a'
            },
            rvalue: true,
            count: 2,
            funcName: id + 'eq'
        });
    }
}());
var binary_ops = {
    and: '&&',
    or: '||',
    eq: '===',
    neq: '!==',
    lt: '<',
    gt: '>',
    leq: '<=',
    geq: '>='
};
(function () {
    for (var id in binary_ops) {
        var op = binary_ops[id];
        exports[id] = makeOp({
            args: [
                'array',
                'array',
                'array'
            ],
            body: {
                args: [
                    'a',
                    'b',
                    'c'
                ],
                body: 'a=b' + op + 'c'
            },
            funcName: id
        });
        exports[id + 's'] = makeOp({
            args: [
                'array',
                'array',
                'scalar'
            ],
            body: {
                args: [
                    'a',
                    'b',
                    's'
                ],
                body: 'a=b' + op + 's'
            },
            funcName: id + 's'
        });
        exports[id + 'eq'] = makeOp({
            args: [
                'array',
                'array'
            ],
            body: {
                args: [
                    'a',
                    'b'
                ],
                body: 'a=a' + op + 'b'
            },
            rvalue: true,
            count: 2,
            funcName: id + 'eq'
        });
        exports[id + 'seq'] = makeOp({
            args: [
                'array',
                'scalar'
            ],
            body: {
                args: [
                    'a',
                    's'
                ],
                body: 'a=a' + op + 's'
            },
            rvalue: true,
            count: 2,
            funcName: id + 'seq'
        });
    }
}());
var math_unary = [
    'abs',
    'acos',
    'asin',
    'atan',
    'ceil',
    'cos',
    'exp',
    'floor',
    'log',
    'round',
    'sin',
    'sqrt',
    'tan'
];
(function () {
    for (var i = 0; i < math_unary.length; ++i) {
        var f = math_unary[i];
        exports[f] = makeOp({
            args: [
                'array',
                'array'
            ],
            pre: {
                args: [],
                body: 'this_f=Math.' + f,
                thisVars: ['this_f']
            },
            body: {
                args: [
                    'a',
                    'b'
                ],
                body: 'a=this_f(b)',
                thisVars: ['this_f']
            },
            funcName: f
        });
        exports[f + 'eq'] = makeOp({
            args: ['array'],
            pre: {
                args: [],
                body: 'this_f=Math.' + f,
                thisVars: ['this_f']
            },
            body: {
                args: ['a'],
                body: 'a=this_f(a)',
                thisVars: ['this_f']
            },
            rvalue: true,
            count: 2,
            funcName: f + 'eq'
        });
    }
}());
var math_comm = [
    'max',
    'min',
    'atan2',
    'pow'
];
(function () {
    for (var i = 0; i < math_comm.length; ++i) {
        var f = math_comm[i];
        exports[f] = makeOp({
            args: [
                'array',
                'array',
                'array'
            ],
            pre: {
                args: [],
                body: 'this_f=Math.' + f,
                thisVars: ['this_f']
            },
            body: {
                args: [
                    'a',
                    'b',
                    'c'
                ],
                body: 'a=this_f(b,c)',
                thisVars: ['this_f']
            },
            funcName: f
        });
        exports[f + 's'] = makeOp({
            args: [
                'array',
                'array',
                'scalar'
            ],
            pre: {
                args: [],
                body: 'this_f=Math.' + f,
                thisVars: ['this_f']
            },
            body: {
                args: [
                    'a',
                    'b',
                    'c'
                ],
                body: 'a=this_f(b,c)',
                thisVars: ['this_f']
            },
            funcName: f + 's'
        });
        exports[f + 'eq'] = makeOp({
            args: [
                'array',
                'array'
            ],
            pre: {
                args: [],
                body: 'this_f=Math.' + f,
                thisVars: ['this_f']
            },
            body: {
                args: [
                    'a',
                    'b'
                ],
                body: 'a=this_f(a,b)',
                thisVars: ['this_f']
            },
            rvalue: true,
            count: 2,
            funcName: f + 'eq'
        });
        exports[f + 'seq'] = makeOp({
            args: [
                'array',
                'scalar'
            ],
            pre: {
                args: [],
                body: 'this_f=Math.' + f,
                thisVars: ['this_f']
            },
            body: {
                args: [
                    'a',
                    'b'
                ],
                body: 'a=this_f(a,b)',
                thisVars: ['this_f']
            },
            rvalue: true,
            count: 2,
            funcName: f + 'seq'
        });
    }
}());
var math_noncomm = [
    'atan2',
    'pow'
];
(function () {
    for (var i = 0; i < math_noncomm.length; ++i) {
        var f = math_noncomm[i];
        exports[f + 'op'] = makeOp({
            args: [
                'array',
                'array',
                'array'
            ],
            pre: {
                args: [],
                body: 'this_f=Math.' + f,
                thisVars: ['this_f']
            },
            body: {
                args: [
                    'a',
                    'b',
                    'c'
                ],
                body: 'a=this_f(c,b)',
                thisVars: ['this_f']
            },
            funcName: f + 'op'
        });
        exports[f + 'ops'] = makeOp({
            args: [
                'array',
                'array',
                'scalar'
            ],
            pre: {
                args: [],
                body: 'this_f=Math.' + f,
                thisVars: ['this_f']
            },
            body: {
                args: [
                    'a',
                    'b',
                    'c'
                ],
                body: 'a=this_f(c,b)',
                thisVars: ['this_f']
            },
            funcName: f + 'ops'
        });
        exports[f + 'opeq'] = makeOp({
            args: [
                'array',
                'array'
            ],
            pre: {
                args: [],
                body: 'this_f=Math.' + f,
                thisVars: ['this_f']
            },
            body: {
                args: [
                    'a',
                    'b'
                ],
                body: 'a=this_f(b,a)',
                thisVars: ['this_f']
            },
            rvalue: true,
            count: 2,
            funcName: f + 'opeq'
        });
        exports[f + 'opseq'] = makeOp({
            args: [
                'array',
                'scalar'
            ],
            pre: {
                args: [],
                body: 'this_f=Math.' + f,
                thisVars: ['this_f']
            },
            body: {
                args: [
                    'a',
                    'b'
                ],
                body: 'a=this_f(b,a)',
                thisVars: ['this_f']
            },
            rvalue: true,
            count: 2,
            funcName: f + 'opseq'
        });
    }
}());
exports.any = compile({
    args: ['array'],
    pre: EmptyProc,
    body: {
        args: [{
                name: 'a',
                lvalue: false,
                rvalue: true,
                count: 1
            }],
        body: 'if(a){return true}',
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: 'return false'
    },
    funcName: 'any'
});
exports.all = compile({
    args: ['array'],
    pre: EmptyProc,
    body: {
        args: [{
                name: 'x',
                lvalue: false,
                rvalue: true,
                count: 1
            }],
        body: 'if(!x){return false}',
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: 'return true'
    },
    funcName: 'all'
});
exports.sum = compile({
    args: ['array'],
    pre: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'this_s=0'
    },
    body: {
        args: [{
                name: 'a',
                lvalue: false,
                rvalue: true,
                count: 1
            }],
        body: 'this_s+=a',
        localVars: [],
        thisVars: ['this_s']
    },
    post: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'return this_s'
    },
    funcName: 'sum'
});
exports.prod = compile({
    args: ['array'],
    pre: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'this_s=1'
    },
    body: {
        args: [{
                name: 'a',
                lvalue: false,
                rvalue: true,
                count: 1
            }],
        body: 'this_s*=a',
        localVars: [],
        thisVars: ['this_s']
    },
    post: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'return this_s'
    },
    funcName: 'prod'
});
exports.norm2squared = compile({
    args: ['array'],
    pre: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'this_s=0'
    },
    body: {
        args: [{
                name: 'a',
                lvalue: false,
                rvalue: true,
                count: 2
            }],
        body: 'this_s+=a*a',
        localVars: [],
        thisVars: ['this_s']
    },
    post: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'return this_s'
    },
    funcName: 'norm2squared'
});
exports.norm2 = compile({
    args: ['array'],
    pre: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'this_s=0'
    },
    body: {
        args: [{
                name: 'a',
                lvalue: false,
                rvalue: true,
                count: 2
            }],
        body: 'this_s+=a*a',
        localVars: [],
        thisVars: ['this_s']
    },
    post: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'return Math.sqrt(this_s)'
    },
    funcName: 'norm2'
});
exports.norminf = compile({
    args: ['array'],
    pre: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'this_s=0'
    },
    body: {
        args: [{
                name: 'a',
                lvalue: false,
                rvalue: true,
                count: 4
            }],
        body: 'if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}',
        localVars: [],
        thisVars: ['this_s']
    },
    post: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'return this_s'
    },
    funcName: 'norminf'
});
exports.norm1 = compile({
    args: ['array'],
    pre: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'this_s=0'
    },
    body: {
        args: [{
                name: 'a',
                lvalue: false,
                rvalue: true,
                count: 3
            }],
        body: 'this_s+=a<0?-a:a',
        localVars: [],
        thisVars: ['this_s']
    },
    post: {
        args: [],
        localVars: [],
        thisVars: ['this_s'],
        body: 'return this_s'
    },
    funcName: 'norm1'
});
exports.sup = compile({
    args: ['array'],
    pre: {
        body: 'this_h=-Infinity',
        args: [],
        thisVars: ['this_h'],
        localVars: []
    },
    body: {
        body: 'if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_',
        args: [{
                'name': '_inline_1_arg0_',
                'lvalue': false,
                'rvalue': true,
                'count': 2
            }],
        thisVars: ['this_h'],
        localVars: []
    },
    post: {
        body: 'return this_h',
        args: [],
        thisVars: ['this_h'],
        localVars: []
    }
});
exports.inf = compile({
    args: ['array'],
    pre: {
        body: 'this_h=Infinity',
        args: [],
        thisVars: ['this_h'],
        localVars: []
    },
    body: {
        body: 'if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_',
        args: [{
                'name': '_inline_1_arg0_',
                'lvalue': false,
                'rvalue': true,
                'count': 2
            }],
        thisVars: ['this_h'],
        localVars: []
    },
    post: {
        body: 'return this_h',
        args: [],
        thisVars: ['this_h'],
        localVars: []
    }
});
exports.argmin = compile({
    args: [
        'index',
        'array',
        'shape'
    ],
    pre: {
        body: '{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}',
        args: [
            {
                name: '_inline_0_arg0_',
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: '_inline_0_arg1_',
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: '_inline_0_arg2_',
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        thisVars: [
            'this_i',
            'this_v'
        ],
        localVars: []
    },
    body: {
        body: '{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}',
        args: [
            {
                name: '_inline_1_arg0_',
                lvalue: false,
                rvalue: true,
                count: 2
            },
            {
                name: '_inline_1_arg1_',
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        thisVars: [
            'this_i',
            'this_v'
        ],
        localVars: ['_inline_1_k']
    },
    post: {
        body: '{return this_i}',
        args: [],
        thisVars: ['this_i'],
        localVars: []
    }
});
exports.argmax = compile({
    args: [
        'index',
        'array',
        'shape'
    ],
    pre: {
        body: '{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}',
        args: [
            {
                name: '_inline_0_arg0_',
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: '_inline_0_arg1_',
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: '_inline_0_arg2_',
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        thisVars: [
            'this_i',
            'this_v'
        ],
        localVars: []
    },
    body: {
        body: '{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}',
        args: [
            {
                name: '_inline_1_arg0_',
                lvalue: false,
                rvalue: true,
                count: 2
            },
            {
                name: '_inline_1_arg1_',
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        thisVars: [
            'this_i',
            'this_v'
        ],
        localVars: ['_inline_1_k']
    },
    post: {
        body: '{return this_i}',
        args: [],
        thisVars: ['this_i'],
        localVars: []
    }
});
exports.random = makeOp({
    args: ['array'],
    pre: {
        args: [],
        body: 'this_f=Math.random',
        thisVars: ['this_f']
    },
    body: {
        args: ['a'],
        body: 'a=this_f()',
        thisVars: ['this_f']
    },
    funcName: 'random'
});
exports.assign = makeOp({
    args: [
        'array',
        'array'
    ],
    body: {
        args: [
            'a',
            'b'
        ],
        body: 'a=b'
    },
    funcName: 'assign'
});
exports.assigns = makeOp({
    args: [
        'array',
        'scalar'
    ],
    body: {
        args: [
            'a',
            'b'
        ],
        body: 'a=b'
    },
    funcName: 'assigns'
});
exports.equals = compile({
    args: [
        'array',
        'array'
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: 'x',
                lvalue: false,
                rvalue: true,
                count: 1
            },
            {
                name: 'y',
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: 'if(x!==y){return false}',
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: 'return true'
    },
    funcName: 'equals'
});
},{"30":30}],243:[function(require,module,exports){
var iota = require(75);
var isBuffer = require(76);
var hasTypedArrays = typeof Float64Array !== 'undefined';
function compare1st(a, b) {
    return a[0] - b[0];
}
function order() {
    var stride = this.stride;
    var terms = new Array(stride.length);
    var i;
    for (i = 0; i < terms.length; ++i) {
        terms[i] = [
            Math.abs(stride[i]),
            i
        ];
    }
    terms.sort(compare1st);
    var result = new Array(terms.length);
    for (i = 0; i < result.length; ++i) {
        result[i] = terms[i][1];
    }
    return result;
}
function compileConstructor(dtype, dimension) {
    var className = [
        'View',
        dimension,
        'd',
        dtype
    ].join('');
    if (dimension < 0) {
        className = 'View_Nil' + dtype;
    }
    var useGetters = dtype === 'generic';
    if (dimension === -1) {
        var code = 'function ' + className + '(a){this.data=a;};var proto=' + className + '.prototype;proto.dtype=\'' + dtype + '\';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new ' + className + '(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_' + className + '(a){return new ' + className + '(a);}';
        var procedure = new Function(code);
        return procedure();
    } else if (dimension === 0) {
        var code = 'function ' + className + '(a,d) {this.data = a;this.offset = d};var proto=' + className + '.prototype;proto.dtype=\'' + dtype + '\';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function ' + className + '_copy() {return new ' + className + '(this.data,this.offset)};proto.pick=function ' + className + '_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function ' + className + '_get(){return ' + (useGetters ? 'this.data.get(this.offset)' : 'this.data[this.offset]') + '};proto.set=function ' + className + '_set(v){return ' + (useGetters ? 'this.data.set(this.offset,v)' : 'this.data[this.offset]=v') + '};return function construct_' + className + '(a,b,c,d){return new ' + className + '(a,d)}';
        var procedure = new Function('TrivialArray', code);
        return procedure(CACHED_CONSTRUCTORS[dtype][0]);
    }
    var code = ['\'use strict\''];
    var indices = iota(dimension);
    var args = indices.map(function (i) {
        return 'i' + i;
    });
    var index_str = 'this.offset+' + indices.map(function (i) {
        return 'this.stride[' + i + ']*i' + i;
    }).join('+');
    var shapeArg = indices.map(function (i) {
        return 'b' + i;
    }).join(',');
    var strideArg = indices.map(function (i) {
        return 'c' + i;
    }).join(',');
    code.push('function ' + className + '(a,' + shapeArg + ',' + strideArg + ',d){this.data=a', 'this.shape=[' + shapeArg + ']', 'this.stride=[' + strideArg + ']', 'this.offset=d|0}', 'var proto=' + className + '.prototype', 'proto.dtype=\'' + dtype + '\'', 'proto.dimension=' + dimension);
    code.push('Object.defineProperty(proto,\'size\',{get:function ' + className + '_size(){return ' + indices.map(function (i) {
        return 'this.shape[' + i + ']';
    }).join('*'), '}})');
    if (dimension === 1) {
        code.push('proto.order=[0]');
    } else {
        code.push('Object.defineProperty(proto,\'order\',{get:');
        if (dimension < 4) {
            code.push('function ' + className + '_order(){');
            if (dimension === 2) {
                code.push('return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})');
            } else if (dimension === 3) {
                code.push('var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})');
            }
        } else {
            code.push('ORDER})');
        }
    }
    code.push('proto.set=function ' + className + '_set(' + args.join(',') + ',v){');
    if (useGetters) {
        code.push('return this.data.set(' + index_str + ',v)}');
    } else {
        code.push('return this.data[' + index_str + ']=v}');
    }
    code.push('proto.get=function ' + className + '_get(' + args.join(',') + '){');
    if (useGetters) {
        code.push('return this.data.get(' + index_str + ')}');
    } else {
        code.push('return this.data[' + index_str + ']}');
    }
    code.push('proto.index=function ' + className + '_index(', args.join(), '){return ' + index_str + '}');
    code.push('proto.hi=function ' + className + '_hi(' + args.join(',') + '){return new ' + className + '(this.data,' + indices.map(function (i) {
        return [
            '(typeof i',
            i,
            '!==\'number\'||i',
            i,
            '<0)?this.shape[',
            i,
            ']:i',
            i,
            '|0'
        ].join('');
    }).join(',') + ',' + indices.map(function (i) {
        return 'this.stride[' + i + ']';
    }).join(',') + ',this.offset)}');
    var a_vars = indices.map(function (i) {
        return 'a' + i + '=this.shape[' + i + ']';
    });
    var c_vars = indices.map(function (i) {
        return 'c' + i + '=this.stride[' + i + ']';
    });
    code.push('proto.lo=function ' + className + '_lo(' + args.join(',') + '){var b=this.offset,d=0,' + a_vars.join(',') + ',' + c_vars.join(','));
    for (var i = 0; i < dimension; ++i) {
        code.push('if(typeof i' + i + '===\'number\'&&i' + i + '>=0){d=i' + i + '|0;b+=c' + i + '*d;a' + i + '-=d}');
    }
    code.push('return new ' + className + '(this.data,' + indices.map(function (i) {
        return 'a' + i;
    }).join(',') + ',' + indices.map(function (i) {
        return 'c' + i;
    }).join(',') + ',b)}');
    code.push('proto.step=function ' + className + '_step(' + args.join(',') + '){var ' + indices.map(function (i) {
        return 'a' + i + '=this.shape[' + i + ']';
    }).join(',') + ',' + indices.map(function (i) {
        return 'b' + i + '=this.stride[' + i + ']';
    }).join(',') + ',c=this.offset,d=0,ceil=Math.ceil');
    for (var i = 0; i < dimension; ++i) {
        code.push('if(typeof i' + i + '===\'number\'){d=i' + i + '|0;if(d<0){c+=b' + i + '*(a' + i + '-1);a' + i + '=ceil(-a' + i + '/d)}else{a' + i + '=ceil(a' + i + '/d)}b' + i + '*=d}');
    }
    code.push('return new ' + className + '(this.data,' + indices.map(function (i) {
        return 'a' + i;
    }).join(',') + ',' + indices.map(function (i) {
        return 'b' + i;
    }).join(',') + ',c)}');
    var tShape = new Array(dimension);
    var tStride = new Array(dimension);
    for (var i = 0; i < dimension; ++i) {
        tShape[i] = 'a[i' + i + ']';
        tStride[i] = 'b[i' + i + ']';
    }
    code.push('proto.transpose=function ' + className + '_transpose(' + args + '){' + args.map(function (n, idx) {
        return n + '=(' + n + '===undefined?' + idx + ':' + n + '|0)';
    }).join(';'), 'var a=this.shape,b=this.stride;return new ' + className + '(this.data,' + tShape.join(',') + ',' + tStride.join(',') + ',this.offset)}');
    code.push('proto.pick=function ' + className + '_pick(' + args + '){var a=[],b=[],c=this.offset');
    for (var i = 0; i < dimension; ++i) {
        code.push('if(typeof i' + i + '===\'number\'&&i' + i + '>=0){c=(c+this.stride[' + i + ']*i' + i + ')|0}else{a.push(this.shape[' + i + ']);b.push(this.stride[' + i + '])}');
    }
    code.push('var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}');
    code.push('return function construct_' + className + '(data,shape,stride,offset){return new ' + className + '(data,' + indices.map(function (i) {
        return 'shape[' + i + ']';
    }).join(',') + ',' + indices.map(function (i) {
        return 'stride[' + i + ']';
    }).join(',') + ',offset)}');
    var procedure = new Function('CTOR_LIST', 'ORDER', code.join('\n'));
    return procedure(CACHED_CONSTRUCTORS[dtype], order);
}
function arrayDType(data) {
    if (isBuffer(data)) {
        return 'buffer';
    }
    if (hasTypedArrays) {
        switch (Object.prototype.toString.call(data)) {
        case '[object Float64Array]':
            return 'float64';
        case '[object Float32Array]':
            return 'float32';
        case '[object Int8Array]':
            return 'int8';
        case '[object Int16Array]':
            return 'int16';
        case '[object Int32Array]':
            return 'int32';
        case '[object Uint8Array]':
            return 'uint8';
        case '[object Uint16Array]':
            return 'uint16';
        case '[object Uint32Array]':
            return 'uint32';
        case '[object Uint8ClampedArray]':
            return 'uint8_clamped';
        }
    }
    if (Array.isArray(data)) {
        return 'array';
    }
    return 'generic';
}
var CACHED_CONSTRUCTORS = {
    'float32': [],
    'float64': [],
    'int8': [],
    'int16': [],
    'int32': [],
    'uint8': [],
    'uint16': [],
    'uint32': [],
    'array': [],
    'uint8_clamped': [],
    'buffer': [],
    'generic': []
};
(function () {
    for (var id in CACHED_CONSTRUCTORS) {
        CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1));
    }
});
function wrappedNDArrayCtor(data, shape, stride, offset) {
    if (data === undefined) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
    } else if (typeof data === 'number') {
        data = [data];
    }
    if (shape === undefined) {
        shape = [data.length];
    }
    var d = shape.length;
    if (stride === undefined) {
        stride = new Array(d);
        for (var i = d - 1, sz = 1; i >= 0; --i) {
            stride[i] = sz;
            sz *= shape[i];
        }
    }
    if (offset === undefined) {
        offset = 0;
        for (var i = 0; i < d; ++i) {
            if (stride[i] < 0) {
                offset -= (shape[i] - 1) * stride[i];
            }
        }
    }
    var dtype = arrayDType(data);
    var ctor_list = CACHED_CONSTRUCTORS[dtype];
    while (ctor_list.length <= d + 1) {
        ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
    }
    var ctor = ctor_list[d + 1];
    return ctor(data, shape, stride, offset);
}
module.exports = wrappedNDArrayCtor;
},{"75":75,"76":76}],244:[function(require,module,exports){
;
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else {
        root.NProgress = factory();
    }
}(this, function () {
    var NProgress = {};
    NProgress.version = '0.2.0';
    var Settings = NProgress.settings = {
        minimum: 0.08,
        easing: 'ease',
        positionUsing: '',
        speed: 200,
        trickle: true,
        trickleRate: 0.02,
        trickleSpeed: 800,
        showSpinner: true,
        barSelector: '[role="bar"]',
        spinnerSelector: '[role="spinner"]',
        parent: 'body',
        template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    };
    NProgress.configure = function (options) {
        var key, value;
        for (key in options) {
            value = options[key];
            if (value !== undefined && options.hasOwnProperty(key))
                Settings[key] = value;
        }
        return this;
    };
    NProgress.status = null;
    NProgress.set = function (n) {
        var started = NProgress.isStarted();
        n = clamp(n, Settings.minimum, 1);
        NProgress.status = n === 1 ? null : n;
        var progress = NProgress.render(!started), bar = progress.querySelector(Settings.barSelector), speed = Settings.speed, ease = Settings.easing;
        progress.offsetWidth;
        queue(function (next) {
            if (Settings.positionUsing === '')
                Settings.positionUsing = NProgress.getPositioningCSS();
            css(bar, barPositionCSS(n, speed, ease));
            if (n === 1) {
                css(progress, {
                    transition: 'none',
                    opacity: 1
                });
                progress.offsetWidth;
                setTimeout(function () {
                    css(progress, {
                        transition: 'all ' + speed + 'ms linear',
                        opacity: 0
                    });
                    setTimeout(function () {
                        NProgress.remove();
                        next();
                    }, speed);
                }, speed);
            } else {
                setTimeout(next, speed);
            }
        });
        return this;
    };
    NProgress.isStarted = function () {
        return typeof NProgress.status === 'number';
    };
    NProgress.start = function () {
        if (!NProgress.status)
            NProgress.set(0);
        var work = function () {
            setTimeout(function () {
                if (!NProgress.status)
                    return;
                NProgress.trickle();
                work();
            }, Settings.trickleSpeed);
        };
        if (Settings.trickle)
            work();
        return this;
    };
    NProgress.done = function (force) {
        if (!force && !NProgress.status)
            return this;
        return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);
    };
    NProgress.inc = function (amount) {
        var n = NProgress.status;
        if (!n) {
            return NProgress.start();
        } else {
            if (typeof amount !== 'number') {
                amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);
            }
            n = clamp(n + amount, 0, 0.994);
            return NProgress.set(n);
        }
    };
    NProgress.trickle = function () {
        return NProgress.inc(Math.random() * Settings.trickleRate);
    };
    (function () {
        var initial = 0, current = 0;
        NProgress.promise = function ($promise) {
            if (!$promise || $promise.state() === 'resolved') {
                return this;
            }
            if (current === 0) {
                NProgress.start();
            }
            initial++;
            current++;
            $promise.always(function () {
                current--;
                if (current === 0) {
                    initial = 0;
                    NProgress.done();
                } else {
                    NProgress.set((initial - current) / initial);
                }
            });
            return this;
        };
    }());
    NProgress.render = function (fromStart) {
        if (NProgress.isRendered())
            return document.getElementById('nprogress');
        addClass(document.documentElement, 'nprogress-busy');
        var progress = document.createElement('div');
        progress.id = 'nprogress';
        progress.innerHTML = Settings.template;
        var bar = progress.querySelector(Settings.barSelector), perc = fromStart ? '-100' : toBarPerc(NProgress.status || 0), parent = document.querySelector(Settings.parent), spinner;
        css(bar, {
            transition: 'all 0 linear',
            transform: 'translate3d(' + perc + '%,0,0)'
        });
        if (!Settings.showSpinner) {
            spinner = progress.querySelector(Settings.spinnerSelector);
            spinner && removeElement(spinner);
        }
        if (parent != document.body) {
            addClass(parent, 'nprogress-custom-parent');
        }
        parent.appendChild(progress);
        return progress;
    };
    NProgress.remove = function () {
        removeClass(document.documentElement, 'nprogress-busy');
        removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');
        var progress = document.getElementById('nprogress');
        progress && removeElement(progress);
    };
    NProgress.isRendered = function () {
        return !!document.getElementById('nprogress');
    };
    NProgress.getPositioningCSS = function () {
        var bodyStyle = document.body.style;
        var vendorPrefix = 'WebkitTransform' in bodyStyle ? 'Webkit' : 'MozTransform' in bodyStyle ? 'Moz' : 'msTransform' in bodyStyle ? 'ms' : 'OTransform' in bodyStyle ? 'O' : '';
        if (vendorPrefix + 'Perspective' in bodyStyle) {
            return 'translate3d';
        } else if (vendorPrefix + 'Transform' in bodyStyle) {
            return 'translate';
        } else {
            return 'margin';
        }
    };
    function clamp(n, min, max) {
        if (n < min)
            return min;
        if (n > max)
            return max;
        return n;
    }
    function toBarPerc(n) {
        return (-1 + n) * 100;
    }
    function barPositionCSS(n, speed, ease) {
        var barCSS;
        if (Settings.positionUsing === 'translate3d') {
            barCSS = { transform: 'translate3d(' + toBarPerc(n) + '%,0,0)' };
        } else if (Settings.positionUsing === 'translate') {
            barCSS = { transform: 'translate(' + toBarPerc(n) + '%,0)' };
        } else {
            barCSS = { 'margin-left': toBarPerc(n) + '%' };
        }
        barCSS.transition = 'all ' + speed + 'ms ' + ease;
        return barCSS;
    }
    var queue = function () {
        var pending = [];
        function next() {
            var fn = pending.shift();
            if (fn) {
                fn(next);
            }
        }
        return function (fn) {
            pending.push(fn);
            if (pending.length == 1)
                next();
        };
    }();
    var css = function () {
        var cssPrefixes = [
                'Webkit',
                'O',
                'Moz',
                'ms'
            ], cssProps = {};
        function camelCase(string) {
            return string.replace(/^-ms-/, 'ms-').replace(/-([\da-z])/gi, function (match, letter) {
                return letter.toUpperCase();
            });
        }
        function getVendorProp(name) {
            var style = document.body.style;
            if (name in style)
                return name;
            var i = cssPrefixes.length, capName = name.charAt(0).toUpperCase() + name.slice(1), vendorName;
            while (i--) {
                vendorName = cssPrefixes[i] + capName;
                if (vendorName in style)
                    return vendorName;
            }
            return name;
        }
        function getStyleProp(name) {
            name = camelCase(name);
            return cssProps[name] || (cssProps[name] = getVendorProp(name));
        }
        function applyCss(element, prop, value) {
            prop = getStyleProp(prop);
            element.style[prop] = value;
        }
        return function (element, properties) {
            var args = arguments, prop, value;
            if (args.length == 2) {
                for (prop in properties) {
                    value = properties[prop];
                    if (value !== undefined && properties.hasOwnProperty(prop))
                        applyCss(element, prop, value);
                }
            } else {
                applyCss(element, args[1], args[2]);
            }
        };
    }();
    function hasClass(element, name) {
        var list = typeof element == 'string' ? element : classList(element);
        return list.indexOf(' ' + name + ' ') >= 0;
    }
    function addClass(element, name) {
        var oldList = classList(element), newList = oldList + name;
        if (hasClass(oldList, name))
            return;
        element.className = newList.substring(1);
    }
    function removeClass(element, name) {
        var oldList = classList(element), newList;
        if (!hasClass(element, name))
            return;
        newList = oldList.replace(' ' + name + ' ', ' ');
        element.className = newList.substring(1, newList.length - 1);
    }
    function classList(element) {
        return (' ' + (element.className || '') + ' ').replace(/\s+/gi, ' ');
    }
    function removeElement(element) {
        element && element.parentNode && element.parentNode.removeChild(element);
    }
    return NProgress;
}));
},{}],245:[function(require,module,exports){
module.exports = compile;
var BaseFuncs = require(4), trueFunc = BaseFuncs.trueFunc, falseFunc = BaseFuncs.falseFunc;
function compile(parsed) {
    var a = parsed[0], b = parsed[1] - 1;
    if (b < 0 && a <= 0)
        return falseFunc;
    if (a === -1)
        return function (pos) {
            return pos <= b;
        };
    if (a === 0)
        return function (pos) {
            return pos === b;
        };
    if (a === 1)
        return b < 0 ? trueFunc : function (pos) {
            return pos >= b;
        };
    var bMod = b % a;
    if (bMod < 0)
        bMod += a;
    if (a > 1) {
        return function (pos) {
            return pos >= b && pos % a === bMod;
        };
    }
    a *= -1;
    return function (pos) {
        return pos <= b && pos % a === bMod;
    };
}
},{"4":4}],246:[function(require,module,exports){
var parse = require(247), compile = require(245);
module.exports = function nthCheck(formula) {
    return compile(parse(formula));
};
module.exports.parse = parse;
module.exports.compile = compile;
},{"245":245,"247":247}],247:[function(require,module,exports){
module.exports = parse;
var re_nthElement = /^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/;
function parse(formula) {
    formula = formula.trim().toLowerCase();
    if (formula === 'even') {
        return [
            2,
            0
        ];
    } else if (formula === 'odd') {
        return [
            2,
            1
        ];
    } else {
        var parsed = formula.match(re_nthElement);
        if (!parsed) {
            throw new SyntaxError('n-th rule couldn\'t be parsed (\'' + formula + '\')');
        }
        var a;
        if (parsed[1]) {
            a = parseInt(parsed[1], 10);
            if (isNaN(a)) {
                if (parsed[1].charAt(0) === '-')
                    a = -1;
                else
                    a = 1;
            }
        } else
            a = 0;
        return [
            a,
            parsed[3] ? parseInt((parsed[2] || '') + parsed[3], 10) : 0
        ];
    }
}
},{}],248:[function(require,module,exports){
'use strict';
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === undefined) {
        throw new TypeError('Object.assign cannot be called with null or undefined');
    }
    return Object(val);
}
function shouldUseNative() {
    try {
        if (!Object.assign) {
            return false;
        }
        var test1 = new String('abc');
        test1[5] = 'de';
        if (Object.getOwnPropertyNames(test1)[0] === '5') {
            return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
            test2['_' + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
            return test2[n];
        });
        if (order2.join('') !== '0123456789') {
            return false;
        }
        var test3 = {};
        'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
            return false;
        }
        return true;
    } catch (err) {
        return false;
    }
}
module.exports = shouldUseNative() ? Object.assign : function (target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
            }
        }
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
                if (propIsEnumerable.call(from, symbols[i])) {
                    to[symbols[i]] = from[symbols[i]];
                }
            }
        }
    }
    return to;
};
},{}],249:[function(require,module,exports){
var document = require(61);
var window = require(62);
var watch = Object.create(null);
var KEY_ID = 'onloadid' + (new Date() % 9000000).toString(36);
var KEY_ATTR = 'data-' + KEY_ID;
var INDEX = 0;
if (window && window.MutationObserver) {
    var observer = new MutationObserver(function (mutations) {
        if (Object.keys(watch).length < 1)
            return;
        for (var i = 0; i < mutations.length; i++) {
            if (mutations[i].attributeName === KEY_ATTR) {
                eachAttr(mutations[i], turnon, turnoff);
                continue;
            }
            eachMutation(mutations[i].removedNodes, turnoff);
            eachMutation(mutations[i].addedNodes, turnon);
        }
    });
    observer.observe(document.body, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeOldValue: true,
        attributeFilter: [KEY_ATTR]
    });
}
module.exports = function onload(el, on, off, caller) {
    on = on || function () {
    };
    off = off || function () {
    };
    el.setAttribute(KEY_ATTR, 'o' + INDEX);
    watch['o' + INDEX] = [
        on,
        off,
        0,
        caller || onload.caller
    ];
    INDEX += 1;
    return el;
};
function turnon(index, el) {
    if (watch[index][0] && watch[index][2] === 0) {
        watch[index][0](el);
        watch[index][2] = 1;
    }
}
function turnoff(index, el) {
    if (watch[index][1] && watch[index][2] === 1) {
        watch[index][1](el);
        watch[index][2] = 0;
    }
}
function eachAttr(mutation, on, off) {
    var newValue = mutation.target.getAttribute(KEY_ATTR);
    if (sameOrigin(mutation.oldValue, newValue)) {
        watch[newValue] = watch[mutation.oldValue];
        return;
    }
    if (watch[mutation.oldValue]) {
        off(mutation.oldValue, mutation.target);
    }
    if (watch[newValue]) {
        on(newValue, mutation.target);
    }
}
function sameOrigin(oldValue, newValue) {
    if (!oldValue || !newValue)
        return false;
    return watch[oldValue][3] === watch[newValue][3];
}
function eachMutation(nodes, fn) {
    var keys = Object.keys(watch);
    for (var i = 0; i < nodes.length; i++) {
        if (nodes[i] && nodes[i].getAttribute && nodes[i].getAttribute(KEY_ATTR)) {
            var onloadid = nodes[i].getAttribute(KEY_ATTR);
            keys.forEach(function (k) {
                if (onloadid === k) {
                    fn(k, nodes[i]);
                }
            });
        }
        if (nodes[i].childNodes.length > 0) {
            eachMutation(nodes[i].childNodes, fn);
        }
    }
}
},{"61":61,"62":62}],250:[function(require,module,exports){
(function (process){
'use strict';
if (!process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
    module.exports = nextTick;
} else {
    module.exports = process.nextTick;
}
function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== 'function') {
        throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
    case 0:
    case 1:
        return process.nextTick(fn);
    case 2:
        return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
        });
    case 3:
        return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
        });
    case 4:
        return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
        });
    default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
            args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
            fn.apply(null, args);
        });
    }
}
}).call(this,require(251))
},{"251":251}],251:[function(require,module,exports){
var process = module.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
}());
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}
function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = '';
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.binding = function (name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};
},{}],252:[function(require,module,exports){
module.exports = require(253);
},{"253":253}],253:[function(require,module,exports){
'use strict';
var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) {
        keys.push(key);
    }
    return keys;
};
module.exports = Duplex;
var processNextTick = require(250);
var util = require(21);
util.inherits = require(73);
var Readable = require(255);
var Writable = require(257);
util.inherits(Duplex, Readable);
var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
}
function Duplex(options) {
    if (!(this instanceof Duplex))
        return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false)
        this.readable = false;
    if (options && options.writable === false)
        this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
    this.once('end', onend);
}
function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
        return;
    processNextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
function forEach(xs, f) {
    for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
    }
}
},{"21":21,"250":250,"255":255,"257":257,"73":73}],254:[function(require,module,exports){
'use strict';
module.exports = PassThrough;
var Transform = require(256);
var util = require(21);
util.inherits = require(73);
util.inherits(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough))
        return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
};
},{"21":21,"256":256,"73":73}],255:[function(require,module,exports){
(function (process){
'use strict';
module.exports = Readable;
var processNextTick = require(250);
var isArray = require(260);
var Duplex;
Readable.ReadableState = ReadableState;
var EE = require(58).EventEmitter;
var EElistenerCount = function (emitter, type) {
    return emitter.listeners(type).length;
};
var Stream = require(259);
var Buffer = require(7).Buffer;
var bufferShim = require(6);
var util = require(21);
util.inherits = require(73);
var debugUtil = require(5);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog('stream');
} else {
    debug = function () {
    };
}
var BufferList = require(258);
var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = [
    'error',
    'close',
    'destroy',
    'pause',
    'resume'
];
function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === 'function') {
        return emitter.prependListener(event, fn);
    } else {
        if (!emitter._events || !emitter._events[event])
            emitter.on(event, fn);
        else if (isArray(emitter._events[event]))
            emitter._events[event].unshift(fn);
        else
            emitter._events[event] = [
                fn,
                emitter._events[event]
            ];
    }
}
function ReadableState(options, stream) {
    Duplex = Duplex || require(253);
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.defaultEncoding = options.defaultEncoding || 'utf8';
    this.ranOut = false;
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder)
            StringDecoder = require(261).StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || require(253);
    if (!(this instanceof Readable))
        return new Readable(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options && typeof options.read === 'function')
        this._read = options.read;
    Stream.call(this);
}
Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;
    if (!state.objectMode && typeof chunk === 'string') {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
            chunk = bufferShim.from(chunk, encoding);
            encoding = '';
        }
    }
    return readableAddChunk(this, state, chunk, encoding, false);
};
Readable.prototype.unshift = function (chunk) {
    var state = this._readableState;
    return readableAddChunk(this, state, chunk, '', true);
};
Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
};
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
    var er = chunkInvalid(state, chunk);
    if (er) {
        stream.emit('error', er);
    } else if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
            var e = new Error('stream.push() after EOF');
            stream.emit('error', e);
        } else if (state.endEmitted && addToFront) {
            var _e = new Error('stream.unshift() after end event');
            stream.emit('error', _e);
        } else {
            var skipAdd;
            if (state.decoder && !addToFront && !encoding) {
                chunk = state.decoder.write(chunk);
                skipAdd = !state.objectMode && chunk.length === 0;
            }
            if (!addToFront)
                state.reading = false;
            if (!skipAdd) {
                if (state.flowing && state.length === 0 && !state.sync) {
                    stream.emit('data', chunk);
                    stream.read(0);
                } else {
                    state.length += state.objectMode ? 1 : chunk.length;
                    if (addToFront)
                        state.buffer.unshift(chunk);
                    else
                        state.buffer.push(chunk);
                    if (state.needReadable)
                        emitReadable(stream);
                }
            }
            maybeReadMore(stream, state);
        }
    } else if (!addToFront) {
        state.reading = false;
    }
    return needMoreData(state);
}
function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
Readable.prototype.setEncoding = function (enc) {
    if (!StringDecoder)
        StringDecoder = require(261).StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
};
var MAX_HWM = 8388608;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
        n = MAX_HWM;
    } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
}
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
        return 0;
    if (state.objectMode)
        return 1;
    if (n !== n) {
        if (state.flowing && state.length)
            return state.buffer.head.data.length;
        else
            return state.length;
    }
    if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
        return n;
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
}
Readable.prototype.read = function (n) {
    debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
        state.emittedReadable = false;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended)
            endReadable(this);
        else
            emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
        if (state.length === 0)
            endReadable(this);
        return null;
    }
    var doRead = state.needReadable;
    debug('need readable', doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
    }
    if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
    } else if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
            state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
            n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
        ret = fromList(n, state);
    else
        ret = null;
    if (ret === null) {
        state.needReadable = true;
        n = 0;
    } else {
        state.length -= n;
    }
    if (state.length === 0) {
        if (!state.ended)
            state.needReadable = true;
        if (nOrig !== n && state.ended)
            endReadable(this);
    }
    if (ret !== null)
        this.emit('data', ret);
    return ret;
};
function chunkInvalid(state, chunk) {
    var er = null;
    if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
    }
    return er;
}
function onEofChunk(stream, state) {
    if (state.ended)
        return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    emitReadable(stream);
}
function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        if (state.sync)
            processNextTick(emitReadable_, stream);
        else
            emitReadable_(stream);
    }
}
function emitReadable_(stream) {
    debug('emit readable');
    stream.emit('readable');
    flow(stream);
}
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        processNextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length)
            break;
        else
            len = state.length;
    }
    state.readingMore = false;
}
Readable.prototype._read = function (n) {
    this.emit('error', new Error('_read() is not implemented'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
    case 0:
        state.pipes = dest;
        break;
    case 1:
        state.pipes = [
            state.pipes,
            dest
        ];
        break;
    default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : cleanup;
    if (state.endEmitted)
        processNextTick(endFn);
    else
        src.once('end', endFn);
    dest.on('unpipe', onunpipe);
    function onunpipe(readable) {
        debug('onunpipe');
        if (readable === src) {
            cleanup();
        }
    }
    function onend() {
        debug('onend');
        dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug('cleanup');
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', cleanup);
        src.removeListener('data', ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
    }
    var increasedAwaitDrain = false;
    src.on('data', ondata);
    function ondata(chunk) {
        debug('ondata');
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug('false write response, pause', src._readableState.awaitDrain);
                src._readableState.awaitDrain++;
                increasedAwaitDrain = true;
            }
            src.pause();
        }
    }
    function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EElistenerCount(dest, 'error') === 0)
            dest.emit('error', er);
    }
    prependListener(dest, 'error', onerror);
    function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
    }
    dest.once('close', onclose);
    function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
    }
    dest.once('finish', onfinish);
    function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
    }
    dest.emit('pipe', src);
    if (!state.flowing) {
        debug('pipe resume');
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function () {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain)
            state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;
    if (state.pipesCount === 0)
        return this;
    if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
            return this;
        if (!dest)
            dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
            dest.emit('unpipe', this);
        return this;
    }
    if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
            dests[i].emit('unpipe', this);
        }
        return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
        return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    dest.emit('unpipe', this);
    return this;
};
Readable.prototype.on = function (ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === 'data') {
        if (this._readableState.flowing !== false)
            this.resume();
    } else if (ev === 'readable') {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.emittedReadable = false;
            if (!state.reading) {
                processNextTick(nReadingNextTick, this);
            } else if (state.length) {
                emitReadable(this, state);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self) {
    debug('readable nexttick read 0');
    self.read(0);
}
Readable.prototype.resume = function () {
    var state = this._readableState;
    if (!state.flowing) {
        debug('resume');
        state.flowing = true;
        resume(this, state);
    }
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        processNextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    if (!state.reading) {
        debug('resume read 0');
        stream.read(0);
    }
    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading)
        stream.read(0);
}
Readable.prototype.pause = function () {
    debug('call pause flowing=%j', this._readableState.flowing);
    if (false !== this._readableState.flowing) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
    }
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug('flow', state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
}
Readable.prototype.wrap = function (stream) {
    var state = this._readableState;
    var paused = false;
    var self = this;
    stream.on('end', function () {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
                self.push(chunk);
        }
        self.push(null);
    });
    stream.on('data', function (chunk) {
        debug('wrapped data');
        if (state.decoder)
            chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === undefined))
            return;
        else if (!state.objectMode && (!chunk || !chunk.length))
            return;
        var ret = self.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    });
    for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
            this[i] = function (method) {
                return function () {
                    return stream[method].apply(stream, arguments);
                };
            }(i);
        }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
    }
    self._read = function (n) {
        debug('wrapped _read', n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return self;
};
Readable._fromList = fromList;
function fromList(n, state) {
    if (state.length === 0)
        return null;
    var ret;
    if (state.objectMode)
        ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        if (state.decoder)
            ret = state.buffer.join('');
        else if (state.buffer.length === 1)
            ret = state.buffer.head.data;
        else
            ret = state.buffer.concat(state.length);
        state.buffer.clear();
    } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
    }
    return ret;
}
function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
        ret = list.shift();
    } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
}
function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
            ret += str;
        else
            ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
            if (nb === str.length) {
                ++c;
                if (p.next)
                    list.head = p.next;
                else
                    list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = str.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
function copyFromBuffer(n, list) {
    var ret = bufferShim.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
            if (nb === buf.length) {
                ++c;
                if (p.next)
                    list.head = p.next;
                else
                    list.head = list.tail = null;
            } else {
                list.head = p;
                p.data = buf.slice(nb);
            }
            break;
        }
        ++c;
    }
    list.length -= c;
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted) {
        state.ended = true;
        processNextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
    }
}
function forEach(xs, f) {
    for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
    }
}
function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
            return i;
    }
    return -1;
}
}).call(this,require(251))
},{"21":21,"250":250,"251":251,"253":253,"258":258,"259":259,"260":260,"261":261,"5":5,"58":58,"6":6,"7":7,"73":73}],256:[function(require,module,exports){
'use strict';
module.exports = Transform;
var Duplex = require(253);
var util = require(21);
util.inherits = require(73);
util.inherits(Transform, Duplex);
function TransformState(stream) {
    this.afterTransform = function (er, data) {
        return afterTransform(stream, er, data);
    };
    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
}
function afterTransform(stream, er, data) {
    var ts = stream._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb)
        return stream.emit('error', new Error('no writecb in Transform class'));
    ts.writechunk = null;
    ts.writecb = null;
    if (data !== null && data !== undefined)
        stream.push(data);
    cb(er);
    var rs = stream._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
    }
}
function Transform(options) {
    if (!(this instanceof Transform))
        return new Transform(options);
    Duplex.call(this, options);
    this._transformState = new TransformState(this);
    var stream = this;
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === 'function')
            this._transform = options.transform;
        if (typeof options.flush === 'function')
            this._flush = options.flush;
    }
    this.once('prefinish', function () {
        if (typeof this._flush === 'function')
            this._flush(function (er, data) {
                done(stream, er, data);
            });
        else
            done(stream);
    });
}
Transform.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform.prototype._transform = function (chunk, encoding, cb) {
    throw new Error('_transform() is not implemented');
};
Transform.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
    }
};
Transform.prototype._read = function (n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
        ts.needTransform = true;
    }
};
function done(stream, er, data) {
    if (er)
        return stream.emit('error', er);
    if (data !== null && data !== undefined)
        stream.push(data);
    var ws = stream._writableState;
    var ts = stream._transformState;
    if (ws.length)
        throw new Error('Calling transform done when ws.length != 0');
    if (ts.transforming)
        throw new Error('Calling transform done when still transforming');
    return stream.push(null);
}
},{"21":21,"253":253,"73":73}],257:[function(require,module,exports){
(function (process){
'use strict';
module.exports = Writable;
var processNextTick = require(250);
var asyncWrite = !process.browser && [
    'v0.10',
    'v0.9.'
].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
var Duplex;
Writable.WritableState = WritableState;
var util = require(21);
util.inherits = require(73);
var internalUtil = { deprecate: require(274) };
var Stream = require(259);
var Buffer = require(7).Buffer;
var bufferShim = require(6);
util.inherits(Writable, Stream);
function nop() {
}
function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
}
function WritableState(options, stream) {
    Duplex = Duplex || require(253);
    options = options || {};
    this.objectMode = !!options.objectMode;
    if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
    this.highWaterMark = ~~this.highWaterMark;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || 'utf8';
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function (er) {
        onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
        out.push(current);
        current = current.next;
    }
    return out;
};
(function () {
    try {
        Object.defineProperty(WritableState.prototype, 'buffer', {
            get: internalUtil.deprecate(function () {
                return this.getBuffer();
            }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
        });
    } catch (_) {
    }
}());
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function (object) {
            if (realHasInstance.call(this, object))
                return true;
            return object && object._writableState instanceof WritableState;
        }
    });
} else {
    realHasInstance = function (object) {
        return object instanceof this;
    };
}
function Writable(options) {
    Duplex = Duplex || require(253);
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
        if (typeof options.write === 'function')
            this._write = options.write;
        if (typeof options.writev === 'function')
            this._writev = options.writev;
    }
    Stream.call(this);
}
Writable.prototype.pipe = function () {
    this.emit('error', new Error('Cannot pipe, not readable'));
};
function writeAfterEnd(stream, cb) {
    var er = new Error('write after end');
    stream.emit('error', er);
    processNextTick(cb, er);
}
function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
        er = new TypeError('May not write null values to stream');
    } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new TypeError('Invalid non-string/buffer chunk');
    }
    if (er) {
        stream.emit('error', er);
        processNextTick(cb, er);
        valid = false;
    }
    return valid;
}
Writable.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = Buffer.isBuffer(chunk);
    if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
    }
    if (isBuf)
        encoding = 'buffer';
    else if (!encoding)
        encoding = state.defaultEncoding;
    if (typeof cb !== 'function')
        cb = nop;
    if (state.ended)
        writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function () {
    var state = this._writableState;
    state.corked++;
};
Writable.prototype.uncork = function () {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === 'string')
        encoding = encoding.toLowerCase();
    if (!([
            'hex',
            'utf8',
            'utf-8',
            'ascii',
            'binary',
            'base64',
            'ucs2',
            'ucs-2',
            'utf16le',
            'utf-16le',
            'raw'
        ].indexOf((encoding + '').toLowerCase()) > -1))
        throw new TypeError('Unknown encoding: ' + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = bufferShim.from(chunk, encoding);
    }
    return chunk;
}
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        chunk = decodeChunk(state, chunk, encoding);
        if (Buffer.isBuffer(chunk))
            encoding = 'buffer';
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
        state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
        if (last) {
            last.next = state.lastBufferedRequest;
        } else {
            state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
    } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev)
        stream._writev(chunk, state.onwrite);
    else
        stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync)
        processNextTick(cb, er);
    else
        cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    onwriteStateUpdate(state);
    if (er)
        onwriteError(stream, state, sync, er, cb);
    else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
        }
        if (sync) {
            asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
            afterWrite(stream, state, finished, cb);
        }
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished)
        onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
    }
}
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        while (entry) {
            buffer[count] = entry;
            entry = entry.next;
            count += 1;
        }
        doWrite(stream, state, true, state.length, buffer, '', holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        } else {
            state.corkedRequestsFree = new CorkedRequest(state);
        }
    } else {
        while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            if (state.writing) {
                break;
            }
        }
        if (entry === null)
            state.lastBufferedRequest = null;
    }
    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
    cb(new Error('_write() is not implemented'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
    } else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
        this.write(chunk, encoding);
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    }
    if (!state.ending && !state.finished)
        endWritable(this, state, cb);
};
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
    if (!state.prefinished) {
        state.prefinished = true;
        stream.emit('prefinish');
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        if (state.pendingcb === 0) {
            prefinish(stream, state);
            state.finished = true;
            stream.emit('finish');
        } else {
            prefinish(stream, state);
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished)
            processNextTick(cb);
        else
            stream.once('finish', cb);
    }
    state.ended = true;
    stream.writable = false;
}
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function (err) {
        var entry = _this.entry;
        _this.entry = null;
        while (entry) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(err);
            entry = entry.next;
        }
        if (state.corkedRequestsFree) {
            state.corkedRequestsFree.next = _this;
        } else {
            state.corkedRequestsFree = _this;
        }
    };
}
}).call(this,require(251))
},{"21":21,"250":250,"251":251,"253":253,"259":259,"274":274,"6":6,"7":7,"73":73}],258:[function(require,module,exports){
'use strict';
var Buffer = require(7).Buffer;
var bufferShim = require(6);
module.exports = BufferList;
function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
}
BufferList.prototype.push = function (v) {
    var entry = {
        data: v,
        next: null
    };
    if (this.length > 0)
        this.tail.next = entry;
    else
        this.head = entry;
    this.tail = entry;
    ++this.length;
};
BufferList.prototype.unshift = function (v) {
    var entry = {
        data: v,
        next: this.head
    };
    if (this.length === 0)
        this.tail = entry;
    this.head = entry;
    ++this.length;
};
BufferList.prototype.shift = function () {
    if (this.length === 0)
        return;
    var ret = this.head.data;
    if (this.length === 1)
        this.head = this.tail = null;
    else
        this.head = this.head.next;
    --this.length;
    return ret;
};
BufferList.prototype.clear = function () {
    this.head = this.tail = null;
    this.length = 0;
};
BufferList.prototype.join = function (s) {
    if (this.length === 0)
        return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
        ret += s + p.data;
    }
    return ret;
};
BufferList.prototype.concat = function (n) {
    if (this.length === 0)
        return bufferShim.alloc(0);
    if (this.length === 1)
        return this.head.data;
    var ret = bufferShim.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
    }
    return ret;
};
},{"6":6,"7":7}],259:[function(require,module,exports){
module.exports = require(58).EventEmitter;
},{"58":58}],260:[function(require,module,exports){
var toString = {}.toString;
module.exports = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
};
},{}],261:[function(require,module,exports){
'use strict';
var Buffer = require(7).Buffer;
var bufferShim = require(6);
var isEncoding = Buffer.isEncoding || function (encoding) {
    encoding = '' + encoding;
    switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
        return true;
    default:
        return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc)
        return 'utf8';
    var retried;
    while (true) {
        switch (enc) {
        case 'utf8':
        case 'utf-8':
            return 'utf8';
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return 'utf16le';
        case 'latin1':
        case 'binary':
            return 'latin1';
        case 'base64':
        case 'ascii':
        case 'hex':
            return enc;
        default:
            if (retried)
                return;
            enc = ('' + enc).toLowerCase();
            retried = true;
        }
    }
}
;
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
}
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
    case 'utf16le':
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
    case 'utf8':
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
    case 'base64':
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
    default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = bufferShim.allocUnsafe(nb);
}
StringDecoder.prototype.write = function (buf) {
    if (buf.length === 0)
        return '';
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined)
            return '';
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
};
StringDecoder.prototype.end = utf8End;
StringDecoder.prototype.text = utf8Text;
StringDecoder.prototype.fillLast = function (buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
function utf8CheckByte(byte) {
    if (byte <= 127)
        return 0;
    else if (byte >> 5 === 6)
        return 2;
    else if (byte >> 4 === 14)
        return 3;
    else if (byte >> 3 === 30)
        return 4;
    return -1;
}
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i)
        return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0)
            self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i)
        return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0)
            self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i)
        return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2)
                nb = 0;
            else
                self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 192) !== 128) {
        self.lastNeed = 0;
        return '\uFFFD'.repeat(p);
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
            self.lastNeed = 1;
            return '\uFFFD'.repeat(p + 1);
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
                self.lastNeed = 2;
                return '\uFFFD'.repeat(p + 2);
            }
        }
    }
}
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
        return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
        return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
}
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed)
        return r + '\uFFFD'.repeat(this.lastTotal - this.lastNeed);
    return r;
}
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
}
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
        return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed)
        return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
}
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
}
},{"6":6,"7":7}],262:[function(require,module,exports){
module.exports = require(263).PassThrough;
},{"263":263}],263:[function(require,module,exports){
exports = module.exports = require(255);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require(257);
exports.Duplex = require(253);
exports.Transform = require(256);
exports.PassThrough = require(254);
},{"253":253,"254":254,"255":255,"256":256,"257":257}],264:[function(require,module,exports){
module.exports = require(263).Transform;
},{"263":263}],265:[function(require,module,exports){
module.exports = require(257);
},{"257":257}],266:[function(require,module,exports){
(function (process,global){
;
(function (undefined) {
    var objectTypes = {
        'function': true,
        'object': true
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports, freeSelf = objectTypes[typeof self] && self.Object && self, freeWindow = objectTypes[typeof window] && window && window.Object && window, freeModule = objectTypes[typeof module] && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports && freeExports, freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var root = root = freeGlobal || freeWindow !== (this && this.window) && freeWindow || freeSelf || this;
    var Rx = {
        internals: {},
        config: { Promise: root.Promise },
        helpers: {}
    };
    var noop = Rx.helpers.noop = function () {
        }, identity = Rx.helpers.identity = function (x) {
            return x;
        }, defaultNow = Rx.helpers.defaultNow = Date.now, defaultComparer = Rx.helpers.defaultComparer = function (x, y) {
            return isEqual(x, y);
        }, defaultSubComparer = Rx.helpers.defaultSubComparer = function (x, y) {
            return x > y ? 1 : x < y ? -1 : 0;
        }, defaultKeySerializer = Rx.helpers.defaultKeySerializer = function (x) {
            return x.toString();
        }, defaultError = Rx.helpers.defaultError = function (err) {
            throw err;
        }, isPromise = Rx.helpers.isPromise = function (p) {
            return !!p && typeof p.subscribe !== 'function' && typeof p.then === 'function';
        }, isFunction = Rx.helpers.isFunction = function () {
            var isFn = function (value) {
                return typeof value == 'function' || false;
            };
            if (isFn(/x/)) {
                isFn = function (value) {
                    return typeof value == 'function' && toString.call(value) == '[object Function]';
                };
            }
            return isFn;
        }();
    function cloneArray(arr) {
        var len = arr.length, a = new Array(len);
        for (var i = 0; i < len; i++) {
            a[i] = arr[i];
        }
        return a;
    }
    var errorObj = { e: {} };
    function tryCatcherGen(tryCatchTarget) {
        return function tryCatcher() {
            try {
                return tryCatchTarget.apply(this, arguments);
            } catch (e) {
                errorObj.e = e;
                return errorObj;
            }
        };
    }
    var tryCatch = Rx.internals.tryCatch = function tryCatch(fn) {
        if (!isFunction(fn)) {
            throw new TypeError('fn must be a function');
        }
        return tryCatcherGen(fn);
    };
    function thrower(e) {
        throw e;
    }
    Rx.config.longStackSupport = false;
    var hasStacks = false, stacks = tryCatch(function () {
            throw new Error();
        })();
    hasStacks = !!stacks.e && !!stacks.e.stack;
    var rStartingLine = captureLine(), rFileName;
    var STACK_JUMP_SEPARATOR = 'From previous event:';
    function makeStackTraceLong(error, observable) {
        if (hasStacks && observable.stack && typeof error === 'object' && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
            var stacks = [];
            for (var o = observable; !!o; o = o.source) {
                if (o.stack) {
                    stacks.unshift(o.stack);
                }
            }
            stacks.unshift(error.stack);
            var concatedStacks = stacks.join('\n' + STACK_JUMP_SEPARATOR + '\n');
            error.stack = filterStackString(concatedStacks);
        }
    }
    function filterStackString(stackString) {
        var lines = stackString.split('\n'), desiredLines = [];
        for (var i = 0, len = lines.length; i < len; i++) {
            var line = lines[i];
            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
                desiredLines.push(line);
            }
        }
        return desiredLines.join('\n');
    }
    function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) {
            return false;
        }
        var fileName = fileNameAndLineNumber[0], lineNumber = fileNameAndLineNumber[1];
        return fileName === rFileName && lineNumber >= rStartingLine && lineNumber <= rEndingLine;
    }
    function isNodeFrame(stackLine) {
        return stackLine.indexOf('(module.js:') !== -1 || stackLine.indexOf('(node.js:') !== -1;
    }
    function captureLine() {
        if (!hasStacks) {
            return;
        }
        try {
            throw new Error();
        } catch (e) {
            var lines = e.stack.split('\n');
            var firstLine = lines[0].indexOf('@') > 0 ? lines[1] : lines[2];
            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
            if (!fileNameAndLineNumber) {
                return;
            }
            rFileName = fileNameAndLineNumber[0];
            return fileNameAndLineNumber[1];
        }
    }
    function getFileNameAndLineNumber(stackLine) {
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
            return [
                attempt1[1],
                Number(attempt1[2])
            ];
        }
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
            return [
                attempt2[1],
                Number(attempt2[2])
            ];
        }
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
            return [
                attempt3[1],
                Number(attempt3[2])
            ];
        }
    }
    var EmptyError = Rx.EmptyError = function () {
        this.message = 'Sequence contains no elements.';
        this.name = 'EmptyError';
        Error.call(this);
    };
    EmptyError.prototype = Object.create(Error.prototype);
    var ObjectDisposedError = Rx.ObjectDisposedError = function () {
        this.message = 'Object has been disposed';
        this.name = 'ObjectDisposedError';
        Error.call(this);
    };
    ObjectDisposedError.prototype = Object.create(Error.prototype);
    var ArgumentOutOfRangeError = Rx.ArgumentOutOfRangeError = function () {
        this.message = 'Argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        Error.call(this);
    };
    ArgumentOutOfRangeError.prototype = Object.create(Error.prototype);
    var NotSupportedError = Rx.NotSupportedError = function (message) {
        this.message = message || 'This operation is not supported';
        this.name = 'NotSupportedError';
        Error.call(this);
    };
    NotSupportedError.prototype = Object.create(Error.prototype);
    var NotImplementedError = Rx.NotImplementedError = function (message) {
        this.message = message || 'This operation is not implemented';
        this.name = 'NotImplementedError';
        Error.call(this);
    };
    NotImplementedError.prototype = Object.create(Error.prototype);
    var notImplemented = Rx.helpers.notImplemented = function () {
        throw new NotImplementedError();
    };
    var notSupported = Rx.helpers.notSupported = function () {
        throw new NotSupportedError();
    };
    var $iterator$ = typeof Symbol === 'function' && Symbol.iterator || '_es6shim_iterator_';
    if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
        $iterator$ = '@@iterator';
    }
    var doneEnumerator = Rx.doneEnumerator = {
        done: true,
        value: undefined
    };
    var isIterable = Rx.helpers.isIterable = function (o) {
        return o[$iterator$] !== undefined;
    };
    var isArrayLike = Rx.helpers.isArrayLike = function (o) {
        return o && o.length !== undefined;
    };
    Rx.helpers.iterator = $iterator$;
    var bindCallback = Rx.internals.bindCallback = function (func, thisArg, argCount) {
        if (typeof thisArg === 'undefined') {
            return func;
        }
        switch (argCount) {
        case 0:
            return function () {
                return func.call(thisArg);
            };
        case 1:
            return function (arg) {
                return func.call(thisArg, arg);
            };
        case 2:
            return function (value, index) {
                return func.call(thisArg, value, index);
            };
        case 3:
            return function (value, index, collection) {
                return func.call(thisArg, value, index, collection);
            };
        }
        return function () {
            return func.apply(thisArg, arguments);
        };
    };
    var dontEnums = [
            'toString',
            'toLocaleString',
            'valueOf',
            'hasOwnProperty',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'constructor'
        ], dontEnumsLength = dontEnums.length;
    var argsClass = '[object Arguments]', arrayClass = '[object Array]', boolClass = '[object Boolean]', dateClass = '[object Date]', errorClass = '[object Error]', funcClass = '[object Function]', numberClass = '[object Number]', objectClass = '[object Object]', regexpClass = '[object RegExp]', stringClass = '[object String]';
    var toString = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, supportsArgsClass = toString.call(arguments) == argsClass, supportNodeClass, errorProto = Error.prototype, objectProto = Object.prototype, stringProto = String.prototype, propertyIsEnumerable = objectProto.propertyIsEnumerable;
    try {
        supportNodeClass = !(toString.call(document) == objectClass && !({ 'toString': 0 } + ''));
    } catch (e) {
        supportNodeClass = true;
    }
    var nonEnumProps = {};
    nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
        'constructor': true,
        'toLocaleString': true,
        'toString': true,
        'valueOf': true
    };
    nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
        'constructor': true,
        'toString': true,
        'valueOf': true
    };
    nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
        'constructor': true,
        'toString': true
    };
    nonEnumProps[objectClass] = { 'constructor': true };
    var support = {};
    (function () {
        var ctor = function () {
                this.x = 1;
            }, props = [];
        ctor.prototype = {
            'valueOf': 1,
            'y': 1
        };
        for (var key in new ctor()) {
            props.push(key);
        }
        for (key in arguments) {
        }
        support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') || propertyIsEnumerable.call(errorProto, 'name');
        support.enumPrototypes = propertyIsEnumerable.call(ctor, 'prototype');
        support.nonEnumArgs = key != 0;
        support.nonEnumShadows = !/valueOf/.test(props);
    }(1));
    var isObject = Rx.internals.isObject = function (value) {
        var type = typeof value;
        return value && (type == 'function' || type == 'object') || false;
    };
    function keysIn(object) {
        var result = [];
        if (!isObject(object)) {
            return result;
        }
        if (support.nonEnumArgs && object.length && isArguments(object)) {
            object = slice.call(object);
        }
        var skipProto = support.enumPrototypes && typeof object == 'function', skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error);
        for (var key in object) {
            if (!(skipProto && key == 'prototype') && !(skipErrorProps && (key == 'message' || key == 'name'))) {
                result.push(key);
            }
        }
        if (support.nonEnumShadows && object !== objectProto) {
            var ctor = object.constructor, index = -1, length = dontEnumsLength;
            if (object === (ctor && ctor.prototype)) {
                var className = object === stringProto ? stringClass : object === errorProto ? errorClass : toString.call(object), nonEnum = nonEnumProps[className];
            }
            while (++index < length) {
                key = dontEnums[index];
                if (!(nonEnum && nonEnum[key]) && hasOwnProperty.call(object, key)) {
                    result.push(key);
                }
            }
        }
        return result;
    }
    function internalFor(object, callback, keysFunc) {
        var index = -1, props = keysFunc(object), length = props.length;
        while (++index < length) {
            var key = props[index];
            if (callback(object[key], key, object) === false) {
                break;
            }
        }
        return object;
    }
    function internalForIn(object, callback) {
        return internalFor(object, callback, keysIn);
    }
    function isNode(value) {
        return typeof value.toString != 'function' && typeof (value + '') == 'string';
    }
    var isArguments = function (value) {
        return value && typeof value == 'object' ? toString.call(value) == argsClass : false;
    };
    if (!supportsArgsClass) {
        isArguments = function (value) {
            return value && typeof value == 'object' ? hasOwnProperty.call(value, 'callee') : false;
        };
    }
    var isEqual = Rx.internals.isEqual = function (x, y) {
        return deepEquals(x, y, [], []);
    };
    function deepEquals(a, b, stackA, stackB) {
        if (a === b) {
            return a !== 0 || 1 / a == 1 / b;
        }
        var type = typeof a, otherType = typeof b;
        if (a === a && (a == null || b == null || type != 'function' && type != 'object' && otherType != 'function' && otherType != 'object')) {
            return false;
        }
        var className = toString.call(a), otherClass = toString.call(b);
        if (className == argsClass) {
            className = objectClass;
        }
        if (otherClass == argsClass) {
            otherClass = objectClass;
        }
        if (className != otherClass) {
            return false;
        }
        switch (className) {
        case boolClass:
        case dateClass:
            return +a == +b;
        case numberClass:
            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
        case regexpClass:
        case stringClass:
            return a == String(b);
        }
        var isArr = className == arrayClass;
        if (!isArr) {
            if (className != objectClass || !support.nodeClass && (isNode(a) || isNode(b))) {
                return false;
            }
            var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor, ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
            if (ctorA != ctorB && !(hasOwnProperty.call(a, 'constructor') && hasOwnProperty.call(b, 'constructor')) && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ('constructor' in a && 'constructor' in b)) {
                return false;
            }
        }
        var initedStack = !stackA;
        stackA || (stackA = []);
        stackB || (stackB = []);
        var length = stackA.length;
        while (length--) {
            if (stackA[length] == a) {
                return stackB[length] == b;
            }
        }
        var size = 0;
        var result = true;
        stackA.push(a);
        stackB.push(b);
        if (isArr) {
            length = a.length;
            size = b.length;
            result = size == length;
            if (result) {
                while (size--) {
                    var index = length, value = b[size];
                    if (!(result = deepEquals(a[size], value, stackA, stackB))) {
                        break;
                    }
                }
            }
        } else {
            internalForIn(b, function (value, key, b) {
                if (hasOwnProperty.call(b, key)) {
                    size++;
                    return result = hasOwnProperty.call(a, key) && deepEquals(a[key], value, stackA, stackB);
                }
            });
            if (result) {
                internalForIn(a, function (value, key, a) {
                    if (hasOwnProperty.call(a, key)) {
                        return result = --size > -1;
                    }
                });
            }
        }
        stackA.pop();
        stackB.pop();
        return result;
    }
    var hasProp = {}.hasOwnProperty, slice = Array.prototype.slice;
    var inherits = Rx.internals.inherits = function (child, parent) {
        function __() {
            this.constructor = child;
        }
        __.prototype = parent.prototype;
        child.prototype = new __();
    };
    var addProperties = Rx.internals.addProperties = function (obj) {
        for (var sources = [], i = 1, len = arguments.length; i < len; i++) {
            sources.push(arguments[i]);
        }
        for (var idx = 0, ln = sources.length; idx < ln; idx++) {
            var source = sources[idx];
            for (var prop in source) {
                obj[prop] = source[prop];
            }
        }
    };
    var addRef = Rx.internals.addRef = function (xs, r) {
        return new AnonymousObservable(function (observer) {
            return new CompositeDisposable(r.getDisposable(), xs.subscribe(observer));
        });
    };
    function arrayInitialize(count, factory) {
        var a = new Array(count);
        for (var i = 0; i < count; i++) {
            a[i] = factory();
        }
        return a;
    }
    var CompositeDisposable = Rx.CompositeDisposable = function () {
        var args = [], i, len;
        if (Array.isArray(arguments[0])) {
            args = arguments[0];
            len = args.length;
        } else {
            len = arguments.length;
            args = new Array(len);
            for (i = 0; i < len; i++) {
                args[i] = arguments[i];
            }
        }
        for (i = 0; i < len; i++) {
            if (!isDisposable(args[i])) {
                throw new TypeError('Not a disposable');
            }
        }
        this.disposables = args;
        this.isDisposed = false;
        this.length = args.length;
    };
    var CompositeDisposablePrototype = CompositeDisposable.prototype;
    CompositeDisposablePrototype.add = function (item) {
        if (this.isDisposed) {
            item.dispose();
        } else {
            this.disposables.push(item);
            this.length++;
        }
    };
    CompositeDisposablePrototype.remove = function (item) {
        var shouldDispose = false;
        if (!this.isDisposed) {
            var idx = this.disposables.indexOf(item);
            if (idx !== -1) {
                shouldDispose = true;
                this.disposables.splice(idx, 1);
                this.length--;
                item.dispose();
            }
        }
        return shouldDispose;
    };
    CompositeDisposablePrototype.dispose = function () {
        if (!this.isDisposed) {
            this.isDisposed = true;
            var len = this.disposables.length, currentDisposables = new Array(len);
            for (var i = 0; i < len; i++) {
                currentDisposables[i] = this.disposables[i];
            }
            this.disposables = [];
            this.length = 0;
            for (i = 0; i < len; i++) {
                currentDisposables[i].dispose();
            }
        }
    };
    var Disposable = Rx.Disposable = function (action) {
        this.isDisposed = false;
        this.action = action || noop;
    };
    Disposable.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.action();
            this.isDisposed = true;
        }
    };
    var disposableCreate = Disposable.create = function (action) {
        return new Disposable(action);
    };
    var disposableEmpty = Disposable.empty = { dispose: noop };
    var isDisposable = Disposable.isDisposable = function (d) {
        return d && isFunction(d.dispose);
    };
    var checkDisposed = Disposable.checkDisposed = function (disposable) {
        if (disposable.isDisposed) {
            throw new ObjectDisposedError();
        }
    };
    var SingleAssignmentDisposable = Rx.SingleAssignmentDisposable = function () {
        this.isDisposed = false;
        this.current = null;
    };
    SingleAssignmentDisposable.prototype.getDisposable = function () {
        return this.current;
    };
    SingleAssignmentDisposable.prototype.setDisposable = function (value) {
        if (this.current) {
            throw new Error('Disposable has already been assigned');
        }
        var shouldDispose = this.isDisposed;
        !shouldDispose && (this.current = value);
        shouldDispose && value && value.dispose();
    };
    SingleAssignmentDisposable.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.isDisposed = true;
            var old = this.current;
            this.current = null;
        }
        old && old.dispose();
    };
    var SerialDisposable = Rx.SerialDisposable = function () {
        this.isDisposed = false;
        this.current = null;
    };
    SerialDisposable.prototype.getDisposable = function () {
        return this.current;
    };
    SerialDisposable.prototype.setDisposable = function (value) {
        var shouldDispose = this.isDisposed;
        if (!shouldDispose) {
            var old = this.current;
            this.current = value;
        }
        old && old.dispose();
        shouldDispose && value && value.dispose();
    };
    SerialDisposable.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.isDisposed = true;
            var old = this.current;
            this.current = null;
        }
        old && old.dispose();
    };
    var RefCountDisposable = Rx.RefCountDisposable = function () {
        function InnerDisposable(disposable) {
            this.disposable = disposable;
            this.disposable.count++;
            this.isInnerDisposed = false;
        }
        InnerDisposable.prototype.dispose = function () {
            if (!this.disposable.isDisposed && !this.isInnerDisposed) {
                this.isInnerDisposed = true;
                this.disposable.count--;
                if (this.disposable.count === 0 && this.disposable.isPrimaryDisposed) {
                    this.disposable.isDisposed = true;
                    this.disposable.underlyingDisposable.dispose();
                }
            }
        };
        function RefCountDisposable(disposable) {
            this.underlyingDisposable = disposable;
            this.isDisposed = false;
            this.isPrimaryDisposed = false;
            this.count = 0;
        }
        RefCountDisposable.prototype.dispose = function () {
            if (!this.isDisposed && !this.isPrimaryDisposed) {
                this.isPrimaryDisposed = true;
                if (this.count === 0) {
                    this.isDisposed = true;
                    this.underlyingDisposable.dispose();
                }
            }
        };
        RefCountDisposable.prototype.getDisposable = function () {
            return this.isDisposed ? disposableEmpty : new InnerDisposable(this);
        };
        return RefCountDisposable;
    }();
    var ScheduledItem = Rx.internals.ScheduledItem = function (scheduler, state, action, dueTime, comparer) {
        this.scheduler = scheduler;
        this.state = state;
        this.action = action;
        this.dueTime = dueTime;
        this.comparer = comparer || defaultSubComparer;
        this.disposable = new SingleAssignmentDisposable();
    };
    ScheduledItem.prototype.invoke = function () {
        this.disposable.setDisposable(this.invokeCore());
    };
    ScheduledItem.prototype.compareTo = function (other) {
        return this.comparer(this.dueTime, other.dueTime);
    };
    ScheduledItem.prototype.isCancelled = function () {
        return this.disposable.isDisposed;
    };
    ScheduledItem.prototype.invokeCore = function () {
        return this.action(this.scheduler, this.state);
    };
    var Scheduler = Rx.Scheduler = function () {
        function Scheduler(now, schedule, scheduleRelative, scheduleAbsolute) {
            this.now = now;
            this._schedule = schedule;
            this._scheduleRelative = scheduleRelative;
            this._scheduleAbsolute = scheduleAbsolute;
        }
        Scheduler.isScheduler = function (s) {
            return s instanceof Scheduler;
        };
        function invokeAction(scheduler, action) {
            action();
            return disposableEmpty;
        }
        var schedulerProto = Scheduler.prototype;
        schedulerProto.schedule = function (action) {
            return this._schedule(action, invokeAction);
        };
        schedulerProto.scheduleWithState = function (state, action) {
            return this._schedule(state, action);
        };
        schedulerProto.scheduleWithRelative = function (dueTime, action) {
            return this._scheduleRelative(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithRelativeAndState = function (state, dueTime, action) {
            return this._scheduleRelative(state, dueTime, action);
        };
        schedulerProto.scheduleWithAbsolute = function (dueTime, action) {
            return this._scheduleAbsolute(action, dueTime, invokeAction);
        };
        schedulerProto.scheduleWithAbsoluteAndState = function (state, dueTime, action) {
            return this._scheduleAbsolute(state, dueTime, action);
        };
        Scheduler.now = defaultNow;
        Scheduler.normalize = function (timeSpan) {
            timeSpan < 0 && (timeSpan = 0);
            return timeSpan;
        };
        return Scheduler;
    }();
    var normalizeTime = Scheduler.normalize, isScheduler = Scheduler.isScheduler;
    (function (schedulerProto) {
        function invokeRecImmediate(scheduler, pair) {
            var state = pair[0], action = pair[1], group = new CompositeDisposable();
            action(state, innerAction);
            return group;
            function innerAction(state2) {
                var isAdded = false, isDone = false;
                var d = scheduler.scheduleWithState(state2, scheduleWork);
                if (!isDone) {
                    group.add(d);
                    isAdded = true;
                }
                function scheduleWork(_, state3) {
                    if (isAdded) {
                        group.remove(d);
                    } else {
                        isDone = true;
                    }
                    action(state3, innerAction);
                    return disposableEmpty;
                }
            }
        }
        function invokeRecDate(scheduler, pair, method) {
            var state = pair[0], action = pair[1], group = new CompositeDisposable();
            action(state, innerAction);
            return group;
            function innerAction(state2, dueTime1) {
                var isAdded = false, isDone = false;
                var d = scheduler[method](state2, dueTime1, scheduleWork);
                if (!isDone) {
                    group.add(d);
                    isAdded = true;
                }
                function scheduleWork(_, state3) {
                    if (isAdded) {
                        group.remove(d);
                    } else {
                        isDone = true;
                    }
                    action(state3, innerAction);
                    return disposableEmpty;
                }
            }
        }
        function invokeRecDateRelative(s, p) {
            return invokeRecDate(s, p, 'scheduleWithRelativeAndState');
        }
        function invokeRecDateAbsolute(s, p) {
            return invokeRecDate(s, p, 'scheduleWithAbsoluteAndState');
        }
        function scheduleInnerRecursive(action, self) {
            action(function (dt) {
                self(action, dt);
            });
        }
        schedulerProto.scheduleRecursive = function (action) {
            return this.scheduleRecursiveWithState(action, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithState = function (state, action) {
            return this.scheduleWithState([
                state,
                action
            ], invokeRecImmediate);
        };
        schedulerProto.scheduleRecursiveWithRelative = function (dueTime, action) {
            return this.scheduleRecursiveWithRelativeAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithRelativeAndState = function (state, dueTime, action) {
            return this._scheduleRelative([
                state,
                action
            ], dueTime, invokeRecDateRelative);
        };
        schedulerProto.scheduleRecursiveWithAbsolute = function (dueTime, action) {
            return this.scheduleRecursiveWithAbsoluteAndState(action, dueTime, scheduleInnerRecursive);
        };
        schedulerProto.scheduleRecursiveWithAbsoluteAndState = function (state, dueTime, action) {
            return this._scheduleAbsolute([
                state,
                action
            ], dueTime, invokeRecDateAbsolute);
        };
    }(Scheduler.prototype));
    (function (schedulerProto) {
        Scheduler.prototype.schedulePeriodic = function (period, action) {
            return this.schedulePeriodicWithState(null, period, action);
        };
        Scheduler.prototype.schedulePeriodicWithState = function (state, period, action) {
            if (typeof root.setInterval === 'undefined') {
                throw new NotSupportedError();
            }
            period = normalizeTime(period);
            var s = state, id = root.setInterval(function () {
                    s = action(s);
                }, period);
            return disposableCreate(function () {
                root.clearInterval(id);
            });
        };
    }(Scheduler.prototype));
    var immediateScheduler = Scheduler.immediate = function () {
        function scheduleNow(state, action) {
            return action(this, state);
        }
        return new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
    }();
    var currentThreadScheduler = Scheduler.currentThread = function () {
        var queue;
        function runTrampoline() {
            while (queue.length > 0) {
                var item = queue.shift();
                !item.isCancelled() && item.invoke();
            }
        }
        function scheduleNow(state, action) {
            var si = new ScheduledItem(this, state, action, this.now());
            if (!queue) {
                queue = [si];
                var result = tryCatch(runTrampoline)();
                queue = null;
                if (result === errorObj) {
                    return thrower(result.e);
                }
            } else {
                queue.push(si);
            }
            return si.disposable;
        }
        var currentScheduler = new Scheduler(defaultNow, scheduleNow, notSupported, notSupported);
        currentScheduler.scheduleRequired = function () {
            return !queue;
        };
        return currentScheduler;
    }();
    var SchedulePeriodicRecursive = Rx.internals.SchedulePeriodicRecursive = function () {
        function tick(command, recurse) {
            recurse(0, this._period);
            try {
                this._state = this._action(this._state);
            } catch (e) {
                this._cancel.dispose();
                throw e;
            }
        }
        function SchedulePeriodicRecursive(scheduler, state, period, action) {
            this._scheduler = scheduler;
            this._state = state;
            this._period = period;
            this._action = action;
        }
        SchedulePeriodicRecursive.prototype.start = function () {
            var d = new SingleAssignmentDisposable();
            this._cancel = d;
            d.setDisposable(this._scheduler.scheduleRecursiveWithRelativeAndState(0, this._period, tick.bind(this)));
            return d;
        };
        return SchedulePeriodicRecursive;
    }();
    var scheduleMethod, clearMethod;
    var localTimer = function () {
        var localSetTimeout, localClearTimeout = noop;
        if (!!root.setTimeout) {
            localSetTimeout = root.setTimeout;
            localClearTimeout = root.clearTimeout;
        } else if (!!root.WScript) {
            localSetTimeout = function (fn, time) {
                root.WScript.Sleep(time);
                fn();
            };
        } else {
            throw new NotSupportedError();
        }
        return {
            setTimeout: localSetTimeout,
            clearTimeout: localClearTimeout
        };
    }();
    var localSetTimeout = localTimer.setTimeout, localClearTimeout = localTimer.clearTimeout;
    (function () {
        var nextHandle = 1, tasksByHandle = {}, currentlyRunning = false;
        clearMethod = function (handle) {
            delete tasksByHandle[handle];
        };
        function runTask(handle) {
            if (currentlyRunning) {
                localSetTimeout(function () {
                    runTask(handle);
                }, 0);
            } else {
                var task = tasksByHandle[handle];
                if (task) {
                    currentlyRunning = true;
                    var result = tryCatch(task)();
                    clearMethod(handle);
                    currentlyRunning = false;
                    if (result === errorObj) {
                        return thrower(result.e);
                    }
                }
            }
        }
        var reNative = RegExp('^' + String(toString).replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/toString| for [^\]]+/g, '.*?') + '$');
        var setImmediate = typeof (setImmediate = freeGlobal && moduleExports && freeGlobal.setImmediate) == 'function' && !reNative.test(setImmediate) && setImmediate;
        function postMessageSupported() {
            if (!root.postMessage || root.importScripts) {
                return false;
            }
            var isAsync = false, oldHandler = root.onmessage;
            root.onmessage = function () {
                isAsync = true;
            };
            root.postMessage('', '*');
            root.onmessage = oldHandler;
            return isAsync;
        }
        if (isFunction(setImmediate)) {
            scheduleMethod = function (action) {
                var id = nextHandle++;
                tasksByHandle[id] = action;
                setImmediate(function () {
                    runTask(id);
                });
                return id;
            };
        } else if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
            scheduleMethod = function (action) {
                var id = nextHandle++;
                tasksByHandle[id] = action;
                process.nextTick(function () {
                    runTask(id);
                });
                return id;
            };
        } else if (postMessageSupported()) {
            var MSG_PREFIX = 'ms.rx.schedule' + Math.random();
            function onGlobalPostMessage(event) {
                if (typeof event.data === 'string' && event.data.substring(0, MSG_PREFIX.length) === MSG_PREFIX) {
                    runTask(event.data.substring(MSG_PREFIX.length));
                }
            }
            if (root.addEventListener) {
                root.addEventListener('message', onGlobalPostMessage, false);
            } else if (root.attachEvent) {
                root.attachEvent('onmessage', onGlobalPostMessage);
            } else {
                root.onmessage = onGlobalPostMessage;
            }
            scheduleMethod = function (action) {
                var id = nextHandle++;
                tasksByHandle[id] = action;
                root.postMessage(MSG_PREFIX + currentId, '*');
                return id;
            };
        } else if (!!root.MessageChannel) {
            var channel = new root.MessageChannel();
            channel.port1.onmessage = function (e) {
                runTask(e.data);
            };
            scheduleMethod = function (action) {
                var id = nextHandle++;
                tasksByHandle[id] = action;
                channel.port2.postMessage(id);
                return id;
            };
        } else if ('document' in root && 'onreadystatechange' in root.document.createElement('script')) {
            scheduleMethod = function (action) {
                var scriptElement = root.document.createElement('script');
                var id = nextHandle++;
                tasksByHandle[id] = action;
                scriptElement.onreadystatechange = function () {
                    runTask(id);
                    scriptElement.onreadystatechange = null;
                    scriptElement.parentNode.removeChild(scriptElement);
                    scriptElement = null;
                };
                root.document.documentElement.appendChild(scriptElement);
                return id;
            };
        } else {
            scheduleMethod = function (action) {
                var id = nextHandle++;
                tasksByHandle[id] = action;
                localSetTimeout(function () {
                    runTask(id);
                }, 0);
                return id;
            };
        }
    }());
    var timeoutScheduler = Scheduler.timeout = Scheduler['default'] = function () {
        function scheduleNow(state, action) {
            var scheduler = this, disposable = new SingleAssignmentDisposable();
            var id = scheduleMethod(function () {
                !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
            });
            return new CompositeDisposable(disposable, disposableCreate(function () {
                clearMethod(id);
            }));
        }
        function scheduleRelative(state, dueTime, action) {
            var scheduler = this, dt = Scheduler.normalize(dueTime), disposable = new SingleAssignmentDisposable();
            if (dt === 0) {
                return scheduler.scheduleWithState(state, action);
            }
            var id = localSetTimeout(function () {
                !disposable.isDisposed && disposable.setDisposable(action(scheduler, state));
            }, dt);
            return new CompositeDisposable(disposable, disposableCreate(function () {
                localClearTimeout(id);
            }));
        }
        function scheduleAbsolute(state, dueTime, action) {
            return this.scheduleWithRelativeAndState(state, dueTime - this.now(), action);
        }
        return new Scheduler(defaultNow, scheduleNow, scheduleRelative, scheduleAbsolute);
    }();
    var Notification = Rx.Notification = function () {
        function Notification(kind, value, exception, accept, acceptObservable, toString) {
            this.kind = kind;
            this.value = value;
            this.exception = exception;
            this._accept = accept;
            this._acceptObservable = acceptObservable;
            this.toString = toString;
        }
        Notification.prototype.accept = function (observerOrOnNext, onError, onCompleted) {
            return observerOrOnNext && typeof observerOrOnNext === 'object' ? this._acceptObservable(observerOrOnNext) : this._accept(observerOrOnNext, onError, onCompleted);
        };
        Notification.prototype.toObservable = function (scheduler) {
            var self = this;
            isScheduler(scheduler) || (scheduler = immediateScheduler);
            return new AnonymousObservable(function (observer) {
                return scheduler.scheduleWithState(self, function (_, notification) {
                    notification._acceptObservable(observer);
                    notification.kind === 'N' && observer.onCompleted();
                });
            });
        };
        return Notification;
    }();
    var notificationCreateOnNext = Notification.createOnNext = function () {
        function _accept(onNext) {
            return onNext(this.value);
        }
        function _acceptObservable(observer) {
            return observer.onNext(this.value);
        }
        function toString() {
            return 'OnNext(' + this.value + ')';
        }
        return function (value) {
            return new Notification('N', value, null, _accept, _acceptObservable, toString);
        };
    }();
    var notificationCreateOnError = Notification.createOnError = function () {
        function _accept(onNext, onError) {
            return onError(this.exception);
        }
        function _acceptObservable(observer) {
            return observer.onError(this.exception);
        }
        function toString() {
            return 'OnError(' + this.exception + ')';
        }
        return function (e) {
            return new Notification('E', null, e, _accept, _acceptObservable, toString);
        };
    }();
    var notificationCreateOnCompleted = Notification.createOnCompleted = function () {
        function _accept(onNext, onError, onCompleted) {
            return onCompleted();
        }
        function _acceptObservable(observer) {
            return observer.onCompleted();
        }
        function toString() {
            return 'OnCompleted()';
        }
        return function () {
            return new Notification('C', null, null, _accept, _acceptObservable, toString);
        };
    }();
    var Observer = Rx.Observer = function () {
    };
    var observerCreate = Observer.create = function (onNext, onError, onCompleted) {
        onNext || (onNext = noop);
        onError || (onError = defaultError);
        onCompleted || (onCompleted = noop);
        return new AnonymousObserver(onNext, onError, onCompleted);
    };
    var AbstractObserver = Rx.internals.AbstractObserver = function (__super__) {
        inherits(AbstractObserver, __super__);
        function AbstractObserver() {
            this.isStopped = false;
        }
        AbstractObserver.prototype.next = notImplemented;
        AbstractObserver.prototype.error = notImplemented;
        AbstractObserver.prototype.completed = notImplemented;
        AbstractObserver.prototype.onNext = function (value) {
            !this.isStopped && this.next(value);
        };
        AbstractObserver.prototype.onError = function (error) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.error(error);
            }
        };
        AbstractObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this.completed();
            }
        };
        AbstractObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        AbstractObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.error(e);
                return true;
            }
            return false;
        };
        return AbstractObserver;
    }(Observer);
    var AnonymousObserver = Rx.AnonymousObserver = function (__super__) {
        inherits(AnonymousObserver, __super__);
        function AnonymousObserver(onNext, onError, onCompleted) {
            __super__.call(this);
            this._onNext = onNext;
            this._onError = onError;
            this._onCompleted = onCompleted;
        }
        AnonymousObserver.prototype.next = function (value) {
            this._onNext(value);
        };
        AnonymousObserver.prototype.error = function (error) {
            this._onError(error);
        };
        AnonymousObserver.prototype.completed = function () {
            this._onCompleted();
        };
        return AnonymousObserver;
    }(AbstractObserver);
    var observableProto;
    var Observable = Rx.Observable = function () {
        function makeSubscribe(self, subscribe) {
            return function (o) {
                var oldOnError = o.onError;
                o.onError = function (e) {
                    makeStackTraceLong(e, self);
                    oldOnError.call(o, e);
                };
                return subscribe.call(self, o);
            };
        }
        function Observable(subscribe) {
            if (Rx.config.longStackSupport && hasStacks) {
                var e = tryCatch(thrower)(new Error()).e;
                this.stack = e.stack.substring(e.stack.indexOf('\n') + 1);
                this._subscribe = makeSubscribe(this, subscribe);
            } else {
                this._subscribe = subscribe;
            }
        }
        observableProto = Observable.prototype;
        Observable.isObservable = function (o) {
            return o && isFunction(o.subscribe);
        };
        observableProto.subscribe = observableProto.forEach = function (oOrOnNext, onError, onCompleted) {
            return this._subscribe(typeof oOrOnNext === 'object' ? oOrOnNext : observerCreate(oOrOnNext, onError, onCompleted));
        };
        observableProto.subscribeOnNext = function (onNext, thisArg) {
            return this._subscribe(observerCreate(typeof thisArg !== 'undefined' ? function (x) {
                onNext.call(thisArg, x);
            } : onNext));
        };
        observableProto.subscribeOnError = function (onError, thisArg) {
            return this._subscribe(observerCreate(null, typeof thisArg !== 'undefined' ? function (e) {
                onError.call(thisArg, e);
            } : onError));
        };
        observableProto.subscribeOnCompleted = function (onCompleted, thisArg) {
            return this._subscribe(observerCreate(null, null, typeof thisArg !== 'undefined' ? function () {
                onCompleted.call(thisArg);
            } : onCompleted));
        };
        return Observable;
    }();
    var ScheduledObserver = Rx.internals.ScheduledObserver = function (__super__) {
        inherits(ScheduledObserver, __super__);
        function ScheduledObserver(scheduler, observer) {
            __super__.call(this);
            this.scheduler = scheduler;
            this.observer = observer;
            this.isAcquired = false;
            this.hasFaulted = false;
            this.queue = [];
            this.disposable = new SerialDisposable();
        }
        ScheduledObserver.prototype.next = function (value) {
            var self = this;
            this.queue.push(function () {
                self.observer.onNext(value);
            });
        };
        ScheduledObserver.prototype.error = function (e) {
            var self = this;
            this.queue.push(function () {
                self.observer.onError(e);
            });
        };
        ScheduledObserver.prototype.completed = function () {
            var self = this;
            this.queue.push(function () {
                self.observer.onCompleted();
            });
        };
        ScheduledObserver.prototype.ensureActive = function () {
            var isOwner = false;
            if (!this.hasFaulted && this.queue.length > 0) {
                isOwner = !this.isAcquired;
                this.isAcquired = true;
            }
            if (isOwner) {
                this.disposable.setDisposable(this.scheduler.scheduleRecursiveWithState(this, function (parent, self) {
                    var work;
                    if (parent.queue.length > 0) {
                        work = parent.queue.shift();
                    } else {
                        parent.isAcquired = false;
                        return;
                    }
                    var res = tryCatch(work)();
                    if (res === errorObj) {
                        parent.queue = [];
                        parent.hasFaulted = true;
                        return thrower(res.e);
                    }
                    self(parent);
                }));
            }
        };
        ScheduledObserver.prototype.dispose = function () {
            __super__.prototype.dispose.call(this);
            this.disposable.dispose();
        };
        return ScheduledObserver;
    }(AbstractObserver);
    var ObservableBase = Rx.ObservableBase = function (__super__) {
        inherits(ObservableBase, __super__);
        function fixSubscriber(subscriber) {
            return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
            var ado = state[0], self = state[1];
            var sub = tryCatch(self.subscribeCore).call(self, ado);
            if (sub === errorObj) {
                if (!ado.fail(errorObj.e)) {
                    return thrower(errorObj.e);
                }
            }
            ado.setDisposable(fixSubscriber(sub));
        }
        function subscribe(observer) {
            var ado = new AutoDetachObserver(observer), state = [
                    ado,
                    this
                ];
            if (currentThreadScheduler.scheduleRequired()) {
                currentThreadScheduler.scheduleWithState(state, setDisposable);
            } else {
                setDisposable(null, state);
            }
            return ado;
        }
        function ObservableBase() {
            __super__.call(this, subscribe);
        }
        ObservableBase.prototype.subscribeCore = notImplemented;
        return ObservableBase;
    }(Observable);
    var FlatMapObservable = function (__super__) {
        inherits(FlatMapObservable, __super__);
        function FlatMapObservable(source, selector, resultSelector, thisArg) {
            this.resultSelector = Rx.helpers.isFunction(resultSelector) ? resultSelector : null;
            this.selector = Rx.internals.bindCallback(Rx.helpers.isFunction(selector) ? selector : function () {
                return selector;
            }, thisArg, 3);
            this.source = source;
            __super__.call(this);
        }
        FlatMapObservable.prototype.subscribeCore = function (o) {
            return this.source.subscribe(new InnerObserver(o, this.selector, this.resultSelector, this));
        };
        function InnerObserver(observer, selector, resultSelector, source) {
            this.i = 0;
            this.selector = selector;
            this.resultSelector = resultSelector;
            this.source = source;
            this.isStopped = false;
            this.o = observer;
        }
        InnerObserver.prototype._wrapResult = function (result, x, i) {
            return this.resultSelector ? result.map(function (y, i2) {
                return this.resultSelector(x, y, i, i2);
            }, this) : result;
        };
        InnerObserver.prototype.onNext = function (x) {
            if (this.isStopped)
                return;
            var i = this.i++;
            var result = tryCatch(this.selector)(x, i, this.source);
            if (result === errorObj) {
                return this.o.onError(result.e);
            }
            Rx.helpers.isPromise(result) && (result = Rx.Observable.fromPromise(result));
            (Rx.helpers.isArrayLike(result) || Rx.helpers.isIterable(result)) && (result = Rx.Observable.from(result));
            this.o.onNext(this._wrapResult(result, x, i));
        };
        InnerObserver.prototype.onError = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onCompleted();
            }
        };
        return FlatMapObservable;
    }(ObservableBase);
    var Enumerable = Rx.internals.Enumerable = function () {
    };
    var ConcatEnumerableObservable = function (__super__) {
        inherits(ConcatEnumerableObservable, __super__);
        function ConcatEnumerableObservable(sources) {
            this.sources = sources;
            __super__.call(this);
        }
        ConcatEnumerableObservable.prototype.subscribeCore = function (o) {
            var isDisposed, subscription = new SerialDisposable();
            var cancelable = immediateScheduler.scheduleRecursiveWithState(this.sources[$iterator$](), function (e, self) {
                if (isDisposed) {
                    return;
                }
                var currentItem = tryCatch(e.next).call(e);
                if (currentItem === errorObj) {
                    return o.onError(currentItem.e);
                }
                if (currentItem.done) {
                    return o.onCompleted();
                }
                var currentValue = currentItem.value;
                isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
                var d = new SingleAssignmentDisposable();
                subscription.setDisposable(d);
                d.setDisposable(currentValue.subscribe(new InnerObserver(o, self, e)));
            });
            return new CompositeDisposable(subscription, cancelable, disposableCreate(function () {
                isDisposed = true;
            }));
        };
        function InnerObserver(o, s, e) {
            this.o = o;
            this.s = s;
            this.e = e;
            this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function (x) {
            if (!this.isStopped) {
                this.o.onNext(x);
            }
        };
        InnerObserver.prototype.onError = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(err);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this.s(this.e);
            }
        };
        InnerObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        InnerObserver.prototype.fail = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(err);
                return true;
            }
            return false;
        };
        return ConcatEnumerableObservable;
    }(ObservableBase);
    Enumerable.prototype.concat = function () {
        return new ConcatEnumerableObservable(this);
    };
    var CatchErrorObservable = function (__super__) {
        inherits(CatchErrorObservable, __super__);
        function CatchErrorObservable(sources) {
            this.sources = sources;
            __super__.call(this);
        }
        CatchErrorObservable.prototype.subscribeCore = function (o) {
            var e = this.sources[$iterator$]();
            var isDisposed, subscription = new SerialDisposable();
            var cancelable = immediateScheduler.scheduleRecursiveWithState(null, function (lastException, self) {
                if (isDisposed) {
                    return;
                }
                var currentItem = tryCatch(e.next).call(e);
                if (currentItem === errorObj) {
                    return o.onError(currentItem.e);
                }
                if (currentItem.done) {
                    return lastException !== null ? o.onError(lastException) : o.onCompleted();
                }
                var currentValue = currentItem.value;
                isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
                var d = new SingleAssignmentDisposable();
                subscription.setDisposable(d);
                d.setDisposable(currentValue.subscribe(function (x) {
                    o.onNext(x);
                }, self, function () {
                    o.onCompleted();
                }));
            });
            return new CompositeDisposable(subscription, cancelable, disposableCreate(function () {
                isDisposed = true;
            }));
        };
        return CatchErrorObservable;
    }(ObservableBase);
    Enumerable.prototype.catchError = function () {
        return new CatchErrorObservable(this);
    };
    Enumerable.prototype.catchErrorWhen = function (notificationHandler) {
        var sources = this;
        return new AnonymousObservable(function (o) {
            var exceptions = new Subject(), notifier = new Subject(), handled = notificationHandler(exceptions), notificationDisposable = handled.subscribe(notifier);
            var e = sources[$iterator$]();
            var isDisposed, lastException, subscription = new SerialDisposable();
            var cancelable = immediateScheduler.scheduleRecursive(function (self) {
                if (isDisposed) {
                    return;
                }
                var currentItem = tryCatch(e.next).call(e);
                if (currentItem === errorObj) {
                    return o.onError(currentItem.e);
                }
                if (currentItem.done) {
                    if (lastException) {
                        o.onError(lastException);
                    } else {
                        o.onCompleted();
                    }
                    return;
                }
                var currentValue = currentItem.value;
                isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
                var outer = new SingleAssignmentDisposable();
                var inner = new SingleAssignmentDisposable();
                subscription.setDisposable(new CompositeDisposable(inner, outer));
                outer.setDisposable(currentValue.subscribe(function (x) {
                    o.onNext(x);
                }, function (exn) {
                    inner.setDisposable(notifier.subscribe(self, function (ex) {
                        o.onError(ex);
                    }, function () {
                        o.onCompleted();
                    }));
                    exceptions.onNext(exn);
                }, function () {
                    o.onCompleted();
                }));
            });
            return new CompositeDisposable(notificationDisposable, subscription, cancelable, disposableCreate(function () {
                isDisposed = true;
            }));
        });
    };
    var RepeatEnumerable = function (__super__) {
        inherits(RepeatEnumerable, __super__);
        function RepeatEnumerable(v, c) {
            this.v = v;
            this.c = c == null ? -1 : c;
        }
        RepeatEnumerable.prototype[$iterator$] = function () {
            return new RepeatEnumerator(this);
        };
        function RepeatEnumerator(p) {
            this.v = p.v;
            this.l = p.c;
        }
        RepeatEnumerator.prototype.next = function () {
            if (this.l === 0) {
                return doneEnumerator;
            }
            if (this.l > 0) {
                this.l--;
            }
            return {
                done: false,
                value: this.v
            };
        };
        return RepeatEnumerable;
    }(Enumerable);
    var enumerableRepeat = Enumerable.repeat = function (value, repeatCount) {
        return new RepeatEnumerable(value, repeatCount);
    };
    var OfEnumerable = function (__super__) {
        inherits(OfEnumerable, __super__);
        function OfEnumerable(s, fn, thisArg) {
            this.s = s;
            this.fn = fn ? bindCallback(fn, thisArg, 3) : null;
        }
        OfEnumerable.prototype[$iterator$] = function () {
            return new OfEnumerator(this);
        };
        function OfEnumerator(p) {
            this.i = -1;
            this.s = p.s;
            this.l = this.s.length;
            this.fn = p.fn;
        }
        OfEnumerator.prototype.next = function () {
            return ++this.i < this.l ? {
                done: false,
                value: !this.fn ? this.s[this.i] : this.fn(this.s[this.i], this.i, this.s)
            } : doneEnumerator;
        };
        return OfEnumerable;
    }(Enumerable);
    var enumerableOf = Enumerable.of = function (source, selector, thisArg) {
        return new OfEnumerable(source, selector, thisArg);
    };
    var ToArrayObservable = function (__super__) {
        inherits(ToArrayObservable, __super__);
        function ToArrayObservable(source) {
            this.source = source;
            __super__.call(this);
        }
        ToArrayObservable.prototype.subscribeCore = function (o) {
            return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
            this.o = o;
            this.a = [];
            this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function (x) {
            if (!this.isStopped) {
                this.a.push(x);
            }
        };
        InnerObserver.prototype.onError = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onNext(this.a);
                this.o.onCompleted();
            }
        };
        InnerObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        InnerObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
                return true;
            }
            return false;
        };
        return ToArrayObservable;
    }(ObservableBase);
    observableProto.toArray = function () {
        return new ToArrayObservable(this);
    };
    Observable.create = function (subscribe, parent) {
        return new AnonymousObservable(subscribe, parent);
    };
    var observableDefer = Observable.defer = function (observableFactory) {
        return new AnonymousObservable(function (observer) {
            var result;
            try {
                result = observableFactory();
            } catch (e) {
                return observableThrow(e).subscribe(observer);
            }
            isPromise(result) && (result = observableFromPromise(result));
            return result.subscribe(observer);
        });
    };
    var EmptyObservable = function (__super__) {
        inherits(EmptyObservable, __super__);
        function EmptyObservable(scheduler) {
            this.scheduler = scheduler;
            __super__.call(this);
        }
        EmptyObservable.prototype.subscribeCore = function (observer) {
            var sink = new EmptySink(observer, this.scheduler);
            return sink.run();
        };
        function EmptySink(observer, scheduler) {
            this.observer = observer;
            this.scheduler = scheduler;
        }
        function scheduleItem(s, state) {
            state.onCompleted();
            return disposableEmpty;
        }
        EmptySink.prototype.run = function () {
            return this.scheduler.scheduleWithState(this.observer, scheduleItem);
        };
        return EmptyObservable;
    }(ObservableBase);
    var EMPTY_OBSERVABLE = new EmptyObservable(immediateScheduler);
    var observableEmpty = Observable.empty = function (scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return scheduler === immediateScheduler ? EMPTY_OBSERVABLE : new EmptyObservable(scheduler);
    };
    var FromObservable = function (__super__) {
        inherits(FromObservable, __super__);
        function FromObservable(iterable, mapper, scheduler) {
            this.iterable = iterable;
            this.mapper = mapper;
            this.scheduler = scheduler;
            __super__.call(this);
        }
        FromObservable.prototype.subscribeCore = function (o) {
            var sink = new FromSink(o, this);
            return sink.run();
        };
        return FromObservable;
    }(ObservableBase);
    var FromSink = function () {
        function FromSink(o, parent) {
            this.o = o;
            this.parent = parent;
        }
        FromSink.prototype.run = function () {
            var list = Object(this.parent.iterable), it = getIterable(list), o = this.o, mapper = this.parent.mapper;
            function loopRecursive(i, recurse) {
                var next = tryCatch(it.next).call(it);
                if (next === errorObj) {
                    return o.onError(next.e);
                }
                if (next.done) {
                    return o.onCompleted();
                }
                var result = next.value;
                if (isFunction(mapper)) {
                    result = tryCatch(mapper)(result, i);
                    if (result === errorObj) {
                        return o.onError(result.e);
                    }
                }
                o.onNext(result);
                recurse(i + 1);
            }
            return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return FromSink;
    }();
    var maxSafeInteger = Math.pow(2, 53) - 1;
    function StringIterable(s) {
        this._s = s;
    }
    StringIterable.prototype[$iterator$] = function () {
        return new StringIterator(this._s);
    };
    function StringIterator(s) {
        this._s = s;
        this._l = s.length;
        this._i = 0;
    }
    StringIterator.prototype[$iterator$] = function () {
        return this;
    };
    StringIterator.prototype.next = function () {
        return this._i < this._l ? {
            done: false,
            value: this._s.charAt(this._i++)
        } : doneEnumerator;
    };
    function ArrayIterable(a) {
        this._a = a;
    }
    ArrayIterable.prototype[$iterator$] = function () {
        return new ArrayIterator(this._a);
    };
    function ArrayIterator(a) {
        this._a = a;
        this._l = toLength(a);
        this._i = 0;
    }
    ArrayIterator.prototype[$iterator$] = function () {
        return this;
    };
    ArrayIterator.prototype.next = function () {
        return this._i < this._l ? {
            done: false,
            value: this._a[this._i++]
        } : doneEnumerator;
    };
    function numberIsFinite(value) {
        return typeof value === 'number' && root.isFinite(value);
    }
    function isNan(n) {
        return n !== n;
    }
    function getIterable(o) {
        var i = o[$iterator$], it;
        if (!i && typeof o === 'string') {
            it = new StringIterable(o);
            return it[$iterator$]();
        }
        if (!i && o.length !== undefined) {
            it = new ArrayIterable(o);
            return it[$iterator$]();
        }
        if (!i) {
            throw new TypeError('Object is not iterable');
        }
        return o[$iterator$]();
    }
    function sign(value) {
        var number = +value;
        if (number === 0) {
            return number;
        }
        if (isNaN(number)) {
            return number;
        }
        return number < 0 ? -1 : 1;
    }
    function toLength(o) {
        var len = +o.length;
        if (isNaN(len)) {
            return 0;
        }
        if (len === 0 || !numberIsFinite(len)) {
            return len;
        }
        len = sign(len) * Math.floor(Math.abs(len));
        if (len <= 0) {
            return 0;
        }
        if (len > maxSafeInteger) {
            return maxSafeInteger;
        }
        return len;
    }
    var observableFrom = Observable.from = function (iterable, mapFn, thisArg, scheduler) {
        if (iterable == null) {
            throw new Error('iterable cannot be null.');
        }
        if (mapFn && !isFunction(mapFn)) {
            throw new Error('mapFn when provided must be a function');
        }
        if (mapFn) {
            var mapper = bindCallback(mapFn, thisArg, 2);
        }
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromObservable(iterable, mapper, scheduler);
    };
    var FromArrayObservable = function (__super__) {
        inherits(FromArrayObservable, __super__);
        function FromArrayObservable(args, scheduler) {
            this.args = args;
            this.scheduler = scheduler;
            __super__.call(this);
        }
        FromArrayObservable.prototype.subscribeCore = function (observer) {
            var sink = new FromArraySink(observer, this);
            return sink.run();
        };
        return FromArrayObservable;
    }(ObservableBase);
    function FromArraySink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
    }
    FromArraySink.prototype.run = function () {
        var observer = this.observer, args = this.parent.args, len = args.length;
        function loopRecursive(i, recurse) {
            if (i < len) {
                observer.onNext(args[i]);
                recurse(i + 1);
            } else {
                observer.onCompleted();
            }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
    };
    var observableFromArray = Observable.fromArray = function (array, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
    };
    var NeverObservable = function (__super__) {
        inherits(NeverObservable, __super__);
        function NeverObservable() {
            __super__.call(this);
        }
        NeverObservable.prototype.subscribeCore = function (observer) {
            return disposableEmpty;
        };
        return NeverObservable;
    }(ObservableBase);
    var NEVER_OBSERVABLE = new NeverObservable();
    var observableNever = Observable.never = function () {
        return NEVER_OBSERVABLE;
    };
    function observableOf(scheduler, array) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new FromArrayObservable(array, scheduler);
    }
    Observable.of = function () {
        var len = arguments.length, args = new Array(len);
        for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        return new FromArrayObservable(args, currentThreadScheduler);
    };
    Observable.ofWithScheduler = function (scheduler) {
        var len = arguments.length, args = new Array(len - 1);
        for (var i = 1; i < len; i++) {
            args[i - 1] = arguments[i];
        }
        return new FromArrayObservable(args, scheduler);
    };
    var PairsObservable = function (__super__) {
        inherits(PairsObservable, __super__);
        function PairsObservable(obj, scheduler) {
            this.obj = obj;
            this.keys = Object.keys(obj);
            this.scheduler = scheduler;
            __super__.call(this);
        }
        PairsObservable.prototype.subscribeCore = function (observer) {
            var sink = new PairsSink(observer, this);
            return sink.run();
        };
        return PairsObservable;
    }(ObservableBase);
    function PairsSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
    }
    PairsSink.prototype.run = function () {
        var observer = this.observer, obj = this.parent.obj, keys = this.parent.keys, len = keys.length;
        function loopRecursive(i, recurse) {
            if (i < len) {
                var key = keys[i];
                observer.onNext([
                    key,
                    obj[key]
                ]);
                recurse(i + 1);
            } else {
                observer.onCompleted();
            }
        }
        return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
    };
    Observable.pairs = function (obj, scheduler) {
        scheduler || (scheduler = currentThreadScheduler);
        return new PairsObservable(obj, scheduler);
    };
    var RangeObservable = function (__super__) {
        inherits(RangeObservable, __super__);
        function RangeObservable(start, count, scheduler) {
            this.start = start;
            this.rangeCount = count;
            this.scheduler = scheduler;
            __super__.call(this);
        }
        RangeObservable.prototype.subscribeCore = function (observer) {
            var sink = new RangeSink(observer, this);
            return sink.run();
        };
        return RangeObservable;
    }(ObservableBase);
    var RangeSink = function () {
        function RangeSink(observer, parent) {
            this.observer = observer;
            this.parent = parent;
        }
        RangeSink.prototype.run = function () {
            var start = this.parent.start, count = this.parent.rangeCount, observer = this.observer;
            function loopRecursive(i, recurse) {
                if (i < count) {
                    observer.onNext(start + i);
                    recurse(i + 1);
                } else {
                    observer.onCompleted();
                }
            }
            return this.parent.scheduler.scheduleRecursiveWithState(0, loopRecursive);
        };
        return RangeSink;
    }();
    Observable.range = function (start, count, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RangeObservable(start, count, scheduler);
    };
    var RepeatObservable = function (__super__) {
        inherits(RepeatObservable, __super__);
        function RepeatObservable(value, repeatCount, scheduler) {
            this.value = value;
            this.repeatCount = repeatCount == null ? -1 : repeatCount;
            this.scheduler = scheduler;
            __super__.call(this);
        }
        RepeatObservable.prototype.subscribeCore = function (observer) {
            var sink = new RepeatSink(observer, this);
            return sink.run();
        };
        return RepeatObservable;
    }(ObservableBase);
    function RepeatSink(observer, parent) {
        this.observer = observer;
        this.parent = parent;
    }
    RepeatSink.prototype.run = function () {
        var observer = this.observer, value = this.parent.value;
        function loopRecursive(i, recurse) {
            if (i === -1 || i > 0) {
                observer.onNext(value);
                i > 0 && i--;
            }
            if (i === 0) {
                return observer.onCompleted();
            }
            recurse(i);
        }
        return this.parent.scheduler.scheduleRecursiveWithState(this.parent.repeatCount, loopRecursive);
    };
    Observable.repeat = function (value, repeatCount, scheduler) {
        isScheduler(scheduler) || (scheduler = currentThreadScheduler);
        return new RepeatObservable(value, repeatCount, scheduler);
    };
    var JustObservable = function (__super__) {
        inherits(JustObservable, __super__);
        function JustObservable(value, scheduler) {
            this.value = value;
            this.scheduler = scheduler;
            __super__.call(this);
        }
        JustObservable.prototype.subscribeCore = function (observer) {
            var sink = new JustSink(observer, this.value, this.scheduler);
            return sink.run();
        };
        function JustSink(observer, value, scheduler) {
            this.observer = observer;
            this.value = value;
            this.scheduler = scheduler;
        }
        function scheduleItem(s, state) {
            var value = state[0], observer = state[1];
            observer.onNext(value);
            observer.onCompleted();
            return disposableEmpty;
        }
        JustSink.prototype.run = function () {
            var state = [
                this.value,
                this.observer
            ];
            return this.scheduler === immediateScheduler ? scheduleItem(null, state) : this.scheduler.scheduleWithState(state, scheduleItem);
        };
        return JustObservable;
    }(ObservableBase);
    var observableReturn = Observable['return'] = Observable.just = function (value, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new JustObservable(value, scheduler);
    };
    var ThrowObservable = function (__super__) {
        inherits(ThrowObservable, __super__);
        function ThrowObservable(error, scheduler) {
            this.error = error;
            this.scheduler = scheduler;
            __super__.call(this);
        }
        ThrowObservable.prototype.subscribeCore = function (o) {
            var sink = new ThrowSink(o, this);
            return sink.run();
        };
        function ThrowSink(o, p) {
            this.o = o;
            this.p = p;
        }
        function scheduleItem(s, state) {
            var e = state[0], o = state[1];
            o.onError(e);
        }
        ThrowSink.prototype.run = function () {
            return this.p.scheduler.scheduleWithState([
                this.p.error,
                this.o
            ], scheduleItem);
        };
        return ThrowObservable;
    }(ObservableBase);
    var observableThrow = Observable['throw'] = function (error, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new ThrowObservable(error, scheduler);
    };
    var CatchObserver = function (__super__) {
        inherits(CatchObserver, __super__);
        function CatchObserver(o, s, fn) {
            this._o = o;
            this._s = s;
            this._fn = fn;
            __super__.call(this);
        }
        CatchObserver.prototype.next = function (x) {
            this._o.onNext(x);
        };
        CatchObserver.prototype.completed = function () {
            return this._o.onCompleted();
        };
        CatchObserver.prototype.error = function (e) {
            var result = tryCatch(this._fn)(e);
            if (result === errorObj) {
                return this._o.onError(result.e);
            }
            isPromise(result) && (result = observableFromPromise(result));
            var d = new SingleAssignmentDisposable();
            this._s.setDisposable(d);
            d.setDisposable(result.subscribe(this._o));
        };
        return CatchObserver;
    }(AbstractObserver);
    function observableCatchHandler(source, handler) {
        return new AnonymousObservable(function (o) {
            var d1 = new SingleAssignmentDisposable(), subscription = new SerialDisposable();
            subscription.setDisposable(d1);
            d1.setDisposable(source.subscribe(new CatchObserver(o, subscription, handler)));
            return subscription;
        }, source);
    }
    observableProto['catch'] = function (handlerOrSecond) {
        return isFunction(handlerOrSecond) ? observableCatchHandler(this, handlerOrSecond) : observableCatch([
            this,
            handlerOrSecond
        ]);
    };
    var observableCatch = Observable['catch'] = function () {
        var items;
        if (Array.isArray(arguments[0])) {
            items = arguments[0];
        } else {
            var len = arguments.length;
            items = new Array(len);
            for (var i = 0; i < len; i++) {
                items[i] = arguments[i];
            }
        }
        return enumerableOf(items).catchError();
    };
    observableProto.combineLatest = function () {
        var len = arguments.length, args = new Array(len);
        for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        if (Array.isArray(args[0])) {
            args[0].unshift(this);
        } else {
            args.unshift(this);
        }
        return combineLatest.apply(this, args);
    };
    function falseFactory() {
        return false;
    }
    function argumentsToArray() {
        var len = arguments.length, args = new Array(len);
        for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        return args;
    }
    var combineLatest = Observable.combineLatest = function () {
        var len = arguments.length, args = new Array(len);
        for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function (o) {
            var n = args.length, hasValue = arrayInitialize(n, falseFactory), hasValueAll = false, isDone = arrayInitialize(n, falseFactory), values = new Array(n);
            function next(i) {
                hasValue[i] = true;
                if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
                    try {
                        var res = resultSelector.apply(null, values);
                    } catch (e) {
                        return o.onError(e);
                    }
                    o.onNext(res);
                } else if (isDone.filter(function (x, j) {
                        return j !== i;
                    }).every(identity)) {
                    o.onCompleted();
                }
            }
            function done(i) {
                isDone[i] = true;
                isDone.every(identity) && o.onCompleted();
            }
            var subscriptions = new Array(n);
            for (var idx = 0; idx < n; idx++) {
                (function (i) {
                    var source = args[i], sad = new SingleAssignmentDisposable();
                    isPromise(source) && (source = observableFromPromise(source));
                    sad.setDisposable(source.subscribe(function (x) {
                        values[i] = x;
                        next(i);
                    }, function (e) {
                        o.onError(e);
                    }, function () {
                        done(i);
                    }));
                    subscriptions[i] = sad;
                }(idx));
            }
            return new CompositeDisposable(subscriptions);
        }, this);
    };
    observableProto.concat = function () {
        for (var args = [], i = 0, len = arguments.length; i < len; i++) {
            args.push(arguments[i]);
        }
        args.unshift(this);
        return observableConcat.apply(null, args);
    };
    var ConcatObservable = function (__super__) {
        inherits(ConcatObservable, __super__);
        function ConcatObservable(sources) {
            this.sources = sources;
            __super__.call(this);
        }
        ConcatObservable.prototype.subscribeCore = function (o) {
            var sink = new ConcatSink(this.sources, o);
            return sink.run();
        };
        function ConcatSink(sources, o) {
            this.sources = sources;
            this.o = o;
        }
        ConcatSink.prototype.run = function () {
            var isDisposed, subscription = new SerialDisposable(), sources = this.sources, length = sources.length, o = this.o;
            var cancelable = immediateScheduler.scheduleRecursiveWithState(0, function (i, self) {
                if (isDisposed) {
                    return;
                }
                if (i === length) {
                    return o.onCompleted();
                }
                var currentValue = sources[i];
                isPromise(currentValue) && (currentValue = observableFromPromise(currentValue));
                var d = new SingleAssignmentDisposable();
                subscription.setDisposable(d);
                d.setDisposable(currentValue.subscribe(function (x) {
                    o.onNext(x);
                }, function (e) {
                    o.onError(e);
                }, function () {
                    self(i + 1);
                }));
            });
            return new CompositeDisposable(subscription, cancelable, disposableCreate(function () {
                isDisposed = true;
            }));
        };
        return ConcatObservable;
    }(ObservableBase);
    var observableConcat = Observable.concat = function () {
        var args;
        if (Array.isArray(arguments[0])) {
            args = arguments[0];
        } else {
            args = new Array(arguments.length);
            for (var i = 0, len = arguments.length; i < len; i++) {
                args[i] = arguments[i];
            }
        }
        return new ConcatObservable(args);
    };
    observableProto.concatAll = function () {
        return this.merge(1);
    };
    var MergeObservable = function (__super__) {
        inherits(MergeObservable, __super__);
        function MergeObservable(source, maxConcurrent) {
            this.source = source;
            this.maxConcurrent = maxConcurrent;
            __super__.call(this);
        }
        MergeObservable.prototype.subscribeCore = function (observer) {
            var g = new CompositeDisposable();
            g.add(this.source.subscribe(new MergeObserver(observer, this.maxConcurrent, g)));
            return g;
        };
        return MergeObservable;
    }(ObservableBase);
    var MergeObserver = function () {
        function MergeObserver(o, max, g) {
            this.o = o;
            this.max = max;
            this.g = g;
            this.done = false;
            this.q = [];
            this.activeCount = 0;
            this.isStopped = false;
        }
        MergeObserver.prototype.handleSubscribe = function (xs) {
            var sad = new SingleAssignmentDisposable();
            this.g.add(sad);
            isPromise(xs) && (xs = observableFromPromise(xs));
            sad.setDisposable(xs.subscribe(new InnerObserver(this, sad)));
        };
        MergeObserver.prototype.onNext = function (innerSource) {
            if (this.isStopped) {
                return;
            }
            if (this.activeCount < this.max) {
                this.activeCount++;
                this.handleSubscribe(innerSource);
            } else {
                this.q.push(innerSource);
            }
        };
        MergeObserver.prototype.onError = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
            }
        };
        MergeObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this.done = true;
                this.activeCount === 0 && this.o.onCompleted();
            }
        };
        MergeObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        MergeObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
                return true;
            }
            return false;
        };
        function InnerObserver(parent, sad) {
            this.parent = parent;
            this.sad = sad;
            this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function (x) {
            if (!this.isStopped) {
                this.parent.o.onNext(x);
            }
        };
        InnerObserver.prototype.onError = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.parent.o.onError(e);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                var parent = this.parent;
                parent.g.remove(this.sad);
                if (parent.q.length > 0) {
                    parent.handleSubscribe(parent.q.shift());
                } else {
                    parent.activeCount--;
                    parent.done && parent.activeCount === 0 && parent.o.onCompleted();
                }
            }
        };
        InnerObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        InnerObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.parent.o.onError(e);
                return true;
            }
            return false;
        };
        return MergeObserver;
    }();
    observableProto.merge = function (maxConcurrentOrOther) {
        return typeof maxConcurrentOrOther !== 'number' ? observableMerge(this, maxConcurrentOrOther) : new MergeObservable(this, maxConcurrentOrOther);
    };
    var observableMerge = Observable.merge = function () {
        var scheduler, sources = [], i, len = arguments.length;
        if (!arguments[0]) {
            scheduler = immediateScheduler;
            for (i = 1; i < len; i++) {
                sources.push(arguments[i]);
            }
        } else if (isScheduler(arguments[0])) {
            scheduler = arguments[0];
            for (i = 1; i < len; i++) {
                sources.push(arguments[i]);
            }
        } else {
            scheduler = immediateScheduler;
            for (i = 0; i < len; i++) {
                sources.push(arguments[i]);
            }
        }
        if (Array.isArray(sources[0])) {
            sources = sources[0];
        }
        return observableOf(scheduler, sources).mergeAll();
    };
    var CompositeError = Rx.CompositeError = function (errors) {
        this.name = 'NotImplementedError';
        this.innerErrors = errors;
        this.message = 'This contains multiple errors. Check the innerErrors';
        Error.call(this);
    };
    CompositeError.prototype = Error.prototype;
    Observable.mergeDelayError = function () {
        var args;
        if (Array.isArray(arguments[0])) {
            args = arguments[0];
        } else {
            var len = arguments.length;
            args = new Array(len);
            for (var i = 0; i < len; i++) {
                args[i] = arguments[i];
            }
        }
        var source = observableOf(null, args);
        return new AnonymousObservable(function (o) {
            var group = new CompositeDisposable(), m = new SingleAssignmentDisposable(), isStopped = false, errors = [];
            function setCompletion() {
                if (errors.length === 0) {
                    o.onCompleted();
                } else if (errors.length === 1) {
                    o.onError(errors[0]);
                } else {
                    o.onError(new CompositeError(errors));
                }
            }
            group.add(m);
            m.setDisposable(source.subscribe(function (innerSource) {
                var innerSubscription = new SingleAssignmentDisposable();
                group.add(innerSubscription);
                isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
                innerSubscription.setDisposable(innerSource.subscribe(function (x) {
                    o.onNext(x);
                }, function (e) {
                    errors.push(e);
                    group.remove(innerSubscription);
                    isStopped && group.length === 1 && setCompletion();
                }, function () {
                    group.remove(innerSubscription);
                    isStopped && group.length === 1 && setCompletion();
                }));
            }, function (e) {
                errors.push(e);
                isStopped = true;
                group.length === 1 && setCompletion();
            }, function () {
                isStopped = true;
                group.length === 1 && setCompletion();
            }));
            return group;
        });
    };
    var MergeAllObservable = function (__super__) {
        inherits(MergeAllObservable, __super__);
        function MergeAllObservable(source) {
            this.source = source;
            __super__.call(this);
        }
        MergeAllObservable.prototype.subscribeCore = function (observer) {
            var g = new CompositeDisposable(), m = new SingleAssignmentDisposable();
            g.add(m);
            m.setDisposable(this.source.subscribe(new MergeAllObserver(observer, g)));
            return g;
        };
        function MergeAllObserver(o, g) {
            this.o = o;
            this.g = g;
            this.isStopped = false;
            this.done = false;
        }
        MergeAllObserver.prototype.onNext = function (innerSource) {
            if (this.isStopped) {
                return;
            }
            var sad = new SingleAssignmentDisposable();
            this.g.add(sad);
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            sad.setDisposable(innerSource.subscribe(new InnerObserver(this, sad)));
        };
        MergeAllObserver.prototype.onError = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
            }
        };
        MergeAllObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this.done = true;
                this.g.length === 1 && this.o.onCompleted();
            }
        };
        MergeAllObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        MergeAllObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
                return true;
            }
            return false;
        };
        function InnerObserver(parent, sad) {
            this.parent = parent;
            this.sad = sad;
            this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function (x) {
            if (!this.isStopped) {
                this.parent.o.onNext(x);
            }
        };
        InnerObserver.prototype.onError = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.parent.o.onError(e);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                var parent = this.parent;
                this.isStopped = true;
                parent.g.remove(this.sad);
                parent.done && parent.g.length === 1 && parent.o.onCompleted();
            }
        };
        InnerObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        InnerObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.parent.o.onError(e);
                return true;
            }
            return false;
        };
        return MergeAllObservable;
    }(ObservableBase);
    observableProto.mergeAll = function () {
        return new MergeAllObservable(this);
    };
    observableProto.skipUntil = function (other) {
        var source = this;
        return new AnonymousObservable(function (o) {
            var isOpen = false;
            var disposables = new CompositeDisposable(source.subscribe(function (left) {
                isOpen && o.onNext(left);
            }, function (e) {
                o.onError(e);
            }, function () {
                isOpen && o.onCompleted();
            }));
            isPromise(other) && (other = observableFromPromise(other));
            var rightSubscription = new SingleAssignmentDisposable();
            disposables.add(rightSubscription);
            rightSubscription.setDisposable(other.subscribe(function () {
                isOpen = true;
                rightSubscription.dispose();
            }, function (e) {
                o.onError(e);
            }, function () {
                rightSubscription.dispose();
            }));
            return disposables;
        }, source);
    };
    var SwitchObservable = function (__super__) {
        inherits(SwitchObservable, __super__);
        function SwitchObservable(source) {
            this.source = source;
            __super__.call(this);
        }
        SwitchObservable.prototype.subscribeCore = function (o) {
            var inner = new SerialDisposable(), s = this.source.subscribe(new SwitchObserver(o, inner));
            return new CompositeDisposable(s, inner);
        };
        function SwitchObserver(o, inner) {
            this.o = o;
            this.inner = inner;
            this.stopped = false;
            this.latest = 0;
            this.hasLatest = false;
            this.isStopped = false;
        }
        SwitchObserver.prototype.onNext = function (innerSource) {
            if (this.isStopped) {
                return;
            }
            var d = new SingleAssignmentDisposable(), id = ++this.latest;
            this.hasLatest = true;
            this.inner.setDisposable(d);
            isPromise(innerSource) && (innerSource = observableFromPromise(innerSource));
            d.setDisposable(innerSource.subscribe(new InnerObserver(this, id)));
        };
        SwitchObserver.prototype.onError = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
            }
        };
        SwitchObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this.stopped = true;
                !this.hasLatest && this.o.onCompleted();
            }
        };
        SwitchObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        SwitchObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
                return true;
            }
            return false;
        };
        function InnerObserver(parent, id) {
            this.parent = parent;
            this.id = id;
            this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function (x) {
            if (this.isStopped) {
                return;
            }
            this.parent.latest === this.id && this.parent.o.onNext(x);
        };
        InnerObserver.prototype.onError = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.parent.latest === this.id && this.parent.o.onError(e);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                if (this.parent.latest === this.id) {
                    this.parent.hasLatest = false;
                    this.parent.isStopped && this.parent.o.onCompleted();
                }
            }
        };
        InnerObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        InnerObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.parent.o.onError(e);
                return true;
            }
            return false;
        };
        return SwitchObservable;
    }(ObservableBase);
    observableProto['switch'] = observableProto.switchLatest = function () {
        return new SwitchObservable(this);
    };
    var TakeUntilObservable = function (__super__) {
        inherits(TakeUntilObservable, __super__);
        function TakeUntilObservable(source, other) {
            this.source = source;
            this.other = isPromise(other) ? observableFromPromise(other) : other;
            __super__.call(this);
        }
        TakeUntilObservable.prototype.subscribeCore = function (o) {
            return new CompositeDisposable(this.source.subscribe(o), this.other.subscribe(new InnerObserver(o)));
        };
        function InnerObserver(o) {
            this.o = o;
            this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function (x) {
            if (this.isStopped) {
                return;
            }
            this.o.onCompleted();
        };
        InnerObserver.prototype.onError = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(err);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            !this.isStopped && (this.isStopped = true);
        };
        InnerObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        InnerObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
                return true;
            }
            return false;
        };
        return TakeUntilObservable;
    }(ObservableBase);
    observableProto.takeUntil = function (other) {
        return new TakeUntilObservable(this, other);
    };
    function falseFactory() {
        return false;
    }
    observableProto.withLatestFrom = function () {
        var len = arguments.length, args = new Array(len);
        for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        var resultSelector = args.pop(), source = this;
        Array.isArray(args[0]) && (args = args[0]);
        return new AnonymousObservable(function (observer) {
            var n = args.length, hasValue = arrayInitialize(n, falseFactory), hasValueAll = false, values = new Array(n);
            var subscriptions = new Array(n + 1);
            for (var idx = 0; idx < n; idx++) {
                (function (i) {
                    var other = args[i], sad = new SingleAssignmentDisposable();
                    isPromise(other) && (other = observableFromPromise(other));
                    sad.setDisposable(other.subscribe(function (x) {
                        values[i] = x;
                        hasValue[i] = true;
                        hasValueAll = hasValue.every(identity);
                    }, function (e) {
                        observer.onError(e);
                    }, noop));
                    subscriptions[i] = sad;
                }(idx));
            }
            var sad = new SingleAssignmentDisposable();
            sad.setDisposable(source.subscribe(function (x) {
                var allValues = [x].concat(values);
                if (!hasValueAll) {
                    return;
                }
                var res = tryCatch(resultSelector).apply(null, allValues);
                if (res === errorObj) {
                    return observer.onError(res.e);
                }
                observer.onNext(res);
            }, function (e) {
                observer.onError(e);
            }, function () {
                observer.onCompleted();
            }));
            subscriptions[n] = sad;
            return new CompositeDisposable(subscriptions);
        }, this);
    };
    function falseFactory() {
        return false;
    }
    function emptyArrayFactory() {
        return [];
    }
    function argumentsToArray() {
        var len = arguments.length, args = new Array(len);
        for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        return args;
    }
    observableProto.zip = function () {
        if (arguments.length === 0) {
            throw new Error('invalid arguments');
        }
        var len = arguments.length, args = new Array(len);
        for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
        Array.isArray(args[0]) && (args = args[0]);
        var parent = this;
        args.unshift(parent);
        return new AnonymousObservable(function (o) {
            var n = args.length, queues = arrayInitialize(n, emptyArrayFactory), isDone = arrayInitialize(n, falseFactory);
            var subscriptions = new Array(n);
            for (var idx = 0; idx < n; idx++) {
                (function (i) {
                    var source = args[i], sad = new SingleAssignmentDisposable();
                    isPromise(source) && (source = observableFromPromise(source));
                    sad.setDisposable(source.subscribe(function (x) {
                        queues[i].push(x);
                        if (queues.every(function (x) {
                                return x.length > 0;
                            })) {
                            var queuedValues = queues.map(function (x) {
                                    return x.shift();
                                }), res = tryCatch(resultSelector).apply(parent, queuedValues);
                            if (res === errorObj) {
                                return o.onError(res.e);
                            }
                            o.onNext(res);
                        } else if (isDone.filter(function (x, j) {
                                return j !== i;
                            }).every(identity)) {
                            o.onCompleted();
                        }
                    }, function (e) {
                        o.onError(e);
                    }, function () {
                        isDone[i] = true;
                        isDone.every(identity) && o.onCompleted();
                    }));
                    subscriptions[i] = sad;
                }(idx));
            }
            return new CompositeDisposable(subscriptions);
        }, parent);
    };
    Observable.zip = function () {
        var len = arguments.length, args = new Array(len);
        for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        if (Array.isArray(args[0])) {
            args = isFunction(args[1]) ? args[0].concat(args[1]) : args[0];
        }
        var first = args.shift();
        return first.zip.apply(first, args);
    };
    function falseFactory() {
        return false;
    }
    function emptyArrayFactory() {
        return [];
    }
    function argumentsToArray() {
        var len = arguments.length, args = new Array(len);
        for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        return args;
    }
    observableProto.zipIterable = function () {
        if (arguments.length === 0) {
            throw new Error('invalid arguments');
        }
        var len = arguments.length, args = new Array(len);
        for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        var resultSelector = isFunction(args[len - 1]) ? args.pop() : argumentsToArray;
        var parent = this;
        args.unshift(parent);
        return new AnonymousObservable(function (o) {
            var n = args.length, queues = arrayInitialize(n, emptyArrayFactory), isDone = arrayInitialize(n, falseFactory);
            var subscriptions = new Array(n);
            for (var idx = 0; idx < n; idx++) {
                (function (i) {
                    var source = args[i], sad = new SingleAssignmentDisposable();
                    (isArrayLike(source) || isIterable(source)) && (source = observableFrom(source));
                    sad.setDisposable(source.subscribe(function (x) {
                        queues[i].push(x);
                        if (queues.every(function (x) {
                                return x.length > 0;
                            })) {
                            var queuedValues = queues.map(function (x) {
                                    return x.shift();
                                }), res = tryCatch(resultSelector).apply(parent, queuedValues);
                            if (res === errorObj) {
                                return o.onError(res.e);
                            }
                            o.onNext(res);
                        } else if (isDone.filter(function (x, j) {
                                return j !== i;
                            }).every(identity)) {
                            o.onCompleted();
                        }
                    }, function (e) {
                        o.onError(e);
                    }, function () {
                        isDone[i] = true;
                        isDone.every(identity) && o.onCompleted();
                    }));
                    subscriptions[i] = sad;
                }(idx));
            }
            return new CompositeDisposable(subscriptions);
        }, parent);
    };
    function asObservable(source) {
        return function subscribe(o) {
            return source.subscribe(o);
        };
    }
    observableProto.asObservable = function () {
        return new AnonymousObservable(asObservable(this), this);
    };
    observableProto.dematerialize = function () {
        var source = this;
        return new AnonymousObservable(function (o) {
            return source.subscribe(function (x) {
                return x.accept(o);
            }, function (e) {
                o.onError(e);
            }, function () {
                o.onCompleted();
            });
        }, this);
    };
    var DistinctUntilChangedObservable = function (__super__) {
        inherits(DistinctUntilChangedObservable, __super__);
        function DistinctUntilChangedObservable(source, keyFn, comparer) {
            this.source = source;
            this.keyFn = keyFn;
            this.comparer = comparer;
            __super__.call(this);
        }
        DistinctUntilChangedObservable.prototype.subscribeCore = function (o) {
            return this.source.subscribe(new DistinctUntilChangedObserver(o, this.keyFn, this.comparer));
        };
        return DistinctUntilChangedObservable;
    }(ObservableBase);
    var DistinctUntilChangedObserver = function (__super__) {
        inherits(DistinctUntilChangedObserver, __super__);
        function DistinctUntilChangedObserver(o, keyFn, comparer) {
            this.o = o;
            this.keyFn = keyFn;
            this.comparer = comparer;
            this.hasCurrentKey = false;
            this.currentKey = null;
            __super__.call(this);
        }
        DistinctUntilChangedObserver.prototype.next = function (x) {
            var key = x, comparerEquals;
            if (isFunction(this.keyFn)) {
                key = tryCatch(this.keyFn)(x);
                if (key === errorObj) {
                    return this.o.onError(key.e);
                }
            }
            if (this.hasCurrentKey) {
                comparerEquals = tryCatch(this.comparer)(this.currentKey, key);
                if (comparerEquals === errorObj) {
                    return this.o.onError(comparerEquals.e);
                }
            }
            if (!this.hasCurrentKey || !comparerEquals) {
                this.hasCurrentKey = true;
                this.currentKey = key;
                this.o.onNext(x);
            }
        };
        DistinctUntilChangedObserver.prototype.error = function (e) {
            this.o.onError(e);
        };
        DistinctUntilChangedObserver.prototype.completed = function () {
            this.o.onCompleted();
        };
        return DistinctUntilChangedObserver;
    }(AbstractObserver);
    observableProto.distinctUntilChanged = function (keyFn, comparer) {
        comparer || (comparer = defaultComparer);
        return new DistinctUntilChangedObservable(this, keyFn, comparer);
    };
    var TapObservable = function (__super__) {
        inherits(TapObservable, __super__);
        function TapObservable(source, observerOrOnNext, onError, onCompleted) {
            this.source = source;
            this._oN = observerOrOnNext;
            this._oE = onError;
            this._oC = onCompleted;
            __super__.call(this);
        }
        TapObservable.prototype.subscribeCore = function (o) {
            return this.source.subscribe(new InnerObserver(o, this));
        };
        function InnerObserver(o, p) {
            this.o = o;
            this.t = !p._oN || isFunction(p._oN) ? observerCreate(p._oN || noop, p._oE || noop, p._oC || noop) : p._oN;
            this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function (x) {
            if (this.isStopped) {
                return;
            }
            var res = tryCatch(this.t.onNext).call(this.t, x);
            if (res === errorObj) {
                this.o.onError(res.e);
            }
            this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                var res = tryCatch(this.t.onError).call(this.t, err);
                if (res === errorObj) {
                    return this.o.onError(res.e);
                }
                this.o.onError(err);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                var res = tryCatch(this.t.onCompleted).call(this.t);
                if (res === errorObj) {
                    return this.o.onError(res.e);
                }
                this.o.onCompleted();
            }
        };
        InnerObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        InnerObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
                return true;
            }
            return false;
        };
        return TapObservable;
    }(ObservableBase);
    observableProto['do'] = observableProto.tap = observableProto.doAction = function (observerOrOnNext, onError, onCompleted) {
        return new TapObservable(this, observerOrOnNext, onError, onCompleted);
    };
    observableProto.doOnNext = observableProto.tapOnNext = function (onNext, thisArg) {
        return this.tap(typeof thisArg !== 'undefined' ? function (x) {
            onNext.call(thisArg, x);
        } : onNext);
    };
    observableProto.doOnError = observableProto.tapOnError = function (onError, thisArg) {
        return this.tap(noop, typeof thisArg !== 'undefined' ? function (e) {
            onError.call(thisArg, e);
        } : onError);
    };
    observableProto.doOnCompleted = observableProto.tapOnCompleted = function (onCompleted, thisArg) {
        return this.tap(noop, null, typeof thisArg !== 'undefined' ? function () {
            onCompleted.call(thisArg);
        } : onCompleted);
    };
    observableProto['finally'] = function (action) {
        var source = this;
        return new AnonymousObservable(function (observer) {
            var subscription = tryCatch(source.subscribe).call(source, observer);
            if (subscription === errorObj) {
                action();
                return thrower(subscription.e);
            }
            return disposableCreate(function () {
                var r = tryCatch(subscription.dispose).call(subscription);
                action();
                r === errorObj && thrower(r.e);
            });
        }, this);
    };
    var IgnoreElementsObservable = function (__super__) {
        inherits(IgnoreElementsObservable, __super__);
        function IgnoreElementsObservable(source) {
            this.source = source;
            __super__.call(this);
        }
        IgnoreElementsObservable.prototype.subscribeCore = function (o) {
            return this.source.subscribe(new InnerObserver(o));
        };
        function InnerObserver(o) {
            this.o = o;
            this.isStopped = false;
        }
        InnerObserver.prototype.onNext = noop;
        InnerObserver.prototype.onError = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(err);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onCompleted();
            }
        };
        InnerObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        InnerObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.observer.onError(e);
                return true;
            }
            return false;
        };
        return IgnoreElementsObservable;
    }(ObservableBase);
    observableProto.ignoreElements = function () {
        return new IgnoreElementsObservable(this);
    };
    observableProto.materialize = function () {
        var source = this;
        return new AnonymousObservable(function (observer) {
            return source.subscribe(function (value) {
                observer.onNext(notificationCreateOnNext(value));
            }, function (e) {
                observer.onNext(notificationCreateOnError(e));
                observer.onCompleted();
            }, function () {
                observer.onNext(notificationCreateOnCompleted());
                observer.onCompleted();
            });
        }, source);
    };
    observableProto.repeat = function (repeatCount) {
        return enumerableRepeat(this, repeatCount).concat();
    };
    observableProto.retry = function (retryCount) {
        return enumerableRepeat(this, retryCount).catchError();
    };
    observableProto.retryWhen = function (notifier) {
        return enumerableRepeat(this).catchErrorWhen(notifier);
    };
    var ScanObservable = function (__super__) {
        inherits(ScanObservable, __super__);
        function ScanObservable(source, accumulator, hasSeed, seed) {
            this.source = source;
            this.accumulator = accumulator;
            this.hasSeed = hasSeed;
            this.seed = seed;
            __super__.call(this);
        }
        ScanObservable.prototype.subscribeCore = function (o) {
            return this.source.subscribe(new InnerObserver(o, this));
        };
        return ScanObservable;
    }(ObservableBase);
    function InnerObserver(o, parent) {
        this.o = o;
        this.accumulator = parent.accumulator;
        this.hasSeed = parent.hasSeed;
        this.seed = parent.seed;
        this.hasAccumulation = false;
        this.accumulation = null;
        this.hasValue = false;
        this.isStopped = false;
    }
    InnerObserver.prototype = {
        onNext: function (x) {
            if (this.isStopped) {
                return;
            }
            !this.hasValue && (this.hasValue = true);
            if (this.hasAccumulation) {
                this.accumulation = tryCatch(this.accumulator)(this.accumulation, x);
            } else {
                this.accumulation = this.hasSeed ? tryCatch(this.accumulator)(this.seed, x) : x;
                this.hasAccumulation = true;
            }
            if (this.accumulation === errorObj) {
                return this.o.onError(this.accumulation.e);
            }
            this.o.onNext(this.accumulation);
        },
        onError: function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
            }
        },
        onCompleted: function () {
            if (!this.isStopped) {
                this.isStopped = true;
                !this.hasValue && this.hasSeed && this.o.onNext(this.seed);
                this.o.onCompleted();
            }
        },
        dispose: function () {
            this.isStopped = true;
        },
        fail: function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
                return true;
            }
            return false;
        }
    };
    observableProto.scan = function () {
        var hasSeed = false, seed, accumulator = arguments[0];
        if (arguments.length === 2) {
            hasSeed = true;
            seed = arguments[1];
        }
        return new ScanObservable(this, accumulator, hasSeed, seed);
    };
    observableProto.skipLast = function (count) {
        if (count < 0) {
            throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function (o) {
            var q = [];
            return source.subscribe(function (x) {
                q.push(x);
                q.length > count && o.onNext(q.shift());
            }, function (e) {
                o.onError(e);
            }, function () {
                o.onCompleted();
            });
        }, source);
    };
    observableProto.startWith = function () {
        var values, scheduler, start = 0;
        if (!!arguments.length && isScheduler(arguments[0])) {
            scheduler = arguments[0];
            start = 1;
        } else {
            scheduler = immediateScheduler;
        }
        for (var args = [], i = start, len = arguments.length; i < len; i++) {
            args.push(arguments[i]);
        }
        return enumerableOf([
            observableFromArray(args, scheduler),
            this
        ]).concat();
    };
    observableProto.takeLast = function (count) {
        if (count < 0) {
            throw new ArgumentOutOfRangeError();
        }
        var source = this;
        return new AnonymousObservable(function (o) {
            var q = [];
            return source.subscribe(function (x) {
                q.push(x);
                q.length > count && q.shift();
            }, function (e) {
                o.onError(e);
            }, function () {
                while (q.length > 0) {
                    o.onNext(q.shift());
                }
                o.onCompleted();
            });
        }, source);
    };
    observableProto.flatMapConcat = observableProto.concatMap = function (selector, resultSelector, thisArg) {
        return new FlatMapObservable(this, selector, resultSelector, thisArg).merge(1);
    };
    var MapObservable = function (__super__) {
        inherits(MapObservable, __super__);
        function MapObservable(source, selector, thisArg) {
            this.source = source;
            this.selector = bindCallback(selector, thisArg, 3);
            __super__.call(this);
        }
        function innerMap(selector, self) {
            return function (x, i, o) {
                return selector.call(this, self.selector(x, i, o), i, o);
            };
        }
        MapObservable.prototype.internalMap = function (selector, thisArg) {
            return new MapObservable(this.source, innerMap(selector, this), thisArg);
        };
        MapObservable.prototype.subscribeCore = function (o) {
            return this.source.subscribe(new InnerObserver(o, this.selector, this));
        };
        function InnerObserver(o, selector, source) {
            this.o = o;
            this.selector = selector;
            this.source = source;
            this.i = 0;
            this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function (x) {
            if (this.isStopped) {
                return;
            }
            var result = tryCatch(this.selector)(x, this.i++, this.source);
            if (result === errorObj) {
                return this.o.onError(result.e);
            }
            this.o.onNext(result);
        };
        InnerObserver.prototype.onError = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onCompleted();
            }
        };
        InnerObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        InnerObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
                return true;
            }
            return false;
        };
        return MapObservable;
    }(ObservableBase);
    observableProto.map = observableProto.select = function (selector, thisArg) {
        var selectorFn = typeof selector === 'function' ? selector : function () {
            return selector;
        };
        return this instanceof MapObservable ? this.internalMap(selectorFn, thisArg) : new MapObservable(this, selectorFn, thisArg);
    };
    function plucker(args, len) {
        return function mapper(x) {
            var currentProp = x;
            for (var i = 0; i < len; i++) {
                var p = currentProp[args[i]];
                if (typeof p !== 'undefined') {
                    currentProp = p;
                } else {
                    return undefined;
                }
            }
            return currentProp;
        };
    }
    observableProto.pluck = function () {
        var len = arguments.length, args = new Array(len);
        if (len === 0) {
            throw new Error('List of properties cannot be empty.');
        }
        for (var i = 0; i < len; i++) {
            args[i] = arguments[i];
        }
        return this.map(plucker(args, len));
    };
    observableProto.flatMap = observableProto.selectMany = function (selector, resultSelector, thisArg) {
        return new FlatMapObservable(this, selector, resultSelector, thisArg).mergeAll();
    };
    Rx.Observable.prototype.flatMapLatest = function (selector, resultSelector, thisArg) {
        return new FlatMapObservable(this, selector, resultSelector, thisArg).switchLatest();
    };
    var SkipObservable = function (__super__) {
        inherits(SkipObservable, __super__);
        function SkipObservable(source, count) {
            this.source = source;
            this.skipCount = count;
            __super__.call(this);
        }
        SkipObservable.prototype.subscribeCore = function (o) {
            return this.source.subscribe(new InnerObserver(o, this.skipCount));
        };
        function InnerObserver(o, c) {
            this.c = c;
            this.r = c;
            this.o = o;
            this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function (x) {
            if (this.isStopped) {
                return;
            }
            if (this.r <= 0) {
                this.o.onNext(x);
            } else {
                this.r--;
            }
        };
        InnerObserver.prototype.onError = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onCompleted();
            }
        };
        InnerObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        InnerObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
                return true;
            }
            return false;
        };
        return SkipObservable;
    }(ObservableBase);
    observableProto.skip = function (count) {
        if (count < 0) {
            throw new ArgumentOutOfRangeError();
        }
        return new SkipObservable(this, count);
    };
    observableProto.skipWhile = function (predicate, thisArg) {
        var source = this, callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function (o) {
            var i = 0, running = false;
            return source.subscribe(function (x) {
                if (!running) {
                    try {
                        running = !callback(x, i++, source);
                    } catch (e) {
                        o.onError(e);
                        return;
                    }
                }
                running && o.onNext(x);
            }, function (e) {
                o.onError(e);
            }, function () {
                o.onCompleted();
            });
        }, source);
    };
    observableProto.take = function (count, scheduler) {
        if (count < 0) {
            throw new ArgumentOutOfRangeError();
        }
        if (count === 0) {
            return observableEmpty(scheduler);
        }
        var source = this;
        return new AnonymousObservable(function (o) {
            var remaining = count;
            return source.subscribe(function (x) {
                if (remaining-- > 0) {
                    o.onNext(x);
                    remaining <= 0 && o.onCompleted();
                }
            }, function (e) {
                o.onError(e);
            }, function () {
                o.onCompleted();
            });
        }, source);
    };
    observableProto.takeWhile = function (predicate, thisArg) {
        var source = this, callback = bindCallback(predicate, thisArg, 3);
        return new AnonymousObservable(function (o) {
            var i = 0, running = true;
            return source.subscribe(function (x) {
                if (running) {
                    try {
                        running = callback(x, i++, source);
                    } catch (e) {
                        o.onError(e);
                        return;
                    }
                    if (running) {
                        o.onNext(x);
                    } else {
                        o.onCompleted();
                    }
                }
            }, function (e) {
                o.onError(e);
            }, function () {
                o.onCompleted();
            });
        }, source);
    };
    var FilterObservable = function (__super__) {
        inherits(FilterObservable, __super__);
        function FilterObservable(source, predicate, thisArg) {
            this.source = source;
            this.predicate = bindCallback(predicate, thisArg, 3);
            __super__.call(this);
        }
        FilterObservable.prototype.subscribeCore = function (o) {
            return this.source.subscribe(new InnerObserver(o, this.predicate, this));
        };
        function innerPredicate(predicate, self) {
            return function (x, i, o) {
                return self.predicate(x, i, o) && predicate.call(this, x, i, o);
            };
        }
        FilterObservable.prototype.internalFilter = function (predicate, thisArg) {
            return new FilterObservable(this.source, innerPredicate(predicate, this), thisArg);
        };
        function InnerObserver(o, predicate, source) {
            this.o = o;
            this.predicate = predicate;
            this.source = source;
            this.i = 0;
            this.isStopped = false;
        }
        InnerObserver.prototype.onNext = function (x) {
            if (this.isStopped) {
                return;
            }
            var shouldYield = tryCatch(this.predicate)(x, this.i++, this.source);
            if (shouldYield === errorObj) {
                return this.o.onError(shouldYield.e);
            }
            shouldYield && this.o.onNext(x);
        };
        InnerObserver.prototype.onError = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
            }
        };
        InnerObserver.prototype.onCompleted = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onCompleted();
            }
        };
        InnerObserver.prototype.dispose = function () {
            this.isStopped = true;
        };
        InnerObserver.prototype.fail = function (e) {
            if (!this.isStopped) {
                this.isStopped = true;
                this.o.onError(e);
                return true;
            }
            return false;
        };
        return FilterObservable;
    }(ObservableBase);
    observableProto.filter = observableProto.where = function (predicate, thisArg) {
        return this instanceof FilterObservable ? this.internalFilter(predicate, thisArg) : new FilterObservable(this, predicate, thisArg);
    };
    function createCbObservable(fn, ctx, selector, args) {
        var o = new AsyncSubject();
        args.push(createCbHandler(o, ctx, selector));
        fn.apply(ctx, args);
        return o.asObservable();
    }
    function createCbHandler(o, ctx, selector) {
        return function handler() {
            var len = arguments.length, results = new Array(len);
            for (var i = 0; i < len; i++) {
                results[i] = arguments[i];
            }
            if (isFunction(selector)) {
                results = tryCatch(selector).apply(ctx, results);
                if (results === errorObj) {
                    return o.onError(results.e);
                }
                o.onNext(results);
            } else {
                if (results.length <= 1) {
                    o.onNext(results[0]);
                } else {
                    o.onNext(results);
                }
            }
            o.onCompleted();
        };
    }
    Observable.fromCallback = function (fn, ctx, selector) {
        return function () {
            typeof ctx === 'undefined' && (ctx = this);
            var len = arguments.length, args = new Array(len);
            for (var i = 0; i < len; i++) {
                args[i] = arguments[i];
            }
            return createCbObservable(fn, ctx, selector, args);
        };
    };
    function createNodeObservable(fn, ctx, selector, args) {
        var o = new AsyncSubject();
        args.push(createNodeHandler(o, ctx, selector));
        fn.apply(ctx, args);
        return o.asObservable();
    }
    function createNodeHandler(o, ctx, selector) {
        return function handler() {
            var err = arguments[0];
            if (err) {
                return o.onError(err);
            }
            var len = arguments.length, results = [];
            for (var i = 1; i < len; i++) {
                results[i - 1] = arguments[i];
            }
            if (isFunction(selector)) {
                var results = tryCatch(selector).apply(ctx, results);
                if (results === errorObj) {
                    return o.onError(results.e);
                }
                o.onNext(results);
            } else {
                if (results.length <= 1) {
                    o.onNext(results[0]);
                } else {
                    o.onNext(results);
                }
            }
            o.onCompleted();
        };
    }
    Observable.fromNodeCallback = function (fn, ctx, selector) {
        return function () {
            typeof ctx === 'undefined' && (ctx = this);
            var len = arguments.length, args = new Array(len);
            for (var i = 0; i < len; i++) {
                args[i] = arguments[i];
            }
            return createNodeObservable(fn, ctx, selector, args);
        };
    };
    function ListenDisposable(e, n, fn) {
        this._e = e;
        this._n = n;
        this._fn = fn;
        this._e.addEventListener(this._n, this._fn, false);
        this.isDisposed = false;
    }
    ListenDisposable.prototype.dispose = function () {
        if (!this.isDisposed) {
            this._e.removeEventListener(this._n, this._fn, false);
            this.isDisposed = true;
        }
    };
    function createEventListener(el, eventName, handler) {
        var disposables = new CompositeDisposable();
        var elemToString = Object.prototype.toString.call(el);
        if (elemToString === '[object NodeList]' || elemToString === '[object HTMLCollection]') {
            for (var i = 0, len = el.length; i < len; i++) {
                disposables.add(createEventListener(el.item(i), eventName, handler));
            }
        } else if (el) {
            disposables.add(new ListenDisposable(el, eventName, handler));
        }
        return disposables;
    }
    Rx.config.useNativeEvents = false;
    function eventHandler(o, selector) {
        return function handler() {
            var results = arguments[0];
            if (isFunction(selector)) {
                results = tryCatch(selector).apply(null, arguments);
                if (results === errorObj) {
                    return o.onError(results.e);
                }
            }
            o.onNext(results);
        };
    }
    Observable.fromEvent = function (element, eventName, selector) {
        if (element.addListener) {
            return fromEventPattern(function (h) {
                element.addListener(eventName, h);
            }, function (h) {
                element.removeListener(eventName, h);
            }, selector);
        }
        if (!Rx.config.useNativeEvents) {
            if (typeof element.on === 'function' && typeof element.off === 'function') {
                return fromEventPattern(function (h) {
                    element.on(eventName, h);
                }, function (h) {
                    element.off(eventName, h);
                }, selector);
            }
        }
        return new AnonymousObservable(function (o) {
            return createEventListener(element, eventName, eventHandler(o, selector));
        }).publish().refCount();
    };
    var fromEventPattern = Observable.fromEventPattern = function (addHandler, removeHandler, selector, scheduler) {
        isScheduler(scheduler) || (scheduler = immediateScheduler);
        return new AnonymousObservable(function (o) {
            function innerHandler() {
                var result = arguments[0];
                if (isFunction(selector)) {
                    result = tryCatch(selector).apply(null, arguments);
                    if (result === errorObj) {
                        return o.onError(result.e);
                    }
                }
                o.onNext(result);
            }
            var returnValue = addHandler(innerHandler);
            return disposableCreate(function () {
                isFunction(removeHandler) && removeHandler(innerHandler, returnValue);
            });
        }).publish().refCount();
    };
    var FromPromiseObservable = function (__super__) {
        inherits(FromPromiseObservable, __super__);
        function FromPromiseObservable(p) {
            this.p = p;
            __super__.call(this);
        }
        FromPromiseObservable.prototype.subscribeCore = function (o) {
            this.p.then(function (data) {
                o.onNext(data);
                o.onCompleted();
            }, function (err) {
                o.onError(err);
            });
            return disposableEmpty;
        };
        return FromPromiseObservable;
    }(ObservableBase);
    var observableFromPromise = Observable.fromPromise = function (promise) {
        return new FromPromiseObservable(promise);
    };
    observableProto.toPromise = function (promiseCtor) {
        promiseCtor || (promiseCtor = Rx.config.Promise);
        if (!promiseCtor) {
            throw new NotSupportedError('Promise type not provided nor in Rx.config.Promise');
        }
        var source = this;
        return new promiseCtor(function (resolve, reject) {
            var value, hasValue = false;
            source.subscribe(function (v) {
                value = v;
                hasValue = true;
            }, reject, function () {
                hasValue && resolve(value);
            });
        });
    };
    Observable.startAsync = function (functionAsync) {
        var promise;
        try {
            promise = functionAsync();
        } catch (e) {
            return observableThrow(e);
        }
        return observableFromPromise(promise);
    };
    observableProto.multicast = function (subjectOrSubjectSelector, selector) {
        var source = this;
        return typeof subjectOrSubjectSelector === 'function' ? new AnonymousObservable(function (observer) {
            var connectable = source.multicast(subjectOrSubjectSelector());
            return new CompositeDisposable(selector(connectable).subscribe(observer), connectable.connect());
        }, source) : new ConnectableObservable(source, subjectOrSubjectSelector);
    };
    observableProto.publish = function (selector) {
        return selector && isFunction(selector) ? this.multicast(function () {
            return new Subject();
        }, selector) : this.multicast(new Subject());
    };
    observableProto.share = function () {
        return this.publish().refCount();
    };
    observableProto.publishLast = function (selector) {
        return selector && isFunction(selector) ? this.multicast(function () {
            return new AsyncSubject();
        }, selector) : this.multicast(new AsyncSubject());
    };
    observableProto.publishValue = function (initialValueOrSelector, initialValue) {
        return arguments.length === 2 ? this.multicast(function () {
            return new BehaviorSubject(initialValue);
        }, initialValueOrSelector) : this.multicast(new BehaviorSubject(initialValueOrSelector));
    };
    observableProto.shareValue = function (initialValue) {
        return this.publishValue(initialValue).refCount();
    };
    observableProto.replay = function (selector, bufferSize, windowSize, scheduler) {
        return selector && isFunction(selector) ? this.multicast(function () {
            return new ReplaySubject(bufferSize, windowSize, scheduler);
        }, selector) : this.multicast(new ReplaySubject(bufferSize, windowSize, scheduler));
    };
    observableProto.shareReplay = function (bufferSize, windowSize, scheduler) {
        return this.replay(null, bufferSize, windowSize, scheduler).refCount();
    };
    var ConnectableObservable = Rx.ConnectableObservable = function (__super__) {
        inherits(ConnectableObservable, __super__);
        function ConnectableObservable(source, subject) {
            var hasSubscription = false, subscription, sourceObservable = source.asObservable();
            this.connect = function () {
                if (!hasSubscription) {
                    hasSubscription = true;
                    subscription = new CompositeDisposable(sourceObservable.subscribe(subject), disposableCreate(function () {
                        hasSubscription = false;
                    }));
                }
                return subscription;
            };
            __super__.call(this, function (o) {
                return subject.subscribe(o);
            });
        }
        ConnectableObservable.prototype.refCount = function () {
            var connectableSubscription, count = 0, source = this;
            return new AnonymousObservable(function (observer) {
                var shouldConnect = ++count === 1, subscription = source.subscribe(observer);
                shouldConnect && (connectableSubscription = source.connect());
                return function () {
                    subscription.dispose();
                    --count === 0 && connectableSubscription.dispose();
                };
            });
        };
        return ConnectableObservable;
    }(Observable);
    function observableTimerDate(dueTime, scheduler) {
        return new AnonymousObservable(function (observer) {
            return scheduler.scheduleWithAbsolute(dueTime, function () {
                observer.onNext(0);
                observer.onCompleted();
            });
        });
    }
    function observableTimerDateAndPeriod(dueTime, period, scheduler) {
        return new AnonymousObservable(function (observer) {
            var d = dueTime, p = normalizeTime(period);
            return scheduler.scheduleRecursiveWithAbsoluteAndState(0, d, function (count, self) {
                if (p > 0) {
                    var now = scheduler.now();
                    d = d + p;
                    d <= now && (d = now + p);
                }
                observer.onNext(count);
                self(count + 1, d);
            });
        });
    }
    function observableTimerTimeSpan(dueTime, scheduler) {
        return new AnonymousObservable(function (observer) {
            return scheduler.scheduleWithRelative(normalizeTime(dueTime), function () {
                observer.onNext(0);
                observer.onCompleted();
            });
        });
    }
    function observableTimerTimeSpanAndPeriod(dueTime, period, scheduler) {
        return dueTime === period ? new AnonymousObservable(function (observer) {
            return scheduler.schedulePeriodicWithState(0, period, function (count) {
                observer.onNext(count);
                return count + 1;
            });
        }) : observableDefer(function () {
            return observableTimerDateAndPeriod(scheduler.now() + dueTime, period, scheduler);
        });
    }
    var observableinterval = Observable.interval = function (period, scheduler) {
        return observableTimerTimeSpanAndPeriod(period, period, isScheduler(scheduler) ? scheduler : timeoutScheduler);
    };
    var observableTimer = Observable.timer = function (dueTime, periodOrScheduler, scheduler) {
        var period;
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        if (periodOrScheduler != null && typeof periodOrScheduler === 'number') {
            period = periodOrScheduler;
        } else if (isScheduler(periodOrScheduler)) {
            scheduler = periodOrScheduler;
        }
        if (dueTime instanceof Date && period === undefined) {
            return observableTimerDate(dueTime.getTime(), scheduler);
        }
        if (dueTime instanceof Date && period !== undefined) {
            return observableTimerDateAndPeriod(dueTime.getTime(), periodOrScheduler, scheduler);
        }
        return period === undefined ? observableTimerTimeSpan(dueTime, scheduler) : observableTimerTimeSpanAndPeriod(dueTime, period, scheduler);
    };
    function observableDelayRelative(source, dueTime, scheduler) {
        return new AnonymousObservable(function (o) {
            var active = false, cancelable = new SerialDisposable(), exception = null, q = [], running = false, subscription;
            subscription = source.materialize().timestamp(scheduler).subscribe(function (notification) {
                var d, shouldRun;
                if (notification.value.kind === 'E') {
                    q = [];
                    q.push(notification);
                    exception = notification.value.exception;
                    shouldRun = !running;
                } else {
                    q.push({
                        value: notification.value,
                        timestamp: notification.timestamp + dueTime
                    });
                    shouldRun = !active;
                    active = true;
                }
                if (shouldRun) {
                    if (exception !== null) {
                        o.onError(exception);
                    } else {
                        d = new SingleAssignmentDisposable();
                        cancelable.setDisposable(d);
                        d.setDisposable(scheduler.scheduleRecursiveWithRelative(dueTime, function (self) {
                            var e, recurseDueTime, result, shouldRecurse;
                            if (exception !== null) {
                                return;
                            }
                            running = true;
                            do {
                                result = null;
                                if (q.length > 0 && q[0].timestamp - scheduler.now() <= 0) {
                                    result = q.shift().value;
                                }
                                if (result !== null) {
                                    result.accept(o);
                                }
                            } while (result !== null);
                            shouldRecurse = false;
                            recurseDueTime = 0;
                            if (q.length > 0) {
                                shouldRecurse = true;
                                recurseDueTime = Math.max(0, q[0].timestamp - scheduler.now());
                            } else {
                                active = false;
                            }
                            e = exception;
                            running = false;
                            if (e !== null) {
                                o.onError(e);
                            } else if (shouldRecurse) {
                                self(recurseDueTime);
                            }
                        }));
                    }
                }
            });
            return new CompositeDisposable(subscription, cancelable);
        }, source);
    }
    function observableDelayAbsolute(source, dueTime, scheduler) {
        return observableDefer(function () {
            return observableDelayRelative(source, dueTime - scheduler.now(), scheduler);
        });
    }
    function delayWithSelector(source, subscriptionDelay, delayDurationSelector) {
        var subDelay, selector;
        if (isFunction(subscriptionDelay)) {
            selector = subscriptionDelay;
        } else {
            subDelay = subscriptionDelay;
            selector = delayDurationSelector;
        }
        return new AnonymousObservable(function (o) {
            var delays = new CompositeDisposable(), atEnd = false, subscription = new SerialDisposable();
            function start() {
                subscription.setDisposable(source.subscribe(function (x) {
                    var delay = tryCatch(selector)(x);
                    if (delay === errorObj) {
                        return o.onError(delay.e);
                    }
                    var d = new SingleAssignmentDisposable();
                    delays.add(d);
                    d.setDisposable(delay.subscribe(function () {
                        o.onNext(x);
                        delays.remove(d);
                        done();
                    }, function (e) {
                        o.onError(e);
                    }, function () {
                        o.onNext(x);
                        delays.remove(d);
                        done();
                    }));
                }, function (e) {
                    o.onError(e);
                }, function () {
                    atEnd = true;
                    subscription.dispose();
                    done();
                }));
            }
            function done() {
                atEnd && delays.length === 0 && o.onCompleted();
            }
            if (!subDelay) {
                start();
            } else {
                subscription.setDisposable(subDelay.subscribe(start, function (e) {
                    o.onError(e);
                }, start));
            }
            return new CompositeDisposable(subscription, delays);
        }, this);
    }
    observableProto.delay = function () {
        if (typeof arguments[0] === 'number' || arguments[0] instanceof Date) {
            var dueTime = arguments[0], scheduler = arguments[1];
            isScheduler(scheduler) || (scheduler = timeoutScheduler);
            return dueTime instanceof Date ? observableDelayAbsolute(this, dueTime, scheduler) : observableDelayRelative(this, dueTime, scheduler);
        } else if (isFunction(arguments[0])) {
            return delayWithSelector(this, arguments[0], arguments[1]);
        } else {
            throw new Error('Invalid arguments');
        }
    };
    function debounce(source, dueTime, scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return new AnonymousObservable(function (observer) {
            var cancelable = new SerialDisposable(), hasvalue = false, value, id = 0;
            var subscription = source.subscribe(function (x) {
                hasvalue = true;
                value = x;
                id++;
                var currentId = id, d = new SingleAssignmentDisposable();
                cancelable.setDisposable(d);
                d.setDisposable(scheduler.scheduleWithRelative(dueTime, function () {
                    hasvalue && id === currentId && observer.onNext(value);
                    hasvalue = false;
                }));
            }, function (e) {
                cancelable.dispose();
                observer.onError(e);
                hasvalue = false;
                id++;
            }, function () {
                cancelable.dispose();
                hasvalue && observer.onNext(value);
                observer.onCompleted();
                hasvalue = false;
                id++;
            });
            return new CompositeDisposable(subscription, cancelable);
        }, this);
    }
    function debounceWithSelector(source, durationSelector) {
        return new AnonymousObservable(function (o) {
            var value, hasValue = false, cancelable = new SerialDisposable(), id = 0;
            var subscription = source.subscribe(function (x) {
                var throttle = tryCatch(durationSelector)(x);
                if (throttle === errorObj) {
                    return o.onError(throttle.e);
                }
                isPromise(throttle) && (throttle = observableFromPromise(throttle));
                hasValue = true;
                value = x;
                id++;
                var currentid = id, d = new SingleAssignmentDisposable();
                cancelable.setDisposable(d);
                d.setDisposable(throttle.subscribe(function () {
                    hasValue && id === currentid && o.onNext(value);
                    hasValue = false;
                    d.dispose();
                }, function (e) {
                    o.onError(e);
                }, function () {
                    hasValue && id === currentid && o.onNext(value);
                    hasValue = false;
                    d.dispose();
                }));
            }, function (e) {
                cancelable.dispose();
                o.onError(e);
                hasValue = false;
                id++;
            }, function () {
                cancelable.dispose();
                hasValue && o.onNext(value);
                o.onCompleted();
                hasValue = false;
                id++;
            });
            return new CompositeDisposable(subscription, cancelable);
        }, source);
    }
    observableProto.debounce = function () {
        if (isFunction(arguments[0])) {
            return debounceWithSelector(this, arguments[0]);
        } else if (typeof arguments[0] === 'number') {
            return debounce(this, arguments[0], arguments[1]);
        } else {
            throw new Error('Invalid arguments');
        }
    };
    observableProto.timestamp = function (scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return this.map(function (x) {
            return {
                value: x,
                timestamp: scheduler.now()
            };
        });
    };
    function sampleObservable(source, sampler) {
        return new AnonymousObservable(function (o) {
            var atEnd = false, value, hasValue = false;
            function sampleSubscribe() {
                if (hasValue) {
                    hasValue = false;
                    o.onNext(value);
                }
                atEnd && o.onCompleted();
            }
            var sourceSubscription = new SingleAssignmentDisposable();
            sourceSubscription.setDisposable(source.subscribe(function (newValue) {
                hasValue = true;
                value = newValue;
            }, function (e) {
                o.onError(e);
            }, function () {
                atEnd = true;
                sourceSubscription.dispose();
            }));
            return new CompositeDisposable(sourceSubscription, sampler.subscribe(sampleSubscribe, function (e) {
                o.onError(e);
            }, sampleSubscribe));
        }, source);
    }
    observableProto.sample = observableProto.throttleLatest = function (intervalOrSampler, scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        return typeof intervalOrSampler === 'number' ? sampleObservable(this, observableinterval(intervalOrSampler, scheduler)) : sampleObservable(this, intervalOrSampler);
    };
    var TimeoutError = Rx.TimeoutError = function (message) {
        this.message = message || 'Timeout has occurred';
        this.name = 'TimeoutError';
        Error.call(this);
    };
    TimeoutError.prototype = Object.create(Error.prototype);
    function timeoutWithSelector(source, firstTimeout, timeoutDurationSelector, other) {
        if (isFunction(firstTimeout)) {
            other = timeoutDurationSelector;
            timeoutDurationSelector = firstTimeout;
            firstTimeout = observableNever();
        }
        other || (other = observableThrow(new TimeoutError()));
        return new AnonymousObservable(function (o) {
            var subscription = new SerialDisposable(), timer = new SerialDisposable(), original = new SingleAssignmentDisposable();
            subscription.setDisposable(original);
            var id = 0, switched = false;
            function setTimer(timeout) {
                var myId = id, d = new SingleAssignmentDisposable();
                timer.setDisposable(d);
                d.setDisposable(timeout.subscribe(function () {
                    id === myId && subscription.setDisposable(other.subscribe(o));
                    d.dispose();
                }, function (e) {
                    id === myId && o.onError(e);
                }, function () {
                    id === myId && subscription.setDisposable(other.subscribe(o));
                }));
            }
            ;
            setTimer(firstTimeout);
            function oWins() {
                var res = !switched;
                if (res) {
                    id++;
                }
                return res;
            }
            original.setDisposable(source.subscribe(function (x) {
                if (oWins()) {
                    o.onNext(x);
                    var timeout = tryCatch(timeoutDurationSelector)(x);
                    if (timeout === errorObj) {
                        return o.onError(timeout.e);
                    }
                    setTimer(isPromise(timeout) ? observableFromPromise(timeout) : timeout);
                }
            }, function (e) {
                oWins() && o.onError(e);
            }, function () {
                oWins() && o.onCompleted();
            }));
            return new CompositeDisposable(subscription, timer);
        }, source);
    }
    function timeout(source, dueTime, other, scheduler) {
        if (other == null) {
            throw new Error('other or scheduler must be specified');
        }
        if (isScheduler(other)) {
            scheduler = other;
            other = observableThrow(new TimeoutError());
        }
        if (other instanceof Error) {
            other = observableThrow(other);
        }
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        var schedulerMethod = dueTime instanceof Date ? 'scheduleWithAbsolute' : 'scheduleWithRelative';
        return new AnonymousObservable(function (o) {
            var id = 0, original = new SingleAssignmentDisposable(), subscription = new SerialDisposable(), switched = false, timer = new SerialDisposable();
            subscription.setDisposable(original);
            function createTimer() {
                var myId = id;
                timer.setDisposable(scheduler[schedulerMethod](dueTime, function () {
                    if (id === myId) {
                        isPromise(other) && (other = observableFromPromise(other));
                        subscription.setDisposable(other.subscribe(o));
                    }
                }));
            }
            createTimer();
            original.setDisposable(source.subscribe(function (x) {
                if (!switched) {
                    id++;
                    o.onNext(x);
                    createTimer();
                }
            }, function (e) {
                if (!switched) {
                    id++;
                    o.onError(e);
                }
            }, function () {
                if (!switched) {
                    id++;
                    o.onCompleted();
                }
            }));
            return new CompositeDisposable(subscription, timer);
        }, source);
    }
    observableProto.timeout = function () {
        var firstArg = arguments[0];
        if (firstArg instanceof Date || typeof firstArg === 'number') {
            return timeout(this, firstArg, arguments[1], arguments[2]);
        } else if (Observable.isObservable(firstArg) || isFunction(firstArg)) {
            return timeoutWithSelector(this, firstArg, arguments[1], arguments[2]);
        } else {
            throw new Error('Invalid arguments');
        }
    };
    observableProto.throttle = function (windowDuration, scheduler) {
        isScheduler(scheduler) || (scheduler = timeoutScheduler);
        var duration = +windowDuration || 0;
        if (duration <= 0) {
            throw new RangeError('windowDuration cannot be less or equal zero.');
        }
        var source = this;
        return new AnonymousObservable(function (o) {
            var lastOnNext = 0;
            return source.subscribe(function (x) {
                var now = scheduler.now();
                if (lastOnNext === 0 || now - lastOnNext >= duration) {
                    lastOnNext = now;
                    o.onNext(x);
                }
            }, function (e) {
                o.onError(e);
            }, function () {
                o.onCompleted();
            });
        }, source);
    };
    var PausableObservable = function (__super__) {
        inherits(PausableObservable, __super__);
        function subscribe(observer) {
            var conn = this.source.publish(), subscription = conn.subscribe(observer), connection = disposableEmpty;
            var pausable = this.pauser.distinctUntilChanged().subscribe(function (b) {
                if (b) {
                    connection = conn.connect();
                } else {
                    connection.dispose();
                    connection = disposableEmpty;
                }
            });
            return new CompositeDisposable(subscription, connection, pausable);
        }
        function PausableObservable(source, pauser) {
            this.source = source;
            this.controller = new Subject();
            if (pauser && pauser.subscribe) {
                this.pauser = this.controller.merge(pauser);
            } else {
                this.pauser = this.controller;
            }
            __super__.call(this, subscribe, source);
        }
        PausableObservable.prototype.pause = function () {
            this.controller.onNext(false);
        };
        PausableObservable.prototype.resume = function () {
            this.controller.onNext(true);
        };
        return PausableObservable;
    }(Observable);
    observableProto.pausable = function (pauser) {
        return new PausableObservable(this, pauser);
    };
    function combineLatestSource(source, subject, resultSelector) {
        return new AnonymousObservable(function (o) {
            var hasValue = [
                    false,
                    false
                ], hasValueAll = false, isDone = false, values = new Array(2), err;
            function next(x, i) {
                values[i] = x;
                hasValue[i] = true;
                if (hasValueAll || (hasValueAll = hasValue.every(identity))) {
                    if (err) {
                        return o.onError(err);
                    }
                    var res = tryCatch(resultSelector).apply(null, values);
                    if (res === errorObj) {
                        return o.onError(res.e);
                    }
                    o.onNext(res);
                }
                isDone && values[1] && o.onCompleted();
            }
            return new CompositeDisposable(source.subscribe(function (x) {
                next(x, 0);
            }, function (e) {
                if (values[1]) {
                    o.onError(e);
                } else {
                    err = e;
                }
            }, function () {
                isDone = true;
                values[1] && o.onCompleted();
            }), subject.subscribe(function (x) {
                next(x, 1);
            }, function (e) {
                o.onError(e);
            }, function () {
                isDone = true;
                next(true, 1);
            }));
        }, source);
    }
    var PausableBufferedObservable = function (__super__) {
        inherits(PausableBufferedObservable, __super__);
        function subscribe(o) {
            var q = [], previousShouldFire;
            function drainQueue() {
                while (q.length > 0) {
                    o.onNext(q.shift());
                }
            }
            var subscription = combineLatestSource(this.source, this.pauser.startWith(false).distinctUntilChanged(), function (data, shouldFire) {
                return {
                    data: data,
                    shouldFire: shouldFire
                };
            }).subscribe(function (results) {
                if (previousShouldFire !== undefined && results.shouldFire != previousShouldFire) {
                    previousShouldFire = results.shouldFire;
                    if (results.shouldFire) {
                        drainQueue();
                    }
                } else {
                    previousShouldFire = results.shouldFire;
                    if (results.shouldFire) {
                        o.onNext(results.data);
                    } else {
                        q.push(results.data);
                    }
                }
            }, function (err) {
                drainQueue();
                o.onError(err);
            }, function () {
                drainQueue();
                o.onCompleted();
            });
            return subscription;
        }
        function PausableBufferedObservable(source, pauser) {
            this.source = source;
            this.controller = new Subject();
            if (pauser && pauser.subscribe) {
                this.pauser = this.controller.merge(pauser);
            } else {
                this.pauser = this.controller;
            }
            __super__.call(this, subscribe, source);
        }
        PausableBufferedObservable.prototype.pause = function () {
            this.controller.onNext(false);
        };
        PausableBufferedObservable.prototype.resume = function () {
            this.controller.onNext(true);
        };
        return PausableBufferedObservable;
    }(Observable);
    observableProto.pausableBuffered = function (subject) {
        return new PausableBufferedObservable(this, subject);
    };
    var ControlledObservable = function (__super__) {
        inherits(ControlledObservable, __super__);
        function subscribe(observer) {
            return this.source.subscribe(observer);
        }
        function ControlledObservable(source, enableQueue, scheduler) {
            __super__.call(this, subscribe, source);
            this.subject = new ControlledSubject(enableQueue, scheduler);
            this.source = source.multicast(this.subject).refCount();
        }
        ControlledObservable.prototype.request = function (numberOfItems) {
            return this.subject.request(numberOfItems == null ? -1 : numberOfItems);
        };
        return ControlledObservable;
    }(Observable);
    var ControlledSubject = function (__super__) {
        function subscribe(observer) {
            return this.subject.subscribe(observer);
        }
        inherits(ControlledSubject, __super__);
        function ControlledSubject(enableQueue, scheduler) {
            enableQueue == null && (enableQueue = true);
            __super__.call(this, subscribe);
            this.subject = new Subject();
            this.enableQueue = enableQueue;
            this.queue = enableQueue ? [] : null;
            this.requestedCount = 0;
            this.requestedDisposable = null;
            this.error = null;
            this.hasFailed = false;
            this.hasCompleted = false;
            this.scheduler = scheduler || currentThreadScheduler;
        }
        addProperties(ControlledSubject.prototype, Observer, {
            onCompleted: function () {
                this.hasCompleted = true;
                if (!this.enableQueue || this.queue.length === 0) {
                    this.subject.onCompleted();
                    this.disposeCurrentRequest();
                } else {
                    this.queue.push(Notification.createOnCompleted());
                }
            },
            onError: function (error) {
                this.hasFailed = true;
                this.error = error;
                if (!this.enableQueue || this.queue.length === 0) {
                    this.subject.onError(error);
                    this.disposeCurrentRequest();
                } else {
                    this.queue.push(Notification.createOnError(error));
                }
            },
            onNext: function (value) {
                if (this.requestedCount <= 0) {
                    this.enableQueue && this.queue.push(Notification.createOnNext(value));
                } else {
                    this.requestedCount-- === 0 && this.disposeCurrentRequest();
                    this.subject.onNext(value);
                }
            },
            _processRequest: function (numberOfItems) {
                if (this.enableQueue) {
                    while (this.queue.length > 0 && (numberOfItems > 0 || this.queue[0].kind !== 'N')) {
                        var first = this.queue.shift();
                        first.accept(this.subject);
                        if (first.kind === 'N') {
                            numberOfItems--;
                        } else {
                            this.disposeCurrentRequest();
                            this.queue = [];
                        }
                    }
                }
                return numberOfItems;
            },
            request: function (number) {
                this.disposeCurrentRequest();
                var self = this;
                this.requestedDisposable = this.scheduler.scheduleWithState(number, function (s, i) {
                    var remaining = self._processRequest(i);
                    var stopped = self.hasCompleted || self.hasFailed;
                    if (!stopped && remaining > 0) {
                        self.requestedCount = remaining;
                        return disposableCreate(function () {
                            self.requestedCount = 0;
                        });
                    }
                });
                return this.requestedDisposable;
            },
            disposeCurrentRequest: function () {
                if (this.requestedDisposable) {
                    this.requestedDisposable.dispose();
                    this.requestedDisposable = null;
                }
            }
        });
        return ControlledSubject;
    }(Observable);
    observableProto.controlled = function (enableQueue, scheduler) {
        if (enableQueue && isScheduler(enableQueue)) {
            scheduler = enableQueue;
            enableQueue = true;
        }
        if (enableQueue == null) {
            enableQueue = true;
        }
        return new ControlledObservable(this, enableQueue, scheduler);
    };
    observableProto.pipe = function (dest) {
        var source = this.pausableBuffered();
        function onDrain() {
            source.resume();
        }
        dest.addListener('drain', onDrain);
        source.subscribe(function (x) {
            !dest.write(String(x)) && source.pause();
        }, function (err) {
            dest.emit('error', err);
        }, function () {
            !dest._isStdio && dest.end();
            dest.removeListener('drain', onDrain);
        });
        source.resume();
        return dest;
    };
    observableProto.transduce = function (transducer) {
        var source = this;
        function transformForObserver(o) {
            return {
                '@@transducer/init': function () {
                    return o;
                },
                '@@transducer/step': function (obs, input) {
                    return obs.onNext(input);
                },
                '@@transducer/result': function (obs) {
                    return obs.onCompleted();
                }
            };
        }
        return new AnonymousObservable(function (o) {
            var xform = transducer(transformForObserver(o));
            return source.subscribe(function (v) {
                var res = tryCatch(xform['@@transducer/step']).call(xform, o, v);
                if (res === errorObj) {
                    o.onError(res.e);
                }
            }, function (e) {
                o.onError(e);
            }, function () {
                xform['@@transducer/result'](o);
            });
        }, source);
    };
    var AnonymousObservable = Rx.AnonymousObservable = function (__super__) {
        inherits(AnonymousObservable, __super__);
        function fixSubscriber(subscriber) {
            return subscriber && isFunction(subscriber.dispose) ? subscriber : isFunction(subscriber) ? disposableCreate(subscriber) : disposableEmpty;
        }
        function setDisposable(s, state) {
            var ado = state[0], self = state[1];
            var sub = tryCatch(self.__subscribe).call(self, ado);
            if (sub === errorObj) {
                if (!ado.fail(errorObj.e)) {
                    return thrower(errorObj.e);
                }
            }
            ado.setDisposable(fixSubscriber(sub));
        }
        function innerSubscribe(observer) {
            var ado = new AutoDetachObserver(observer), state = [
                    ado,
                    this
                ];
            if (currentThreadScheduler.scheduleRequired()) {
                currentThreadScheduler.scheduleWithState(state, setDisposable);
            } else {
                setDisposable(null, state);
            }
            return ado;
        }
        function AnonymousObservable(subscribe, parent) {
            this.source = parent;
            this.__subscribe = subscribe;
            __super__.call(this, innerSubscribe);
        }
        return AnonymousObservable;
    }(Observable);
    var AutoDetachObserver = function (__super__) {
        inherits(AutoDetachObserver, __super__);
        function AutoDetachObserver(observer) {
            __super__.call(this);
            this.observer = observer;
            this.m = new SingleAssignmentDisposable();
        }
        var AutoDetachObserverPrototype = AutoDetachObserver.prototype;
        AutoDetachObserverPrototype.next = function (value) {
            var result = tryCatch(this.observer.onNext).call(this.observer, value);
            if (result === errorObj) {
                this.dispose();
                thrower(result.e);
            }
        };
        AutoDetachObserverPrototype.error = function (err) {
            var result = tryCatch(this.observer.onError).call(this.observer, err);
            this.dispose();
            result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.completed = function () {
            var result = tryCatch(this.observer.onCompleted).call(this.observer);
            this.dispose();
            result === errorObj && thrower(result.e);
        };
        AutoDetachObserverPrototype.setDisposable = function (value) {
            this.m.setDisposable(value);
        };
        AutoDetachObserverPrototype.getDisposable = function () {
            return this.m.getDisposable();
        };
        AutoDetachObserverPrototype.dispose = function () {
            __super__.prototype.dispose.call(this);
            this.m.dispose();
        };
        return AutoDetachObserver;
    }(AbstractObserver);
    var InnerSubscription = function (subject, observer) {
        this.subject = subject;
        this.observer = observer;
    };
    InnerSubscription.prototype.dispose = function () {
        if (!this.subject.isDisposed && this.observer !== null) {
            var idx = this.subject.observers.indexOf(this.observer);
            this.subject.observers.splice(idx, 1);
            this.observer = null;
        }
    };
    var Subject = Rx.Subject = function (__super__) {
        function subscribe(observer) {
            checkDisposed(this);
            if (!this.isStopped) {
                this.observers.push(observer);
                return new InnerSubscription(this, observer);
            }
            if (this.hasError) {
                observer.onError(this.error);
                return disposableEmpty;
            }
            observer.onCompleted();
            return disposableEmpty;
        }
        inherits(Subject, __super__);
        function Subject() {
            __super__.call(this, subscribe);
            this.isDisposed = false, this.isStopped = false, this.observers = [];
            this.hasError = false;
        }
        addProperties(Subject.prototype, Observer.prototype, {
            hasObservers: function () {
                return this.observers.length > 0;
            },
            onCompleted: function () {
                checkDisposed(this);
                if (!this.isStopped) {
                    this.isStopped = true;
                    for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                        os[i].onCompleted();
                    }
                    this.observers.length = 0;
                }
            },
            onError: function (error) {
                checkDisposed(this);
                if (!this.isStopped) {
                    this.isStopped = true;
                    this.error = error;
                    this.hasError = true;
                    for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                        os[i].onError(error);
                    }
                    this.observers.length = 0;
                }
            },
            onNext: function (value) {
                checkDisposed(this);
                if (!this.isStopped) {
                    for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                        os[i].onNext(value);
                    }
                }
            },
            dispose: function () {
                this.isDisposed = true;
                this.observers = null;
            }
        });
        Subject.create = function (observer, observable) {
            return new AnonymousSubject(observer, observable);
        };
        return Subject;
    }(Observable);
    var AsyncSubject = Rx.AsyncSubject = function (__super__) {
        function subscribe(observer) {
            checkDisposed(this);
            if (!this.isStopped) {
                this.observers.push(observer);
                return new InnerSubscription(this, observer);
            }
            if (this.hasError) {
                observer.onError(this.error);
            } else if (this.hasValue) {
                observer.onNext(this.value);
                observer.onCompleted();
            } else {
                observer.onCompleted();
            }
            return disposableEmpty;
        }
        inherits(AsyncSubject, __super__);
        function AsyncSubject() {
            __super__.call(this, subscribe);
            this.isDisposed = false;
            this.isStopped = false;
            this.hasValue = false;
            this.observers = [];
            this.hasError = false;
        }
        addProperties(AsyncSubject.prototype, Observer, {
            hasObservers: function () {
                checkDisposed(this);
                return this.observers.length > 0;
            },
            onCompleted: function () {
                var i, len;
                checkDisposed(this);
                if (!this.isStopped) {
                    this.isStopped = true;
                    var os = cloneArray(this.observers), len = os.length;
                    if (this.hasValue) {
                        for (i = 0; i < len; i++) {
                            var o = os[i];
                            o.onNext(this.value);
                            o.onCompleted();
                        }
                    } else {
                        for (i = 0; i < len; i++) {
                            os[i].onCompleted();
                        }
                    }
                    this.observers.length = 0;
                }
            },
            onError: function (error) {
                checkDisposed(this);
                if (!this.isStopped) {
                    this.isStopped = true;
                    this.hasError = true;
                    this.error = error;
                    for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                        os[i].onError(error);
                    }
                    this.observers.length = 0;
                }
            },
            onNext: function (value) {
                checkDisposed(this);
                if (this.isStopped) {
                    return;
                }
                this.value = value;
                this.hasValue = true;
            },
            dispose: function () {
                this.isDisposed = true;
                this.observers = null;
                this.exception = null;
                this.value = null;
            }
        });
        return AsyncSubject;
    }(Observable);
    var AnonymousSubject = Rx.AnonymousSubject = function (__super__) {
        inherits(AnonymousSubject, __super__);
        function subscribe(observer) {
            return this.observable.subscribe(observer);
        }
        function AnonymousSubject(observer, observable) {
            this.observer = observer;
            this.observable = observable;
            __super__.call(this, subscribe);
        }
        addProperties(AnonymousSubject.prototype, Observer.prototype, {
            onCompleted: function () {
                this.observer.onCompleted();
            },
            onError: function (error) {
                this.observer.onError(error);
            },
            onNext: function (value) {
                this.observer.onNext(value);
            }
        });
        return AnonymousSubject;
    }(Observable);
    var BehaviorSubject = Rx.BehaviorSubject = function (__super__) {
        function subscribe(observer) {
            checkDisposed(this);
            if (!this.isStopped) {
                this.observers.push(observer);
                observer.onNext(this.value);
                return new InnerSubscription(this, observer);
            }
            if (this.hasError) {
                observer.onError(this.error);
            } else {
                observer.onCompleted();
            }
            return disposableEmpty;
        }
        inherits(BehaviorSubject, __super__);
        function BehaviorSubject(value) {
            __super__.call(this, subscribe);
            this.value = value, this.observers = [], this.isDisposed = false, this.isStopped = false, this.hasError = false;
        }
        addProperties(BehaviorSubject.prototype, Observer, {
            getValue: function () {
                checkDisposed(this);
                if (this.hasError) {
                    throw this.error;
                }
                return this.value;
            },
            hasObservers: function () {
                return this.observers.length > 0;
            },
            onCompleted: function () {
                checkDisposed(this);
                if (this.isStopped) {
                    return;
                }
                this.isStopped = true;
                for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                    os[i].onCompleted();
                }
                this.observers.length = 0;
            },
            onError: function (error) {
                checkDisposed(this);
                if (this.isStopped) {
                    return;
                }
                this.isStopped = true;
                this.hasError = true;
                this.error = error;
                for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                    os[i].onError(error);
                }
                this.observers.length = 0;
            },
            onNext: function (value) {
                checkDisposed(this);
                if (this.isStopped) {
                    return;
                }
                this.value = value;
                for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                    os[i].onNext(value);
                }
            },
            dispose: function () {
                this.isDisposed = true;
                this.observers = null;
                this.value = null;
                this.exception = null;
            }
        });
        return BehaviorSubject;
    }(Observable);
    var ReplaySubject = Rx.ReplaySubject = function (__super__) {
        var maxSafeInteger = Math.pow(2, 53) - 1;
        function createRemovableDisposable(subject, observer) {
            return disposableCreate(function () {
                observer.dispose();
                !subject.isDisposed && subject.observers.splice(subject.observers.indexOf(observer), 1);
            });
        }
        function subscribe(observer) {
            var so = new ScheduledObserver(this.scheduler, observer), subscription = createRemovableDisposable(this, so);
            checkDisposed(this);
            this._trim(this.scheduler.now());
            this.observers.push(so);
            for (var i = 0, len = this.q.length; i < len; i++) {
                so.onNext(this.q[i].value);
            }
            if (this.hasError) {
                so.onError(this.error);
            } else if (this.isStopped) {
                so.onCompleted();
            }
            so.ensureActive();
            return subscription;
        }
        inherits(ReplaySubject, __super__);
        function ReplaySubject(bufferSize, windowSize, scheduler) {
            this.bufferSize = bufferSize == null ? maxSafeInteger : bufferSize;
            this.windowSize = windowSize == null ? maxSafeInteger : windowSize;
            this.scheduler = scheduler || currentThreadScheduler;
            this.q = [];
            this.observers = [];
            this.isStopped = false;
            this.isDisposed = false;
            this.hasError = false;
            this.error = null;
            __super__.call(this, subscribe);
        }
        addProperties(ReplaySubject.prototype, Observer.prototype, {
            hasObservers: function () {
                return this.observers.length > 0;
            },
            _trim: function (now) {
                while (this.q.length > this.bufferSize) {
                    this.q.shift();
                }
                while (this.q.length > 0 && now - this.q[0].interval > this.windowSize) {
                    this.q.shift();
                }
            },
            onNext: function (value) {
                checkDisposed(this);
                if (this.isStopped) {
                    return;
                }
                var now = this.scheduler.now();
                this.q.push({
                    interval: now,
                    value: value
                });
                this._trim(now);
                for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                    var observer = os[i];
                    observer.onNext(value);
                    observer.ensureActive();
                }
            },
            onError: function (error) {
                checkDisposed(this);
                if (this.isStopped) {
                    return;
                }
                this.isStopped = true;
                this.error = error;
                this.hasError = true;
                var now = this.scheduler.now();
                this._trim(now);
                for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                    var observer = os[i];
                    observer.onError(error);
                    observer.ensureActive();
                }
                this.observers.length = 0;
            },
            onCompleted: function () {
                checkDisposed(this);
                if (this.isStopped) {
                    return;
                }
                this.isStopped = true;
                var now = this.scheduler.now();
                this._trim(now);
                for (var i = 0, os = cloneArray(this.observers), len = os.length; i < len; i++) {
                    var observer = os[i];
                    observer.onCompleted();
                    observer.ensureActive();
                }
                this.observers.length = 0;
            },
            dispose: function () {
                this.isDisposed = true;
                this.observers = null;
            }
        });
        return ReplaySubject;
    }(Observable);
    Rx.Pauser = function (__super__) {
        inherits(Pauser, __super__);
        function Pauser() {
            __super__.call(this);
        }
        Pauser.prototype.pause = function () {
            this.onNext(false);
        };
        Pauser.prototype.resume = function () {
            this.onNext(true);
        };
        return Pauser;
    }(Subject);
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root.Rx = Rx;
        define(function () {
            return Rx;
        });
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = Rx).Rx = Rx;
        } else {
            freeExports.Rx = Rx;
        }
    } else {
        root.Rx = Rx;
    }
    var rEndingLine = captureLine();
}.call(this));
}).call(this,require(251),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"251":251}],267:[function(require,module,exports){
(function (Buffer){
;
(function (sax) {
    sax.parser = function (strict, opt) {
        return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
        'comment',
        'sgmlDecl',
        'textNode',
        'tagName',
        'doctype',
        'procInstName',
        'procInstBody',
        'entity',
        'attribName',
        'attribValue',
        'cdata',
        'script'
    ];
    sax.EVENTS = [
        'text',
        'processinginstruction',
        'sgmldeclaration',
        'doctype',
        'comment',
        'opentagstart',
        'attribute',
        'opentag',
        'closetag',
        'opencdata',
        'cdata',
        'closecdata',
        'error',
        'end',
        'ready',
        'script',
        'opennamespace',
        'closenamespace'
    ];
    function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = '';
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
        }
        emit(parser, 'onready');
    }
    if (!Object.create) {
        Object.create = function (o) {
            function F() {
            }
            F.prototype = o;
            var newf = new F();
            return newf;
        };
    }
    if (!Object.keys) {
        Object.keys = function (o) {
            var a = [];
            for (var i in o)
                if (o.hasOwnProperty(i))
                    a.push(i);
            return a;
        };
    }
    function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) {
                switch (buffers[i]) {
                case 'textNode':
                    closeText(parser);
                    break;
                case 'cdata':
                    emitNode(parser, 'oncdata', parser.cdata);
                    parser.cdata = '';
                    break;
                case 'script':
                    emitNode(parser, 'onscript', parser.script);
                    parser.script = '';
                    break;
                default:
                    error(parser, 'Max buffer length exceeded: ' + buffers[i]);
                }
            }
            maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
            parser[buffers[i]] = '';
        }
    }
    function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== '') {
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
        }
        if (parser.script !== '') {
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
    }
    SAXParser.prototype = {
        end: function () {
            end(this);
        },
        write: write,
        resume: function () {
            this.error = null;
            return this;
        },
        close: function () {
            return this.write(null);
        },
        flush: function () {
            flushBuffers(this);
        }
    };
    var Stream;
    try {
        Stream = require(268).Stream;
    } catch (ex) {
        Stream = function () {
        };
    }
    var streamWraps = sax.EVENTS.filter(function (ev) {
        return ev !== 'error' && ev !== 'end';
    });
    function createStream(strict, opt) {
        return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
            return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function () {
            me.emit('end');
        };
        this._parser.onerror = function (er) {
            me.emit('error', er);
            me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function (ev) {
            Object.defineProperty(me, 'on' + ev, {
                get: function () {
                    return me._parser['on' + ev];
                },
                set: function (h) {
                    if (!h) {
                        me.removeAllListeners(ev);
                        me._parser['on' + ev] = h;
                        return h;
                    }
                    me.on(ev, h);
                },
                enumerable: true,
                configurable: false
            });
        });
    }
    SAXStream.prototype = Object.create(Stream.prototype, { constructor: { value: SAXStream } });
    SAXStream.prototype.write = function (data) {
        if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
            if (!this._decoder) {
                var SD = require(269).StringDecoder;
                this._decoder = new SD('utf8');
            }
            data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit('data', data);
        return true;
    };
    SAXStream.prototype.end = function (chunk) {
        if (chunk && chunk.length) {
            this.write(chunk);
        }
        this._parser.end();
        return true;
    };
    SAXStream.prototype.on = function (ev, handler) {
        var me = this;
        if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
            me._parser['on' + ev] = function () {
                var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
                args.splice(0, 0, ev);
                me.emit.apply(me, args);
            };
        }
        return Stream.prototype.on.call(me, ev, handler);
    };
    var whitespace = '\r\n\t ';
    var quote = '\'"';
    var attribEnd = whitespace + '>';
    var CDATA = '[CDATA[';
    var DOCTYPE = 'DOCTYPE';
    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
    var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
    var rootNS = {
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
    };
    whitespace = charClass(whitespace);
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    quote = charClass(quote);
    attribEnd = charClass(attribEnd);
    function charClass(str) {
        return str.split('').reduce(function (s, c) {
            s[c] = true;
            return s;
        }, {});
    }
    function isMatch(regex, c) {
        return regex.test(c);
    }
    function is(charclass, c) {
        return charclass[c];
    }
    function notMatch(regex, c) {
        return !isMatch(regex, c);
    }
    function not(charclass, c) {
        return !is(charclass, c);
    }
    var S = 0;
    sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++
    };
    sax.XML_ENTITIES = {
        'amp': '&',
        'gt': '>',
        'lt': '<',
        'quot': '"',
        'apos': '\''
    };
    sax.ENTITIES = {
        'amp': '&',
        'gt': '>',
        'lt': '<',
        'quot': '"',
        'apos': '\'',
        'AElig': 198,
        'Aacute': 193,
        'Acirc': 194,
        'Agrave': 192,
        'Aring': 197,
        'Atilde': 195,
        'Auml': 196,
        'Ccedil': 199,
        'ETH': 208,
        'Eacute': 201,
        'Ecirc': 202,
        'Egrave': 200,
        'Euml': 203,
        'Iacute': 205,
        'Icirc': 206,
        'Igrave': 204,
        'Iuml': 207,
        'Ntilde': 209,
        'Oacute': 211,
        'Ocirc': 212,
        'Ograve': 210,
        'Oslash': 216,
        'Otilde': 213,
        'Ouml': 214,
        'THORN': 222,
        'Uacute': 218,
        'Ucirc': 219,
        'Ugrave': 217,
        'Uuml': 220,
        'Yacute': 221,
        'aacute': 225,
        'acirc': 226,
        'aelig': 230,
        'agrave': 224,
        'aring': 229,
        'atilde': 227,
        'auml': 228,
        'ccedil': 231,
        'eacute': 233,
        'ecirc': 234,
        'egrave': 232,
        'eth': 240,
        'euml': 235,
        'iacute': 237,
        'icirc': 238,
        'igrave': 236,
        'iuml': 239,
        'ntilde': 241,
        'oacute': 243,
        'ocirc': 244,
        'ograve': 242,
        'oslash': 248,
        'otilde': 245,
        'ouml': 246,
        'szlig': 223,
        'thorn': 254,
        'uacute': 250,
        'ucirc': 251,
        'ugrave': 249,
        'uuml': 252,
        'yacute': 253,
        'yuml': 255,
        'copy': 169,
        'reg': 174,
        'nbsp': 160,
        'iexcl': 161,
        'cent': 162,
        'pound': 163,
        'curren': 164,
        'yen': 165,
        'brvbar': 166,
        'sect': 167,
        'uml': 168,
        'ordf': 170,
        'laquo': 171,
        'not': 172,
        'shy': 173,
        'macr': 175,
        'deg': 176,
        'plusmn': 177,
        'sup1': 185,
        'sup2': 178,
        'sup3': 179,
        'acute': 180,
        'micro': 181,
        'para': 182,
        'middot': 183,
        'cedil': 184,
        'ordm': 186,
        'raquo': 187,
        'frac14': 188,
        'frac12': 189,
        'frac34': 190,
        'iquest': 191,
        'times': 215,
        'divide': 247,
        'OElig': 338,
        'oelig': 339,
        'Scaron': 352,
        'scaron': 353,
        'Yuml': 376,
        'fnof': 402,
        'circ': 710,
        'tilde': 732,
        'Alpha': 913,
        'Beta': 914,
        'Gamma': 915,
        'Delta': 916,
        'Epsilon': 917,
        'Zeta': 918,
        'Eta': 919,
        'Theta': 920,
        'Iota': 921,
        'Kappa': 922,
        'Lambda': 923,
        'Mu': 924,
        'Nu': 925,
        'Xi': 926,
        'Omicron': 927,
        'Pi': 928,
        'Rho': 929,
        'Sigma': 931,
        'Tau': 932,
        'Upsilon': 933,
        'Phi': 934,
        'Chi': 935,
        'Psi': 936,
        'Omega': 937,
        'alpha': 945,
        'beta': 946,
        'gamma': 947,
        'delta': 948,
        'epsilon': 949,
        'zeta': 950,
        'eta': 951,
        'theta': 952,
        'iota': 953,
        'kappa': 954,
        'lambda': 955,
        'mu': 956,
        'nu': 957,
        'xi': 958,
        'omicron': 959,
        'pi': 960,
        'rho': 961,
        'sigmaf': 962,
        'sigma': 963,
        'tau': 964,
        'upsilon': 965,
        'phi': 966,
        'chi': 967,
        'psi': 968,
        'omega': 969,
        'thetasym': 977,
        'upsih': 978,
        'piv': 982,
        'ensp': 8194,
        'emsp': 8195,
        'thinsp': 8201,
        'zwnj': 8204,
        'zwj': 8205,
        'lrm': 8206,
        'rlm': 8207,
        'ndash': 8211,
        'mdash': 8212,
        'lsquo': 8216,
        'rsquo': 8217,
        'sbquo': 8218,
        'ldquo': 8220,
        'rdquo': 8221,
        'bdquo': 8222,
        'dagger': 8224,
        'Dagger': 8225,
        'bull': 8226,
        'hellip': 8230,
        'permil': 8240,
        'prime': 8242,
        'Prime': 8243,
        'lsaquo': 8249,
        'rsaquo': 8250,
        'oline': 8254,
        'frasl': 8260,
        'euro': 8364,
        'image': 8465,
        'weierp': 8472,
        'real': 8476,
        'trade': 8482,
        'alefsym': 8501,
        'larr': 8592,
        'uarr': 8593,
        'rarr': 8594,
        'darr': 8595,
        'harr': 8596,
        'crarr': 8629,
        'lArr': 8656,
        'uArr': 8657,
        'rArr': 8658,
        'dArr': 8659,
        'hArr': 8660,
        'forall': 8704,
        'part': 8706,
        'exist': 8707,
        'empty': 8709,
        'nabla': 8711,
        'isin': 8712,
        'notin': 8713,
        'ni': 8715,
        'prod': 8719,
        'sum': 8721,
        'minus': 8722,
        'lowast': 8727,
        'radic': 8730,
        'prop': 8733,
        'infin': 8734,
        'ang': 8736,
        'and': 8743,
        'or': 8744,
        'cap': 8745,
        'cup': 8746,
        'int': 8747,
        'there4': 8756,
        'sim': 8764,
        'cong': 8773,
        'asymp': 8776,
        'ne': 8800,
        'equiv': 8801,
        'le': 8804,
        'ge': 8805,
        'sub': 8834,
        'sup': 8835,
        'nsub': 8836,
        'sube': 8838,
        'supe': 8839,
        'oplus': 8853,
        'otimes': 8855,
        'perp': 8869,
        'sdot': 8901,
        'lceil': 8968,
        'rceil': 8969,
        'lfloor': 8970,
        'rfloor': 8971,
        'lang': 9001,
        'rang': 9002,
        'loz': 9674,
        'spades': 9824,
        'clubs': 9827,
        'hearts': 9829,
        'diams': 9830
    };
    Object.keys(sax.ENTITIES).forEach(function (key) {
        var e = sax.ENTITIES[key];
        var s = typeof e === 'number' ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s;
    });
    for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
    }
    S = sax.STATE;
    function emit(parser, event, data) {
        parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
        if (parser.textNode)
            closeText(parser);
        emit(parser, nodeType, data);
    }
    function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode)
            emit(parser, 'ontext', parser.textNode);
        parser.textNode = '';
    }
    function textopts(opt, text) {
        if (opt.trim)
            text = text.trim();
        if (opt.normalize)
            text = text.replace(/\s+/g, ' ');
        return text;
    }
    function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
            er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, 'onerror', er);
        return parser;
    }
    function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
            strictFail(parser, 'Unclosed root tag');
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
            error(parser, 'Unexpected end');
        }
        closeText(parser);
        parser.c = '';
        parser.closed = true;
        emit(parser, 'onend');
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
    }
    function strictFail(parser, message) {
        if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
            throw new Error('bad call to strictFail');
        }
        if (parser.strict) {
            error(parser, message);
        }
    }
    function newTag(parser) {
        if (!parser.strict)
            parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = {
            name: parser.tagName,
            attributes: {}
        };
        if (parser.opt.xmlns) {
            tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, 'onopentagstart', tag);
    }
    function qname(name, attribute) {
        var i = name.indexOf(':');
        var qualName = i < 0 ? [
            '',
            name
        ] : name.split(':');
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === 'xmlns') {
            prefix = 'xmlns';
            local = '';
        }
        return {
            prefix: prefix,
            local: local
        };
    }
    function attrib(parser) {
        if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = '';
            return;
        }
        if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === 'xmlns') {
                if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
                    strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
                    strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                } else {
                    var tag = parser.tag;
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns === parent.ns) {
                        tag.ns = Object.create(parent.ns);
                    }
                    tag.ns[local] = parser.attribValue;
                }
            }
            parser.attribList.push([
                parser.attribName,
                parser.attribValue
            ]);
        } else {
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, 'onattribute', {
                name: parser.attribName,
                value: parser.attribValue
            });
        }
        parser.attribName = parser.attribValue = '';
    }
    function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
            var tag = parser.tag;
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || '';
            if (tag.prefix && !tag.uri) {
                strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
                tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
                Object.keys(tag.ns).forEach(function (p) {
                    emitNode(parser, 'onopennamespace', {
                        prefix: p,
                        uri: tag.ns[p]
                    });
                });
            }
            for (var i = 0, l = parser.attribList.length; i < l; i++) {
                var nv = parser.attribList[i];
                var name = nv[0];
                var value = nv[1];
                var qualName = qname(name, true);
                var prefix = qualName.prefix;
                var local = qualName.local;
                var uri = prefix === '' ? '' : tag.ns[prefix] || '';
                var a = {
                    name: name,
                    value: value,
                    prefix: prefix,
                    local: local,
                    uri: uri
                };
                if (prefix && prefix !== 'xmlns' && !uri) {
                    strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
                    a.uri = prefix;
                }
                parser.tag.attributes[name] = a;
                emitNode(parser, 'onattribute', a);
            }
            parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, 'onopentag', parser.tag);
        if (!selfClosing) {
            if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
                parser.state = S.SCRIPT;
            } else {
                parser.state = S.TEXT;
            }
            parser.tag = null;
            parser.tagName = '';
        }
        parser.attribName = parser.attribValue = '';
        parser.attribList.length = 0;
    }
    function closeTag(parser) {
        if (!parser.tagName) {
            strictFail(parser, 'Weird empty close tag.');
            parser.textNode += '</>';
            parser.state = S.TEXT;
            return;
        }
        if (parser.script) {
            if (parser.tagName !== 'script') {
                parser.script += '</' + parser.tagName + '>';
                parser.tagName = '';
                parser.state = S.SCRIPT;
                return;
            }
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
            var close = parser.tags[t];
            if (close.name !== closeTo) {
                strictFail(parser, 'Unexpected close tag');
            } else {
                break;
            }
        }
        if (t < 0) {
            strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
            parser.textNode += '</' + parser.tagName + '>';
            parser.state = S.TEXT;
            return;
        }
        parser.tagName = tagName;
        var s = parser.tags.length;
        while (s-- > t) {
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, 'onclosetag', parser.tagName);
            var x = {};
            for (var i in tag.ns) {
                x[i] = tag.ns[i];
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
                Object.keys(tag.ns).forEach(function (p) {
                    var n = tag.ns[p];
                    emitNode(parser, 'onclosenamespace', {
                        prefix: p,
                        uri: n
                    });
                });
            }
        }
        if (t === 0)
            parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = '';
        parser.attribList.length = 0;
        parser.state = S.TEXT;
    }
    function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = '';
        if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === '#') {
            if (entity.charAt(1) === 'x') {
                entity = entity.slice(2);
                num = parseInt(entity, 16);
                numStr = num.toString(16);
            } else {
                entity = entity.slice(1);
                num = parseInt(entity, 10);
                numStr = num.toString(10);
            }
        }
        entity = entity.replace(/^0+/, '');
        if (numStr.toLowerCase() !== entity) {
            strictFail(parser, 'Invalid character entity');
            return '&' + parser.entity + ';';
        }
        return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
        if (c === '<') {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
        } else if (not(whitespace, c)) {
            strictFail(parser, 'Non-whitespace before first tag.');
            parser.textNode = c;
            parser.state = S.TEXT;
        }
    }
    function charAt(chunk, i) {
        var result = '';
        if (i < chunk.length) {
            result = chunk.charAt(i);
        }
        return result;
    }
    function write(chunk) {
        var parser = this;
        if (this.error) {
            throw this.error;
        }
        if (parser.closed) {
            return error(parser, 'Cannot write after close. Assign an onready handler.');
        }
        if (chunk === null) {
            return end(parser);
        }
        if (typeof chunk === 'object') {
            chunk = chunk.toString();
        }
        var i = 0;
        var c = '';
        while (true) {
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) {
                break;
            }
            if (parser.trackPosition) {
                parser.position++;
                if (c === '\n') {
                    parser.line++;
                    parser.column = 0;
                } else {
                    parser.column++;
                }
            }
            switch (parser.state) {
            case S.BEGIN:
                parser.state = S.BEGIN_WHITESPACE;
                if (c === '\uFEFF') {
                    continue;
                }
                beginWhiteSpace(parser, c);
                continue;
            case S.BEGIN_WHITESPACE:
                beginWhiteSpace(parser, c);
                continue;
            case S.TEXT:
                if (parser.sawRoot && !parser.closedRoot) {
                    var starti = i - 1;
                    while (c && c !== '<' && c !== '&') {
                        c = charAt(chunk, i++);
                        if (c && parser.trackPosition) {
                            parser.position++;
                            if (c === '\n') {
                                parser.line++;
                                parser.column = 0;
                            } else {
                                parser.column++;
                            }
                        }
                    }
                    parser.textNode += chunk.substring(starti, i - 1);
                }
                if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                    parser.state = S.OPEN_WAKA;
                    parser.startTagPosition = parser.position;
                } else {
                    if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
                        strictFail(parser, 'Text data outside of root node.');
                    }
                    if (c === '&') {
                        parser.state = S.TEXT_ENTITY;
                    } else {
                        parser.textNode += c;
                    }
                }
                continue;
            case S.SCRIPT:
                if (c === '<') {
                    parser.state = S.SCRIPT_ENDING;
                } else {
                    parser.script += c;
                }
                continue;
            case S.SCRIPT_ENDING:
                if (c === '/') {
                    parser.state = S.CLOSE_TAG;
                } else {
                    parser.script += '<' + c;
                    parser.state = S.SCRIPT;
                }
                continue;
            case S.OPEN_WAKA:
                if (c === '!') {
                    parser.state = S.SGML_DECL;
                    parser.sgmlDecl = '';
                } else if (is(whitespace, c)) {
                } else if (isMatch(nameStart, c)) {
                    parser.state = S.OPEN_TAG;
                    parser.tagName = c;
                } else if (c === '/') {
                    parser.state = S.CLOSE_TAG;
                    parser.tagName = '';
                } else if (c === '?') {
                    parser.state = S.PROC_INST;
                    parser.procInstName = parser.procInstBody = '';
                } else {
                    strictFail(parser, 'Unencoded <');
                    if (parser.startTagPosition + 1 < parser.position) {
                        var pad = parser.position - parser.startTagPosition;
                        c = new Array(pad).join(' ') + c;
                    }
                    parser.textNode += '<' + c;
                    parser.state = S.TEXT;
                }
                continue;
            case S.SGML_DECL:
                if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                    emitNode(parser, 'onopencdata');
                    parser.state = S.CDATA;
                    parser.sgmlDecl = '';
                    parser.cdata = '';
                } else if (parser.sgmlDecl + c === '--') {
                    parser.state = S.COMMENT;
                    parser.comment = '';
                    parser.sgmlDecl = '';
                } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                    parser.state = S.DOCTYPE;
                    if (parser.doctype || parser.sawRoot) {
                        strictFail(parser, 'Inappropriately located doctype declaration');
                    }
                    parser.doctype = '';
                    parser.sgmlDecl = '';
                } else if (c === '>') {
                    emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                    parser.sgmlDecl = '';
                    parser.state = S.TEXT;
                } else if (is(quote, c)) {
                    parser.state = S.SGML_DECL_QUOTED;
                    parser.sgmlDecl += c;
                } else {
                    parser.sgmlDecl += c;
                }
                continue;
            case S.SGML_DECL_QUOTED:
                if (c === parser.q) {
                    parser.state = S.SGML_DECL;
                    parser.q = '';
                }
                parser.sgmlDecl += c;
                continue;
            case S.DOCTYPE:
                if (c === '>') {
                    parser.state = S.TEXT;
                    emitNode(parser, 'ondoctype', parser.doctype);
                    parser.doctype = true;
                } else {
                    parser.doctype += c;
                    if (c === '[') {
                        parser.state = S.DOCTYPE_DTD;
                    } else if (is(quote, c)) {
                        parser.state = S.DOCTYPE_QUOTED;
                        parser.q = c;
                    }
                }
                continue;
            case S.DOCTYPE_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                    parser.q = '';
                    parser.state = S.DOCTYPE;
                }
                continue;
            case S.DOCTYPE_DTD:
                parser.doctype += c;
                if (c === ']') {
                    parser.state = S.DOCTYPE;
                } else if (is(quote, c)) {
                    parser.state = S.DOCTYPE_DTD_QUOTED;
                    parser.q = c;
                }
                continue;
            case S.DOCTYPE_DTD_QUOTED:
                parser.doctype += c;
                if (c === parser.q) {
                    parser.state = S.DOCTYPE_DTD;
                    parser.q = '';
                }
                continue;
            case S.COMMENT:
                if (c === '-') {
                    parser.state = S.COMMENT_ENDING;
                } else {
                    parser.comment += c;
                }
                continue;
            case S.COMMENT_ENDING:
                if (c === '-') {
                    parser.state = S.COMMENT_ENDED;
                    parser.comment = textopts(parser.opt, parser.comment);
                    if (parser.comment) {
                        emitNode(parser, 'oncomment', parser.comment);
                    }
                    parser.comment = '';
                } else {
                    parser.comment += '-' + c;
                    parser.state = S.COMMENT;
                }
                continue;
            case S.COMMENT_ENDED:
                if (c !== '>') {
                    strictFail(parser, 'Malformed comment');
                    parser.comment += '--' + c;
                    parser.state = S.COMMENT;
                } else {
                    parser.state = S.TEXT;
                }
                continue;
            case S.CDATA:
                if (c === ']') {
                    parser.state = S.CDATA_ENDING;
                } else {
                    parser.cdata += c;
                }
                continue;
            case S.CDATA_ENDING:
                if (c === ']') {
                    parser.state = S.CDATA_ENDING_2;
                } else {
                    parser.cdata += ']' + c;
                    parser.state = S.CDATA;
                }
                continue;
            case S.CDATA_ENDING_2:
                if (c === '>') {
                    if (parser.cdata) {
                        emitNode(parser, 'oncdata', parser.cdata);
                    }
                    emitNode(parser, 'onclosecdata');
                    parser.cdata = '';
                    parser.state = S.TEXT;
                } else if (c === ']') {
                    parser.cdata += ']';
                } else {
                    parser.cdata += ']]' + c;
                    parser.state = S.CDATA;
                }
                continue;
            case S.PROC_INST:
                if (c === '?') {
                    parser.state = S.PROC_INST_ENDING;
                } else if (is(whitespace, c)) {
                    parser.state = S.PROC_INST_BODY;
                } else {
                    parser.procInstName += c;
                }
                continue;
            case S.PROC_INST_BODY:
                if (!parser.procInstBody && is(whitespace, c)) {
                    continue;
                } else if (c === '?') {
                    parser.state = S.PROC_INST_ENDING;
                } else {
                    parser.procInstBody += c;
                }
                continue;
            case S.PROC_INST_ENDING:
                if (c === '>') {
                    emitNode(parser, 'onprocessinginstruction', {
                        name: parser.procInstName,
                        body: parser.procInstBody
                    });
                    parser.procInstName = parser.procInstBody = '';
                    parser.state = S.TEXT;
                } else {
                    parser.procInstBody += '?' + c;
                    parser.state = S.PROC_INST_BODY;
                }
                continue;
            case S.OPEN_TAG:
                if (isMatch(nameBody, c)) {
                    parser.tagName += c;
                } else {
                    newTag(parser);
                    if (c === '>') {
                        openTag(parser);
                    } else if (c === '/') {
                        parser.state = S.OPEN_TAG_SLASH;
                    } else {
                        if (not(whitespace, c)) {
                            strictFail(parser, 'Invalid character in tag name');
                        }
                        parser.state = S.ATTRIB;
                    }
                }
                continue;
            case S.OPEN_TAG_SLASH:
                if (c === '>') {
                    openTag(parser, true);
                    closeTag(parser);
                } else {
                    strictFail(parser, 'Forward-slash in opening tag not followed by >');
                    parser.state = S.ATTRIB;
                }
                continue;
            case S.ATTRIB:
                if (is(whitespace, c)) {
                    continue;
                } else if (c === '>') {
                    openTag(parser);
                } else if (c === '/') {
                    parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                    parser.attribName = c;
                    parser.attribValue = '';
                    parser.state = S.ATTRIB_NAME;
                } else {
                    strictFail(parser, 'Invalid attribute name');
                }
                continue;
            case S.ATTRIB_NAME:
                if (c === '=') {
                    parser.state = S.ATTRIB_VALUE;
                } else if (c === '>') {
                    strictFail(parser, 'Attribute without value');
                    parser.attribValue = parser.attribName;
                    attrib(parser);
                    openTag(parser);
                } else if (is(whitespace, c)) {
                    parser.state = S.ATTRIB_NAME_SAW_WHITE;
                } else if (isMatch(nameBody, c)) {
                    parser.attribName += c;
                } else {
                    strictFail(parser, 'Invalid attribute name');
                }
                continue;
            case S.ATTRIB_NAME_SAW_WHITE:
                if (c === '=') {
                    parser.state = S.ATTRIB_VALUE;
                } else if (is(whitespace, c)) {
                    continue;
                } else {
                    strictFail(parser, 'Attribute without value');
                    parser.tag.attributes[parser.attribName] = '';
                    parser.attribValue = '';
                    emitNode(parser, 'onattribute', {
                        name: parser.attribName,
                        value: ''
                    });
                    parser.attribName = '';
                    if (c === '>') {
                        openTag(parser);
                    } else if (isMatch(nameStart, c)) {
                        parser.attribName = c;
                        parser.state = S.ATTRIB_NAME;
                    } else {
                        strictFail(parser, 'Invalid attribute name');
                        parser.state = S.ATTRIB;
                    }
                }
                continue;
            case S.ATTRIB_VALUE:
                if (is(whitespace, c)) {
                    continue;
                } else if (is(quote, c)) {
                    parser.q = c;
                    parser.state = S.ATTRIB_VALUE_QUOTED;
                } else {
                    strictFail(parser, 'Unquoted attribute value');
                    parser.state = S.ATTRIB_VALUE_UNQUOTED;
                    parser.attribValue = c;
                }
                continue;
            case S.ATTRIB_VALUE_QUOTED:
                if (c !== parser.q) {
                    if (c === '&') {
                        parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                    } else {
                        parser.attribValue += c;
                    }
                    continue;
                }
                attrib(parser);
                parser.q = '';
                parser.state = S.ATTRIB_VALUE_CLOSED;
                continue;
            case S.ATTRIB_VALUE_CLOSED:
                if (is(whitespace, c)) {
                    parser.state = S.ATTRIB;
                } else if (c === '>') {
                    openTag(parser);
                } else if (c === '/') {
                    parser.state = S.OPEN_TAG_SLASH;
                } else if (isMatch(nameStart, c)) {
                    strictFail(parser, 'No whitespace between attributes');
                    parser.attribName = c;
                    parser.attribValue = '';
                    parser.state = S.ATTRIB_NAME;
                } else {
                    strictFail(parser, 'Invalid attribute name');
                }
                continue;
            case S.ATTRIB_VALUE_UNQUOTED:
                if (not(attribEnd, c)) {
                    if (c === '&') {
                        parser.state = S.ATTRIB_VALUE_ENTITY_U;
                    } else {
                        parser.attribValue += c;
                    }
                    continue;
                }
                attrib(parser);
                if (c === '>') {
                    openTag(parser);
                } else {
                    parser.state = S.ATTRIB;
                }
                continue;
            case S.CLOSE_TAG:
                if (!parser.tagName) {
                    if (is(whitespace, c)) {
                        continue;
                    } else if (notMatch(nameStart, c)) {
                        if (parser.script) {
                            parser.script += '</' + c;
                            parser.state = S.SCRIPT;
                        } else {
                            strictFail(parser, 'Invalid tagname in closing tag.');
                        }
                    } else {
                        parser.tagName = c;
                    }
                } else if (c === '>') {
                    closeTag(parser);
                } else if (isMatch(nameBody, c)) {
                    parser.tagName += c;
                } else if (parser.script) {
                    parser.script += '</' + parser.tagName;
                    parser.tagName = '';
                    parser.state = S.SCRIPT;
                } else {
                    if (not(whitespace, c)) {
                        strictFail(parser, 'Invalid tagname in closing tag');
                    }
                    parser.state = S.CLOSE_TAG_SAW_WHITE;
                }
                continue;
            case S.CLOSE_TAG_SAW_WHITE:
                if (is(whitespace, c)) {
                    continue;
                }
                if (c === '>') {
                    closeTag(parser);
                } else {
                    strictFail(parser, 'Invalid characters in closing tag');
                }
                continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
                var returnState;
                var buffer;
                switch (parser.state) {
                case S.TEXT_ENTITY:
                    returnState = S.TEXT;
                    buffer = 'textNode';
                    break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                    returnState = S.ATTRIB_VALUE_QUOTED;
                    buffer = 'attribValue';
                    break;
                case S.ATTRIB_VALUE_ENTITY_U:
                    returnState = S.ATTRIB_VALUE_UNQUOTED;
                    buffer = 'attribValue';
                    break;
                }
                if (c === ';') {
                    parser[buffer] += parseEntity(parser);
                    parser.entity = '';
                    parser.state = returnState;
                } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                    parser.entity += c;
                } else {
                    strictFail(parser, 'Invalid character in entity name');
                    parser[buffer] += '&' + parser.entity + c;
                    parser.entity = '';
                    parser.state = returnState;
                }
                continue;
            default:
                throw new Error(parser, 'Unknown state: ' + parser.state);
            }
        }
        if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
        }
        return parser;
    }
    if (!String.fromCodePoint) {
        (function () {
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function () {
                var MAX_SIZE = 16384;
                var codeUnits = [];
                var highSurrogate;
                var lowSurrogate;
                var index = -1;
                var length = arguments.length;
                if (!length) {
                    return '';
                }
                var result = '';
                while (++index < length) {
                    var codePoint = Number(arguments[index]);
                    if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || floor(codePoint) !== codePoint) {
                        throw RangeError('Invalid code point: ' + codePoint);
                    }
                    if (codePoint <= 65535) {
                        codeUnits.push(codePoint);
                    } else {
                        codePoint -= 65536;
                        highSurrogate = (codePoint >> 10) + 55296;
                        lowSurrogate = codePoint % 1024 + 56320;
                        codeUnits.push(highSurrogate, lowSurrogate);
                    }
                    if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                        result += stringFromCharCode.apply(null, codeUnits);
                        codeUnits.length = 0;
                    }
                }
                return result;
            };
            if (Object.defineProperty) {
                Object.defineProperty(String, 'fromCodePoint', {
                    value: fromCodePoint,
                    configurable: true,
                    writable: true
                });
            } else {
                String.fromCodePoint = fromCodePoint;
            }
        }());
    }
}(typeof exports === 'undefined' ? this.sax = {} : exports));
}).call(this,require(7).Buffer)
},{"268":268,"269":269,"7":7}],268:[function(require,module,exports){
module.exports = Stream;
var EE = require(58).EventEmitter;
var inherits = require(73);
inherits(Stream, EE);
Stream.Readable = require(263);
Stream.Writable = require(265);
Stream.Duplex = require(252);
Stream.Transform = require(264);
Stream.PassThrough = require(262);
Stream.Stream = Stream;
function Stream() {
    EE.call(this);
}
Stream.prototype.pipe = function (dest, options) {
    var source = this;
    function ondata(chunk) {
        if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
                source.pause();
            }
        }
    }
    source.on('data', ondata);
    function ondrain() {
        if (source.readable && source.resume) {
            source.resume();
        }
    }
    dest.on('drain', ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
    }
    var didOnEnd = false;
    function onend() {
        if (didOnEnd)
            return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd)
            return;
        didOnEnd = true;
        if (typeof dest.destroy === 'function')
            dest.destroy();
    }
    function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, 'error') === 0) {
            throw er;
        }
    }
    source.on('error', onerror);
    dest.on('error', onerror);
    function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);
        source.removeListener('end', onend);
        source.removeListener('close', onclose);
        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);
        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);
        dest.removeListener('close', cleanup);
    }
    source.on('end', cleanup);
    source.on('close', cleanup);
    dest.on('close', cleanup);
    dest.emit('pipe', source);
    return dest;
};
},{"252":252,"262":262,"263":263,"264":264,"265":265,"58":58,"73":73}],269:[function(require,module,exports){
var Buffer = require(7).Buffer;
var isBufferEncoding = Buffer.isEncoding || function (encoding) {
    switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
        return true;
    default:
        return false;
    }
};
function assertEncoding(encoding) {
    if (encoding && !isBufferEncoding(encoding)) {
        throw new Error('Unknown encoding: ' + encoding);
    }
}
var StringDecoder = exports.StringDecoder = function (encoding) {
    this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
    assertEncoding(encoding);
    switch (this.encoding) {
    case 'utf8':
        this.surrogateSize = 3;
        break;
    case 'ucs2':
    case 'utf16le':
        this.surrogateSize = 2;
        this.detectIncompleteChar = utf16DetectIncompleteChar;
        break;
    case 'base64':
        this.surrogateSize = 3;
        this.detectIncompleteChar = base64DetectIncompleteChar;
        break;
    default:
        this.write = passThroughWrite;
        return;
    }
    this.charBuffer = new Buffer(6);
    this.charReceived = 0;
    this.charLength = 0;
};
StringDecoder.prototype.write = function (buffer) {
    var charStr = '';
    while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
            return '';
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
            this.charLength += this.surrogateSize;
            charStr = '';
            continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
            return charStr;
        }
        break;
    }
    this.detectIncompleteChar(buffer);
    var end = buffer.length;
    if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
    }
    charStr += buffer.toString(this.encoding, 0, end);
    var end = charStr.length - 1;
    var charCode = charStr.charCodeAt(end);
    if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
    }
    return charStr;
};
StringDecoder.prototype.detectIncompleteChar = function (buffer) {
    var i = buffer.length >= 3 ? 3 : buffer.length;
    for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
            this.charLength = 2;
            break;
        }
        if (i <= 2 && c >> 4 == 14) {
            this.charLength = 3;
            break;
        }
        if (i <= 3 && c >> 3 == 30) {
            this.charLength = 4;
            break;
        }
    }
    this.charReceived = i;
};
StringDecoder.prototype.end = function (buffer) {
    var res = '';
    if (buffer && buffer.length)
        res = this.write(buffer);
    if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
    }
    return res;
};
function passThroughWrite(buffer) {
    return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 2;
    this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 3;
    this.charLength = this.charReceived ? 3 : 0;
}
},{"7":7}],270:[function(require,module,exports){
(function (process){
var Transform = require(264), inherits = require(277).inherits, xtend = require(300);
function DestroyableTransform(opts) {
    Transform.call(this, opts);
    this._destroyed = false;
}
inherits(DestroyableTransform, Transform);
DestroyableTransform.prototype.destroy = function (err) {
    if (this._destroyed)
        return;
    this._destroyed = true;
    var self = this;
    process.nextTick(function () {
        if (err)
            self.emit('error', err);
        self.emit('close');
    });
};
function noop(chunk, enc, callback) {
    callback(null, chunk);
}
function through2(construct) {
    return function (options, transform, flush) {
        if (typeof options == 'function') {
            flush = transform;
            transform = options;
            options = {};
        }
        if (typeof transform != 'function')
            transform = noop;
        if (typeof flush != 'function')
            flush = null;
        return construct(options, transform, flush);
    };
}
module.exports = through2(function (options, transform, flush) {
    var t2 = new DestroyableTransform(options);
    t2._transform = transform;
    if (flush)
        t2._flush = flush;
    return t2;
});
module.exports.ctor = through2(function (options, transform, flush) {
    function Through2(override) {
        if (!(this instanceof Through2))
            return new Through2(override);
        this.options = xtend(options, override);
        DestroyableTransform.call(this, this.options);
    }
    inherits(Through2, DestroyableTransform);
    Through2.prototype._transform = transform;
    if (flush)
        Through2.prototype._flush = flush;
    return Through2;
});
module.exports.obj = through2(function (options, transform, flush) {
    var t2 = new DestroyableTransform(xtend({
        objectMode: true,
        highWaterMark: 16
    }, options));
    t2._transform = transform;
    if (flush)
        t2._flush = flush;
    return t2;
});
}).call(this,require(251))
},{"251":251,"264":264,"277":277,"300":300}],271:[function(require,module,exports){
var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};
function Traverse(obj) {
    this.value = obj;
}
Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};
Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};
Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key))
            node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};
Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};
Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};
Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};
Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path);
    });
    return acc;
};
Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};
Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    return function clone(src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            parents.push(src);
            nodes.push(dst);
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            parents.pop();
            nodes.pop();
            return dst;
        } else {
            return src;
        }
    }(this.value);
};
function walk(root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    return function walker(node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        var keepGoing = true;
        var state = {
            node: node,
            node_: node_,
            path: [].concat(path),
            parent: parents[parents.length - 1],
            parents: parents,
            key: path.slice(-1)[0],
            isRoot: path.length === 0,
            level: path.length,
            circular: null,
            update: function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere)
                    keepGoing = false;
            },
            'delete': function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere)
                    keepGoing = false;
            },
            remove: function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                } else {
                    delete state.parent.node[state.key];
                }
                if (stopHere)
                    keepGoing = false;
            },
            keys: null,
            before: function (f) {
                modifiers.before = f;
            },
            after: function (f) {
                modifiers.after = f;
            },
            pre: function (f) {
                modifiers.pre = f;
            },
            post: function (f) {
                modifiers.post = f;
            },
            stop: function () {
                alive = false;
            },
            block: function () {
                keepGoing = false;
            }
        };
        if (!alive)
            return state;
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node);
                }
                state.isLeaf = state.keys.length == 0;
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            } else {
                state.isLeaf = true;
                state.keys = null;
            }
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        updateState();
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update)
            state.update(ret);
        if (modifiers.before)
            modifiers.before.call(state, state.node);
        if (!keepGoing)
            return state;
        if (typeof state.node == 'object' && state.node !== null && !state.circular) {
            parents.push(state);
            updateState();
            forEach(state.keys, function (key, i) {
                path.push(key);
                if (modifiers.pre)
                    modifiers.pre.call(state, state.node[key], key);
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                if (modifiers.post)
                    modifiers.post.call(state, child);
                path.pop();
            });
            parents.pop();
        }
        if (modifiers.after)
            modifiers.after.call(state, state.node);
        return state;
    }(root).node;
}
function copy(src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        if (isArray(src)) {
            dst = [];
        } else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        } else if (isRegExp(src)) {
            dst = new RegExp(src);
        } else if (isError(src)) {
            dst = { message: src.message };
        } else if (isBoolean(src)) {
            dst = new Boolean(src);
        } else if (isNumber(src)) {
            dst = new Number(src);
        } else if (isString(src)) {
            dst = new String(src);
        } else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        } else if (src.constructor === Object) {
            dst = {};
        } else {
            var proto = src.constructor && src.constructor.prototype || src.__proto__ || {};
            var T = function () {
            };
            T.prototype = proto;
            dst = new T();
        }
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    } else
        return src;
}
var objectKeys = Object.keys || function keys(obj) {
    var res = [];
    for (var key in obj)
        res.push(key);
    return res;
};
function toS(obj) {
    return Object.prototype.toString.call(obj);
}
function isDate(obj) {
    return toS(obj) === '[object Date]';
}
function isRegExp(obj) {
    return toS(obj) === '[object RegExp]';
}
function isError(obj) {
    return toS(obj) === '[object Error]';
}
function isBoolean(obj) {
    return toS(obj) === '[object Boolean]';
}
function isNumber(obj) {
    return toS(obj) === '[object Number]';
}
function isString(obj) {
    return toS(obj) === '[object String]';
}
var isArray = Array.isArray || function isArray(xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};
var forEach = function (xs, fn) {
    if (xs.forEach)
        return xs.forEach(fn);
    else
        for (var i = 0; i < xs.length; i++) {
            fn(xs[i], i, xs);
        }
};
forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});
var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};
},{}],272:[function(require,module,exports){
(function (Buffer){
var isTypedArray = require(78).strict;
module.exports = function typedarrayToBuffer(arr) {
    if (isTypedArray(arr)) {
        var buf = new Buffer(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
            buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
    } else {
        return new Buffer(arr);
    }
};
}).call(this,require(7).Buffer)
},{"7":7,"78":78}],273:[function(require,module,exports){
'use strict';
function unique_pred(list, compare) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for (var i = 1; i < len; ++i) {
        b = a;
        a = list[i];
        if (compare(a, b)) {
            if (i === ptr) {
                ptr++;
                continue;
            }
            list[ptr++] = a;
        }
    }
    list.length = ptr;
    return list;
}
function unique_eq(list) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for (var i = 1; i < len; ++i, b = a) {
        b = a;
        a = list[i];
        if (a !== b) {
            if (i === ptr) {
                ptr++;
                continue;
            }
            list[ptr++] = a;
        }
    }
    list.length = ptr;
    return list;
}
function unique(list, compare, sorted) {
    if (list.length === 0) {
        return list;
    }
    if (compare) {
        if (!sorted) {
            list.sort(compare);
        }
        return unique_pred(list, compare);
    }
    if (!sorted) {
        list.sort();
    }
    return unique_eq(list);
}
module.exports = unique;
},{}],274:[function(require,module,exports){
(function (global){
module.exports = deprecate;
function deprecate(fn, msg) {
    if (config('noDeprecation')) {
        return fn;
    }
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (config('throwDeprecation')) {
                throw new Error(msg);
            } else if (config('traceDeprecation')) {
                console.trace(msg);
            } else {
                console.warn(msg);
            }
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
}
function config(name) {
    try {
        if (!global.localStorage)
            return false;
    } catch (_) {
        return false;
    }
    var val = global.localStorage[name];
    if (null == val)
        return false;
    return String(val).toLowerCase() === 'true';
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],275:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"73":73}],276:[function(require,module,exports){
module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};
},{}],277:[function(require,module,exports){
(function (process,global){
var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
    if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function (x) {
        if (x === '%%')
            return '%';
        if (i >= len)
            return x;
        switch (x) {
        case '%s':
            return String(args[i++]);
        case '%d':
            return Number(args[i++]);
        case '%j':
            try {
                return JSON.stringify(args[i++]);
            } catch (_) {
                return '[Circular]';
            }
        default:
            return x;
        }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
            str += ' ' + x;
        } else {
            str += ' ' + inspect(x);
        }
    }
    return str;
};
exports.deprecate = function (fn, msg) {
    if (isUndefined(global.process)) {
        return function () {
            return exports.deprecate(fn, msg).apply(this, arguments);
        };
    }
    if (process.noDeprecation === true) {
        return fn;
    }
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (process.throwDeprecation) {
                throw new Error(msg);
            } else if (process.traceDeprecation) {
                console.trace(msg);
            } else {
                console.error(msg);
            }
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
};
var debugs = {};
var debugEnviron;
exports.debuglog = function (set) {
    if (isUndefined(debugEnviron))
        debugEnviron = process.env.NODE_DEBUG || '';
    set = set.toUpperCase();
    if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
            var pid = process.pid;
            debugs[set] = function () {
                var msg = exports.format.apply(exports, arguments);
                console.error('%s %d: %s', set, pid, msg);
            };
        } else {
            debugs[set] = function () {
            };
        }
    }
    return debugs[set];
};
function inspect(obj, opts) {
    var ctx = {
        seen: [],
        stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
        ctx.depth = arguments[2];
    if (arguments.length >= 4)
        ctx.colors = arguments[3];
    if (isBoolean(opts)) {
        ctx.showHidden = opts;
    } else if (opts) {
        exports._extend(ctx, opts);
    }
    if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
    if (isUndefined(ctx.depth))
        ctx.depth = 2;
    if (isUndefined(ctx.colors))
        ctx.colors = false;
    if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
    if (ctx.colors)
        ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
inspect.colors = {
    'bold': [
        1,
        22
    ],
    'italic': [
        3,
        23
    ],
    'underline': [
        4,
        24
    ],
    'inverse': [
        7,
        27
    ],
    'white': [
        37,
        39
    ],
    'grey': [
        90,
        39
    ],
    'black': [
        30,
        39
    ],
    'blue': [
        34,
        39
    ],
    'cyan': [
        36,
        39
    ],
    'green': [
        32,
        39
    ],
    'magenta': [
        35,
        39
    ],
    'red': [
        31,
        39
    ],
    'yellow': [
        33,
        39
    ]
};
inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) {
        return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
    } else {
        return str;
    }
}
function stylizeNoColor(str, styleType) {
    return str;
}
function arrayToHash(array) {
    var hash = {};
    array.forEach(function (val, idx) {
        hash[val] = true;
    });
    return hash;
}
function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
        return primitive;
    }
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
    }
    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
    }
    if (keys.length === 0) {
        if (isFunction(value)) {
            var name = value.name ? ': ' + value.name : '';
            return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
            return formatError(value);
        }
    }
    var base = '', array = false, braces = [
            '{',
            '}'
        ];
    if (isArray(value)) {
        array = true;
        braces = [
            '[',
            ']'
        ];
    }
    if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
    }
    if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
    }
    if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
        base = ' ' + formatError(value);
    }
    if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
        if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
            return ctx.stylize('[Object]', 'special');
        }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
        output = keys.map(function (key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
    if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, '\\\'').replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
    }
    if (isNumber(value))
        return ctx.stylize('' + value, 'number');
    if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
    if (isNull(value))
        return ctx.stylize('null', 'null');
}
function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
            output.push('');
        }
    }
    keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
    });
    return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
        if (desc.set) {
            str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
            str = ctx.stylize('[Getter]', 'special');
        }
    } else {
        if (desc.set) {
            str = ctx.stylize('[Setter]', 'special');
        }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
    }
    if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
                str = formatValue(ctx, desc.value, null);
            } else {
                str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
                if (array) {
                    str = str.split('\n').map(function (line) {
                        return '  ' + line;
                    }).join('\n').substr(2);
                } else {
                    str = '\n' + str.split('\n').map(function (line) {
                        return '   ' + line;
                    }).join('\n');
                }
            }
        } else {
            str = ctx.stylize('[Circular]', 'special');
        }
    }
    if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
            return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, 'name');
        } else {
            name = name.replace(/'/g, '\\\'').replace(/\\"/g, '"').replace(/(^"|"$)/g, '\'');
            name = ctx.stylize(name, 'string');
        }
    }
    return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0)
            numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);
    if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }
    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}
function isArray(ar) {
    return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
    return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
    return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
    return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
    return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
    return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
    return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
function isError(e) {
    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
function isFunction(arg) {
    return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = require(276);
function objectToString(o) {
    return Object.prototype.toString.call(o);
}
function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec'
];
function timestamp() {
    var d = new Date();
    var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
    ].join(':');
    return [
        d.getDate(),
        months[d.getMonth()],
        time
    ].join(' ');
}
exports.log = function () {
    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
exports.inherits = require(275);
exports._extend = function (origin, add) {
    if (!add || !isObject(add))
        return origin;
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
        origin[keys[i]] = add[keys[i]];
    }
    return origin;
};
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
}).call(this,require(251),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"251":251,"275":275,"276":276}],278:[function(require,module,exports){
var trie = require(279);
module.exports = Wayfarer;
function Wayfarer(dft) {
    if (!(this instanceof Wayfarer))
        return new Wayfarer(dft);
    var _default = (dft || '').replace(/^\//, '');
    var _trie = trie();
    emit._trie = _trie;
    emit.emit = emit;
    emit.on = on;
    emit._wayfarer = true;
    return emit;
    function on(route, cb) {
        route = route || '/';
        if (cb && cb._wayfarer && cb._trie) {
            _trie.mount(route, cb._trie.trie);
        } else {
            var node = _trie.create(route);
            node.cb = cb;
        }
        return emit;
    }
    function emit(route) {
        var args = new Array(arguments.length);
        for (var i = 1; i < args.length; i++) {
            args[i] = arguments[i];
        }
        var node = _trie.match(route);
        if (node && node.cb) {
            args[0] = node.params;
            return node.cb.apply(null, args);
        }
        var dft = _trie.match(_default);
        if (dft && dft.cb) {
            args[0] = dft.params;
            return dft.cb.apply(null, args);
        }
        throw new Error('route \'' + route + '\' did not match');
    }
}
},{"279":279}],279:[function(require,module,exports){
var mutate = require(301);
var xtend = require(300);
module.exports = Trie;
function Trie() {
    if (!(this instanceof Trie))
        return new Trie();
    this.trie = { nodes: {} };
}
Trie.prototype.create = function (route) {
    var routes = route.replace(/^\//, '').split('/');
    return function createNode(index, trie) {
        var thisRoute = routes[index];
        if (thisRoute === undefined)
            return trie;
        var node = null;
        if (/^:|^\*/.test(thisRoute)) {
            if (!trie.nodes['$$']) {
                node = { nodes: {} };
                trie.nodes['$$'] = node;
            } else {
                node = trie.nodes['$$'];
            }
            if (thisRoute[0] === '*') {
                trie.wildcard = true;
            }
            trie.name = thisRoute.replace(/^:|^\*/, '');
        } else if (!trie.nodes[thisRoute]) {
            node = { nodes: {} };
            trie.nodes[thisRoute] = node;
        } else {
            node = trie.nodes[thisRoute];
        }
        return createNode(index + 1, node);
    }(0, this.trie);
};
Trie.prototype.match = function (route) {
    var routes = route.replace(/^\//, '').split('/');
    var params = {};
    var node = function search(index, trie) {
        if (trie === undefined)
            return undefined;
        var thisRoute = routes[index];
        if (thisRoute === undefined)
            return trie;
        if (trie.nodes[thisRoute]) {
            return search(index + 1, trie.nodes[thisRoute]);
        } else if (trie.wildcard) {
            params['wildcard'] = decodeURIComponent(routes.slice(index).join('/'));
            return trie.nodes['$$'];
        } else if (trie.name) {
            params[trie.name] = decodeURIComponent(thisRoute);
            return search(index + 1, trie.nodes['$$']);
        } else {
            return search(index + 1);
        }
    }(0, this.trie);
    if (!node)
        return undefined;
    node = xtend(node);
    node.params = params;
    return node;
};
Trie.prototype.mount = function (route, trie) {
    var split = route.replace(/^\//, '').split('/');
    var node = null;
    var key = null;
    if (split.length === 1) {
        key = split[0];
        node = this.create(key);
    } else {
        var headArr = split.splice(0, split.length - 1);
        var head = headArr.join('/');
        key = split[0];
        node = this.create(head);
    }
    mutate(node.nodes, trie.nodes);
    if (trie.name)
        node.name = trie.name;
    if (node.nodes['']) {
        Object.keys(node.nodes['']).forEach(function (key) {
            if (key === 'nodes')
                return;
            node[key] = node.nodes[''][key];
        });
        mutate(node.nodes, node.nodes[''].nodes);
        delete node.nodes[''].nodes;
    }
};
},{"300":300,"301":301}],280:[function(require,module,exports){
'use strict';
function __export(m) {
    for (var p in m)
        if (!exports.hasOwnProperty(p))
            exports[p] = m[p];
}
__export(require(281));
__export(require(283));
__export(require(286));
__export(require(287));
__export(require(288));
__export(require(289));
__export(require(290));
__export(require(291));
__export(require(292));
__export(require(293));
__export(require(294));
__export(require(295));
__export(require(296));
__export(require(297));
__export(require(298));
__export(require(282));
},{"281":281,"282":282,"283":283,"286":286,"287":287,"288":288,"289":289,"290":290,"291":291,"292":292,"293":293,"294":294,"295":295,"296":296,"297":297,"298":298}],281:[function(require,module,exports){
'use strict';
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var layout_1 = require(290);
var LayoutAdaptor = function (_super) {
    __extends(LayoutAdaptor, _super);
    function LayoutAdaptor(options) {
        var _this = _super.call(this) || this;
        var self = _this;
        var o = options;
        if (o.trigger) {
            _this.trigger = o.trigger;
        }
        if (o.kick) {
            _this.kick = o.kick;
        }
        if (o.drag) {
            _this.drag = o.drag;
        }
        if (o.on) {
            _this.on = o.on;
        }
        _this.dragstart = _this.dragStart = layout_1.Layout.dragStart;
        _this.dragend = _this.dragEnd = layout_1.Layout.dragEnd;
        return _this;
    }
    LayoutAdaptor.prototype.trigger = function (e) {
    };
    ;
    LayoutAdaptor.prototype.kick = function () {
    };
    ;
    LayoutAdaptor.prototype.drag = function () {
    };
    ;
    LayoutAdaptor.prototype.on = function (eventType, listener) {
        return this;
    };
    ;
    return LayoutAdaptor;
}(layout_1.Layout);
exports.LayoutAdaptor = LayoutAdaptor;
function adaptor(options) {
    return new LayoutAdaptor(options);
}
exports.adaptor = adaptor;
},{"290":290}],282:[function(require,module,exports){
'use strict';
var layout_1 = require(290);
var gridrouter_1 = require(288);
function gridify(pgLayout, nudgeGap, margin, groupMargin) {
    pgLayout.cola.start(0, 0, 0, 10, false);
    var gridrouter = route(pgLayout.cola.nodes(), pgLayout.cola.groups(), margin, groupMargin);
    return gridrouter.routeEdges(pgLayout.powerGraph.powerEdges, nudgeGap, function (e) {
        return e.source.routerNode.id;
    }, function (e) {
        return e.target.routerNode.id;
    });
}
exports.gridify = gridify;
function route(nodes, groups, margin, groupMargin) {
    nodes.forEach(function (d) {
        d.routerNode = {
            name: d.name,
            bounds: d.bounds.inflate(-margin)
        };
    });
    groups.forEach(function (d) {
        d.routerNode = {
            bounds: d.bounds.inflate(-groupMargin),
            children: (typeof d.groups !== 'undefined' ? d.groups.map(function (c) {
                return nodes.length + c.id;
            }) : []).concat(typeof d.leaves !== 'undefined' ? d.leaves.map(function (c) {
                return c.index;
            }) : [])
        };
    });
    var gridRouterNodes = nodes.concat(groups).map(function (d, i) {
        d.routerNode.id = i;
        return d.routerNode;
    });
    return new gridrouter_1.GridRouter(gridRouterNodes, {
        getChildren: function (v) {
            return v.children;
        },
        getBounds: function (v) {
            return v.bounds;
        }
    }, margin - groupMargin);
}
function powerGraphGridLayout(graph, size, grouppadding) {
    var powerGraph;
    graph.nodes.forEach(function (v, i) {
        return v.index = i;
    });
    new layout_1.Layout().avoidOverlaps(false).nodes(graph.nodes).links(graph.links).powerGraphGroups(function (d) {
        powerGraph = d;
        powerGraph.groups.forEach(function (v) {
            return v.padding = grouppadding;
        });
    });
    var n = graph.nodes.length;
    var edges = [];
    var vs = graph.nodes.slice(0);
    vs.forEach(function (v, i) {
        return v.index = i;
    });
    powerGraph.groups.forEach(function (g) {
        var sourceInd = g.index = g.id + n;
        vs.push(g);
        if (typeof g.leaves !== 'undefined')
            g.leaves.forEach(function (v) {
                return edges.push({
                    source: sourceInd,
                    target: v.index
                });
            });
        if (typeof g.groups !== 'undefined')
            g.groups.forEach(function (gg) {
                return edges.push({
                    source: sourceInd,
                    target: gg.id + n
                });
            });
    });
    powerGraph.powerEdges.forEach(function (e) {
        edges.push({
            source: e.source.index,
            target: e.target.index
        });
    });
    new layout_1.Layout().size(size).nodes(vs).links(edges).avoidOverlaps(false).linkDistance(30).symmetricDiffLinkLengths(5).convergenceThreshold(0.0001).start(100, 0, 0, 0, false);
    return {
        cola: new layout_1.Layout().convergenceThreshold(0.001).size(size).avoidOverlaps(true).nodes(graph.nodes).links(graph.links).groupCompactness(0.0001).linkDistance(30).symmetricDiffLinkLengths(5).powerGraphGroups(function (d) {
            powerGraph = d;
            powerGraph.groups.forEach(function (v) {
                v.padding = grouppadding;
            });
        }).start(50, 0, 100, 0, false),
        powerGraph: powerGraph
    };
}
exports.powerGraphGridLayout = powerGraphGridLayout;
},{"288":288,"290":290}],283:[function(require,module,exports){
'use strict';
var d3v3 = require(284);
var d3v4 = require(285);
;
function d3adaptor(d3Context) {
    if (!d3Context || isD3V3(d3Context)) {
        return new d3v3.D3StyleLayoutAdaptor();
    }
    return new d3v4.D3StyleLayoutAdaptor(d3Context);
}
exports.d3adaptor = d3adaptor;
function isD3V3(d3Context) {
    var v3exp = /^3\./;
    return d3Context.version && d3Context.version.match(v3exp) !== null;
}
},{"284":284,"285":285}],284:[function(require,module,exports){
'use strict';
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var layout_1 = require(290);
var D3StyleLayoutAdaptor = function (_super) {
    __extends(D3StyleLayoutAdaptor, _super);
    function D3StyleLayoutAdaptor() {
        var _this = _super.call(this) || this;
        _this.event = d3.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
        var d3layout = _this;
        var drag;
        _this.drag = function () {
            if (!drag) {
                var drag = d3.behavior.drag().origin(layout_1.Layout.dragOrigin).on('dragstart.d3adaptor', layout_1.Layout.dragStart).on('drag.d3adaptor', function (d) {
                    layout_1.Layout.drag(d, d3.event);
                    d3layout.resume();
                }).on('dragend.d3adaptor', layout_1.Layout.dragEnd);
            }
            if (!arguments.length)
                return drag;
            this.call(drag);
        };
        return _this;
    }
    D3StyleLayoutAdaptor.prototype.trigger = function (e) {
        var d3event = {
            type: layout_1.EventType[e.type],
            alpha: e.alpha,
            stress: e.stress
        };
        this.event[d3event.type](d3event);
    };
    D3StyleLayoutAdaptor.prototype.kick = function () {
        var _this = this;
        d3.timer(function () {
            return _super.prototype.tick.call(_this);
        });
    };
    D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {
        if (typeof eventType === 'string') {
            this.event.on(eventType, listener);
        } else {
            this.event.on(layout_1.EventType[eventType], listener);
        }
        return this;
    };
    return D3StyleLayoutAdaptor;
}(layout_1.Layout);
exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;
function d3adaptor() {
    return new D3StyleLayoutAdaptor();
}
exports.d3adaptor = d3adaptor;
},{"290":290}],285:[function(require,module,exports){
'use strict';
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var layout_1 = require(290);
var D3StyleLayoutAdaptor = function (_super) {
    __extends(D3StyleLayoutAdaptor, _super);
    function D3StyleLayoutAdaptor(d3Context) {
        var _this = _super.call(this) || this;
        _this.d3Context = d3Context;
        _this.event = d3Context.dispatch(layout_1.EventType[layout_1.EventType.start], layout_1.EventType[layout_1.EventType.tick], layout_1.EventType[layout_1.EventType.end]);
        var d3layout = _this;
        var drag;
        _this.drag = function () {
            if (!drag) {
                var drag = d3Context.drag().subject(layout_1.Layout.dragOrigin).on('start.d3adaptor', layout_1.Layout.dragStart).on('drag.d3adaptor', function (d) {
                    layout_1.Layout.drag(d, d3Context.event);
                    d3layout.resume();
                }).on('end.d3adaptor', layout_1.Layout.dragEnd);
            }
            if (!arguments.length)
                return drag;
            arguments[0].call(drag);
        };
        return _this;
    }
    D3StyleLayoutAdaptor.prototype.trigger = function (e) {
        var d3event = {
            type: layout_1.EventType[e.type],
            alpha: e.alpha,
            stress: e.stress
        };
        this.event.call(d3event.type, d3event);
    };
    D3StyleLayoutAdaptor.prototype.kick = function () {
        var _this = this;
        var t = this.d3Context.timer(function () {
            return _super.prototype.tick.call(_this) && t.stop();
        });
    };
    D3StyleLayoutAdaptor.prototype.on = function (eventType, listener) {
        if (typeof eventType === 'string') {
            this.event.on(eventType, listener);
        } else {
            this.event.on(layout_1.EventType[eventType], listener);
        }
        return this;
    };
    return D3StyleLayoutAdaptor;
}(layout_1.Layout);
exports.D3StyleLayoutAdaptor = D3StyleLayoutAdaptor;
},{"290":290}],286:[function(require,module,exports){
'use strict';
var Locks = function () {
    function Locks() {
        this.locks = {};
    }
    Locks.prototype.add = function (id, x) {
        this.locks[id] = x;
    };
    Locks.prototype.clear = function () {
        this.locks = {};
    };
    Locks.prototype.isEmpty = function () {
        for (var l in this.locks)
            return false;
        return true;
    };
    Locks.prototype.apply = function (f) {
        for (var l in this.locks) {
            f(Number(l), this.locks[l]);
        }
    };
    return Locks;
}();
exports.Locks = Locks;
var Descent = function () {
    function Descent(x, D, G) {
        if (G === void 0) {
            G = null;
        }
        this.D = D;
        this.G = G;
        this.threshold = 0.0001;
        this.numGridSnapNodes = 0;
        this.snapGridSize = 100;
        this.snapStrength = 1000;
        this.scaleSnapByMaxH = false;
        this.random = new PseudoRandom();
        this.project = null;
        this.x = x;
        this.k = x.length;
        var n = this.n = x[0].length;
        this.H = new Array(this.k);
        this.g = new Array(this.k);
        this.Hd = new Array(this.k);
        this.a = new Array(this.k);
        this.b = new Array(this.k);
        this.c = new Array(this.k);
        this.d = new Array(this.k);
        this.e = new Array(this.k);
        this.ia = new Array(this.k);
        this.ib = new Array(this.k);
        this.xtmp = new Array(this.k);
        this.locks = new Locks();
        this.minD = Number.MAX_VALUE;
        var i = n, j;
        while (i--) {
            j = n;
            while (--j > i) {
                var d = D[i][j];
                if (d > 0 && d < this.minD) {
                    this.minD = d;
                }
            }
        }
        if (this.minD === Number.MAX_VALUE)
            this.minD = 1;
        i = this.k;
        while (i--) {
            this.g[i] = new Array(n);
            this.H[i] = new Array(n);
            j = n;
            while (j--) {
                this.H[i][j] = new Array(n);
            }
            this.Hd[i] = new Array(n);
            this.a[i] = new Array(n);
            this.b[i] = new Array(n);
            this.c[i] = new Array(n);
            this.d[i] = new Array(n);
            this.e[i] = new Array(n);
            this.ia[i] = new Array(n);
            this.ib[i] = new Array(n);
            this.xtmp[i] = new Array(n);
        }
    }
    Descent.createSquareMatrix = function (n, f) {
        var M = new Array(n);
        for (var i = 0; i < n; ++i) {
            M[i] = new Array(n);
            for (var j = 0; j < n; ++j) {
                M[i][j] = f(i, j);
            }
        }
        return M;
    };
    Descent.prototype.offsetDir = function () {
        var _this = this;
        var u = new Array(this.k);
        var l = 0;
        for (var i = 0; i < this.k; ++i) {
            var x = u[i] = this.random.getNextBetween(0.01, 1) - 0.5;
            l += x * x;
        }
        l = Math.sqrt(l);
        return u.map(function (x) {
            return x *= _this.minD / l;
        });
    };
    Descent.prototype.computeDerivatives = function (x) {
        var _this = this;
        var n = this.n;
        if (n < 1)
            return;
        var i;
        var d = new Array(this.k);
        var d2 = new Array(this.k);
        var Huu = new Array(this.k);
        var maxH = 0;
        for (var u = 0; u < n; ++u) {
            for (i = 0; i < this.k; ++i)
                Huu[i] = this.g[i][u] = 0;
            for (var v = 0; v < n; ++v) {
                if (u === v)
                    continue;
                var maxDisplaces = n;
                while (maxDisplaces--) {
                    var sd2 = 0;
                    for (i = 0; i < this.k; ++i) {
                        var dx = d[i] = x[i][u] - x[i][v];
                        sd2 += d2[i] = dx * dx;
                    }
                    if (sd2 > 1e-9)
                        break;
                    var rd = this.offsetDir();
                    for (i = 0; i < this.k; ++i)
                        x[i][v] += rd[i];
                }
                var l = Math.sqrt(sd2);
                var D = this.D[u][v];
                var weight = this.G != null ? this.G[u][v] : 1;
                if (weight > 1 && l > D || !isFinite(D)) {
                    for (i = 0; i < this.k; ++i)
                        this.H[i][u][v] = 0;
                    continue;
                }
                if (weight > 1) {
                    weight = 1;
                }
                var D2 = D * D;
                var gs = 2 * weight * (l - D) / (D2 * l);
                var l3 = l * l * l;
                var hs = 2 * -weight / (D2 * l3);
                if (!isFinite(gs))
                    console.log(gs);
                for (i = 0; i < this.k; ++i) {
                    this.g[i][u] += d[i] * gs;
                    Huu[i] -= this.H[i][u][v] = hs * (l3 + D * (d2[i] - sd2) + l * sd2);
                }
            }
            for (i = 0; i < this.k; ++i)
                maxH = Math.max(maxH, this.H[i][u][u] = Huu[i]);
        }
        var r = this.snapGridSize / 2;
        var g = this.snapGridSize;
        var w = this.snapStrength;
        var k = w / (r * r);
        var numNodes = this.numGridSnapNodes;
        for (var u = 0; u < numNodes; ++u) {
            for (i = 0; i < this.k; ++i) {
                var xiu = this.x[i][u];
                var m = xiu / g;
                var f = m % 1;
                var q = m - f;
                var a = Math.abs(f);
                var dx = a <= 0.5 ? xiu - q * g : xiu > 0 ? xiu - (q + 1) * g : xiu - (q - 1) * g;
                if (-r < dx && dx <= r) {
                    if (this.scaleSnapByMaxH) {
                        this.g[i][u] += maxH * k * dx;
                        this.H[i][u][u] += maxH * k;
                    } else {
                        this.g[i][u] += k * dx;
                        this.H[i][u][u] += k;
                    }
                }
            }
        }
        if (!this.locks.isEmpty()) {
            this.locks.apply(function (u, p) {
                for (i = 0; i < _this.k; ++i) {
                    _this.H[i][u][u] += maxH;
                    _this.g[i][u] -= maxH * (p[i] - x[i][u]);
                }
            });
        }
    };
    Descent.dotProd = function (a, b) {
        var x = 0, i = a.length;
        while (i--)
            x += a[i] * b[i];
        return x;
    };
    Descent.rightMultiply = function (m, v, r) {
        var i = m.length;
        while (i--)
            r[i] = Descent.dotProd(m[i], v);
    };
    Descent.prototype.computeStepSize = function (d) {
        var numerator = 0, denominator = 0;
        for (var i = 0; i < this.k; ++i) {
            numerator += Descent.dotProd(this.g[i], d[i]);
            Descent.rightMultiply(this.H[i], d[i], this.Hd[i]);
            denominator += Descent.dotProd(d[i], this.Hd[i]);
        }
        if (denominator === 0 || !isFinite(denominator))
            return 0;
        return 1 * numerator / denominator;
    };
    Descent.prototype.reduceStress = function () {
        this.computeDerivatives(this.x);
        var alpha = this.computeStepSize(this.g);
        for (var i = 0; i < this.k; ++i) {
            this.takeDescentStep(this.x[i], this.g[i], alpha);
        }
        return this.computeStress();
    };
    Descent.copy = function (a, b) {
        var m = a.length, n = b[0].length;
        for (var i = 0; i < m; ++i) {
            for (var j = 0; j < n; ++j) {
                b[i][j] = a[i][j];
            }
        }
    };
    Descent.prototype.stepAndProject = function (x0, r, d, stepSize) {
        Descent.copy(x0, r);
        this.takeDescentStep(r[0], d[0], stepSize);
        if (this.project)
            this.project[0](x0[0], x0[1], r[0]);
        this.takeDescentStep(r[1], d[1], stepSize);
        if (this.project)
            this.project[1](r[0], x0[1], r[1]);
        for (var i = 2; i < this.k; i++)
            this.takeDescentStep(r[i], d[i], stepSize);
    };
    Descent.mApply = function (m, n, f) {
        var i = m;
        while (i-- > 0) {
            var j = n;
            while (j-- > 0)
                f(i, j);
        }
    };
    Descent.prototype.matrixApply = function (f) {
        Descent.mApply(this.k, this.n, f);
    };
    Descent.prototype.computeNextPosition = function (x0, r) {
        var _this = this;
        this.computeDerivatives(x0);
        var alpha = this.computeStepSize(this.g);
        this.stepAndProject(x0, r, this.g, alpha);
        if (this.project) {
            this.matrixApply(function (i, j) {
                return _this.e[i][j] = x0[i][j] - r[i][j];
            });
            var beta = this.computeStepSize(this.e);
            beta = Math.max(0.2, Math.min(beta, 1));
            this.stepAndProject(x0, r, this.e, beta);
        }
    };
    Descent.prototype.run = function (iterations) {
        var stress = Number.MAX_VALUE, converged = false;
        while (!converged && iterations-- > 0) {
            var s = this.rungeKutta();
            converged = Math.abs(stress / s - 1) < this.threshold;
            stress = s;
        }
        return stress;
    };
    Descent.prototype.rungeKutta = function () {
        var _this = this;
        this.computeNextPosition(this.x, this.a);
        Descent.mid(this.x, this.a, this.ia);
        this.computeNextPosition(this.ia, this.b);
        Descent.mid(this.x, this.b, this.ib);
        this.computeNextPosition(this.ib, this.c);
        this.computeNextPosition(this.c, this.d);
        var disp = 0;
        this.matrixApply(function (i, j) {
            var x = (_this.a[i][j] + 2 * _this.b[i][j] + 2 * _this.c[i][j] + _this.d[i][j]) / 6, d = _this.x[i][j] - x;
            disp += d * d;
            _this.x[i][j] = x;
        });
        return disp;
    };
    Descent.mid = function (a, b, m) {
        Descent.mApply(a.length, a[0].length, function (i, j) {
            return m[i][j] = a[i][j] + (b[i][j] - a[i][j]) / 2;
        });
    };
    Descent.prototype.takeDescentStep = function (x, d, stepSize) {
        for (var i = 0; i < this.n; ++i) {
            x[i] = x[i] - stepSize * d[i];
        }
    };
    Descent.prototype.computeStress = function () {
        var stress = 0;
        for (var u = 0, nMinus1 = this.n - 1; u < nMinus1; ++u) {
            for (var v = u + 1, n = this.n; v < n; ++v) {
                var l = 0;
                for (var i = 0; i < this.k; ++i) {
                    var dx = this.x[i][u] - this.x[i][v];
                    l += dx * dx;
                }
                l = Math.sqrt(l);
                var d = this.D[u][v];
                if (!isFinite(d))
                    continue;
                var rl = d - l;
                var d2 = d * d;
                stress += rl * rl / d2;
            }
        }
        return stress;
    };
    return Descent;
}();
Descent.zeroDistance = 1e-10;
exports.Descent = Descent;
var PseudoRandom = function () {
    function PseudoRandom(seed) {
        if (seed === void 0) {
            seed = 1;
        }
        this.seed = seed;
        this.a = 214013;
        this.c = 2531011;
        this.m = 2147483648;
        this.range = 32767;
    }
    PseudoRandom.prototype.getNext = function () {
        this.seed = (this.seed * this.a + this.c) % this.m;
        return (this.seed >> 16) / this.range;
    };
    PseudoRandom.prototype.getNextBetween = function (min, max) {
        return min + this.getNext() * (max - min);
    };
    return PseudoRandom;
}();
exports.PseudoRandom = PseudoRandom;
},{}],287:[function(require,module,exports){
'use strict';
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var rectangle_1 = require(296);
var Point = function () {
    function Point() {
    }
    return Point;
}();
exports.Point = Point;
var LineSegment = function () {
    function LineSegment(x1, y1, x2, y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }
    return LineSegment;
}();
exports.LineSegment = LineSegment;
var PolyPoint = function (_super) {
    __extends(PolyPoint, _super);
    function PolyPoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PolyPoint;
}(Point);
exports.PolyPoint = PolyPoint;
function isLeft(P0, P1, P2) {
    return (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);
}
exports.isLeft = isLeft;
function above(p, vi, vj) {
    return isLeft(p, vi, vj) > 0;
}
function below(p, vi, vj) {
    return isLeft(p, vi, vj) < 0;
}
function ConvexHull(S) {
    var P = S.slice(0).sort(function (a, b) {
        return a.x !== b.x ? b.x - a.x : b.y - a.y;
    });
    var n = S.length, i;
    var minmin = 0;
    var xmin = P[0].x;
    for (i = 1; i < n; ++i) {
        if (P[i].x !== xmin)
            break;
    }
    var minmax = i - 1;
    var H = [];
    H.push(P[minmin]);
    if (minmax === n - 1) {
        if (P[minmax].y !== P[minmin].y)
            H.push(P[minmax]);
    } else {
        var maxmin, maxmax = n - 1;
        var xmax = P[n - 1].x;
        for (i = n - 2; i >= 0; i--)
            if (P[i].x !== xmax)
                break;
        maxmin = i + 1;
        i = minmax;
        while (++i <= maxmin) {
            if (isLeft(P[minmin], P[maxmin], P[i]) >= 0 && i < maxmin)
                continue;
            while (H.length > 1) {
                if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
                    break;
                else
                    H.length -= 1;
            }
            if (i != minmin)
                H.push(P[i]);
        }
        if (maxmax != maxmin)
            H.push(P[maxmax]);
        var bot = H.length;
        i = maxmin;
        while (--i >= minmax) {
            if (isLeft(P[maxmax], P[minmax], P[i]) >= 0 && i > minmax)
                continue;
            while (H.length > bot) {
                if (isLeft(H[H.length - 2], H[H.length - 1], P[i]) > 0)
                    break;
                else
                    H.length -= 1;
            }
            if (i != minmin)
                H.push(P[i]);
        }
    }
    return H;
}
exports.ConvexHull = ConvexHull;
function clockwiseRadialSweep(p, P, f) {
    P.slice(0).sort(function (a, b) {
        return Math.atan2(a.y - p.y, a.x - p.x) - Math.atan2(b.y - p.y, b.x - p.x);
    }).forEach(f);
}
exports.clockwiseRadialSweep = clockwiseRadialSweep;
function nextPolyPoint(p, ps) {
    if (p.polyIndex === ps.length - 1)
        return ps[0];
    return ps[p.polyIndex + 1];
}
function prevPolyPoint(p, ps) {
    if (p.polyIndex === 0)
        return ps[ps.length - 1];
    return ps[p.polyIndex - 1];
}
function tangent_PointPolyC(P, V) {
    return {
        rtan: Rtangent_PointPolyC(P, V),
        ltan: Ltangent_PointPolyC(P, V)
    };
}
function Rtangent_PointPolyC(P, V) {
    var n = V.length - 1;
    var a, b, c;
    var upA, dnC;
    if (below(P, V[1], V[0]) && !above(P, V[n - 1], V[0]))
        return 0;
    for (a = 0, b = n;;) {
        if (b - a === 1)
            if (above(P, V[a], V[b]))
                return a;
            else
                return b;
        c = Math.floor((a + b) / 2);
        dnC = below(P, V[c + 1], V[c]);
        if (dnC && !above(P, V[c - 1], V[c]))
            return c;
        upA = above(P, V[a + 1], V[a]);
        if (upA) {
            if (dnC)
                b = c;
            else {
                if (above(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        } else {
            if (!dnC)
                a = c;
            else {
                if (below(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
    }
}
function Ltangent_PointPolyC(P, V) {
    var n = V.length - 1;
    var a, b, c;
    var dnA, dnC;
    if (above(P, V[n - 1], V[0]) && !below(P, V[1], V[0]))
        return 0;
    for (a = 0, b = n;;) {
        if (b - a === 1)
            if (below(P, V[a], V[b]))
                return a;
            else
                return b;
        c = Math.floor((a + b) / 2);
        dnC = below(P, V[c + 1], V[c]);
        if (above(P, V[c - 1], V[c]) && !dnC)
            return c;
        dnA = below(P, V[a + 1], V[a]);
        if (dnA) {
            if (!dnC)
                b = c;
            else {
                if (below(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        } else {
            if (dnC)
                a = c;
            else {
                if (above(P, V[a], V[c]))
                    b = c;
                else
                    a = c;
            }
        }
    }
}
function tangent_PolyPolyC(V, W, t1, t2, cmp1, cmp2) {
    var ix1, ix2;
    ix1 = t1(W[0], V);
    ix2 = t2(V[ix1], W);
    var done = false;
    while (!done) {
        done = true;
        while (true) {
            if (ix1 === V.length - 1)
                ix1 = 0;
            if (cmp1(W[ix2], V[ix1], V[ix1 + 1]))
                break;
            ++ix1;
        }
        while (true) {
            if (ix2 === 0)
                ix2 = W.length - 1;
            if (cmp2(V[ix1], W[ix2], W[ix2 - 1]))
                break;
            --ix2;
            done = false;
        }
    }
    return {
        t1: ix1,
        t2: ix2
    };
}
exports.tangent_PolyPolyC = tangent_PolyPolyC;
function LRtangent_PolyPolyC(V, W) {
    var rl = RLtangent_PolyPolyC(W, V);
    return {
        t1: rl.t2,
        t2: rl.t1
    };
}
exports.LRtangent_PolyPolyC = LRtangent_PolyPolyC;
function RLtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Ltangent_PointPolyC, above, below);
}
exports.RLtangent_PolyPolyC = RLtangent_PolyPolyC;
function LLtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Ltangent_PointPolyC, Ltangent_PointPolyC, below, below);
}
exports.LLtangent_PolyPolyC = LLtangent_PolyPolyC;
function RRtangent_PolyPolyC(V, W) {
    return tangent_PolyPolyC(V, W, Rtangent_PointPolyC, Rtangent_PointPolyC, above, above);
}
exports.RRtangent_PolyPolyC = RRtangent_PolyPolyC;
var BiTangent = function () {
    function BiTangent(t1, t2) {
        this.t1 = t1;
        this.t2 = t2;
    }
    return BiTangent;
}();
exports.BiTangent = BiTangent;
var BiTangents = function () {
    function BiTangents() {
    }
    return BiTangents;
}();
exports.BiTangents = BiTangents;
var TVGPoint = function (_super) {
    __extends(TVGPoint, _super);
    function TVGPoint() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return TVGPoint;
}(Point);
exports.TVGPoint = TVGPoint;
var VisibilityVertex = function () {
    function VisibilityVertex(id, polyid, polyvertid, p) {
        this.id = id;
        this.polyid = polyid;
        this.polyvertid = polyvertid;
        this.p = p;
        p.vv = this;
    }
    return VisibilityVertex;
}();
exports.VisibilityVertex = VisibilityVertex;
var VisibilityEdge = function () {
    function VisibilityEdge(source, target) {
        this.source = source;
        this.target = target;
    }
    VisibilityEdge.prototype.length = function () {
        var dx = this.source.p.x - this.target.p.x;
        var dy = this.source.p.y - this.target.p.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    return VisibilityEdge;
}();
exports.VisibilityEdge = VisibilityEdge;
var TangentVisibilityGraph = function () {
    function TangentVisibilityGraph(P, g0) {
        this.P = P;
        this.V = [];
        this.E = [];
        if (!g0) {
            var n = P.length;
            for (var i = 0; i < n; i++) {
                var p = P[i];
                for (var j = 0; j < p.length; ++j) {
                    var pj = p[j], vv = new VisibilityVertex(this.V.length, i, j, pj);
                    this.V.push(vv);
                    if (j > 0)
                        this.E.push(new VisibilityEdge(p[j - 1].vv, vv));
                }
            }
            for (var i = 0; i < n - 1; i++) {
                var Pi = P[i];
                for (var j = i + 1; j < n; j++) {
                    var Pj = P[j], t = tangents(Pi, Pj);
                    for (var q in t) {
                        var c = t[q], source = Pi[c.t1], target = Pj[c.t2];
                        this.addEdgeIfVisible(source, target, i, j);
                    }
                }
            }
        } else {
            this.V = g0.V.slice(0);
            this.E = g0.E.slice(0);
        }
    }
    TangentVisibilityGraph.prototype.addEdgeIfVisible = function (u, v, i1, i2) {
        if (!this.intersectsPolys(new LineSegment(u.x, u.y, v.x, v.y), i1, i2)) {
            this.E.push(new VisibilityEdge(u.vv, v.vv));
        }
    };
    TangentVisibilityGraph.prototype.addPoint = function (p, i1) {
        var n = this.P.length;
        this.V.push(new VisibilityVertex(this.V.length, n, 0, p));
        for (var i = 0; i < n; ++i) {
            if (i === i1)
                continue;
            var poly = this.P[i], t = tangent_PointPolyC(p, poly);
            this.addEdgeIfVisible(p, poly[t.ltan], i1, i);
            this.addEdgeIfVisible(p, poly[t.rtan], i1, i);
        }
        return p.vv;
    };
    TangentVisibilityGraph.prototype.intersectsPolys = function (l, i1, i2) {
        for (var i = 0, n = this.P.length; i < n; ++i) {
            if (i != i1 && i != i2 && intersects(l, this.P[i]).length > 0) {
                return true;
            }
        }
        return false;
    };
    return TangentVisibilityGraph;
}();
exports.TangentVisibilityGraph = TangentVisibilityGraph;
function intersects(l, P) {
    var ints = [];
    for (var i = 1, n = P.length; i < n; ++i) {
        var int = rectangle_1.Rectangle.lineIntersection(l.x1, l.y1, l.x2, l.y2, P[i - 1].x, P[i - 1].y, P[i].x, P[i].y);
        if (int)
            ints.push(int);
    }
    return ints;
}
function tangents(V, W) {
    var m = V.length - 1, n = W.length - 1;
    var bt = new BiTangents();
    for (var i = 0; i < m; ++i) {
        for (var j = 0; j < n; ++j) {
            var v1 = V[i == 0 ? m - 1 : i - 1];
            var v2 = V[i];
            var v3 = V[i + 1];
            var w1 = W[j == 0 ? n - 1 : j - 1];
            var w2 = W[j];
            var w3 = W[j + 1];
            var v1v2w2 = isLeft(v1, v2, w2);
            var v2w1w2 = isLeft(v2, w1, w2);
            var v2w2w3 = isLeft(v2, w2, w3);
            var w1w2v2 = isLeft(w1, w2, v2);
            var w2v1v2 = isLeft(w2, v1, v2);
            var w2v2v3 = isLeft(w2, v2, v3);
            if (v1v2w2 >= 0 && v2w1w2 >= 0 && v2w2w3 < 0 && w1w2v2 >= 0 && w2v1v2 >= 0 && w2v2v3 < 0) {
                bt.ll = new BiTangent(i, j);
            } else if (v1v2w2 <= 0 && v2w1w2 <= 0 && v2w2w3 > 0 && w1w2v2 <= 0 && w2v1v2 <= 0 && w2v2v3 > 0) {
                bt.rr = new BiTangent(i, j);
            } else if (v1v2w2 <= 0 && v2w1w2 > 0 && v2w2w3 <= 0 && w1w2v2 >= 0 && w2v1v2 < 0 && w2v2v3 >= 0) {
                bt.rl = new BiTangent(i, j);
            } else if (v1v2w2 >= 0 && v2w1w2 < 0 && v2w2w3 >= 0 && w1w2v2 <= 0 && w2v1v2 > 0 && w2v2v3 <= 0) {
                bt.lr = new BiTangent(i, j);
            }
        }
    }
    return bt;
}
exports.tangents = tangents;
function isPointInsidePoly(p, poly) {
    for (var i = 1, n = poly.length; i < n; ++i)
        if (below(poly[i - 1], poly[i], p))
            return false;
    return true;
}
function isAnyPInQ(p, q) {
    return !p.every(function (v) {
        return !isPointInsidePoly(v, q);
    });
}
function polysOverlap(p, q) {
    if (isAnyPInQ(p, q))
        return true;
    if (isAnyPInQ(q, p))
        return true;
    for (var i = 1, n = p.length; i < n; ++i) {
        var v = p[i], u = p[i - 1];
        if (intersects(new LineSegment(u.x, u.y, v.x, v.y), q).length > 0)
            return true;
    }
    return false;
}
exports.polysOverlap = polysOverlap;
},{"296":296}],288:[function(require,module,exports){
'use strict';
var rectangle_1 = require(296);
var vpsc_1 = require(298);
var shortestpaths_1 = require(297);
var NodeWrapper = function () {
    function NodeWrapper(id, rect, children) {
        this.id = id;
        this.rect = rect;
        this.children = children;
        this.leaf = typeof children === 'undefined' || children.length === 0;
    }
    return NodeWrapper;
}();
exports.NodeWrapper = NodeWrapper;
var Vert = function () {
    function Vert(id, x, y, node, line) {
        if (node === void 0) {
            node = null;
        }
        if (line === void 0) {
            line = null;
        }
        this.id = id;
        this.x = x;
        this.y = y;
        this.node = node;
        this.line = line;
    }
    return Vert;
}();
exports.Vert = Vert;
var LongestCommonSubsequence = function () {
    function LongestCommonSubsequence(s, t) {
        this.s = s;
        this.t = t;
        var mf = LongestCommonSubsequence.findMatch(s, t);
        var tr = t.slice(0).reverse();
        var mr = LongestCommonSubsequence.findMatch(s, tr);
        if (mf.length >= mr.length) {
            this.length = mf.length;
            this.si = mf.si;
            this.ti = mf.ti;
            this.reversed = false;
        } else {
            this.length = mr.length;
            this.si = mr.si;
            this.ti = t.length - mr.ti - mr.length;
            this.reversed = true;
        }
    }
    LongestCommonSubsequence.findMatch = function (s, t) {
        var m = s.length;
        var n = t.length;
        var match = {
            length: 0,
            si: -1,
            ti: -1
        };
        var l = new Array(m);
        for (var i = 0; i < m; i++) {
            l[i] = new Array(n);
            for (var j = 0; j < n; j++)
                if (s[i] === t[j]) {
                    var v = l[i][j] = i === 0 || j === 0 ? 1 : l[i - 1][j - 1] + 1;
                    if (v > match.length) {
                        match.length = v;
                        match.si = i - v + 1;
                        match.ti = j - v + 1;
                    }
                    ;
                } else
                    l[i][j] = 0;
        }
        return match;
    };
    LongestCommonSubsequence.prototype.getSequence = function () {
        return this.length >= 0 ? this.s.slice(this.si, this.si + this.length) : [];
    };
    return LongestCommonSubsequence;
}();
exports.LongestCommonSubsequence = LongestCommonSubsequence;
var GridRouter = function () {
    function GridRouter(originalnodes, accessor, groupPadding) {
        if (groupPadding === void 0) {
            groupPadding = 12;
        }
        var _this = this;
        this.originalnodes = originalnodes;
        this.groupPadding = groupPadding;
        this.leaves = null;
        this.nodes = originalnodes.map(function (v, i) {
            return new NodeWrapper(i, accessor.getBounds(v), accessor.getChildren(v));
        });
        this.leaves = this.nodes.filter(function (v) {
            return v.leaf;
        });
        this.groups = this.nodes.filter(function (g) {
            return !g.leaf;
        });
        this.cols = this.getGridLines('x');
        this.rows = this.getGridLines('y');
        this.groups.forEach(function (v) {
            return v.children.forEach(function (c) {
                return _this.nodes[c].parent = v;
            });
        });
        this.root = { children: [] };
        this.nodes.forEach(function (v) {
            if (typeof v.parent === 'undefined') {
                v.parent = _this.root;
                _this.root.children.push(v.id);
            }
            v.ports = [];
        });
        this.backToFront = this.nodes.slice(0);
        this.backToFront.sort(function (x, y) {
            return _this.getDepth(x) - _this.getDepth(y);
        });
        var frontToBackGroups = this.backToFront.slice(0).reverse().filter(function (g) {
            return !g.leaf;
        });
        frontToBackGroups.forEach(function (v) {
            var r = rectangle_1.Rectangle.empty();
            v.children.forEach(function (c) {
                return r = r.union(_this.nodes[c].rect);
            });
            v.rect = r.inflate(_this.groupPadding);
        });
        var colMids = this.midPoints(this.cols.map(function (r) {
            return r.pos;
        }));
        var rowMids = this.midPoints(this.rows.map(function (r) {
            return r.pos;
        }));
        var rowx = colMids[0], rowX = colMids[colMids.length - 1];
        var coly = rowMids[0], colY = rowMids[rowMids.length - 1];
        var hlines = this.rows.map(function (r) {
            return {
                x1: rowx,
                x2: rowX,
                y1: r.pos,
                y2: r.pos
            };
        }).concat(rowMids.map(function (m) {
            return {
                x1: rowx,
                x2: rowX,
                y1: m,
                y2: m
            };
        }));
        var vlines = this.cols.map(function (c) {
            return {
                x1: c.pos,
                x2: c.pos,
                y1: coly,
                y2: colY
            };
        }).concat(colMids.map(function (m) {
            return {
                x1: m,
                x2: m,
                y1: coly,
                y2: colY
            };
        }));
        var lines = hlines.concat(vlines);
        lines.forEach(function (l) {
            return l.verts = [];
        });
        this.verts = [];
        this.edges = [];
        hlines.forEach(function (h) {
            return vlines.forEach(function (v) {
                var p = new Vert(_this.verts.length, v.x1, h.y1);
                h.verts.push(p);
                v.verts.push(p);
                _this.verts.push(p);
                var i = _this.backToFront.length;
                while (i-- > 0) {
                    var node = _this.backToFront[i], r = node.rect;
                    var dx = Math.abs(p.x - r.cx()), dy = Math.abs(p.y - r.cy());
                    if (dx < r.width() / 2 && dy < r.height() / 2) {
                        p.node = node;
                        break;
                    }
                }
            });
        });
        lines.forEach(function (l, li) {
            _this.nodes.forEach(function (v, i) {
                v.rect.lineIntersections(l.x1, l.y1, l.x2, l.y2).forEach(function (intersect, j) {
                    var p = new Vert(_this.verts.length, intersect.x, intersect.y, v, l);
                    _this.verts.push(p);
                    l.verts.push(p);
                    v.ports.push(p);
                });
            });
            var isHoriz = Math.abs(l.y1 - l.y2) < 0.1;
            var delta = function (a, b) {
                return isHoriz ? b.x - a.x : b.y - a.y;
            };
            l.verts.sort(delta);
            for (var i = 1; i < l.verts.length; i++) {
                var u = l.verts[i - 1], v = l.verts[i];
                if (u.node && u.node === v.node && u.node.leaf)
                    continue;
                _this.edges.push({
                    source: u.id,
                    target: v.id,
                    length: Math.abs(delta(u, v))
                });
            }
        });
    }
    GridRouter.prototype.avg = function (a) {
        return a.reduce(function (x, y) {
            return x + y;
        }) / a.length;
    };
    GridRouter.prototype.getGridLines = function (axis) {
        var columns = [];
        var ls = this.leaves.slice(0, this.leaves.length);
        while (ls.length > 0) {
            var overlapping = ls.filter(function (v) {
                return v.rect['overlap' + axis.toUpperCase()](ls[0].rect);
            });
            var col = {
                nodes: overlapping,
                pos: this.avg(overlapping.map(function (v) {
                    return v.rect['c' + axis]();
                }))
            };
            columns.push(col);
            col.nodes.forEach(function (v) {
                return ls.splice(ls.indexOf(v), 1);
            });
        }
        columns.sort(function (a, b) {
            return a.pos - b.pos;
        });
        return columns;
    };
    GridRouter.prototype.getDepth = function (v) {
        var depth = 0;
        while (v.parent !== this.root) {
            depth++;
            v = v.parent;
        }
        return depth;
    };
    GridRouter.prototype.midPoints = function (a) {
        var gap = a[1] - a[0];
        var mids = [a[0] - gap / 2];
        for (var i = 1; i < a.length; i++) {
            mids.push((a[i] + a[i - 1]) / 2);
        }
        mids.push(a[a.length - 1] + gap / 2);
        return mids;
    };
    GridRouter.prototype.findLineage = function (v) {
        var lineage = [v];
        do {
            v = v.parent;
            lineage.push(v);
        } while (v !== this.root);
        return lineage.reverse();
    };
    GridRouter.prototype.findAncestorPathBetween = function (a, b) {
        var aa = this.findLineage(a), ba = this.findLineage(b), i = 0;
        while (aa[i] === ba[i])
            i++;
        return {
            commonAncestor: aa[i - 1],
            lineages: aa.slice(i).concat(ba.slice(i))
        };
    };
    GridRouter.prototype.siblingObstacles = function (a, b) {
        var _this = this;
        var path = this.findAncestorPathBetween(a, b);
        var lineageLookup = {};
        path.lineages.forEach(function (v) {
            return lineageLookup[v.id] = {};
        });
        var obstacles = path.commonAncestor.children.filter(function (v) {
            return !(v in lineageLookup);
        });
        path.lineages.filter(function (v) {
            return v.parent !== path.commonAncestor;
        }).forEach(function (v) {
            return obstacles = obstacles.concat(v.parent.children.filter(function (c) {
                return c !== v.id;
            }));
        });
        return obstacles.map(function (v) {
            return _this.nodes[v];
        });
    };
    GridRouter.getSegmentSets = function (routes, x, y) {
        var vsegments = [];
        for (var ei = 0; ei < routes.length; ei++) {
            var route = routes[ei];
            for (var si = 0; si < route.length; si++) {
                var s = route[si];
                s.edgeid = ei;
                s.i = si;
                var sdx = s[1][x] - s[0][x];
                if (Math.abs(sdx) < 0.1) {
                    vsegments.push(s);
                }
            }
        }
        vsegments.sort(function (a, b) {
            return a[0][x] - b[0][x];
        });
        var vsegmentsets = [];
        var segmentset = null;
        for (var i = 0; i < vsegments.length; i++) {
            var s = vsegments[i];
            if (!segmentset || Math.abs(s[0][x] - segmentset.pos) > 0.1) {
                segmentset = {
                    pos: s[0][x],
                    segments: []
                };
                vsegmentsets.push(segmentset);
            }
            segmentset.segments.push(s);
        }
        return vsegmentsets;
    };
    GridRouter.nudgeSegs = function (x, y, routes, segments, leftOf, gap) {
        var n = segments.length;
        if (n <= 1)
            return;
        var vs = segments.map(function (s) {
            return new vpsc_1.Variable(s[0][x]);
        });
        var cs = [];
        for (var i = 0; i < n; i++) {
            for (var j = 0; j < n; j++) {
                if (i === j)
                    continue;
                var s1 = segments[i], s2 = segments[j], e1 = s1.edgeid, e2 = s2.edgeid, lind = -1, rind = -1;
                if (x == 'x') {
                    if (leftOf(e1, e2)) {
                        if (s1[0][y] < s1[1][y]) {
                            lind = j, rind = i;
                        } else {
                            lind = i, rind = j;
                        }
                    }
                } else {
                    if (leftOf(e1, e2)) {
                        if (s1[0][y] < s1[1][y]) {
                            lind = i, rind = j;
                        } else {
                            lind = j, rind = i;
                        }
                    }
                }
                if (lind >= 0) {
                    cs.push(new vpsc_1.Constraint(vs[lind], vs[rind], gap));
                }
            }
        }
        var solver = new vpsc_1.Solver(vs, cs);
        solver.solve();
        vs.forEach(function (v, i) {
            var s = segments[i];
            var pos = v.position();
            s[0][x] = s[1][x] = pos;
            var route = routes[s.edgeid];
            if (s.i > 0)
                route[s.i - 1][1][x] = pos;
            if (s.i < route.length - 1)
                route[s.i + 1][0][x] = pos;
        });
    };
    GridRouter.nudgeSegments = function (routes, x, y, leftOf, gap) {
        var vsegmentsets = GridRouter.getSegmentSets(routes, x, y);
        for (var i = 0; i < vsegmentsets.length; i++) {
            var ss = vsegmentsets[i];
            var events = [];
            for (var j = 0; j < ss.segments.length; j++) {
                var s = ss.segments[j];
                events.push({
                    type: 0,
                    s: s,
                    pos: Math.min(s[0][y], s[1][y])
                });
                events.push({
                    type: 1,
                    s: s,
                    pos: Math.max(s[0][y], s[1][y])
                });
            }
            events.sort(function (a, b) {
                return a.pos - b.pos + a.type - b.type;
            });
            var open = [];
            var openCount = 0;
            events.forEach(function (e) {
                if (e.type === 0) {
                    open.push(e.s);
                    openCount++;
                } else {
                    openCount--;
                }
                if (openCount == 0) {
                    GridRouter.nudgeSegs(x, y, routes, open, leftOf, gap);
                    open = [];
                }
            });
        }
    };
    GridRouter.prototype.routeEdges = function (edges, nudgeGap, source, target) {
        var _this = this;
        var routePaths = edges.map(function (e) {
            return _this.route(source(e), target(e));
        });
        var order = GridRouter.orderEdges(routePaths);
        var routes = routePaths.map(function (e) {
            return GridRouter.makeSegments(e);
        });
        GridRouter.nudgeSegments(routes, 'x', 'y', order, nudgeGap);
        GridRouter.nudgeSegments(routes, 'y', 'x', order, nudgeGap);
        GridRouter.unreverseEdges(routes, routePaths);
        return routes;
    };
    GridRouter.unreverseEdges = function (routes, routePaths) {
        routes.forEach(function (segments, i) {
            var path = routePaths[i];
            if (path.reversed) {
                segments.reverse();
                segments.forEach(function (segment) {
                    segment.reverse();
                });
            }
        });
    };
    GridRouter.angleBetween2Lines = function (line1, line2) {
        var angle1 = Math.atan2(line1[0].y - line1[1].y, line1[0].x - line1[1].x);
        var angle2 = Math.atan2(line2[0].y - line2[1].y, line2[0].x - line2[1].x);
        var diff = angle1 - angle2;
        if (diff > Math.PI || diff < -Math.PI) {
            diff = angle2 - angle1;
        }
        return diff;
    };
    GridRouter.isLeft = function (a, b, c) {
        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x) <= 0;
    };
    GridRouter.getOrder = function (pairs) {
        var outgoing = {};
        for (var i = 0; i < pairs.length; i++) {
            var p = pairs[i];
            if (typeof outgoing[p.l] === 'undefined')
                outgoing[p.l] = {};
            outgoing[p.l][p.r] = true;
        }
        return function (l, r) {
            return typeof outgoing[l] !== 'undefined' && outgoing[l][r];
        };
    };
    GridRouter.orderEdges = function (edges) {
        var edgeOrder = [];
        for (var i = 0; i < edges.length - 1; i++) {
            for (var j = i + 1; j < edges.length; j++) {
                var e = edges[i], f = edges[j], lcs = new LongestCommonSubsequence(e, f);
                var u, vi, vj;
                if (lcs.length === 0)
                    continue;
                if (lcs.reversed) {
                    f.reverse();
                    f.reversed = true;
                    lcs = new LongestCommonSubsequence(e, f);
                }
                if ((lcs.si <= 0 || lcs.ti <= 0) && (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length)) {
                    edgeOrder.push({
                        l: i,
                        r: j
                    });
                    continue;
                }
                if (lcs.si + lcs.length >= e.length || lcs.ti + lcs.length >= f.length) {
                    u = e[lcs.si + 1];
                    vj = e[lcs.si - 1];
                    vi = f[lcs.ti - 1];
                } else {
                    u = e[lcs.si + lcs.length - 2];
                    vi = e[lcs.si + lcs.length];
                    vj = f[lcs.ti + lcs.length];
                }
                if (GridRouter.isLeft(u, vi, vj)) {
                    edgeOrder.push({
                        l: j,
                        r: i
                    });
                } else {
                    edgeOrder.push({
                        l: i,
                        r: j
                    });
                }
            }
        }
        return GridRouter.getOrder(edgeOrder);
    };
    GridRouter.makeSegments = function (path) {
        function copyPoint(p) {
            return {
                x: p.x,
                y: p.y
            };
        }
        var isStraight = function (a, b, c) {
            return Math.abs((b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) < 0.001;
        };
        var segments = [];
        var a = copyPoint(path[0]);
        for (var i = 1; i < path.length; i++) {
            var b = copyPoint(path[i]), c = i < path.length - 1 ? path[i + 1] : null;
            if (!c || !isStraight(a, b, c)) {
                segments.push([
                    a,
                    b
                ]);
                a = b;
            }
        }
        return segments;
    };
    GridRouter.prototype.route = function (s, t) {
        var _this = this;
        var source = this.nodes[s], target = this.nodes[t];
        this.obstacles = this.siblingObstacles(source, target);
        var obstacleLookup = {};
        this.obstacles.forEach(function (o) {
            return obstacleLookup[o.id] = o;
        });
        this.passableEdges = this.edges.filter(function (e) {
            var u = _this.verts[e.source], v = _this.verts[e.target];
            return !(u.node && u.node.id in obstacleLookup || v.node && v.node.id in obstacleLookup);
        });
        for (var i = 1; i < source.ports.length; i++) {
            var u = source.ports[0].id;
            var v = source.ports[i].id;
            this.passableEdges.push({
                source: u,
                target: v,
                length: 0
            });
        }
        for (var i = 1; i < target.ports.length; i++) {
            var u = target.ports[0].id;
            var v = target.ports[i].id;
            this.passableEdges.push({
                source: u,
                target: v,
                length: 0
            });
        }
        var getSource = function (e) {
                return e.source;
            }, getTarget = function (e) {
                return e.target;
            }, getLength = function (e) {
                return e.length;
            };
        var shortestPathCalculator = new shortestpaths_1.Calculator(this.verts.length, this.passableEdges, getSource, getTarget, getLength);
        var bendPenalty = function (u, v, w) {
            var a = _this.verts[u], b = _this.verts[v], c = _this.verts[w];
            var dx = Math.abs(c.x - a.x), dy = Math.abs(c.y - a.y);
            if (a.node === source && a.node === b.node || b.node === target && b.node === c.node)
                return 0;
            return dx > 1 && dy > 1 ? 1000 : 0;
        };
        var shortestPath = shortestPathCalculator.PathFromNodeToNodeWithPrevCost(source.ports[0].id, target.ports[0].id, bendPenalty);
        var pathPoints = shortestPath.reverse().map(function (vi) {
            return _this.verts[vi];
        });
        pathPoints.push(this.nodes[target.id].ports[0]);
        return pathPoints.filter(function (v, i) {
            return !(i < pathPoints.length - 1 && pathPoints[i + 1].node === source && v.node === source || i > 0 && v.node === target && pathPoints[i - 1].node === target);
        });
    };
    GridRouter.getRoutePath = function (route, cornerradius, arrowwidth, arrowheight) {
        var result = {
            routepath: 'M ' + route[0][0].x + ' ' + route[0][0].y + ' ',
            arrowpath: ''
        };
        if (route.length > 1) {
            for (var i = 0; i < route.length; i++) {
                var li = route[i];
                var x = li[1].x, y = li[1].y;
                var dx = x - li[0].x;
                var dy = y - li[0].y;
                if (i < route.length - 1) {
                    if (Math.abs(dx) > 0) {
                        x -= dx / Math.abs(dx) * cornerradius;
                    } else {
                        y -= dy / Math.abs(dy) * cornerradius;
                    }
                    result.routepath += 'L ' + x + ' ' + y + ' ';
                    var l = route[i + 1];
                    var x0 = l[0].x, y0 = l[0].y;
                    var x1 = l[1].x;
                    var y1 = l[1].y;
                    dx = x1 - x0;
                    dy = y1 - y0;
                    var angle = GridRouter.angleBetween2Lines(li, l) < 0 ? 1 : 0;
                    var x2, y2;
                    if (Math.abs(dx) > 0) {
                        x2 = x0 + dx / Math.abs(dx) * cornerradius;
                        y2 = y0;
                    } else {
                        x2 = x0;
                        y2 = y0 + dy / Math.abs(dy) * cornerradius;
                    }
                    var cx = Math.abs(x2 - x);
                    var cy = Math.abs(y2 - y);
                    result.routepath += 'A ' + cx + ' ' + cy + ' 0 0 ' + angle + ' ' + x2 + ' ' + y2 + ' ';
                } else {
                    var arrowtip = [
                        x,
                        y
                    ];
                    var arrowcorner1, arrowcorner2;
                    if (Math.abs(dx) > 0) {
                        x -= dx / Math.abs(dx) * arrowheight;
                        arrowcorner1 = [
                            x,
                            y + arrowwidth
                        ];
                        arrowcorner2 = [
                            x,
                            y - arrowwidth
                        ];
                    } else {
                        y -= dy / Math.abs(dy) * arrowheight;
                        arrowcorner1 = [
                            x + arrowwidth,
                            y
                        ];
                        arrowcorner2 = [
                            x - arrowwidth,
                            y
                        ];
                    }
                    result.routepath += 'L ' + x + ' ' + y + ' ';
                    if (arrowheight > 0) {
                        result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1] + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];
                    }
                }
            }
        } else {
            var li = route[0];
            var x = li[1].x, y = li[1].y;
            var dx = x - li[0].x;
            var dy = y - li[0].y;
            var arrowtip = [
                x,
                y
            ];
            var arrowcorner1, arrowcorner2;
            if (Math.abs(dx) > 0) {
                x -= dx / Math.abs(dx) * arrowheight;
                arrowcorner1 = [
                    x,
                    y + arrowwidth
                ];
                arrowcorner2 = [
                    x,
                    y - arrowwidth
                ];
            } else {
                y -= dy / Math.abs(dy) * arrowheight;
                arrowcorner1 = [
                    x + arrowwidth,
                    y
                ];
                arrowcorner2 = [
                    x - arrowwidth,
                    y
                ];
            }
            result.routepath += 'L ' + x + ' ' + y + ' ';
            if (arrowheight > 0) {
                result.arrowpath = 'M ' + arrowtip[0] + ' ' + arrowtip[1] + ' L ' + arrowcorner1[0] + ' ' + arrowcorner1[1] + ' L ' + arrowcorner2[0] + ' ' + arrowcorner2[1];
            }
        }
        return result;
    };
    return GridRouter;
}();
exports.GridRouter = GridRouter;
},{"296":296,"297":297,"298":298}],289:[function(require,module,exports){
'use strict';
var packingOptions = {
    PADDING: 10,
    GOLDEN_SECTION: (1 + Math.sqrt(5)) / 2,
    FLOAT_EPSILON: 0.0001,
    MAX_INERATIONS: 100
};
function applyPacking(graphs, w, h, node_size, desired_ratio) {
    if (desired_ratio === void 0) {
        desired_ratio = 1;
    }
    var init_x = 0, init_y = 0, svg_width = w, svg_height = h, desired_ratio = typeof desired_ratio !== 'undefined' ? desired_ratio : 1, node_size = typeof node_size !== 'undefined' ? node_size : 0, real_width = 0, real_height = 0, min_width = 0, global_bottom = 0, line = [];
    if (graphs.length == 0)
        return;
    calculate_bb(graphs);
    apply(graphs, desired_ratio);
    put_nodes_to_right_positions(graphs);
    function calculate_bb(graphs) {
        graphs.forEach(function (g) {
            calculate_single_bb(g);
        });
        function calculate_single_bb(graph) {
            var min_x = Number.MAX_VALUE, min_y = Number.MAX_VALUE, max_x = 0, max_y = 0;
            graph.array.forEach(function (v) {
                var w = typeof v.width !== 'undefined' ? v.width : node_size;
                var h = typeof v.height !== 'undefined' ? v.height : node_size;
                w /= 2;
                h /= 2;
                max_x = Math.max(v.x + w, max_x);
                min_x = Math.min(v.x - w, min_x);
                max_y = Math.max(v.y + h, max_y);
                min_y = Math.min(v.y - h, min_y);
            });
            graph.width = max_x - min_x;
            graph.height = max_y - min_y;
        }
    }
    function put_nodes_to_right_positions(graphs) {
        graphs.forEach(function (g) {
            var center = {
                x: 0,
                y: 0
            };
            g.array.forEach(function (node) {
                center.x += node.x;
                center.y += node.y;
            });
            center.x /= g.array.length;
            center.y /= g.array.length;
            var corner = {
                x: center.x - g.width / 2,
                y: center.y - g.height / 2
            };
            var offset = {
                x: g.x - corner.x + svg_width / 2 - real_width / 2,
                y: g.y - corner.y + svg_height / 2 - real_height / 2
            };
            g.array.forEach(function (node) {
                node.x += offset.x;
                node.y += offset.y;
            });
        });
    }
    function apply(data, desired_ratio) {
        var curr_best_f = Number.POSITIVE_INFINITY;
        var curr_best = 0;
        data.sort(function (a, b) {
            return b.height - a.height;
        });
        min_width = data.reduce(function (a, b) {
            return a.width < b.width ? a.width : b.width;
        });
        var left = x1 = min_width;
        var right = x2 = get_entire_width(data);
        var iterationCounter = 0;
        var f_x1 = Number.MAX_VALUE;
        var f_x2 = Number.MAX_VALUE;
        var flag = -1;
        var dx = Number.MAX_VALUE;
        var df = Number.MAX_VALUE;
        while (dx > min_width || df > packingOptions.FLOAT_EPSILON) {
            if (flag != 1) {
                var x1 = right - (right - left) / packingOptions.GOLDEN_SECTION;
                var f_x1 = step(data, x1);
            }
            if (flag != 0) {
                var x2 = left + (right - left) / packingOptions.GOLDEN_SECTION;
                var f_x2 = step(data, x2);
            }
            dx = Math.abs(x1 - x2);
            df = Math.abs(f_x1 - f_x2);
            if (f_x1 < curr_best_f) {
                curr_best_f = f_x1;
                curr_best = x1;
            }
            if (f_x2 < curr_best_f) {
                curr_best_f = f_x2;
                curr_best = x2;
            }
            if (f_x1 > f_x2) {
                left = x1;
                x1 = x2;
                f_x1 = f_x2;
                flag = 1;
            } else {
                right = x2;
                x2 = x1;
                f_x2 = f_x1;
                flag = 0;
            }
            if (iterationCounter++ > 100) {
                break;
            }
        }
        step(data, curr_best);
    }
    function step(data, max_width) {
        line = [];
        real_width = 0;
        real_height = 0;
        global_bottom = init_y;
        for (var i = 0; i < data.length; i++) {
            var o = data[i];
            put_rect(o, max_width);
        }
        return Math.abs(get_real_ratio() - desired_ratio);
    }
    function put_rect(rect, max_width) {
        var parent = undefined;
        for (var i = 0; i < line.length; i++) {
            if (line[i].space_left >= rect.height && line[i].x + line[i].width + rect.width + packingOptions.PADDING - max_width <= packingOptions.FLOAT_EPSILON) {
                parent = line[i];
                break;
            }
        }
        line.push(rect);
        if (parent !== undefined) {
            rect.x = parent.x + parent.width + packingOptions.PADDING;
            rect.y = parent.bottom;
            rect.space_left = rect.height;
            rect.bottom = rect.y;
            parent.space_left -= rect.height + packingOptions.PADDING;
            parent.bottom += rect.height + packingOptions.PADDING;
        } else {
            rect.y = global_bottom;
            global_bottom += rect.height + packingOptions.PADDING;
            rect.x = init_x;
            rect.bottom = rect.y;
            rect.space_left = rect.height;
        }
        if (rect.y + rect.height - real_height > -packingOptions.FLOAT_EPSILON)
            real_height = rect.y + rect.height - init_y;
        if (rect.x + rect.width - real_width > -packingOptions.FLOAT_EPSILON)
            real_width = rect.x + rect.width - init_x;
    }
    ;
    function get_entire_width(data) {
        var width = 0;
        data.forEach(function (d) {
            return width += d.width + packingOptions.PADDING;
        });
        return width;
    }
    function get_real_ratio() {
        return real_width / real_height;
    }
}
exports.applyPacking = applyPacking;
function separateGraphs(nodes, links) {
    var marks = {};
    var ways = {};
    var graphs = [];
    var clusters = 0;
    for (var i = 0; i < links.length; i++) {
        var link = links[i];
        var n1 = link.source;
        var n2 = link.target;
        if (ways[n1.index])
            ways[n1.index].push(n2);
        else
            ways[n1.index] = [n2];
        if (ways[n2.index])
            ways[n2.index].push(n1);
        else
            ways[n2.index] = [n1];
    }
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (marks[node.index])
            continue;
        explore_node(node, true);
    }
    function explore_node(n, is_new) {
        if (marks[n.index] !== undefined)
            return;
        if (is_new) {
            clusters++;
            graphs.push({ array: [] });
        }
        marks[n.index] = clusters;
        graphs[clusters - 1].array.push(n);
        var adjacent = ways[n.index];
        if (!adjacent)
            return;
        for (var j = 0; j < adjacent.length; j++) {
            explore_node(adjacent[j], false);
        }
    }
    return graphs;
}
exports.separateGraphs = separateGraphs;
},{}],290:[function(require,module,exports){
'use strict';
var powergraph = require(293);
var linklengths_1 = require(292);
var descent_1 = require(286);
var rectangle_1 = require(296);
var shortestpaths_1 = require(297);
var geom_1 = require(287);
var handledisconnected_1 = require(289);
var EventType;
(function (EventType) {
    EventType[EventType['start'] = 0] = 'start';
    EventType[EventType['tick'] = 1] = 'tick';
    EventType[EventType['end'] = 2] = 'end';
}(EventType = exports.EventType || (exports.EventType = {})));
;
function isGroup(g) {
    return typeof g.leaves !== 'undefined' || typeof g.groups !== 'undefined';
}
var Layout = function () {
    function Layout() {
        var _this = this;
        this._canvasSize = [
            1,
            1
        ];
        this._linkDistance = 20;
        this._defaultNodeSize = 10;
        this._linkLengthCalculator = null;
        this._linkType = null;
        this._avoidOverlaps = false;
        this._handleDisconnected = true;
        this._running = false;
        this._nodes = [];
        this._groups = [];
        this._rootGroup = null;
        this._links = [];
        this._constraints = [];
        this._distanceMatrix = null;
        this._descent = null;
        this._directedLinkConstraints = null;
        this._threshold = 0.01;
        this._visibilityGraph = null;
        this._groupCompactness = 0.000001;
        this.event = null;
        this.linkAccessor = {
            getSourceIndex: Layout.getSourceIndex,
            getTargetIndex: Layout.getTargetIndex,
            setLength: Layout.setLinkLength,
            getType: function (l) {
                return typeof _this._linkType === 'function' ? _this._linkType(l) : 0;
            }
        };
    }
    Layout.prototype.on = function (e, listener) {
        if (!this.event)
            this.event = {};
        if (typeof e === 'string') {
            this.event[EventType[e]] = listener;
        } else {
            this.event[e] = listener;
        }
        return this;
    };
    Layout.prototype.trigger = function (e) {
        if (this.event && typeof this.event[e.type] !== 'undefined') {
            this.event[e.type](e);
        }
    };
    Layout.prototype.kick = function () {
        while (!this.tick());
    };
    Layout.prototype.tick = function () {
        if (this._alpha < this._threshold) {
            this._running = false;
            this.trigger({
                type: EventType.end,
                alpha: this._alpha = 0,
                stress: this._lastStress
            });
            return true;
        }
        var n = this._nodes.length, m = this._links.length;
        var o, i;
        this._descent.locks.clear();
        for (i = 0; i < n; ++i) {
            o = this._nodes[i];
            if (o.fixed) {
                if (typeof o.px === 'undefined' || typeof o.py === 'undefined') {
                    o.px = o.x;
                    o.py = o.y;
                }
                var p = [
                    o.px,
                    o.py
                ];
                this._descent.locks.add(i, p);
            }
        }
        var s1 = this._descent.rungeKutta();
        if (s1 === 0) {
            this._alpha = 0;
        } else if (typeof this._lastStress !== 'undefined') {
            this._alpha = s1;
        }
        this._lastStress = s1;
        this.updateNodePositions();
        this.trigger({
            type: EventType.tick,
            alpha: this._alpha,
            stress: this._lastStress
        });
        return false;
    };
    Layout.prototype.updateNodePositions = function () {
        var x = this._descent.x[0], y = this._descent.x[1];
        var o, i = this._nodes.length;
        while (i--) {
            o = this._nodes[i];
            o.x = x[i];
            o.y = y[i];
        }
    };
    Layout.prototype.nodes = function (v) {
        if (!v) {
            if (this._nodes.length === 0 && this._links.length > 0) {
                var n = 0;
                this._links.forEach(function (l) {
                    n = Math.max(n, l.source, l.target);
                });
                this._nodes = new Array(++n);
                for (var i = 0; i < n; ++i) {
                    this._nodes[i] = {};
                }
            }
            return this._nodes;
        }
        this._nodes = v;
        return this;
    };
    Layout.prototype.groups = function (x) {
        var _this = this;
        if (!x)
            return this._groups;
        this._groups = x;
        this._rootGroup = {};
        this._groups.forEach(function (g) {
            if (typeof g.padding === 'undefined')
                g.padding = 1;
            if (typeof g.leaves !== 'undefined') {
                g.leaves.forEach(function (v, i) {
                    if (typeof v === 'number')
                        (g.leaves[i] = _this._nodes[v]).parent = g;
                });
            }
            if (typeof g.groups !== 'undefined') {
                g.groups.forEach(function (gi, i) {
                    if (typeof gi === 'number')
                        (g.groups[i] = _this._groups[gi]).parent = g;
                });
            }
        });
        this._rootGroup.leaves = this._nodes.filter(function (v) {
            return typeof v.parent === 'undefined';
        });
        this._rootGroup.groups = this._groups.filter(function (g) {
            return typeof g.parent === 'undefined';
        });
        return this;
    };
    Layout.prototype.powerGraphGroups = function (f) {
        var g = powergraph.getGroups(this._nodes, this._links, this.linkAccessor, this._rootGroup);
        this.groups(g.groups);
        f(g);
        return this;
    };
    Layout.prototype.avoidOverlaps = function (v) {
        if (!arguments.length)
            return this._avoidOverlaps;
        this._avoidOverlaps = v;
        return this;
    };
    Layout.prototype.handleDisconnected = function (v) {
        if (!arguments.length)
            return this._handleDisconnected;
        this._handleDisconnected = v;
        return this;
    };
    Layout.prototype.flowLayout = function (axis, minSeparation) {
        if (!arguments.length)
            axis = 'y';
        this._directedLinkConstraints = {
            axis: axis,
            getMinSeparation: typeof minSeparation === 'number' ? function () {
                return minSeparation;
            } : minSeparation
        };
        return this;
    };
    Layout.prototype.links = function (x) {
        if (!arguments.length)
            return this._links;
        this._links = x;
        return this;
    };
    Layout.prototype.constraints = function (c) {
        if (!arguments.length)
            return this._constraints;
        this._constraints = c;
        return this;
    };
    Layout.prototype.distanceMatrix = function (d) {
        if (!arguments.length)
            return this._distanceMatrix;
        this._distanceMatrix = d;
        return this;
    };
    Layout.prototype.size = function (x) {
        if (!x)
            return this._canvasSize;
        this._canvasSize = x;
        return this;
    };
    Layout.prototype.defaultNodeSize = function (x) {
        if (!x)
            return this._defaultNodeSize;
        this._defaultNodeSize = x;
        return this;
    };
    Layout.prototype.groupCompactness = function (x) {
        if (!x)
            return this._groupCompactness;
        this._groupCompactness = x;
        return this;
    };
    Layout.prototype.linkDistance = function (x) {
        if (!x) {
            return this._linkDistance;
        }
        this._linkDistance = typeof x === 'function' ? x : +x;
        this._linkLengthCalculator = null;
        return this;
    };
    Layout.prototype.linkType = function (f) {
        this._linkType = f;
        return this;
    };
    Layout.prototype.convergenceThreshold = function (x) {
        if (!x)
            return this._threshold;
        this._threshold = typeof x === 'function' ? x : +x;
        return this;
    };
    Layout.prototype.alpha = function (x) {
        if (!arguments.length)
            return this._alpha;
        else {
            x = +x;
            if (this._alpha) {
                if (x > 0)
                    this._alpha = x;
                else
                    this._alpha = 0;
            } else if (x > 0) {
                if (!this._running) {
                    this._running = true;
                    this.trigger({
                        type: EventType.start,
                        alpha: this._alpha = x
                    });
                    this.kick();
                }
            }
            return this;
        }
    };
    Layout.prototype.getLinkLength = function (link) {
        return typeof this._linkDistance === 'function' ? +this._linkDistance(link) : this._linkDistance;
    };
    Layout.setLinkLength = function (link, length) {
        link.length = length;
    };
    Layout.prototype.getLinkType = function (link) {
        return typeof this._linkType === 'function' ? this._linkType(link) : 0;
    };
    Layout.prototype.symmetricDiffLinkLengths = function (idealLength, w) {
        var _this = this;
        if (w === void 0) {
            w = 1;
        }
        this.linkDistance(function (l) {
            return idealLength * l.length;
        });
        this._linkLengthCalculator = function () {
            return linklengths_1.symmetricDiffLinkLengths(_this._links, _this.linkAccessor, w);
        };
        return this;
    };
    Layout.prototype.jaccardLinkLengths = function (idealLength, w) {
        var _this = this;
        if (w === void 0) {
            w = 1;
        }
        this.linkDistance(function (l) {
            return idealLength * l.length;
        });
        this._linkLengthCalculator = function () {
            return linklengths_1.jaccardLinkLengths(_this._links, _this.linkAccessor, w);
        };
        return this;
    };
    Layout.prototype.start = function (initialUnconstrainedIterations, initialUserConstraintIterations, initialAllConstraintsIterations, gridSnapIterations, keepRunning) {
        var _this = this;
        if (initialUnconstrainedIterations === void 0) {
            initialUnconstrainedIterations = 0;
        }
        if (initialUserConstraintIterations === void 0) {
            initialUserConstraintIterations = 0;
        }
        if (initialAllConstraintsIterations === void 0) {
            initialAllConstraintsIterations = 0;
        }
        if (gridSnapIterations === void 0) {
            gridSnapIterations = 0;
        }
        if (keepRunning === void 0) {
            keepRunning = true;
        }
        var i, j, n = this.nodes().length, N = n + 2 * this._groups.length, m = this._links.length, w = this._canvasSize[0], h = this._canvasSize[1];
        var x = new Array(N), y = new Array(N);
        var G = null;
        var ao = this._avoidOverlaps;
        this._nodes.forEach(function (v, i) {
            v.index = i;
            if (typeof v.x === 'undefined') {
                v.x = w / 2, v.y = h / 2;
            }
            x[i] = v.x, y[i] = v.y;
        });
        if (this._linkLengthCalculator)
            this._linkLengthCalculator();
        var distances;
        if (this._distanceMatrix) {
            distances = this._distanceMatrix;
        } else {
            distances = new shortestpaths_1.Calculator(N, this._links, Layout.getSourceIndex, Layout.getTargetIndex, function (l) {
                return _this.getLinkLength(l);
            }).DistanceMatrix();
            G = descent_1.Descent.createSquareMatrix(N, function () {
                return 2;
            });
            this._links.forEach(function (l) {
                if (typeof l.source == 'number')
                    l.source = _this._nodes[l.source];
                if (typeof l.target == 'number')
                    l.target = _this._nodes[l.target];
            });
            this._links.forEach(function (e) {
                var u = Layout.getSourceIndex(e), v = Layout.getTargetIndex(e);
                G[u][v] = G[v][u] = e.weight || 1;
            });
        }
        var D = descent_1.Descent.createSquareMatrix(N, function (i, j) {
            return distances[i][j];
        });
        if (this._rootGroup && typeof this._rootGroup.groups !== 'undefined') {
            var i = n;
            var addAttraction = function (i, j, strength, idealDistance) {
                G[i][j] = G[j][i] = strength;
                D[i][j] = D[j][i] = idealDistance;
            };
            this._groups.forEach(function (g) {
                addAttraction(i, i + 1, _this._groupCompactness, 0.1);
                x[i] = 0, y[i++] = 0;
                x[i] = 0, y[i++] = 0;
            });
        } else
            this._rootGroup = {
                leaves: this._nodes,
                groups: []
            };
        var curConstraints = this._constraints || [];
        if (this._directedLinkConstraints) {
            this.linkAccessor.getMinSeparation = this._directedLinkConstraints.getMinSeparation;
            curConstraints = curConstraints.concat(linklengths_1.generateDirectedEdgeConstraints(n, this._links, this._directedLinkConstraints.axis, this.linkAccessor));
        }
        this.avoidOverlaps(false);
        this._descent = new descent_1.Descent([
            x,
            y
        ], D);
        this._descent.locks.clear();
        for (var i = 0; i < n; ++i) {
            var o = this._nodes[i];
            if (o.fixed) {
                o.px = o.x;
                o.py = o.y;
                var p = [
                    o.x,
                    o.y
                ];
                this._descent.locks.add(i, p);
            }
        }
        this._descent.threshold = this._threshold;
        this.initialLayout(initialUnconstrainedIterations, x, y);
        if (curConstraints.length > 0)
            this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints).projectFunctions();
        this._descent.run(initialUserConstraintIterations);
        this.separateOverlappingComponents(w, h);
        this.avoidOverlaps(ao);
        if (ao) {
            this._nodes.forEach(function (v, i) {
                v.x = x[i], v.y = y[i];
            });
            this._descent.project = new rectangle_1.Projection(this._nodes, this._groups, this._rootGroup, curConstraints, true).projectFunctions();
            this._nodes.forEach(function (v, i) {
                x[i] = v.x, y[i] = v.y;
            });
        }
        this._descent.G = G;
        this._descent.run(initialAllConstraintsIterations);
        if (gridSnapIterations) {
            this._descent.snapStrength = 1000;
            this._descent.snapGridSize = this._nodes[0].width;
            this._descent.numGridSnapNodes = n;
            this._descent.scaleSnapByMaxH = n != N;
            var G0 = descent_1.Descent.createSquareMatrix(N, function (i, j) {
                if (i >= n || j >= n)
                    return G[i][j];
                return 0;
            });
            this._descent.G = G0;
            this._descent.run(gridSnapIterations);
        }
        this.updateNodePositions();
        this.separateOverlappingComponents(w, h);
        return keepRunning ? this.resume() : this;
    };
    Layout.prototype.initialLayout = function (iterations, x, y) {
        if (this._groups.length > 0 && iterations > 0) {
            var n = this._nodes.length;
            var edges = this._links.map(function (e) {
                return {
                    source: e.source.index,
                    target: e.target.index
                };
            });
            var vs = this._nodes.map(function (v) {
                return { index: v.index };
            });
            this._groups.forEach(function (g, i) {
                vs.push({ index: g.index = n + i });
            });
            this._groups.forEach(function (g, i) {
                if (typeof g.leaves !== 'undefined')
                    g.leaves.forEach(function (v) {
                        return edges.push({
                            source: g.index,
                            target: v.index
                        });
                    });
                if (typeof g.groups !== 'undefined')
                    g.groups.forEach(function (gg) {
                        return edges.push({
                            source: g.index,
                            target: gg.index
                        });
                    });
            });
            new Layout().size(this.size()).nodes(vs).links(edges).avoidOverlaps(false).linkDistance(this.linkDistance()).symmetricDiffLinkLengths(5).convergenceThreshold(0.0001).start(iterations, 0, 0, 0, false);
            this._nodes.forEach(function (v) {
                x[v.index] = vs[v.index].x;
                y[v.index] = vs[v.index].y;
            });
        } else {
            this._descent.run(iterations);
        }
    };
    Layout.prototype.separateOverlappingComponents = function (width, height) {
        var _this = this;
        if (!this._distanceMatrix && this._handleDisconnected) {
            var x_1 = this._descent.x[0], y_1 = this._descent.x[1];
            this._nodes.forEach(function (v, i) {
                v.x = x_1[i], v.y = y_1[i];
            });
            var graphs = handledisconnected_1.separateGraphs(this._nodes, this._links);
            handledisconnected_1.applyPacking(graphs, width, height, this._defaultNodeSize);
            this._nodes.forEach(function (v, i) {
                _this._descent.x[0][i] = v.x, _this._descent.x[1][i] = v.y;
                if (v.bounds) {
                    v.bounds.setXCentre(v.x);
                    v.bounds.setYCentre(v.y);
                }
            });
        }
    };
    Layout.prototype.resume = function () {
        return this.alpha(0.1);
    };
    Layout.prototype.stop = function () {
        return this.alpha(0);
    };
    Layout.prototype.prepareEdgeRouting = function (nodeMargin) {
        if (nodeMargin === void 0) {
            nodeMargin = 0;
        }
        this._visibilityGraph = new geom_1.TangentVisibilityGraph(this._nodes.map(function (v) {
            return v.bounds.inflate(-nodeMargin).vertices();
        }));
    };
    Layout.prototype.routeEdge = function (edge, draw) {
        var lineData = [];
        var vg2 = new geom_1.TangentVisibilityGraph(this._visibilityGraph.P, {
                V: this._visibilityGraph.V,
                E: this._visibilityGraph.E
            }), port1 = {
                x: edge.source.x,
                y: edge.source.y
            }, port2 = {
                x: edge.target.x,
                y: edge.target.y
            }, start = vg2.addPoint(port1, edge.source.index), end = vg2.addPoint(port2, edge.target.index);
        vg2.addEdgeIfVisible(port1, port2, edge.source.index, edge.target.index);
        if (typeof draw !== 'undefined') {
            draw(vg2);
        }
        var sourceInd = function (e) {
                return e.source.id;
            }, targetInd = function (e) {
                return e.target.id;
            }, length = function (e) {
                return e.length();
            }, spCalc = new shortestpaths_1.Calculator(vg2.V.length, vg2.E, sourceInd, targetInd, length), shortestPath = spCalc.PathFromNodeToNode(start.id, end.id);
        if (shortestPath.length === 1 || shortestPath.length === vg2.V.length) {
            var route = rectangle_1.makeEdgeBetween(edge.source.innerBounds, edge.target.innerBounds, 5);
            lineData = [
                route.sourceIntersection,
                route.arrowStart
            ];
        } else {
            var n = shortestPath.length - 2, p = vg2.V[shortestPath[n]].p, q = vg2.V[shortestPath[0]].p, lineData = [edge.source.innerBounds.rayIntersection(p.x, p.y)];
            for (var i = n; i >= 0; --i)
                lineData.push(vg2.V[shortestPath[i]].p);
            lineData.push(rectangle_1.makeEdgeTo(q, edge.target.innerBounds, 5));
        }
        return lineData;
    };
    Layout.getSourceIndex = function (e) {
        return typeof e.source === 'number' ? e.source : e.source.index;
    };
    Layout.getTargetIndex = function (e) {
        return typeof e.target === 'number' ? e.target : e.target.index;
    };
    Layout.linkId = function (e) {
        return Layout.getSourceIndex(e) + '-' + Layout.getTargetIndex(e);
    };
    Layout.dragStart = function (d) {
        if (isGroup(d)) {
            Layout.storeOffset(d, Layout.dragOrigin(d));
        } else {
            Layout.stopNode(d);
            d.fixed |= 2;
        }
    };
    Layout.stopNode = function (v) {
        v.px = v.x;
        v.py = v.y;
    };
    Layout.storeOffset = function (d, origin) {
        if (typeof d.leaves !== 'undefined') {
            d.leaves.forEach(function (v) {
                v.fixed |= 2;
                Layout.stopNode(v);
                v._dragGroupOffsetX = v.x - origin.x;
                v._dragGroupOffsetY = v.y - origin.y;
            });
        }
        if (typeof d.groups !== 'undefined') {
            d.groups.forEach(function (g) {
                return Layout.storeOffset(g, origin);
            });
        }
    };
    Layout.dragOrigin = function (d) {
        if (isGroup(d)) {
            return {
                x: d.bounds.cx(),
                y: d.bounds.cy()
            };
        } else {
            return d;
        }
    };
    Layout.drag = function (d, position) {
        if (isGroup(d)) {
            if (typeof d.leaves !== 'undefined') {
                d.leaves.forEach(function (v) {
                    d.bounds.setXCentre(position.x);
                    d.bounds.setYCentre(position.y);
                    v.px = v._dragGroupOffsetX + position.x;
                    v.py = v._dragGroupOffsetY + position.y;
                });
            }
            if (typeof d.groups !== 'undefined') {
                d.groups.forEach(function (g) {
                    return Layout.drag(g, position);
                });
            }
        } else {
            d.px = position.x;
            d.py = position.y;
        }
    };
    Layout.dragEnd = function (d) {
        if (isGroup(d)) {
            if (typeof d.leaves !== 'undefined') {
                d.leaves.forEach(function (v) {
                    Layout.dragEnd(v);
                    delete v._dragGroupOffsetX;
                    delete v._dragGroupOffsetY;
                });
            }
            if (typeof d.groups !== 'undefined') {
                d.groups.forEach(Layout.dragEnd);
            }
        } else {
            d.fixed &= ~6;
        }
    };
    Layout.mouseOver = function (d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    };
    Layout.mouseOut = function (d) {
        d.fixed &= ~4;
    };
    return Layout;
}();
exports.Layout = Layout;
},{"286":286,"287":287,"289":289,"292":292,"293":293,"296":296,"297":297}],291:[function(require,module,exports){
'use strict';
var shortestpaths_1 = require(297);
var descent_1 = require(286);
var rectangle_1 = require(296);
var linklengths_1 = require(292);
var Link3D = function () {
    function Link3D(source, target) {
        this.source = source;
        this.target = target;
    }
    Link3D.prototype.actualLength = function (x) {
        var _this = this;
        return Math.sqrt(x.reduce(function (c, v) {
            var dx = v[_this.target] - v[_this.source];
            return c + dx * dx;
        }, 0));
    };
    return Link3D;
}();
exports.Link3D = Link3D;
var Node3D = function () {
    function Node3D(x, y, z) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (z === void 0) {
            z = 0;
        }
        this.x = x;
        this.y = y;
        this.z = z;
    }
    return Node3D;
}();
exports.Node3D = Node3D;
var Layout3D = function () {
    function Layout3D(nodes, links, idealLinkLength) {
        if (idealLinkLength === void 0) {
            idealLinkLength = 1;
        }
        var _this = this;
        this.nodes = nodes;
        this.links = links;
        this.idealLinkLength = idealLinkLength;
        this.constraints = null;
        this.useJaccardLinkLengths = true;
        this.result = new Array(Layout3D.k);
        for (var i = 0; i < Layout3D.k; ++i) {
            this.result[i] = new Array(nodes.length);
        }
        nodes.forEach(function (v, i) {
            for (var _i = 0, _a = Layout3D.dims; _i < _a.length; _i++) {
                var dim = _a[_i];
                if (typeof v[dim] == 'undefined')
                    v[dim] = Math.random();
            }
            _this.result[0][i] = v.x;
            _this.result[1][i] = v.y;
            _this.result[2][i] = v.z;
        });
    }
    ;
    Layout3D.prototype.linkLength = function (l) {
        return l.actualLength(this.result);
    };
    Layout3D.prototype.start = function (iterations) {
        var _this = this;
        if (iterations === void 0) {
            iterations = 100;
        }
        var n = this.nodes.length;
        var linkAccessor = new LinkAccessor();
        if (this.useJaccardLinkLengths)
            linklengths_1.jaccardLinkLengths(this.links, linkAccessor, 1.5);
        this.links.forEach(function (e) {
            return e.length *= _this.idealLinkLength;
        });
        var distanceMatrix = new shortestpaths_1.Calculator(n, this.links, function (e) {
            return e.source;
        }, function (e) {
            return e.target;
        }, function (e) {
            return e.length;
        }).DistanceMatrix();
        var D = descent_1.Descent.createSquareMatrix(n, function (i, j) {
            return distanceMatrix[i][j];
        });
        var G = descent_1.Descent.createSquareMatrix(n, function () {
            return 2;
        });
        this.links.forEach(function (_a) {
            var source = _a.source, target = _a.target;
            return G[source][target] = G[target][source] = 1;
        });
        this.descent = new descent_1.Descent(this.result, D);
        this.descent.threshold = 0.001;
        this.descent.G = G;
        if (this.constraints)
            this.descent.project = new rectangle_1.Projection(this.nodes, null, null, this.constraints).projectFunctions();
        for (var i = 0; i < this.nodes.length; i++) {
            var v = this.nodes[i];
            if (v.fixed) {
                this.descent.locks.add(i, [
                    v.x,
                    v.y,
                    v.z
                ]);
            }
        }
        this.descent.run(iterations);
        return this;
    };
    Layout3D.prototype.tick = function () {
        this.descent.locks.clear();
        for (var i = 0; i < this.nodes.length; i++) {
            var v = this.nodes[i];
            if (v.fixed) {
                this.descent.locks.add(i, [
                    v.x,
                    v.y,
                    v.z
                ]);
            }
        }
        return this.descent.rungeKutta();
    };
    return Layout3D;
}();
Layout3D.dims = [
    'x',
    'y',
    'z'
];
Layout3D.k = Layout3D.dims.length;
exports.Layout3D = Layout3D;
var LinkAccessor = function () {
    function LinkAccessor() {
    }
    LinkAccessor.prototype.getSourceIndex = function (e) {
        return e.source;
    };
    LinkAccessor.prototype.getTargetIndex = function (e) {
        return e.target;
    };
    LinkAccessor.prototype.getLength = function (e) {
        return e.length;
    };
    LinkAccessor.prototype.setLength = function (e, l) {
        e.length = l;
    };
    return LinkAccessor;
}();
},{"286":286,"292":292,"296":296,"297":297}],292:[function(require,module,exports){
'use strict';
function unionCount(a, b) {
    var u = {};
    for (var i in a)
        u[i] = {};
    for (var i in b)
        u[i] = {};
    return Object.keys(u).length;
}
function intersectionCount(a, b) {
    var n = 0;
    for (var i in a)
        if (typeof b[i] !== 'undefined')
            ++n;
    return n;
}
function getNeighbours(links, la) {
    var neighbours = {};
    var addNeighbours = function (u, v) {
        if (typeof neighbours[u] === 'undefined')
            neighbours[u] = {};
        neighbours[u][v] = {};
    };
    links.forEach(function (e) {
        var u = la.getSourceIndex(e), v = la.getTargetIndex(e);
        addNeighbours(u, v);
        addNeighbours(v, u);
    });
    return neighbours;
}
function computeLinkLengths(links, w, f, la) {
    var neighbours = getNeighbours(links, la);
    links.forEach(function (l) {
        var a = neighbours[la.getSourceIndex(l)];
        var b = neighbours[la.getTargetIndex(l)];
        la.setLength(l, 1 + w * f(a, b));
    });
}
function symmetricDiffLinkLengths(links, la, w) {
    if (w === void 0) {
        w = 1;
    }
    computeLinkLengths(links, w, function (a, b) {
        return Math.sqrt(unionCount(a, b) - intersectionCount(a, b));
    }, la);
}
exports.symmetricDiffLinkLengths = symmetricDiffLinkLengths;
function jaccardLinkLengths(links, la, w) {
    if (w === void 0) {
        w = 1;
    }
    computeLinkLengths(links, w, function (a, b) {
        return Math.min(Object.keys(a).length, Object.keys(b).length) < 1.1 ? 0 : intersectionCount(a, b) / unionCount(a, b);
    }, la);
}
exports.jaccardLinkLengths = jaccardLinkLengths;
function generateDirectedEdgeConstraints(n, links, axis, la) {
    var components = stronglyConnectedComponents(n, links, la);
    var nodes = {};
    components.forEach(function (c, i) {
        return c.forEach(function (v) {
            return nodes[v] = i;
        });
    });
    var constraints = [];
    links.forEach(function (l) {
        var ui = la.getSourceIndex(l), vi = la.getTargetIndex(l), u = nodes[ui], v = nodes[vi];
        if (u !== v) {
            constraints.push({
                axis: axis,
                left: ui,
                right: vi,
                gap: la.getMinSeparation(l)
            });
        }
    });
    return constraints;
}
exports.generateDirectedEdgeConstraints = generateDirectedEdgeConstraints;
function stronglyConnectedComponents(numVertices, edges, la) {
    var nodes = [];
    var index = 0;
    var stack = [];
    var components = [];
    function strongConnect(v) {
        v.index = v.lowlink = index++;
        stack.push(v);
        v.onStack = true;
        for (var _i = 0, _a = v.out; _i < _a.length; _i++) {
            var w = _a[_i];
            if (typeof w.index === 'undefined') {
                strongConnect(w);
                v.lowlink = Math.min(v.lowlink, w.lowlink);
            } else if (w.onStack) {
                v.lowlink = Math.min(v.lowlink, w.index);
            }
        }
        if (v.lowlink === v.index) {
            var component = [];
            while (stack.length) {
                w = stack.pop();
                w.onStack = false;
                component.push(w);
                if (w === v)
                    break;
            }
            components.push(component.map(function (v) {
                return v.id;
            }));
        }
    }
    for (var i = 0; i < numVertices; i++) {
        nodes.push({
            id: i,
            out: []
        });
    }
    for (var _i = 0, edges_1 = edges; _i < edges_1.length; _i++) {
        var e = edges_1[_i];
        var v_1 = nodes[la.getSourceIndex(e)], w = nodes[la.getTargetIndex(e)];
        v_1.out.push(w);
    }
    for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {
        var v = nodes_1[_a];
        if (typeof v.index === 'undefined')
            strongConnect(v);
    }
    return components;
}
exports.stronglyConnectedComponents = stronglyConnectedComponents;
},{}],293:[function(require,module,exports){
'use strict';
var PowerEdge = function () {
    function PowerEdge(source, target, type) {
        this.source = source;
        this.target = target;
        this.type = type;
    }
    return PowerEdge;
}();
exports.PowerEdge = PowerEdge;
var Configuration = function () {
    function Configuration(n, edges, linkAccessor, rootGroup) {
        var _this = this;
        this.linkAccessor = linkAccessor;
        this.modules = new Array(n);
        this.roots = [];
        if (rootGroup) {
            this.initModulesFromGroup(rootGroup);
        } else {
            this.roots.push(new ModuleSet());
            for (var i = 0; i < n; ++i)
                this.roots[0].add(this.modules[i] = new Module(i));
        }
        this.R = edges.length;
        edges.forEach(function (e) {
            var s = _this.modules[linkAccessor.getSourceIndex(e)], t = _this.modules[linkAccessor.getTargetIndex(e)], type = linkAccessor.getType(e);
            s.outgoing.add(type, t);
            t.incoming.add(type, s);
        });
    }
    Configuration.prototype.initModulesFromGroup = function (group) {
        var moduleSet = new ModuleSet();
        this.roots.push(moduleSet);
        for (var i = 0; i < group.leaves.length; ++i) {
            var node = group.leaves[i];
            var module = new Module(node.id);
            this.modules[node.id] = module;
            moduleSet.add(module);
        }
        if (group.groups) {
            for (var j = 0; j < group.groups.length; ++j) {
                var child = group.groups[j];
                var definition = {};
                for (var prop in child)
                    if (prop !== 'leaves' && prop !== 'groups' && child.hasOwnProperty(prop))
                        definition[prop] = child[prop];
                moduleSet.add(new Module(-1 - j, new LinkSets(), new LinkSets(), this.initModulesFromGroup(child), definition));
            }
        }
        return moduleSet;
    };
    Configuration.prototype.merge = function (a, b, k) {
        if (k === void 0) {
            k = 0;
        }
        var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);
        var children = new ModuleSet();
        children.add(a);
        children.add(b);
        var m = new Module(this.modules.length, outInt, inInt, children);
        this.modules.push(m);
        var update = function (s, i, o) {
            s.forAll(function (ms, linktype) {
                ms.forAll(function (n) {
                    var nls = n[i];
                    nls.add(linktype, m);
                    nls.remove(linktype, a);
                    nls.remove(linktype, b);
                    a[o].remove(linktype, n);
                    b[o].remove(linktype, n);
                });
            });
        };
        update(outInt, 'incoming', 'outgoing');
        update(inInt, 'outgoing', 'incoming');
        this.R -= inInt.count() + outInt.count();
        this.roots[k].remove(a);
        this.roots[k].remove(b);
        this.roots[k].add(m);
        return m;
    };
    Configuration.prototype.rootMerges = function (k) {
        if (k === void 0) {
            k = 0;
        }
        var rs = this.roots[k].modules();
        var n = rs.length;
        var merges = new Array(n * (n - 1));
        var ctr = 0;
        for (var i = 0, i_ = n - 1; i < i_; ++i) {
            for (var j = i + 1; j < n; ++j) {
                var a = rs[i], b = rs[j];
                merges[ctr] = {
                    id: ctr,
                    nEdges: this.nEdges(a, b),
                    a: a,
                    b: b
                };
                ctr++;
            }
        }
        return merges;
    };
    Configuration.prototype.greedyMerge = function () {
        for (var i = 0; i < this.roots.length; ++i) {
            if (this.roots[i].modules().length < 2)
                continue;
            var ms = this.rootMerges(i).sort(function (a, b) {
                return a.nEdges == b.nEdges ? a.id - b.id : a.nEdges - b.nEdges;
            });
            var m = ms[0];
            if (m.nEdges >= this.R)
                continue;
            this.merge(m.a, m.b, i);
            return true;
        }
    };
    Configuration.prototype.nEdges = function (a, b) {
        var inInt = a.incoming.intersection(b.incoming), outInt = a.outgoing.intersection(b.outgoing);
        return this.R - inInt.count() - outInt.count();
    };
    Configuration.prototype.getGroupHierarchy = function (retargetedEdges) {
        var _this = this;
        var groups = [];
        var root = {};
        toGroups(this.roots[0], root, groups);
        var es = this.allEdges();
        es.forEach(function (e) {
            var a = _this.modules[e.source];
            var b = _this.modules[e.target];
            retargetedEdges.push(new PowerEdge(typeof a.gid === 'undefined' ? e.source : groups[a.gid], typeof b.gid === 'undefined' ? e.target : groups[b.gid], e.type));
        });
        return groups;
    };
    Configuration.prototype.allEdges = function () {
        var es = [];
        Configuration.getEdges(this.roots[0], es);
        return es;
    };
    Configuration.getEdges = function (modules, es) {
        modules.forAll(function (m) {
            m.getEdges(es);
            Configuration.getEdges(m.children, es);
        });
    };
    return Configuration;
}();
exports.Configuration = Configuration;
function toGroups(modules, group, groups) {
    modules.forAll(function (m) {
        if (m.isLeaf()) {
            if (!group.leaves)
                group.leaves = [];
            group.leaves.push(m.id);
        } else {
            var g = group;
            m.gid = groups.length;
            if (!m.isIsland() || m.isPredefined()) {
                g = { id: m.gid };
                if (m.isPredefined())
                    for (var prop in m.definition)
                        g[prop] = m.definition[prop];
                if (!group.groups)
                    group.groups = [];
                group.groups.push(m.gid);
                groups.push(g);
            }
            toGroups(m.children, g, groups);
        }
    });
}
var Module = function () {
    function Module(id, outgoing, incoming, children, definition) {
        if (outgoing === void 0) {
            outgoing = new LinkSets();
        }
        if (incoming === void 0) {
            incoming = new LinkSets();
        }
        if (children === void 0) {
            children = new ModuleSet();
        }
        this.id = id;
        this.outgoing = outgoing;
        this.incoming = incoming;
        this.children = children;
        this.definition = definition;
    }
    Module.prototype.getEdges = function (es) {
        var _this = this;
        this.outgoing.forAll(function (ms, edgetype) {
            ms.forAll(function (target) {
                es.push(new PowerEdge(_this.id, target.id, edgetype));
            });
        });
    };
    Module.prototype.isLeaf = function () {
        return this.children.count() === 0;
    };
    Module.prototype.isIsland = function () {
        return this.outgoing.count() === 0 && this.incoming.count() === 0;
    };
    Module.prototype.isPredefined = function () {
        return typeof this.definition !== 'undefined';
    };
    return Module;
}();
exports.Module = Module;
function intersection(m, n) {
    var i = {};
    for (var v in m)
        if (v in n)
            i[v] = m[v];
    return i;
}
var ModuleSet = function () {
    function ModuleSet() {
        this.table = {};
    }
    ModuleSet.prototype.count = function () {
        return Object.keys(this.table).length;
    };
    ModuleSet.prototype.intersection = function (other) {
        var result = new ModuleSet();
        result.table = intersection(this.table, other.table);
        return result;
    };
    ModuleSet.prototype.intersectionCount = function (other) {
        return this.intersection(other).count();
    };
    ModuleSet.prototype.contains = function (id) {
        return id in this.table;
    };
    ModuleSet.prototype.add = function (m) {
        this.table[m.id] = m;
    };
    ModuleSet.prototype.remove = function (m) {
        delete this.table[m.id];
    };
    ModuleSet.prototype.forAll = function (f) {
        for (var mid in this.table) {
            f(this.table[mid]);
        }
    };
    ModuleSet.prototype.modules = function () {
        var vs = [];
        this.forAll(function (m) {
            if (!m.isPredefined())
                vs.push(m);
        });
        return vs;
    };
    return ModuleSet;
}();
exports.ModuleSet = ModuleSet;
var LinkSets = function () {
    function LinkSets() {
        this.sets = {};
        this.n = 0;
    }
    LinkSets.prototype.count = function () {
        return this.n;
    };
    LinkSets.prototype.contains = function (id) {
        var result = false;
        this.forAllModules(function (m) {
            if (!result && m.id == id) {
                result = true;
            }
        });
        return result;
    };
    LinkSets.prototype.add = function (linktype, m) {
        var s = linktype in this.sets ? this.sets[linktype] : this.sets[linktype] = new ModuleSet();
        s.add(m);
        ++this.n;
    };
    LinkSets.prototype.remove = function (linktype, m) {
        var ms = this.sets[linktype];
        ms.remove(m);
        if (ms.count() === 0) {
            delete this.sets[linktype];
        }
        --this.n;
    };
    LinkSets.prototype.forAll = function (f) {
        for (var linktype in this.sets) {
            f(this.sets[linktype], Number(linktype));
        }
    };
    LinkSets.prototype.forAllModules = function (f) {
        this.forAll(function (ms, lt) {
            return ms.forAll(f);
        });
    };
    LinkSets.prototype.intersection = function (other) {
        var result = new LinkSets();
        this.forAll(function (ms, lt) {
            if (lt in other.sets) {
                var i = ms.intersection(other.sets[lt]), n = i.count();
                if (n > 0) {
                    result.sets[lt] = i;
                    result.n += n;
                }
            }
        });
        return result;
    };
    return LinkSets;
}();
exports.LinkSets = LinkSets;
function intersectionCount(m, n) {
    return Object.keys(intersection(m, n)).length;
}
function getGroups(nodes, links, la, rootGroup) {
    var n = nodes.length, c = new Configuration(n, links, la, rootGroup);
    while (c.greedyMerge());
    var powerEdges = [];
    var g = c.getGroupHierarchy(powerEdges);
    powerEdges.forEach(function (e) {
        var f = function (end) {
            var g = e[end];
            if (typeof g == 'number')
                e[end] = nodes[g];
        };
        f('source');
        f('target');
    });
    return {
        groups: g,
        powerEdges: powerEdges
    };
}
exports.getGroups = getGroups;
},{}],294:[function(require,module,exports){
'use strict';
var PairingHeap = function () {
    function PairingHeap(elem) {
        this.elem = elem;
        this.subheaps = [];
    }
    PairingHeap.prototype.toString = function (selector) {
        var str = '', needComma = false;
        for (var i = 0; i < this.subheaps.length; ++i) {
            var subheap = this.subheaps[i];
            if (!subheap.elem) {
                needComma = false;
                continue;
            }
            if (needComma) {
                str = str + ',';
            }
            str = str + subheap.toString(selector);
            needComma = true;
        }
        if (str !== '') {
            str = '(' + str + ')';
        }
        return (this.elem ? selector(this.elem) : '') + str;
    };
    PairingHeap.prototype.forEach = function (f) {
        if (!this.empty()) {
            f(this.elem, this);
            this.subheaps.forEach(function (s) {
                return s.forEach(f);
            });
        }
    };
    PairingHeap.prototype.count = function () {
        return this.empty() ? 0 : 1 + this.subheaps.reduce(function (n, h) {
            return n + h.count();
        }, 0);
    };
    PairingHeap.prototype.min = function () {
        return this.elem;
    };
    PairingHeap.prototype.empty = function () {
        return this.elem == null;
    };
    PairingHeap.prototype.contains = function (h) {
        if (this === h)
            return true;
        for (var i = 0; i < this.subheaps.length; i++) {
            if (this.subheaps[i].contains(h))
                return true;
        }
        return false;
    };
    PairingHeap.prototype.isHeap = function (lessThan) {
        var _this = this;
        return this.subheaps.every(function (h) {
            return lessThan(_this.elem, h.elem) && h.isHeap(lessThan);
        });
    };
    PairingHeap.prototype.insert = function (obj, lessThan) {
        return this.merge(new PairingHeap(obj), lessThan);
    };
    PairingHeap.prototype.merge = function (heap2, lessThan) {
        if (this.empty())
            return heap2;
        else if (heap2.empty())
            return this;
        else if (lessThan(this.elem, heap2.elem)) {
            this.subheaps.push(heap2);
            return this;
        } else {
            heap2.subheaps.push(this);
            return heap2;
        }
    };
    PairingHeap.prototype.removeMin = function (lessThan) {
        if (this.empty())
            return null;
        else
            return this.mergePairs(lessThan);
    };
    PairingHeap.prototype.mergePairs = function (lessThan) {
        if (this.subheaps.length == 0)
            return new PairingHeap(null);
        else if (this.subheaps.length == 1) {
            return this.subheaps[0];
        } else {
            var firstPair = this.subheaps.pop().merge(this.subheaps.pop(), lessThan);
            var remaining = this.mergePairs(lessThan);
            return firstPair.merge(remaining, lessThan);
        }
    };
    PairingHeap.prototype.decreaseKey = function (subheap, newValue, setHeapNode, lessThan) {
        var newHeap = subheap.removeMin(lessThan);
        subheap.elem = newHeap.elem;
        subheap.subheaps = newHeap.subheaps;
        if (setHeapNode !== null && newHeap.elem !== null) {
            setHeapNode(subheap.elem, subheap);
        }
        var pairingNode = new PairingHeap(newValue);
        if (setHeapNode !== null) {
            setHeapNode(newValue, pairingNode);
        }
        return this.merge(pairingNode, lessThan);
    };
    return PairingHeap;
}();
exports.PairingHeap = PairingHeap;
var PriorityQueue = function () {
    function PriorityQueue(lessThan) {
        this.lessThan = lessThan;
    }
    PriorityQueue.prototype.top = function () {
        if (this.empty()) {
            return null;
        }
        return this.root.elem;
    };
    PriorityQueue.prototype.push = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var pairingNode;
        for (var i = 0, arg; arg = args[i]; ++i) {
            pairingNode = new PairingHeap(arg);
            this.root = this.empty() ? pairingNode : this.root.merge(pairingNode, this.lessThan);
        }
        return pairingNode;
    };
    PriorityQueue.prototype.empty = function () {
        return !this.root || !this.root.elem;
    };
    PriorityQueue.prototype.isHeap = function () {
        return this.root.isHeap(this.lessThan);
    };
    PriorityQueue.prototype.forEach = function (f) {
        this.root.forEach(f);
    };
    PriorityQueue.prototype.pop = function () {
        if (this.empty()) {
            return null;
        }
        var obj = this.root.min();
        this.root = this.root.removeMin(this.lessThan);
        return obj;
    };
    PriorityQueue.prototype.reduceKey = function (heapNode, newKey, setHeapNode) {
        if (setHeapNode === void 0) {
            setHeapNode = null;
        }
        this.root = this.root.decreaseKey(heapNode, newKey, setHeapNode, this.lessThan);
    };
    PriorityQueue.prototype.toString = function (selector) {
        return this.root.toString(selector);
    };
    PriorityQueue.prototype.count = function () {
        return this.root.count();
    };
    return PriorityQueue;
}();
exports.PriorityQueue = PriorityQueue;
},{}],295:[function(require,module,exports){
'use strict';
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var TreeBase = function () {
    function TreeBase() {
        this.findIter = function (data) {
            var res = this._root;
            var iter = this.iterator();
            while (res !== null) {
                var c = this._comparator(data, res.data);
                if (c === 0) {
                    iter._cursor = res;
                    return iter;
                } else {
                    iter._ancestors.push(res);
                    res = res.get_child(c > 0);
                }
            }
            return null;
        };
    }
    TreeBase.prototype.clear = function () {
        this._root = null;
        this.size = 0;
    };
    ;
    TreeBase.prototype.find = function (data) {
        var res = this._root;
        while (res !== null) {
            var c = this._comparator(data, res.data);
            if (c === 0) {
                return res.data;
            } else {
                res = res.get_child(c > 0);
            }
        }
        return null;
    };
    ;
    TreeBase.prototype.lowerBound = function (data) {
        return this._bound(data, this._comparator);
    };
    ;
    TreeBase.prototype.upperBound = function (data) {
        var cmp = this._comparator;
        function reverse_cmp(a, b) {
            return cmp(b, a);
        }
        return this._bound(data, reverse_cmp);
    };
    ;
    TreeBase.prototype.min = function () {
        var res = this._root;
        if (res === null) {
            return null;
        }
        while (res.left !== null) {
            res = res.left;
        }
        return res.data;
    };
    ;
    TreeBase.prototype.max = function () {
        var res = this._root;
        if (res === null) {
            return null;
        }
        while (res.right !== null) {
            res = res.right;
        }
        return res.data;
    };
    ;
    TreeBase.prototype.iterator = function () {
        return new Iterator(this);
    };
    ;
    TreeBase.prototype.each = function (cb) {
        var it = this.iterator(), data;
        while ((data = it.next()) !== null) {
            cb(data);
        }
    };
    ;
    TreeBase.prototype.reach = function (cb) {
        var it = this.iterator(), data;
        while ((data = it.prev()) !== null) {
            cb(data);
        }
    };
    ;
    TreeBase.prototype._bound = function (data, cmp) {
        var cur = this._root;
        var iter = this.iterator();
        while (cur !== null) {
            var c = this._comparator(data, cur.data);
            if (c === 0) {
                iter._cursor = cur;
                return iter;
            }
            iter._ancestors.push(cur);
            cur = cur.get_child(c > 0);
        }
        for (var i = iter._ancestors.length - 1; i >= 0; --i) {
            cur = iter._ancestors[i];
            if (cmp(data, cur.data) > 0) {
                iter._cursor = cur;
                iter._ancestors.length = i;
                return iter;
            }
        }
        iter._ancestors.length = 0;
        return iter;
    };
    ;
    return TreeBase;
}();
exports.TreeBase = TreeBase;
var Iterator = function () {
    function Iterator(tree) {
        this._tree = tree;
        this._ancestors = [];
        this._cursor = null;
    }
    Iterator.prototype.data = function () {
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype.next = function () {
        if (this._cursor === null) {
            var root = this._tree._root;
            if (root !== null) {
                this._minNode(root);
            }
        } else {
            if (this._cursor.right === null) {
                var save;
                do {
                    save = this._cursor;
                    if (this._ancestors.length) {
                        this._cursor = this._ancestors.pop();
                    } else {
                        this._cursor = null;
                        break;
                    }
                } while (this._cursor.right === save);
            } else {
                this._ancestors.push(this._cursor);
                this._minNode(this._cursor.right);
            }
        }
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype.prev = function () {
        if (this._cursor === null) {
            var root = this._tree._root;
            if (root !== null) {
                this._maxNode(root);
            }
        } else {
            if (this._cursor.left === null) {
                var save;
                do {
                    save = this._cursor;
                    if (this._ancestors.length) {
                        this._cursor = this._ancestors.pop();
                    } else {
                        this._cursor = null;
                        break;
                    }
                } while (this._cursor.left === save);
            } else {
                this._ancestors.push(this._cursor);
                this._maxNode(this._cursor.left);
            }
        }
        return this._cursor !== null ? this._cursor.data : null;
    };
    ;
    Iterator.prototype._minNode = function (start) {
        while (start.left !== null) {
            this._ancestors.push(start);
            start = start.left;
        }
        this._cursor = start;
    };
    ;
    Iterator.prototype._maxNode = function (start) {
        while (start.right !== null) {
            this._ancestors.push(start);
            start = start.right;
        }
        this._cursor = start;
    };
    ;
    return Iterator;
}();
exports.Iterator = Iterator;
var Node = function () {
    function Node(data) {
        this.data = data;
        this.left = null;
        this.right = null;
        this.red = true;
    }
    Node.prototype.get_child = function (dir) {
        return dir ? this.right : this.left;
    };
    ;
    Node.prototype.set_child = function (dir, val) {
        if (dir) {
            this.right = val;
        } else {
            this.left = val;
        }
    };
    ;
    return Node;
}();
var RBTree = function (_super) {
    __extends(RBTree, _super);
    function RBTree(comparator) {
        var _this = _super.call(this) || this;
        _this._root = null;
        _this._comparator = comparator;
        _this.size = 0;
        return _this;
    }
    RBTree.prototype.insert = function (data) {
        var ret = false;
        if (this._root === null) {
            this._root = new Node(data);
            ret = true;
            this.size++;
        } else {
            var head = new Node(undefined);
            var dir = false;
            var last = false;
            var gp = null;
            var ggp = head;
            var p = null;
            var node = this._root;
            ggp.right = this._root;
            while (true) {
                if (node === null) {
                    node = new Node(data);
                    p.set_child(dir, node);
                    ret = true;
                    this.size++;
                } else if (RBTree.is_red(node.left) && RBTree.is_red(node.right)) {
                    node.red = true;
                    node.left.red = false;
                    node.right.red = false;
                }
                if (RBTree.is_red(node) && RBTree.is_red(p)) {
                    var dir2 = ggp.right === gp;
                    if (node === p.get_child(last)) {
                        ggp.set_child(dir2, RBTree.single_rotate(gp, !last));
                    } else {
                        ggp.set_child(dir2, RBTree.double_rotate(gp, !last));
                    }
                }
                var cmp = this._comparator(node.data, data);
                if (cmp === 0) {
                    break;
                }
                last = dir;
                dir = cmp < 0;
                if (gp !== null) {
                    ggp = gp;
                }
                gp = p;
                p = node;
                node = node.get_child(dir);
            }
            this._root = head.right;
        }
        this._root.red = false;
        return ret;
    };
    ;
    RBTree.prototype.remove = function (data) {
        if (this._root === null) {
            return false;
        }
        var head = new Node(undefined);
        var node = head;
        node.right = this._root;
        var p = null;
        var gp = null;
        var found = null;
        var dir = true;
        while (node.get_child(dir) !== null) {
            var last = dir;
            gp = p;
            p = node;
            node = node.get_child(dir);
            var cmp = this._comparator(data, node.data);
            dir = cmp > 0;
            if (cmp === 0) {
                found = node;
            }
            if (!RBTree.is_red(node) && !RBTree.is_red(node.get_child(dir))) {
                if (RBTree.is_red(node.get_child(!dir))) {
                    var sr = RBTree.single_rotate(node, dir);
                    p.set_child(last, sr);
                    p = sr;
                } else if (!RBTree.is_red(node.get_child(!dir))) {
                    var sibling = p.get_child(!last);
                    if (sibling !== null) {
                        if (!RBTree.is_red(sibling.get_child(!last)) && !RBTree.is_red(sibling.get_child(last))) {
                            p.red = false;
                            sibling.red = true;
                            node.red = true;
                        } else {
                            var dir2 = gp.right === p;
                            if (RBTree.is_red(sibling.get_child(last))) {
                                gp.set_child(dir2, RBTree.double_rotate(p, last));
                            } else if (RBTree.is_red(sibling.get_child(!last))) {
                                gp.set_child(dir2, RBTree.single_rotate(p, last));
                            }
                            var gpc = gp.get_child(dir2);
                            gpc.red = true;
                            node.red = true;
                            gpc.left.red = false;
                            gpc.right.red = false;
                        }
                    }
                }
            }
        }
        if (found !== null) {
            found.data = node.data;
            p.set_child(p.right === node, node.get_child(node.left === null));
            this.size--;
        }
        this._root = head.right;
        if (this._root !== null) {
            this._root.red = false;
        }
        return found !== null;
    };
    ;
    RBTree.is_red = function (node) {
        return node !== null && node.red;
    };
    RBTree.single_rotate = function (root, dir) {
        var save = root.get_child(!dir);
        root.set_child(!dir, save.get_child(dir));
        save.set_child(dir, root);
        root.red = true;
        save.red = false;
        return save;
    };
    RBTree.double_rotate = function (root, dir) {
        root.set_child(!dir, RBTree.single_rotate(root.get_child(!dir), !dir));
        return RBTree.single_rotate(root, dir);
    };
    return RBTree;
}(TreeBase);
exports.RBTree = RBTree;
},{}],296:[function(require,module,exports){
'use strict';
var __extends = this && this.__extends || function (d, b) {
    for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var vpsc_1 = require(298);
var rbtree_1 = require(295);
function computeGroupBounds(g) {
    g.bounds = typeof g.leaves !== 'undefined' ? g.leaves.reduce(function (r, c) {
        return c.bounds.union(r);
    }, Rectangle.empty()) : Rectangle.empty();
    if (typeof g.groups !== 'undefined')
        g.bounds = g.groups.reduce(function (r, c) {
            return computeGroupBounds(c).union(r);
        }, g.bounds);
    g.bounds = g.bounds.inflate(g.padding);
    return g.bounds;
}
exports.computeGroupBounds = computeGroupBounds;
var Rectangle = function () {
    function Rectangle(x, X, y, Y) {
        this.x = x;
        this.X = X;
        this.y = y;
        this.Y = Y;
    }
    Rectangle.empty = function () {
        return new Rectangle(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
    };
    Rectangle.prototype.cx = function () {
        return (this.x + this.X) / 2;
    };
    Rectangle.prototype.cy = function () {
        return (this.y + this.Y) / 2;
    };
    Rectangle.prototype.overlapX = function (r) {
        var ux = this.cx(), vx = r.cx();
        if (ux <= vx && r.x < this.X)
            return this.X - r.x;
        if (vx <= ux && this.x < r.X)
            return r.X - this.x;
        return 0;
    };
    Rectangle.prototype.overlapY = function (r) {
        var uy = this.cy(), vy = r.cy();
        if (uy <= vy && r.y < this.Y)
            return this.Y - r.y;
        if (vy <= uy && this.y < r.Y)
            return r.Y - this.y;
        return 0;
    };
    Rectangle.prototype.setXCentre = function (cx) {
        var dx = cx - this.cx();
        this.x += dx;
        this.X += dx;
    };
    Rectangle.prototype.setYCentre = function (cy) {
        var dy = cy - this.cy();
        this.y += dy;
        this.Y += dy;
    };
    Rectangle.prototype.width = function () {
        return this.X - this.x;
    };
    Rectangle.prototype.height = function () {
        return this.Y - this.y;
    };
    Rectangle.prototype.union = function (r) {
        return new Rectangle(Math.min(this.x, r.x), Math.max(this.X, r.X), Math.min(this.y, r.y), Math.max(this.Y, r.Y));
    };
    Rectangle.prototype.lineIntersections = function (x1, y1, x2, y2) {
        var sides = [
            [
                this.x,
                this.y,
                this.X,
                this.y
            ],
            [
                this.X,
                this.y,
                this.X,
                this.Y
            ],
            [
                this.X,
                this.Y,
                this.x,
                this.Y
            ],
            [
                this.x,
                this.Y,
                this.x,
                this.y
            ]
        ];
        var intersections = [];
        for (var i = 0; i < 4; ++i) {
            var r = Rectangle.lineIntersection(x1, y1, x2, y2, sides[i][0], sides[i][1], sides[i][2], sides[i][3]);
            if (r !== null)
                intersections.push({
                    x: r.x,
                    y: r.y
                });
        }
        return intersections;
    };
    Rectangle.prototype.rayIntersection = function (x2, y2) {
        var ints = this.lineIntersections(this.cx(), this.cy(), x2, y2);
        return ints.length > 0 ? ints[0] : null;
    };
    Rectangle.prototype.vertices = function () {
        return [
            {
                x: this.x,
                y: this.y
            },
            {
                x: this.X,
                y: this.y
            },
            {
                x: this.X,
                y: this.Y
            },
            {
                x: this.x,
                y: this.Y
            },
            {
                x: this.x,
                y: this.y
            }
        ];
    };
    Rectangle.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {
        var dx12 = x2 - x1, dx34 = x4 - x3, dy12 = y2 - y1, dy34 = y4 - y3, denominator = dy34 * dx12 - dx34 * dy12;
        if (denominator == 0)
            return null;
        var dx31 = x1 - x3, dy31 = y1 - y3, numa = dx34 * dy31 - dy34 * dx31, a = numa / denominator, numb = dx12 * dy31 - dy12 * dx31, b = numb / denominator;
        if (a >= 0 && a <= 1 && b >= 0 && b <= 1) {
            return {
                x: x1 + a * dx12,
                y: y1 + a * dy12
            };
        }
        return null;
    };
    Rectangle.prototype.inflate = function (pad) {
        return new Rectangle(this.x - pad, this.X + pad, this.y - pad, this.Y + pad);
    };
    return Rectangle;
}();
exports.Rectangle = Rectangle;
function makeEdgeBetween(source, target, ah) {
    var si = source.rayIntersection(target.cx(), target.cy()) || {
            x: source.cx(),
            y: source.cy()
        }, ti = target.rayIntersection(source.cx(), source.cy()) || {
            x: target.cx(),
            y: target.cy()
        }, dx = ti.x - si.x, dy = ti.y - si.y, l = Math.sqrt(dx * dx + dy * dy), al = l - ah;
    return {
        sourceIntersection: si,
        targetIntersection: ti,
        arrowStart: {
            x: si.x + al * dx / l,
            y: si.y + al * dy / l
        }
    };
}
exports.makeEdgeBetween = makeEdgeBetween;
function makeEdgeTo(s, target, ah) {
    var ti = target.rayIntersection(s.x, s.y);
    if (!ti)
        ti = {
            x: target.cx(),
            y: target.cy()
        };
    var dx = ti.x - s.x, dy = ti.y - s.y, l = Math.sqrt(dx * dx + dy * dy);
    return {
        x: ti.x - ah * dx / l,
        y: ti.y - ah * dy / l
    };
}
exports.makeEdgeTo = makeEdgeTo;
var Node = function () {
    function Node(v, r, pos) {
        this.v = v;
        this.r = r;
        this.pos = pos;
        this.prev = makeRBTree();
        this.next = makeRBTree();
    }
    return Node;
}();
var Event = function () {
    function Event(isOpen, v, pos) {
        this.isOpen = isOpen;
        this.v = v;
        this.pos = pos;
    }
    return Event;
}();
function compareEvents(a, b) {
    if (a.pos > b.pos) {
        return 1;
    }
    if (a.pos < b.pos) {
        return -1;
    }
    if (a.isOpen) {
        return -1;
    }
    if (b.isOpen) {
        return 1;
    }
    return 0;
}
function makeRBTree() {
    return new rbtree_1.RBTree(function (a, b) {
        return a.pos - b.pos;
    });
}
var xRect = {
    getCentre: function (r) {
        return r.cx();
    },
    getOpen: function (r) {
        return r.y;
    },
    getClose: function (r) {
        return r.Y;
    },
    getSize: function (r) {
        return r.width();
    },
    makeRect: function (open, close, center, size) {
        return new Rectangle(center - size / 2, center + size / 2, open, close);
    },
    findNeighbours: findXNeighbours
};
var yRect = {
    getCentre: function (r) {
        return r.cy();
    },
    getOpen: function (r) {
        return r.x;
    },
    getClose: function (r) {
        return r.X;
    },
    getSize: function (r) {
        return r.height();
    },
    makeRect: function (open, close, center, size) {
        return new Rectangle(open, close, center - size / 2, center + size / 2);
    },
    findNeighbours: findYNeighbours
};
function generateGroupConstraints(root, f, minSep, isContained) {
    if (isContained === void 0) {
        isContained = false;
    }
    var padding = root.padding, gn = typeof root.groups !== 'undefined' ? root.groups.length : 0, ln = typeof root.leaves !== 'undefined' ? root.leaves.length : 0, childConstraints = !gn ? [] : root.groups.reduce(function (ccs, g) {
            return ccs.concat(generateGroupConstraints(g, f, minSep, true));
        }, []), n = (isContained ? 2 : 0) + ln + gn, vs = new Array(n), rs = new Array(n), i = 0, add = function (r, v) {
            rs[i] = r;
            vs[i++] = v;
        };
    if (isContained) {
        var b = root.bounds, c = f.getCentre(b), s = f.getSize(b) / 2, open = f.getOpen(b), close = f.getClose(b), min = c - s + padding / 2, max = c + s - padding / 2;
        root.minVar.desiredPosition = min;
        add(f.makeRect(open, close, min, padding), root.minVar);
        root.maxVar.desiredPosition = max;
        add(f.makeRect(open, close, max, padding), root.maxVar);
    }
    if (ln)
        root.leaves.forEach(function (l) {
            return add(l.bounds, l.variable);
        });
    if (gn)
        root.groups.forEach(function (g) {
            var b = g.bounds;
            add(f.makeRect(f.getOpen(b), f.getClose(b), f.getCentre(b), f.getSize(b)), g.minVar);
        });
    var cs = generateConstraints(rs, vs, f, minSep);
    if (gn) {
        vs.forEach(function (v) {
            v.cOut = [], v.cIn = [];
        });
        cs.forEach(function (c) {
            c.left.cOut.push(c), c.right.cIn.push(c);
        });
        root.groups.forEach(function (g) {
            var gapAdjustment = (g.padding - f.getSize(g.bounds)) / 2;
            g.minVar.cIn.forEach(function (c) {
                return c.gap += gapAdjustment;
            });
            g.minVar.cOut.forEach(function (c) {
                c.left = g.maxVar;
                c.gap += gapAdjustment;
            });
        });
    }
    return childConstraints.concat(cs);
}
function generateConstraints(rs, vars, rect, minSep) {
    var i, n = rs.length;
    var N = 2 * n;
    var events = new Array(N);
    for (i = 0; i < n; ++i) {
        var r = rs[i];
        var v = new Node(vars[i], r, rect.getCentre(r));
        events[i] = new Event(true, v, rect.getOpen(r));
        events[i + n] = new Event(false, v, rect.getClose(r));
    }
    events.sort(compareEvents);
    var cs = new Array();
    var scanline = makeRBTree();
    for (i = 0; i < N; ++i) {
        var e = events[i];
        var v = e.v;
        if (e.isOpen) {
            scanline.insert(v);
            rect.findNeighbours(v, scanline);
        } else {
            scanline.remove(v);
            var makeConstraint = function (l, r) {
                var sep = (rect.getSize(l.r) + rect.getSize(r.r)) / 2 + minSep;
                cs.push(new vpsc_1.Constraint(l.v, r.v, sep));
            };
            var visitNeighbours = function (forward, reverse, mkcon) {
                var u, it = v[forward].iterator();
                while ((u = it[forward]()) !== null) {
                    mkcon(u, v);
                    u[reverse].remove(v);
                }
            };
            visitNeighbours('prev', 'next', function (u, v) {
                return makeConstraint(u, v);
            });
            visitNeighbours('next', 'prev', function (u, v) {
                return makeConstraint(v, u);
            });
        }
    }
    return cs;
}
function findXNeighbours(v, scanline) {
    var f = function (forward, reverse) {
        var it = scanline.findIter(v);
        var u;
        while ((u = it[forward]()) !== null) {
            var uovervX = u.r.overlapX(v.r);
            if (uovervX <= 0 || uovervX <= u.r.overlapY(v.r)) {
                v[forward].insert(u);
                u[reverse].insert(v);
            }
            if (uovervX <= 0) {
                break;
            }
        }
    };
    f('next', 'prev');
    f('prev', 'next');
}
function findYNeighbours(v, scanline) {
    var f = function (forward, reverse) {
        var u = scanline.findIter(v)[forward]();
        if (u !== null && u.r.overlapX(v.r) > 0) {
            v[forward].insert(u);
            u[reverse].insert(v);
        }
    };
    f('next', 'prev');
    f('prev', 'next');
}
function generateXConstraints(rs, vars) {
    return generateConstraints(rs, vars, xRect, 0.000001);
}
exports.generateXConstraints = generateXConstraints;
function generateYConstraints(rs, vars) {
    return generateConstraints(rs, vars, yRect, 0.000001);
}
exports.generateYConstraints = generateYConstraints;
function generateXGroupConstraints(root) {
    return generateGroupConstraints(root, xRect, 0.000001);
}
exports.generateXGroupConstraints = generateXGroupConstraints;
function generateYGroupConstraints(root) {
    return generateGroupConstraints(root, yRect, 0.000001);
}
exports.generateYGroupConstraints = generateYGroupConstraints;
function removeOverlaps(rs) {
    var vs = rs.map(function (r) {
        return new vpsc_1.Variable(r.cx());
    });
    var cs = generateXConstraints(rs, vs);
    var solver = new vpsc_1.Solver(vs, cs);
    solver.solve();
    vs.forEach(function (v, i) {
        return rs[i].setXCentre(v.position());
    });
    vs = rs.map(function (r) {
        return new vpsc_1.Variable(r.cy());
    });
    cs = generateYConstraints(rs, vs);
    solver = new vpsc_1.Solver(vs, cs);
    solver.solve();
    vs.forEach(function (v, i) {
        return rs[i].setYCentre(v.position());
    });
}
exports.removeOverlaps = removeOverlaps;
var IndexedVariable = function (_super) {
    __extends(IndexedVariable, _super);
    function IndexedVariable(index, w) {
        var _this = _super.call(this, 0, w) || this;
        _this.index = index;
        return _this;
    }
    return IndexedVariable;
}(vpsc_1.Variable);
exports.IndexedVariable = IndexedVariable;
var Projection = function () {
    function Projection(nodes, groups, rootGroup, constraints, avoidOverlaps) {
        if (rootGroup === void 0) {
            rootGroup = null;
        }
        if (constraints === void 0) {
            constraints = null;
        }
        if (avoidOverlaps === void 0) {
            avoidOverlaps = false;
        }
        var _this = this;
        this.nodes = nodes;
        this.groups = groups;
        this.rootGroup = rootGroup;
        this.avoidOverlaps = avoidOverlaps;
        this.variables = nodes.map(function (v, i) {
            return v.variable = new IndexedVariable(i, 1);
        });
        if (constraints)
            this.createConstraints(constraints);
        if (avoidOverlaps && rootGroup && typeof rootGroup.groups !== 'undefined') {
            nodes.forEach(function (v) {
                if (!v.width || !v.height) {
                    v.bounds = new Rectangle(v.x, v.x, v.y, v.y);
                    return;
                }
                var w2 = v.width / 2, h2 = v.height / 2;
                v.bounds = new Rectangle(v.x - w2, v.x + w2, v.y - h2, v.y + h2);
            });
            computeGroupBounds(rootGroup);
            var i = nodes.length;
            groups.forEach(function (g) {
                _this.variables[i] = g.minVar = new IndexedVariable(i++, typeof g.stiffness !== 'undefined' ? g.stiffness : 0.01);
                _this.variables[i] = g.maxVar = new IndexedVariable(i++, typeof g.stiffness !== 'undefined' ? g.stiffness : 0.01);
            });
        }
    }
    Projection.prototype.createSeparation = function (c) {
        return new vpsc_1.Constraint(this.nodes[c.left].variable, this.nodes[c.right].variable, c.gap, typeof c.equality !== 'undefined' ? c.equality : false);
    };
    Projection.prototype.makeFeasible = function (c) {
        var _this = this;
        if (!this.avoidOverlaps)
            return;
        var axis = 'x', dim = 'width';
        if (c.axis === 'x')
            axis = 'y', dim = 'height';
        var vs = c.offsets.map(function (o) {
            return _this.nodes[o.node];
        }).sort(function (a, b) {
            return a[axis] - b[axis];
        });
        var p = null;
        vs.forEach(function (v) {
            if (p)
                v[axis] = p[axis] + p[dim] + 1;
            p = v;
        });
    };
    Projection.prototype.createAlignment = function (c) {
        var _this = this;
        var u = this.nodes[c.offsets[0].node].variable;
        this.makeFeasible(c);
        var cs = c.axis === 'x' ? this.xConstraints : this.yConstraints;
        c.offsets.slice(1).forEach(function (o) {
            var v = _this.nodes[o.node].variable;
            cs.push(new vpsc_1.Constraint(u, v, o.offset, true));
        });
    };
    Projection.prototype.createConstraints = function (constraints) {
        var _this = this;
        var isSep = function (c) {
            return typeof c.type === 'undefined' || c.type === 'separation';
        };
        this.xConstraints = constraints.filter(function (c) {
            return c.axis === 'x' && isSep(c);
        }).map(function (c) {
            return _this.createSeparation(c);
        });
        this.yConstraints = constraints.filter(function (c) {
            return c.axis === 'y' && isSep(c);
        }).map(function (c) {
            return _this.createSeparation(c);
        });
        constraints.filter(function (c) {
            return c.type === 'alignment';
        }).forEach(function (c) {
            return _this.createAlignment(c);
        });
    };
    Projection.prototype.setupVariablesAndBounds = function (x0, y0, desired, getDesired) {
        this.nodes.forEach(function (v, i) {
            if (v.fixed) {
                v.variable.weight = v.fixedWeight ? v.fixedWeight : 1000;
                desired[i] = getDesired(v);
            } else {
                v.variable.weight = 1;
            }
            var w = (v.width || 0) / 2, h = (v.height || 0) / 2;
            var ix = x0[i], iy = y0[i];
            v.bounds = new Rectangle(ix - w, ix + w, iy - h, iy + h);
        });
    };
    Projection.prototype.xProject = function (x0, y0, x) {
        if (!this.rootGroup && !(this.avoidOverlaps || this.xConstraints))
            return;
        this.project(x0, y0, x0, x, function (v) {
            return v.px;
        }, this.xConstraints, generateXGroupConstraints, function (v) {
            return v.bounds.setXCentre(x[v.variable.index] = v.variable.position());
        }, function (g) {
            var xmin = x[g.minVar.index] = g.minVar.position();
            var xmax = x[g.maxVar.index] = g.maxVar.position();
            var p2 = g.padding / 2;
            g.bounds.x = xmin - p2;
            g.bounds.X = xmax + p2;
        });
    };
    Projection.prototype.yProject = function (x0, y0, y) {
        if (!this.rootGroup && !this.yConstraints)
            return;
        this.project(x0, y0, y0, y, function (v) {
            return v.py;
        }, this.yConstraints, generateYGroupConstraints, function (v) {
            return v.bounds.setYCentre(y[v.variable.index] = v.variable.position());
        }, function (g) {
            var ymin = y[g.minVar.index] = g.minVar.position();
            var ymax = y[g.maxVar.index] = g.maxVar.position();
            var p2 = g.padding / 2;
            g.bounds.y = ymin - p2;
            ;
            g.bounds.Y = ymax + p2;
        });
    };
    Projection.prototype.projectFunctions = function () {
        var _this = this;
        return [
            function (x0, y0, x) {
                return _this.xProject(x0, y0, x);
            },
            function (x0, y0, y) {
                return _this.yProject(x0, y0, y);
            }
        ];
    };
    Projection.prototype.project = function (x0, y0, start, desired, getDesired, cs, generateConstraints, updateNodeBounds, updateGroupBounds) {
        this.setupVariablesAndBounds(x0, y0, desired, getDesired);
        if (this.rootGroup && this.avoidOverlaps) {
            computeGroupBounds(this.rootGroup);
            cs = cs.concat(generateConstraints(this.rootGroup));
        }
        this.solve(this.variables, cs, start, desired);
        this.nodes.forEach(updateNodeBounds);
        if (this.rootGroup && this.avoidOverlaps) {
            this.groups.forEach(updateGroupBounds);
            computeGroupBounds(this.rootGroup);
        }
    };
    Projection.prototype.solve = function (vs, cs, starting, desired) {
        var solver = new vpsc_1.Solver(vs, cs);
        solver.setStartingPositions(starting);
        solver.setDesiredPositions(desired);
        solver.solve();
    };
    return Projection;
}();
exports.Projection = Projection;
},{"295":295,"298":298}],297:[function(require,module,exports){
'use strict';
var pqueue_1 = require(294);
var Neighbour = function () {
    function Neighbour(id, distance) {
        this.id = id;
        this.distance = distance;
    }
    return Neighbour;
}();
var Node = function () {
    function Node(id) {
        this.id = id;
        this.neighbours = [];
    }
    return Node;
}();
var QueueEntry = function () {
    function QueueEntry(node, prev, d) {
        this.node = node;
        this.prev = prev;
        this.d = d;
    }
    return QueueEntry;
}();
var Calculator = function () {
    function Calculator(n, es, getSourceIndex, getTargetIndex, getLength) {
        this.n = n;
        this.es = es;
        this.neighbours = new Array(this.n);
        var i = this.n;
        while (i--)
            this.neighbours[i] = new Node(i);
        i = this.es.length;
        while (i--) {
            var e = this.es[i];
            var u = getSourceIndex(e), v = getTargetIndex(e);
            var d = getLength(e);
            this.neighbours[u].neighbours.push(new Neighbour(v, d));
            this.neighbours[v].neighbours.push(new Neighbour(u, d));
        }
    }
    Calculator.prototype.DistanceMatrix = function () {
        var D = new Array(this.n);
        for (var i = 0; i < this.n; ++i) {
            D[i] = this.dijkstraNeighbours(i);
        }
        return D;
    };
    Calculator.prototype.DistancesFromNode = function (start) {
        return this.dijkstraNeighbours(start);
    };
    Calculator.prototype.PathFromNodeToNode = function (start, end) {
        return this.dijkstraNeighbours(start, end);
    };
    Calculator.prototype.PathFromNodeToNodeWithPrevCost = function (start, end, prevCost) {
        var q = new pqueue_1.PriorityQueue(function (a, b) {
                return a.d <= b.d;
            }), u = this.neighbours[start], qu = new QueueEntry(u, null, 0), visitedFrom = {};
        q.push(qu);
        while (!q.empty()) {
            qu = q.pop();
            u = qu.node;
            if (u.id === end) {
                break;
            }
            var i = u.neighbours.length;
            while (i--) {
                var neighbour = u.neighbours[i], v = this.neighbours[neighbour.id];
                if (qu.prev && v.id === qu.prev.node.id)
                    continue;
                var viduid = v.id + ',' + u.id;
                if (viduid in visitedFrom && visitedFrom[viduid] <= qu.d)
                    continue;
                var cc = qu.prev ? prevCost(qu.prev.node.id, u.id, v.id) : 0, t = qu.d + neighbour.distance + cc;
                visitedFrom[viduid] = t;
                q.push(new QueueEntry(v, qu, t));
            }
        }
        var path = [];
        while (qu.prev) {
            qu = qu.prev;
            path.push(qu.node.id);
        }
        return path;
    };
    Calculator.prototype.dijkstraNeighbours = function (start, dest) {
        if (dest === void 0) {
            dest = -1;
        }
        var q = new pqueue_1.PriorityQueue(function (a, b) {
                return a.d <= b.d;
            }), i = this.neighbours.length, d = new Array(i);
        while (i--) {
            var node = this.neighbours[i];
            node.d = i === start ? 0 : Number.POSITIVE_INFINITY;
            node.q = q.push(node);
        }
        while (!q.empty()) {
            var u = q.pop();
            d[u.id] = u.d;
            if (u.id === dest) {
                var path = [];
                var v = u;
                while (typeof v.prev !== 'undefined') {
                    path.push(v.prev.id);
                    v = v.prev;
                }
                return path;
            }
            i = u.neighbours.length;
            while (i--) {
                var neighbour = u.neighbours[i];
                var v = this.neighbours[neighbour.id];
                var t = u.d + neighbour.distance;
                if (u.d !== Number.MAX_VALUE && v.d > t) {
                    v.d = t;
                    v.prev = u;
                    q.reduceKey(v.q, v, function (e, q) {
                        return e.q = q;
                    });
                }
            }
        }
        return d;
    };
    return Calculator;
}();
exports.Calculator = Calculator;
},{"294":294}],298:[function(require,module,exports){
'use strict';
var PositionStats = function () {
    function PositionStats(scale) {
        this.scale = scale;
        this.AB = 0;
        this.AD = 0;
        this.A2 = 0;
    }
    PositionStats.prototype.addVariable = function (v) {
        var ai = this.scale / v.scale;
        var bi = v.offset / v.scale;
        var wi = v.weight;
        this.AB += wi * ai * bi;
        this.AD += wi * ai * v.desiredPosition;
        this.A2 += wi * ai * ai;
    };
    PositionStats.prototype.getPosn = function () {
        return (this.AD - this.AB) / this.A2;
    };
    return PositionStats;
}();
exports.PositionStats = PositionStats;
var Constraint = function () {
    function Constraint(left, right, gap, equality) {
        if (equality === void 0) {
            equality = false;
        }
        this.left = left;
        this.right = right;
        this.gap = gap;
        this.equality = equality;
        this.active = false;
        this.unsatisfiable = false;
        this.left = left;
        this.right = right;
        this.gap = gap;
        this.equality = equality;
    }
    Constraint.prototype.slack = function () {
        return this.unsatisfiable ? Number.MAX_VALUE : this.right.scale * this.right.position() - this.gap - this.left.scale * this.left.position();
    };
    return Constraint;
}();
exports.Constraint = Constraint;
var Variable = function () {
    function Variable(desiredPosition, weight, scale) {
        if (weight === void 0) {
            weight = 1;
        }
        if (scale === void 0) {
            scale = 1;
        }
        this.desiredPosition = desiredPosition;
        this.weight = weight;
        this.scale = scale;
        this.offset = 0;
    }
    Variable.prototype.dfdv = function () {
        return 2 * this.weight * (this.position() - this.desiredPosition);
    };
    Variable.prototype.position = function () {
        return (this.block.ps.scale * this.block.posn + this.offset) / this.scale;
    };
    Variable.prototype.visitNeighbours = function (prev, f) {
        var ff = function (c, next) {
            return c.active && prev !== next && f(c, next);
        };
        this.cOut.forEach(function (c) {
            return ff(c, c.right);
        });
        this.cIn.forEach(function (c) {
            return ff(c, c.left);
        });
    };
    return Variable;
}();
exports.Variable = Variable;
var Block = function () {
    function Block(v) {
        this.vars = [];
        v.offset = 0;
        this.ps = new PositionStats(v.scale);
        this.addVariable(v);
    }
    Block.prototype.addVariable = function (v) {
        v.block = this;
        this.vars.push(v);
        this.ps.addVariable(v);
        this.posn = this.ps.getPosn();
    };
    Block.prototype.updateWeightedPosition = function () {
        this.ps.AB = this.ps.AD = this.ps.A2 = 0;
        for (var i = 0, n = this.vars.length; i < n; ++i)
            this.ps.addVariable(this.vars[i]);
        this.posn = this.ps.getPosn();
    };
    Block.prototype.compute_lm = function (v, u, postAction) {
        var _this = this;
        var dfdv = v.dfdv();
        v.visitNeighbours(u, function (c, next) {
            var _dfdv = _this.compute_lm(next, v, postAction);
            if (next === c.right) {
                dfdv += _dfdv * c.left.scale;
                c.lm = _dfdv;
            } else {
                dfdv += _dfdv * c.right.scale;
                c.lm = -_dfdv;
            }
            postAction(c);
        });
        return dfdv / v.scale;
    };
    Block.prototype.populateSplitBlock = function (v, prev) {
        var _this = this;
        v.visitNeighbours(prev, function (c, next) {
            next.offset = v.offset + (next === c.right ? c.gap : -c.gap);
            _this.addVariable(next);
            _this.populateSplitBlock(next, v);
        });
    };
    Block.prototype.traverse = function (visit, acc, v, prev) {
        var _this = this;
        if (v === void 0) {
            v = this.vars[0];
        }
        if (prev === void 0) {
            prev = null;
        }
        v.visitNeighbours(prev, function (c, next) {
            acc.push(visit(c));
            _this.traverse(visit, acc, next, v);
        });
    };
    Block.prototype.findMinLM = function () {
        var m = null;
        this.compute_lm(this.vars[0], null, function (c) {
            if (!c.equality && (m === null || c.lm < m.lm))
                m = c;
        });
        return m;
    };
    Block.prototype.findMinLMBetween = function (lv, rv) {
        this.compute_lm(lv, null, function () {
        });
        var m = null;
        this.findPath(lv, null, rv, function (c, next) {
            if (!c.equality && c.right === next && (m === null || c.lm < m.lm))
                m = c;
        });
        return m;
    };
    Block.prototype.findPath = function (v, prev, to, visit) {
        var _this = this;
        var endFound = false;
        v.visitNeighbours(prev, function (c, next) {
            if (!endFound && (next === to || _this.findPath(next, v, to, visit))) {
                endFound = true;
                visit(c, next);
            }
        });
        return endFound;
    };
    Block.prototype.isActiveDirectedPathBetween = function (u, v) {
        if (u === v)
            return true;
        var i = u.cOut.length;
        while (i--) {
            var c = u.cOut[i];
            if (c.active && this.isActiveDirectedPathBetween(c.right, v))
                return true;
        }
        return false;
    };
    Block.split = function (c) {
        c.active = false;
        return [
            Block.createSplitBlock(c.left),
            Block.createSplitBlock(c.right)
        ];
    };
    Block.createSplitBlock = function (startVar) {
        var b = new Block(startVar);
        b.populateSplitBlock(startVar, null);
        return b;
    };
    Block.prototype.splitBetween = function (vl, vr) {
        var c = this.findMinLMBetween(vl, vr);
        if (c !== null) {
            var bs = Block.split(c);
            return {
                constraint: c,
                lb: bs[0],
                rb: bs[1]
            };
        }
        return null;
    };
    Block.prototype.mergeAcross = function (b, c, dist) {
        c.active = true;
        for (var i = 0, n = b.vars.length; i < n; ++i) {
            var v = b.vars[i];
            v.offset += dist;
            this.addVariable(v);
        }
        this.posn = this.ps.getPosn();
    };
    Block.prototype.cost = function () {
        var sum = 0, i = this.vars.length;
        while (i--) {
            var v = this.vars[i], d = v.position() - v.desiredPosition;
            sum += d * d * v.weight;
        }
        return sum;
    };
    return Block;
}();
exports.Block = Block;
var Blocks = function () {
    function Blocks(vs) {
        this.vs = vs;
        var n = vs.length;
        this.list = new Array(n);
        while (n--) {
            var b = new Block(vs[n]);
            this.list[n] = b;
            b.blockInd = n;
        }
    }
    Blocks.prototype.cost = function () {
        var sum = 0, i = this.list.length;
        while (i--)
            sum += this.list[i].cost();
        return sum;
    };
    Blocks.prototype.insert = function (b) {
        b.blockInd = this.list.length;
        this.list.push(b);
    };
    Blocks.prototype.remove = function (b) {
        var last = this.list.length - 1;
        var swapBlock = this.list[last];
        this.list.length = last;
        if (b !== swapBlock) {
            this.list[b.blockInd] = swapBlock;
            swapBlock.blockInd = b.blockInd;
        }
    };
    Blocks.prototype.merge = function (c) {
        var l = c.left.block, r = c.right.block;
        var dist = c.right.offset - c.left.offset - c.gap;
        if (l.vars.length < r.vars.length) {
            r.mergeAcross(l, c, dist);
            this.remove(l);
        } else {
            l.mergeAcross(r, c, -dist);
            this.remove(r);
        }
    };
    Blocks.prototype.forEach = function (f) {
        this.list.forEach(f);
    };
    Blocks.prototype.updateBlockPositions = function () {
        this.list.forEach(function (b) {
            return b.updateWeightedPosition();
        });
    };
    Blocks.prototype.split = function (inactive) {
        var _this = this;
        this.updateBlockPositions();
        this.list.forEach(function (b) {
            var v = b.findMinLM();
            if (v !== null && v.lm < Solver.LAGRANGIAN_TOLERANCE) {
                b = v.left.block;
                Block.split(v).forEach(function (nb) {
                    return _this.insert(nb);
                });
                _this.remove(b);
                inactive.push(v);
            }
        });
    };
    return Blocks;
}();
exports.Blocks = Blocks;
var Solver = function () {
    function Solver(vs, cs) {
        this.vs = vs;
        this.cs = cs;
        this.vs = vs;
        vs.forEach(function (v) {
            v.cIn = [], v.cOut = [];
        });
        this.cs = cs;
        cs.forEach(function (c) {
            c.left.cOut.push(c);
            c.right.cIn.push(c);
        });
        this.inactive = cs.map(function (c) {
            c.active = false;
            return c;
        });
        this.bs = null;
    }
    Solver.prototype.cost = function () {
        return this.bs.cost();
    };
    Solver.prototype.setStartingPositions = function (ps) {
        this.inactive = this.cs.map(function (c) {
            c.active = false;
            return c;
        });
        this.bs = new Blocks(this.vs);
        this.bs.forEach(function (b, i) {
            return b.posn = ps[i];
        });
    };
    Solver.prototype.setDesiredPositions = function (ps) {
        this.vs.forEach(function (v, i) {
            return v.desiredPosition = ps[i];
        });
    };
    Solver.prototype.mostViolated = function () {
        var minSlack = Number.MAX_VALUE, v = null, l = this.inactive, n = l.length, deletePoint = n;
        for (var i = 0; i < n; ++i) {
            var c = l[i];
            if (c.unsatisfiable)
                continue;
            var slack = c.slack();
            if (c.equality || slack < minSlack) {
                minSlack = slack;
                v = c;
                deletePoint = i;
                if (c.equality)
                    break;
            }
        }
        if (deletePoint !== n && (minSlack < Solver.ZERO_UPPERBOUND && !v.active || v.equality)) {
            l[deletePoint] = l[n - 1];
            l.length = n - 1;
        }
        return v;
    };
    Solver.prototype.satisfy = function () {
        if (this.bs == null) {
            this.bs = new Blocks(this.vs);
        }
        this.bs.split(this.inactive);
        var v = null;
        while ((v = this.mostViolated()) && (v.equality || v.slack() < Solver.ZERO_UPPERBOUND && !v.active)) {
            var lb = v.left.block, rb = v.right.block;
            if (lb !== rb) {
                this.bs.merge(v);
            } else {
                if (lb.isActiveDirectedPathBetween(v.right, v.left)) {
                    v.unsatisfiable = true;
                    continue;
                }
                var split = lb.splitBetween(v.left, v.right);
                if (split !== null) {
                    this.bs.insert(split.lb);
                    this.bs.insert(split.rb);
                    this.bs.remove(lb);
                    this.inactive.push(split.constraint);
                } else {
                    v.unsatisfiable = true;
                    continue;
                }
                if (v.slack() >= 0) {
                    this.inactive.push(v);
                } else {
                    this.bs.merge(v);
                }
            }
        }
    };
    Solver.prototype.solve = function () {
        this.satisfy();
        var lastcost = Number.MAX_VALUE, cost = this.bs.cost();
        while (Math.abs(lastcost - cost) > 0.0001) {
            this.satisfy();
            lastcost = cost;
            cost = this.bs.cost();
        }
        return cost;
    };
    return Solver;
}();
Solver.LAGRANGIAN_TOLERANCE = -0.0001;
Solver.ZERO_UPPERBOUND = -1e-10;
exports.Solver = Solver;
function removeOverlapInOneDimension(spans, lowerBound, upperBound) {
    var vs = spans.map(function (s) {
        return new Variable(s.desiredCenter);
    });
    var cs = [];
    var n = spans.length;
    for (var i = 0; i < n - 1; i++) {
        var left = spans[i], right = spans[i + 1];
        cs.push(new Constraint(vs[i], vs[i + 1], (left.size + right.size) / 2));
    }
    var leftMost = vs[0], rightMost = vs[n - 1], leftMostSize = spans[0].size / 2, rightMostSize = spans[n - 1].size / 2;
    var vLower = null, vUpper = null;
    if (lowerBound) {
        vLower = new Variable(lowerBound, leftMost.weight * 1000);
        vs.push(vLower);
        cs.push(new Constraint(vLower, leftMost, leftMostSize));
    }
    if (upperBound) {
        vUpper = new Variable(upperBound, rightMost.weight * 1000);
        vs.push(vUpper);
        cs.push(new Constraint(rightMost, vUpper, rightMostSize));
    }
    var solver = new Solver(vs, cs);
    solver.solve();
    return {
        newCenters: vs.slice(0, spans.length).map(function (v) {
            return v.position();
        }),
        lowerBound: vLower ? vLower.position() : leftMost.position() - leftMostSize,
        upperBound: vUpper ? vUpper.position() : rightMost.position() + rightMostSize
    };
}
exports.removeOverlapInOneDimension = removeOverlapInOneDimension;
},{}],299:[function(require,module,exports){
var bundleFn = arguments[3];
var sources = arguments[4];
var cache = arguments[5];
var stringify = JSON.stringify;
module.exports = function (fn, options) {
    var wkey;
    var cacheKeys = Object.keys(cache);
    for (var i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i];
        var exp = cache[key].exports;
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }
    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (var i = 0, l = cacheKeys.length; i < l; i++) {
            var key = cacheKeys[i];
            wcache[key] = key;
        }
        sources[wkey] = [
            Function([
                'require',
                'module',
                'exports'
            ], '(' + fn + ')(self)'),
            wcache
        ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
    var scache = {};
    scache[wkey] = wkey;
    sources[skey] = [
        Function(['require'], 'var f = require(' + stringify(wkey) + ');' + '(f.default ? f.default : f)(self);'),
        scache
    ];
    var workerSources = {};
    resolveSources(skey);
    function resolveSources(key) {
        workerSources[key] = true;
        for (var depPath in sources[key][1]) {
            var depKey = sources[key][1][depPath];
            if (!workerSources[depKey]) {
                resolveSources(depKey);
            }
        }
    }
    var src = '(' + bundleFn + ')({' + Object.keys(workerSources).map(function (key) {
        return stringify(key) + ':[' + sources[key][0] + ',' + stringify(sources[key][1]) + ']';
    }).join(',') + '},{},[' + stringify(skey) + '])';
    var URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
    var blob = new Blob([src], { type: 'text/javascript' });
    if (options && options.bare) {
        return blob;
    }
    var workerUrl = URL.createObjectURL(blob);
    var worker = new Worker(workerUrl);
    worker.objectURL = workerUrl;
    return worker;
};
},{}],300:[function(require,module,exports){
module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function extend() {
    var target = {};
    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
}
},{}],301:[function(require,module,exports){
module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;
function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }
    return target;
}
},{}],302:[function(require,module,exports){
module.exports = function yoyoifyAppendChild(el, childs) {
    for (var i = 0; i < childs.length; i++) {
        var node = childs[i];
        if (Array.isArray(node)) {
            yoyoifyAppendChild(el, node);
            continue;
        }
        if (typeof node === 'number' || typeof node === 'boolean' || node instanceof Date || node instanceof RegExp) {
            node = node.toString();
        }
        if (typeof node === 'string') {
            if (el.lastChild && el.lastChild.nodeName === '#text') {
                el.lastChild.nodeValue += node;
                continue;
            }
            node = document.createTextNode(node);
        }
        if (node && node.nodeType) {
            el.appendChild(node);
        }
    }
};
},{}],303:[function(require,module,exports){
const choo = require(20);
const frs = require(59);
const {Observable} = require(266);
const np = require(244);
const {search, fba, parse, kegg} = require(310);
const {Model, revive} = require(307);
const mainView = require(321);
const hotkeys = require(305);
const {noop, dnd} = require(316);
const filePicker = require(304);
const app = module.exports = choo();
app.route('/', mainView);
app.use(function (state) {
    state.content = {};
    state.menu = {
        active: null,
        search: {
            searchId: 'search',
            term: '',
            busy: false,
            results: []
        }
    };
});
app.use(function (state, emitter) {
    const emit = emitter.emit.bind(emitter);
    const done = () => emitter.emit('render');
    const reduce = ([name, fn]) => emitter.on(name, data => {
        if (fn.length === 4)
            fn(state, data, emit, done);
        else {
            fn(state, data, emit);
            done();
        }
    });
    Object.entries({
        activeMenu(s, active) {
            s.menu.active = active === s.menu.active ? null : active;
        },
        searchResults(s, results) {
            s.menu.search.results = results;
            s.menu.search.busy = false;
        },
        searchFor(s, term, emit) {
            if (term === s.menu.search.term)
                return;
            s.menu.search.term = term;
            s.menu.search.busy = term && term.length > 2;
            s.menu.search.results = [];
            search.input.onNext(term);
        },
        setModel(s, model) {
            s.content.model = model;
        },
        setFluxes(s, fluxes) {
            console.log(fluxes);
            if (s.content.model)
                s.content.model.fluxes = fluxes;
            else
                throw new Error('Cannot set fluxes when no model is loaded');
        },
        newModel(state, _, emit) {
            emit('setModel', new Model());
        },
        openModelFile(state, _, emit) {
            filePicker({ accept: 'xml' }, files => emit('dropFiles', files));
        },
        dropFiles(state, files, emit) {
            np.start();
            frs(files[0]).on('data', data => parse.input.onNext({ data })).on('end', () => parse.input.onNext({ end: true }));
        },
        dropItems(state, [href], emit) {
            if (!state.content.model)
                return;
            kegg.input.onNext({ href });
            kegg.output.filter(m => m.href === href).subscribe(m => {
                console.log(m);
            });
        },
        blur(state, data, emit) {
            document.activeElement.blur();
        },
        focus(state, id, emit) {
            setTimeout(() => {
                let e = document.querySelector(id);
                if (e)
                    e.focus();
            }, 10);
        },
        runFBA(state, _, emit) {
            if (state.content.model) {
                const model = state.content.model;
                const options = {};
                fba({
                    model,
                    options
                }).then(result => emit('setFluxes', result)).catch(e => console.error(e));
            }
        }
    }).forEach(reduce);
});
app.use(function (state, emitter) {
    const emit = emitter.emit.bind(emitter);
    search.output.subscribe(results => emit('searchResults', results, noop));
    search.log.subscribe(m => console.log(m));
    search.error.subscribe(e => console.error(e));
    parse.output.map(m => revive(m)).tap(() => np.done()).subscribe(m => emit('setModel', m, noop));
    parse.log.subscribe(m => console.log(m));
    parse.error.subscribe(e => console.error(e));
    Observable.fromEvent(document.body, 'keydown').merge(Observable.fromEvent(document.body, 'keyup')).filter(e => e.key === 'Escape' || (e.target ? e.target.nodeName !== 'INPUT' : true)).map(hotkeys).filter(Boolean).subscribe(args => args.forEach(a => emit(...[
        ...a,
        noop
    ])));
    dnd(document.body, ({items, files}) => {
        if (items.length)
            emit('dropItems', items, noop);
        if (files.length)
            emit('dropFiles', files, noop);
    });
});
},{"20":20,"244":244,"266":266,"304":304,"305":305,"307":307,"310":310,"316":316,"321":321,"59":59}],304:[function(require,module,exports){
module.exports = function filePicker(opts, callback) {
    if (arguments.length === 1) {
        callback = opts;
        opts = {};
    }
    const i = document.createElement('input');
    i.type = 'file';
    if (opts.accept)
        i.accept = opts.accept;
    if (opts.multiple)
        i.multiple = opts.multiple;
    if (opts.dir)
        i.dir = opts.dir;
    i.onchange = function () {
        const files = i.files;
        i.remove();
        callback(files);
    };
    document.body.appendChild(i);
    i.click();
};
},{}],305:[function(require,module,exports){
const m = new Map();
const kill = e => {
    e.preventDefault();
    e.stopPropagation();
};
const tab = t => [
    'activeMenu',
    t
];
const etype = (type, ...k) => {
    let t = keys(...k);
    return e => e.type === type && t(e);
};
const keydown = (...k) => etype('keydown', ...k);
const keyup = (...k) => etype('keyup', ...k);
const keys = (...ks) => {
    const ts = ks.map(key);
    return e => ts.some(t => t(e));
};
const key = k => {
    let s = k.split('-');
    let key = s[s.length - 1];
    let mods = s.slice(0, -1);
    return e => e.key === key && mods.every(m => e[m + 'Key']);
};
m.set(keydown('alt-f'), [tab('file')]);
m.set(keydown('alt-n'), [tab('network')]);
m.set(keydown('alt-c'), [tab('calculate')]);
m.set(keydown('alt-o'), [tab('options')]);
m.set(keydown('ctrl-o'), [['openModelFile']]);
m.set(keydown('ctrl-n'), [['newModel']]);
m.set(keydown('ctrl-s', '/'), [
    tab('search'),
    [
        'focus',
        '#search'
    ]
]);
m.set(keydown('Escape'), [['blur']]);
module.exports = function (e, state) {
    for (let [t, a] of m.entries()) {
        if (t(e, state)) {
            kill(e);
            return a;
        }
    }
};
},{}],306:[function(require,module,exports){
;
require(74)(`
/* C:\Users\wre\workspace\fba\src\main\index.js */
/**/

:root {
  /* Colors
     ====== */
  /* Grays */
  /* Brand Accent Colors */
  /* Semantic Brand Colors */
  /* Shadows, transparencies etc. */
  /* Semantic Colors */
  /* Fonts
     ===== */
}

/**/

:root {
  /* Theme internally shared Variables
     --------------------------------- */
  /* App
     --- */
  /* App Content Area
     ---------------- */
  /* App Header
     ---------- */
  /* App Footer
     ---------- */
  /* Grid
     ---- */
  /* Flex Layout
     ----------- */
  /* Typography
     ---------- */
  /* Font settings */
  /* Modular scale variants */
  /* Colors */
  /* List
     ---- */
  /* Label
     ---- */
  /* Badge
     ----- */
  /* Table
     ----- */
  /* Table Extras
     ------------ */
  /* Sum Table
     ---------- */
  /* Data List
     --------- */
  /* Data Tree
     --------- */
  /* Calendar
     ----------- */
  /* Pagination
     ---------- */
  /* Tab Navigation
     -------------- */
  /* Breadcrumb Navigation
     --------------------- */
  /* Navigation
     ----------- */
  /* Process Navigation
     ------------------ */
  /* Tooltip
     ------- */
  /* Popover
     ------- */
  /* Layer
     ----- */
  /* Nag
     --- */
  /* Scrollbar
     --------- */
  /* Ribbon
     ------- */
  /* Loading Layer
     ------------- */
  /* Container
     --------- */
  /* Go-to-top
     --------- */
  /* Divider
     ------- */
  /* Panel
     ----- */
  /* Toolbar
     -------- */
  /* Notification
     ------------ */
  /* Progress Bar
     ------------ */
  /* Callout
     ------- */
  /* Article Structuring
     ------------------- */
  /* Button
     ------ */
  /* Default variant */
  /* Emphasized variant */
  /* Transparent variant */
  /* Emphasized & transparent variant */
  /* Half transparent alternative variant */
  /* Transparent alternative variant */
  /* Danger variant */
  /* Suggestive variant */
  /* Form Control Label
     ------------------ */
  /* Fieldset
     -------- */
  /* Input
     ----- */
  /* File Input
     ---------- */
  /* Checkbox
     -------- */
  /* Radio Button
     ------------ */
  /* Input Group
     ----------- */
  /* Embedded Input Group
     -------------------- */
  /* Slider
     ------ */
  /* Rating
     ------ */
  /* Token
     ----- */
  /* Flip Switch
     ----------- */
  /* Drop Down
     --------- */
  /* Date Picker
     ----------- */
  /* Time Picker
     ----------- */
  /* Responsive Image
     ---------------- */
  /* Image Shapes
     ------------ */
  /* Gallery
     ------- */
  /* Drawer
     ------ */
  /* E-Mail
     ------ */
  /* Product List
     ------------ */
}

/*! normalize.css v6.0.0 | MIT License | github.com/necolas/normalize.css */

/* Document
   ========================================================================== */

/**
 * 1. Correct the line height in all browsers.
 * 2. Prevent adjustments of font size after orientation changes in
 *    IE on Windows Phone and in iOS.
 */

html {
  line-height: 1.15;
  /* 1 */
  -ms-text-size-adjust: 100%;
  /* 2 */
  -webkit-text-size-adjust: 100%;
  /* 2 */
}

/* Sections
   ========================================================================== */

/**
 * Add the correct display in IE 9-.
 */

article,
aside,
footer,
header,
nav,
section {
  display: block;
}

/**
 * Correct the font size and margin on \`h1\` elements within \`section\` and
 * \`article\` contexts in Chrome, Firefox, and Safari.
 */

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

/* Grouping content
   ========================================================================== */

/**
 * Add the correct display in IE 9-.
 * 1. Add the correct display in IE.
 */

figcaption,
figure,
main {
  /* 1 */
  display: block;
}

/**
 * Add the correct margin in IE 8.
 */

figure {
  margin: 1em 40px;
}

/**
 * 1. Add the correct box sizing in Firefox.
 * 2. Show the overflow in Edge and IE.
 */

hr {
  box-sizing: content-box;
  /* 1 */
  height: 0;
  /* 1 */
  overflow: visible;
  /* 2 */
}

/**
 * 1. Correct the inheritance and scaling of font size in all browsers.
 * 2. Correct the odd \`em\` font sizing in all browsers.
 */

pre {
  font-family: monospace, monospace;
  /* 1 */
  font-size: 1em;
  /* 2 */
}

/* Text-level semantics
   ========================================================================== */

/**
 * 1. Remove the gray background on active links in IE 10.
 * 2. Remove gaps in links underline in iOS 8+ and Safari 8+.
 */

a {
  background-color: transparent;
  /* 1 */
  -webkit-text-decoration-skip: objects;
  /* 2 */
}

/**
 * 1. Remove the bottom border in Chrome 57- and Firefox 39-.
 * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.
 */

abbr[title] {
  border-bottom: none;
  /* 1 */
  text-decoration: underline;
  /* 2 */
  text-decoration: underline dotted;
  /* 2 */
}

/**
 * Prevent the duplicate application of \`bolder\` by the next rule in Safari 6.
 */

b,
strong {
  font-weight: inherit;
}

/**
 * Add the correct font weight in Chrome, Edge, and Safari.
 */

b,
strong {
  font-weight: bolder;
}

/**
 * 1. Correct the inheritance and scaling of font size in all browsers.
 * 2. Correct the odd \`em\` font sizing in all browsers.
 */

code,
kbd,
samp {
  font-family: monospace, monospace;
  /* 1 */
  font-size: 1em;
  /* 2 */
}

/**
 * Add the correct font style in Android 4.3-.
 */

dfn {
  font-style: italic;
}

/**
 * Add the correct background and color in IE 9-.
 */

mark {
  background-color: #ff0;
  color: #000;
}

/**
 * Add the correct font size in all browsers.
 */

small {
  font-size: 80%;
}

/**
 * Prevent \`sub\` and \`sup\` elements from affecting the line height in
 * all browsers.
 */

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/* Embedded content
   ========================================================================== */

/**
 * Add the correct display in IE 9-.
 */

audio,
video {
  display: inline-block;
}

/**
 * Add the correct display in iOS 4-7.
 */

audio:not([controls]) {
  display: none;
  height: 0;
}

/**
 * Remove the border on images inside links in IE 10-.
 */

img {
  border-style: none;
}

/**
 * Hide the overflow in IE.
 */

svg:not(:root) {
  overflow: hidden;
}

/* Forms
   ========================================================================== */

/**
 * Remove the margin in Firefox and Safari.
 */

button,
input,
optgroup,
select,
textarea {
  margin: 0;
}

/**
 * Show the overflow in IE.
 * 1. Show the overflow in Edge.
 */

button,
input {
  /* 1 */
  overflow: visible;
}

/**
 * Remove the inheritance of text transform in Edge, Firefox, and IE.
 * 1. Remove the inheritance of text transform in Firefox.
 */

button,
select {
  /* 1 */
  text-transform: none;
}

/**
 * 1. Prevent a WebKit bug where (2) destroys native \`audio\` and \`video\`
 *    controls in Android 4.
 * 2. Correct the inability to style clickable types in iOS and Safari.
 */

button,
html [type="button"],
[type="reset"],
[type="submit"] {
  -webkit-appearance: button;
  /* 2 */
}

/**
 * Remove the inner border and padding in Firefox.
 */

button::-moz-focus-inner,
[type="button"]::-moz-focus-inner,
[type="reset"]::-moz-focus-inner,
[type="submit"]::-moz-focus-inner {
  border-style: none;
  padding: 0;
}

/**
 * Restore the focus styles unset by the previous rule.
 */

button:-moz-focusring,
[type="button"]:-moz-focusring,
[type="reset"]:-moz-focusring,
[type="submit"]:-moz-focusring {
  outline: 1px dotted ButtonText;
}

/**
 * 1. Correct the text wrapping in Edge and IE.
 * 2. Correct the color inheritance from \`fieldset\` elements in IE.
 * 3. Remove the padding so developers are not caught out when they zero out
 *    \`fieldset\` elements in all browsers.
 */

legend {
  box-sizing: border-box;
  /* 1 */
  color: inherit;
  /* 2 */
  display: table;
  /* 1 */
  max-width: 100%;
  /* 1 */
  padding: 0;
  /* 3 */
  white-space: normal;
  /* 1 */
}

/**
 * 1. Add the correct display in IE 9-.
 * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.
 */

progress {
  display: inline-block;
  /* 1 */
  vertical-align: baseline;
  /* 2 */
}

/**
 * Remove the default vertical scrollbar in IE.
 */

textarea {
  overflow: auto;
}

/**
 * 1. Add the correct box sizing in IE 10-.
 * 2. Remove the padding in IE 10-.
 */

[type="checkbox"],
[type="radio"] {
  box-sizing: border-box;
  /* 1 */
  padding: 0;
  /* 2 */
}

/**
 * Correct the cursor style of increment and decrement buttons in Chrome.
 */

[type="number"]::-webkit-inner-spin-button,
[type="number"]::-webkit-outer-spin-button {
  height: auto;
}

/**
 * 1. Correct the odd appearance in Chrome and Safari.
 * 2. Correct the outline style in Safari.
 */

[type="search"] {
  -webkit-appearance: textfield;
  /* 1 */
  outline-offset: -2px;
  /* 2 */
}

/**
 * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.
 */

[type="search"]::-webkit-search-cancel-button,
[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}

/**
 * 1. Correct the inability to style clickable types in iOS and Safari.
 * 2. Change font properties to \`inherit\` in Safari.
 */

::-webkit-file-upload-button {
  -webkit-appearance: button;
  /* 1 */
  font: inherit;
  /* 2 */
}

/* Interactive
   ========================================================================== */

/*
 * Add the correct display in IE 9-.
 * 1. Add the correct display in Edge, IE, and Firefox.
 */

details,
menu {
  display: block;
}

/*
 * Add the correct display in all browsers.
 */

summary {
  display: list-item;
}

/* Scripting
   ========================================================================== */

/**
 * Add the correct display in IE 9-.
 */

canvas {
  display: inline-block;
}

/**
 * Add the correct display in IE.
 */

template {
  display: none;
}

/* Hidden
   ========================================================================== */

/**
 * Add the correct display in IE 10-.
 */

[hidden] {
  display: none;
}

/**/

nothing to do here */;

:root {
  --typography-font-family: Arial;
  --app-area-max-width: 1260px;
  --app-header-bg-color: transparent;
  --app-footer-bg-color: transparent;
}

/* Chapter level header */

.vclMasterHeader {
  text-align: center;
  line-height: 1;
  margin: 0;
  margin-top: 3.3em;
  margin-bottom: 1em;
  margin-right: auto;
  margin-left: auto;
}

.vclMasterHeader h1 {
  font-size: 3em;
  font-weight: bold;
  line-height: 1;
  margin-bottom: 0.8em;
}

.vclMasterHeader h2 {
  font-size: 1.9em;
  font-weight: bold;
  line-height: 1;
  margin-bottom: 0.8em;
}

.vclMasterHeader p {
  font-size: 1.8em;
  font-weight: bold;
  line-height: 1;
}

/* Article header */

.vclArticleHeader {
  border-bottom-color: hsl(0, 0%, 75%);
  overflow: hidden ;
  margin-bottom: 0;
  line-height: 1.22em;
  display: block;
  border-bottom-width: 1px;
  border-bottom-style: solid;
  margin-top: 1.2em;
  margin-bottom: 1.2em;
}

.vclArticleHeader .vclArticleSubHeader  {
  color: hsl(0, 0%, 45%);
  font-weight: 500;
  margin-left: 0.4em;
  margin-bottom: 0.1em;
  display: inline;
  font-size: 0.65em;
}

/* Article */

.vclArticle {
  border: 0;
  margin-bottom: 1.3em;
}

/* Automatic numbering of sectionized content */

.vclSectAutoNumbering,
.vclSectAutoNumberingReset {
  counter-reset: sectCounterH1;
}

.vclSectAutoNumbering h1:before {
  content: counter(sectCounterH1) "\\0000a0";
}

.vclSectAutoNumbering h1 {
  counter-increment: sectCounterH1;
  counter-reset: sectCounterH2;
}

.vclSectAutoNumbering h2:before {
  content: counter(sectCounterH1) "." counter(sectCounterH2) "\\0000a0";
}

.vclSectAutoNumbering h2 {
  counter-increment: sectCounterH2;
  counter-reset: sectCounterH3;
}

.vclSectAutoNumbering h3:before {
  content: counter(sectCounterH1) "." counter(sectCounterH2) "." counter(sectCounterH3) "\\0000a0";
  counter-reset: sectCounterH4;
}

.vclSectAutoNumbering h3 {
  counter-increment: sectCounterH3;
}

/* Set the viewport width to the device width */

@-ms-viewport {
  width: device-width;
}

@-moz-viewport {
  width: device-width;
}

@-o-viewport {
  width: device-width;
}

@-webkit-viewport {
  width: device-width;
}

@viewport {
  width: device-width;
}

.vclViewport {
  min-height: 100vh;
  background-color: hsl(0, 0%, 95%);
}

.vclViewportBg {
  background-color: hsl(0, 0%, 95%);
}

.vclApp {
  background-color: transparent;
  max-width: 95%;
  min-width: 0;
  margin-left: auto;
  margin-right: auto;
  *zoom: 1;
}

.vclApp:before,
.vclApp:after {
  content: " ";
  display: table;
}

.vclApp:after {
  clear: both;
}

.vclLayoutWidth {
  max-width: 95%;
}

.vclContentArea {
  background-color: #FFFFFF;
}

.vclContentArea.vclTransparent {
  background-color: transparent;
}

.vclContentBgColor {
  background-color: #FFFFFF;
}

.vclContentBgColor.vclSecondary {
  background-color: hsl(0, 0%, 95%);
}

.vclApplicationFooter {
  box-sizing: border-box;
  position: relative;
  color: inherit;
  background-color: #FFFFFF;
  margin-top: 2em;
  margin-bottom: 2em;
}

.vclApplicationHeader {
  box-sizing: border-box;
  margin-top: 1.5em;
  margin-bottom: 1.5em;
  color: inherit;
  background-color: #FFFFFF;
}

.vclApplicationHeader .vclLogo {
  margin-left: 0.5em;
  width: 4em;
}

.vclApplicationHeader .vclAppName {
  font-size: 1.4em;
  margin-top: 0;
  margin-left: 0.8em;
  margin-right: 0.8em;
  margin-bottom: 0;
  font-weight: normal;
}

.vclBadge {
  display: inline-block;
  padding-top: 0.2em;
  padding-right: 0.5em;
  padding-bottom: 0.2em;
  padding-left: 0.5em;
  font-weight: bold;
  font-size: 80%;
  line-height: 1;
  white-space: nowrap;
  vertical-align: baseline;
  border-radius: 2.5em;
  color: #FFFFFF;
  background-color: hsl(0, 0%, 15%);
}

.vclBadge:empty {
  display: none;
}

.vclBadge.vclPrimary {
  color: #FFFFFF;
  background-color: hsl(0, 0%, 30%);
}

.vclBadge.vclSuccess {
  color: #FFFFFF;
  background-color: #5cb85c;
}

.vclBadge.vclInfo {
  color: #FFFFFF;
  background-color: #5bc0de;
}

.vclBadge.vclWarning {
  color: #FFFFFF;
  background-color: #f0ad4e;
}

.vclBadge.vclDanger,
.vclBadge.vclError,
.vclBadge.vclImportant {
  color: #FFFFFF;
  background-color: #d9534f;
}

.vclBreadcrumbNav ol li a +.vclBreadcrumbNavDivider,
.vclBreadcrumbNav ol li .vclBreadcrumbNavItemLabel +.vclBreadcrumbNavDivider {
  color: inherit;
  display: inline-block;
  padding-left: 0.2em;
  padding-right: 0.2em;
}

.vclBreadcrumbNav ol li a,
.vclBreadcrumbNav ol li .vclBreadcrumbNavItemLabel {
  color: #0888BF;
  display: inline-block;
}

.vclBreadcrumbNav ol li a:hover,
.vclBreadcrumbNav ol li .vclBreadcrumbNavItemLabel:hover,
.vclBreadcrumbNav ol li a:focus,
.vclBreadcrumbNav ol li .vclBreadcrumbNavItemLabel:focus {
  color: #00ADEF;
}

.vclBreadcrumbNav ol li.vclSelected a,
.vclBreadcrumbNav ol li.vclSelected .vclBreadcrumbNavItemLabel {
  color: inherit;
}

.vclBreadcrumbNav ol li.vclSelected {
  cursor: default;
  background: transparent;
  border: 0;
}

.vclBreadcrumbNav ol li {
  float: left;
  font-weight: bold;
  font-size: 0.98em;
}

.vclBreadcrumbNav ol {
  list-style: none;
  list-style-type: none;
  overflow: hidden;
  padding: 0;
  margin: 0;
  margin-bottom: 1.3em;
}

.vclBusyIndicator {
  margin-left: auto;
  margin-right: auto;
}

.vclBusyIndicator > i {
  width: 3em;
  height: 3em;
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.vclBusyIndicator > span {
  display: block;
  margin-top: 0.8em;
  text-align: center;
}

[class^="vclBusy-"],
[class*=" vclBusy-"] {
  display: inline-block;
  width: 1.8em;
  height: 1em;
  line-height: inherit;
  vertical-align: baseline;
  background-attachment: inherit;
  background-size: auto;
  background-position: center;
  background-repeat: no-repeat;
}

.vclBusy-busyIndCircular {
  background-image: url('../imgs/vclBusyIndicatorCircular.svg');
  background-position: center;
  background-repeat: no-repeat;
}

.vclBusy-busyIndStraight {
  background-image: url('../imgs/vclBusyIndicatorStraight.svg');
  background-position: center;
  background-repeat: no-repeat;
}

.vclButtonDim {
  display: inline;
  vertical-align: middle;
  border-width: 0;
  line-height: initial;
  height: 2.5em;
  font-weight: bolder;
  box-sizing: border-box;
  padding-right: 0.8em;
  padding-left: 0.8em;
  padding-top: 0;
  padding-bottom: 0;
}

.vclButtonDim.vclSquare {
  min-width: 2.5em;
}

.vclButton,
.vclButton[disabled] {
  border-width: 0;
  border-color: transparent;
  border-style: solid;
  border-radius: 0;
  padding-right: 0.8em;
  padding-left: 0.8em;
  padding-top: 0;
  padding-bottom: 0;
  line-height: initial;
  text-decoration: none;
  font-weight: bolder;
  vertical-align: middle;
  display: inline-block;
  height: 2.5em;
  box-sizing: border-box;
  user-select: none;
  white-space: normal;
  cursor: pointer;
  transition: color .25s linear, background-color .25s ease-in-out, border-color .25s ease-in-out;
  *zoom: 1;
}

.vclButton:before,
.vclButton:after,
.vclButton[disabled]:before,
.vclButton[disabled]:after {
  content: " ";
  display: table;
}

.vclButton:after,
.vclButton[disabled]:after {
  clear: both;
}

.vclButton > span,
.vclButton > .vclIcogram {
  font-size: 0.96em;
  line-height: initial;
}

a.vclButton > .vclIcogram {
  display: inline-block;
}

.vclButton.vclOverflowEllipsis > .vclIcogram > .vclText {
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
}

a.vclButton,
a.vclButton[disabled] {
  line-height: 2.5em;
}

a.vclButton > span,
a.vclButton[disabled] > span {
  line-height: inherit;
}

span.vclButton,
span.vclButton[disabled] {
  display: inline-block;
  line-height: initial;
}

.vclButton:focus {
  outline: none;
}

.vclButton:active {
  outline: none;
}

.vclButton.vclSquare {
  min-width: 2.5em;
  padding-right: 0;
  padding-left: 0;
  text-align: center;
}

.vclButton.vclDisabled,
.vclButton[disabled] {
  pointer-events: none;
  opacity: .75;
  cursor: default;
}

/* Standard variant */

.vclButton {
  border-color: transparent;
  background-color: hsl(0, 0%, 50%);
  color: #FFFFFF;
  text-transform: none;
}

.vclButton.vclSelected {
  color: #FFFFFF;
  background-color: #005F84;
}

.vclButton:active,
.vclButton.vclPressed,
.vclButton.vclActive {
  background-color: hsl(0, 0%, 20%);
  color: #FFFFFF;
}

.vclButton.vclDisabled,
.vclButton[disabled] {
  color: hsl(0, 0%, 88%);
}

/* Emphasized variant */

.vclButton.vclEmphasized {
  border-color: transparent;
  background-color: #00ADEF;
  color: #FFFFFF;
}

.vclButton.vclEmphasized:active,
.vclButton.vclEmphasized.vclPressed,
.vclButton.vclEmphasized.vclActive {
  background-color: #0888BF;
  color: #FFFFFF;
}

/* Emphasized & transparent variant */

.vclButton.vclEmphasizedTransparent {
  color: #00ADEF;
  background: none;
}

.vclButton.vclEmphasizedTransparent.vclDisabled,
.vclButton.vclEmphasizedTransparent[disabled] {
  color: hsl(0, 0%, 88%);
}

.vclButton.vclEmphasizedTransparent:active,
.vclButton.vclEmphasizedTransparent.vclPressed,
.vclButton.vclEmphasizedTransparent.vclActive {
  background: none;
  color: #005F84;
}

/* Transparent variant */

.vclButton.vclTransparent {
  color: hsl(0, 0%, 45%);
  background: none;
}

.vclButton.vclTransparent.vclDisabled,
.vclButton.vclTransparent[disabled] {
  color: hsl(0, 0%, 63%);
}

.vclButton.vclTransparent:active,
.vclButton.vclTransparent.vclPressed,
.vclButton.vclTransparent.vclActive {
  background: none;
  color: #000000;
}

/* Transparent alternative variant */

.vclButton.vclTransparentAlt {
  background: none;
  background-color: transparent;
  color: hsl(0, 0%, 88%);
}

.vclButton.vclTransparentAlt.vclDisabled,
.vclButton.vclTransparentAlt[disabled] {
  color: hsl(0, 0%, 63%);
}

.vclButton.vclTransparentAlt:active,
.vclButton.vclTransparentAlt.vclPressed,
.vclButton.vclTransparentAlt.vclActive {
  background: none;
  color: #FFFFFF;
}

/* Half transparent variant */

.vclButton.vclHalfTransparent {
  background: none;
  background-color: transparent;
  color: inherit;
}

.vclButton.vclHalfTransparent.vclDisabled,
.vclButton.vclHalfTransparent[disabled] {
  color: hsl(0, 0%, 63%);
}

.vclButton.vclHalfTransparent:active,
.vclButton.vclHalfTransparent.vclPressed,
.vclButton.vclHalfTransparent.vclActive {
  background-color: hsl(0, 0%, 92%);
  color: inherit;
}

/* Danger variant */

.vclButton.vclDanger {
  color: #FFFFFF;
  background-color: #d9534f;
}

.vclButton.vclDanger:active,
.vclButton.vclDanger.vclPressed,
.vclButton.vclDanger.vclActive {
  color: #FFFFFF;
  background-color: #a94442;
}

.vclButton.vclDanger.vclDisabled,
.vclButton.vclDanger[disabled] {
  color: hsl(0, 0%, 63%);
}

/* Suggestive variant */

.vclButton.vclSuggestive {
  color: #FFFFFF;
  background-color: #5cb85c;
}

.vclButton.vclSuggestive:active,
.vclButton.vclSuggestive.vclPressed,
.vclButton.vclSuggestive.vclActive {
  color: #FFFFFF;
  background-color: #3c763d;
}

.vclButton.vclSuggestive.vclDisabled,
.vclButton.vclSuggestive[disabled] {
  color: hsl(0, 0%, 88%);
}

/* Outline modifier */

.vclOutline {
  border-color: hsl(0, 0%, 50%);
  border-width: 2px;
}

/* Circular modifier */

.vclCircular {
  border-radius: 50%;
}

/* Hover support */

.vclButton:hover,
.vclButton:focus,
.vclButton.vclHover,
.vclButton.vclFocused {
  background-color: hsl(0, 0%, 20%);
  color: #FFFFFF;
}

.vclButton.vclEmphasized:hover,
.vclButton.vclEmphasized:focus,
.vclButton.vclEmphasized.vclHover,
.vclButton.vclEmphasized.vclFocused {
  background-color: #0888BF;
  color: #FFFFFF;
}

.vclButton.vclEmphasizedTransparent:hover,
.vclButton.vclEmphasizedTransparent:focus,
.vclButton.vclEmphasizedTransparent.vclHover,
.vclButton.vclEmphasizedTransparent.vclFocused {
  background: none;
  color: #005F84;
}

.vclButton.vclTransparent:hover,
.vclButton.vclTransparent:focus,
.vclButton.vclTransparent.vclHover,
.vclButton.vclTransparent.vclFocused {
  background: none;
  color: #000000;
}

.vclButton.vclTransparentAlt:hover,
.vclButton.vclTransparentAlt:focus,
.vclButton.vclTransparentAlt.vclHover,
.vclButton.vclTransparentAlt.vclFocused {
  background: none;
  color: #FFFFFF;
}

.vclButton.vclHalfTransparent:hover,
.vclButton.vclHalfTransparent:focus,
.vclButton.vclHalfTransparent.vclHover,
.vclButton.vclHalfTransparent.vclFocused {
  background-color: hsl(0, 0%, 92%);
  color: inherit;
}

.vclButton.vclDanger:hover,
.vclButton.vclDanger:focus,
.vclButton.vclDanger.vclHover,
.vclButton.vclDanger.vclFocused {
  color: #FFFFFF;
  background-color: #a94442;
}

.vclButton.vclSuggestive:hover,
.vclButton.vclSuggestive:focus,
.vclButton.vclSuggestive.vclHover,
.vclButton.vclSuggestive.vclFocused {
  color: #FFFFFF;
  background-color: #3c763d;
}

.vclButtonGroup {
  *zoom: 1;
}

.vclButtonGroup:before,
.vclButtonGroup:after {
  content: " ";
  display: table;
}

.vclButtonGroup:after {
  clear: both;
}

.vclButtonGroup .vclButton:first-child {
  border-bottom-left-radius: 4px;
  border-top-left-radius: 4px;
  margin-left: 0;
}

.vclButtonGroup .vclButton:last-child {
  border-bottom-right-radius: 4px;
  border-top-right-radius: 4px;
}

.vclButtonGroup .vclButton {
  vertical-align: top;
  border-radius: 0 0 0 0;
  float: left;
}

.vclButtonGroup + .vclButtonGroup {
  margin-left: 0.5em;
}

.vclButtonGroup.vclVertical > .vclButton:first-child {
  border-bottom-left-radius: 0;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
}

.vclButtonGroup.vclVertical > .vclButton:last-child {
  border-bottom-right-radius: 4px;
  border-bottom-left-radius: 4px;
  border-top-right-radius: 0;
}

.vclButtonGroup.vclVertical > .vclButton {
  float: none;
  display: block;
  width: 100%;
}

.vclCalendar {
  background-color: transparent;
  height: 100%;
  overflow: hidden;
}

.vclCalHeaderLabel {
  font-weight: 600;
  font-size: 0.85em;
  line-height: 2em;
}

.vclWeekdayLabel {
  font-size: 0.85em;
  min-height: 2em;
}

.vclCalItem {
  cursor: pointer;
  color: inherit;
  background-color: transparent;
  transition: color .25s linear, background-color .25s ease-in-out, border-color .25s ease-in-out;
  min-height: 2.5em;
  outline: 0;
}

.vclCalendar.vclCalInput {
  user-select: none;
  outline: 0;
}

.vclCalendar.vclCalInput .vclCalItem:hover {
  color: hsl(0, 0%, 20%);
  background-color: hsl(0, 0%, 92%);
}

.vclCalItem.vclToday,
.vclCalendar.vclCalInput .vclCalItem.vclToday:hover {
  font-weight: 500;
  color: #FF6347;
}

.vclCalItem.vclOtherMonth,
.vclCalendar.vclCalInput .vclCalItem.vclOtherMonth:hover {
  color: hsl(0, 0%, 63%);
}

.vclCalItem.vclDisabled,
.vclCalendar.vclCalInput .vclCalItem.vclDisabled:hover {
  color: hsl(0, 0%, 50%);
  background-color: hsl(0, 0%, 88%);
  cursor: default;
}

.vclCalItem.vclAvailable,
.vclCalendar.vclCalInput .vclCalItem.vclAvailable:hover {
  background-color: #dff0d8;
}

.vclCalItem.vclUnavailable,
.vclCalendar.vclCalInput .vclCalItem.vclUnavailable:hover {
  background-color: #f2dede;
}

.vclCalItem.vclSelected,
.vclCalendar.vclCalInput .vclCalItem.vclSelected:hover {
  color: #FFFFFF;
  background-color: #0888BF;
  font-weight: 500;
}

.vclCheckbox {
  cursor: pointer;
  outline: none;
  display: inline-block;
}

.vclCheckbox > .vclFormControlLabel {
  display: inline-block;
}

.vclCheckbox > .vclIcon {
  color: hsl(0, 0%, 63%);
  display: inline-block;
  min-width: 1.5em;
  text-align: center;
  padding-right: 0.4em;
  padding-left: 0.4em;
  font-size: 1.16em;
}

.vclCheckbox:hover > .vclIcon {
  color: #00ADEF;
}

.vclCheckbox:focus > .vclIcon {
  color: #00ADEF;
}

.vclCheckbox.vclDisabled > .vclIcon {
  color: hsl(0, 0%, 88%);
}

.vclFormControlLabel:hover .vclCheckbox:not(.vclDisabled) .vclIcon {
  color: #00ADEF;
}

* {
  /* Prevent auto size adjustments as we do this explicitly with breakpoints */
  -webkit-text-size-adjust: none;
  -moz-text-size-adjust: none;
  -ms-text-size-adjust: none;
  /* Prevent highlighting of elements on tap */
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  -webkit-touch-callout: none;
}

/* Disable zoom on double-tap */

body {
  -ms-touch-action: none !important;
}

.vclContainer {
  box-sizing: border-box;
  background-color: hsl(0, 0%, 88%);
  border-width: 1px;
  border-color: hsl(0, 0%, 75%);
  border-style: solid;
  border-radius: 0;
  padding: 0.6rem;
  min-width: 1em;
  margin-bottom: 1.3em;
}

.vclContainer.vclTransparent {
  background-color: transparent;
}

.vclDataGrid {
  margin-bottom: 1.3em;
  display: flex;
  flex-direction: column;
}

.vclCalendar {
  background-color: transparent;
  height: 100%;
  overflow: hidden;
}

.vclDataGrid .vclDGRow,
.vclDataGrid .vclDGCell {
  display: flex;
  flex: 1;
  border-collapse: collapse;
  user-select: none;
}

.vclDGAlignCentered .vclDGCell,
.vclDGAlignCentered.vclDGCell {
  justify-content: center;
  text-align: center;
}

.vclDGAlignRight .vclDGCell,
.vclDGAlignRight.vclDGCell {
  justify-content: flex-end;
  text-align: right;
}

.vclDGVAlignMiddle .vclDGCell,
.vclDGVAlignMiddle.vclDGCell {
  align-items: center;
}

.vclDGVAlignBottom .vclDGCell,
.vclDGVAlignBottom.vclDGCell {
  align-items: flex-end;
}

.vclDataList {
  margin-bottom: 1.3em;
  background-color: transparent;
}

.vclDataList .vclDataListHeader {
  background-color: transparent;
}

.vclDataList .vclDataListFooter {
  background-color: transparent;
}

.vclDataList > .vclDataListBody > .vclDataListItem.vclDisabled:hover {
  color: hsl(0, 0%, 75%);
  background-color: transparent;
}

.vclDataList > .vclDataListBody > .vclDataListItem.vclDisabled {
  background-color: transparent;
  color: hsl(0, 0%, 75%);
  cursor: default;
}

.vclDataList > .vclDataListBody > .vclDataListItem {
  min-height: 3em;
  position: relative;
}

.vclDataList > .vclDataListBody > .vclDataListItem.vclSelected,
.vclDataList > .vclDataListBody > .vclDataListItem:hover.vclSelected {
  color: #FFFFFF;
  background-color: #0888BF;
}

.vclDataList > .vclDataListBody {
  width: 100%;
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
  list-style: none;
  list-style-type: none;
  border-top-width: 1px;
  border-top-style: solid;
  border-bottom-width: 1px;
  border-bottom-style: solid;
  border-top-color: hsl(0, 0%, 75%);
  border-bottom-color: hsl(0, 0%, 75%);
}

.vclDataList.vclDivider .vclDataListItem:last-of-type {
  border-bottom: 0;
}

.vclDataList.vclDivider .vclDataListItem {
  border-bottom-width: 1px;
  border-bottom-style: solid;
  border-bottom-color: hsl(0, 0%, 88%);
}

.vclDataList.vclNoBorder .vclDataListBody {
  border: 0;
}

.vclDataList.vclItemHoverHighlight .vclDataListItem:hover {
  color: hsl(0, 0%, 20%);
  background-color: hsl(0, 0%, 92%);
}

.vclDataList.vclItemSelectability .vclDataListItem {
  cursor: pointer;
}

.vclTree {
  background-color: transparent;
  margin-bottom: 1.3em;
}

.vclTree ul > li li {
  padding-left: 1.5em;
}

.vclTree ul > li {
  padding: 0;
  /* Nested vertical items */
}

.vclTree ul {
  margin: 0;
  list-style: none;
  list-style-type: none;
  padding: 0;
}

.vclTree .vclSeparator a {
  display: none;
}

.vclTree .vclSeparator {
  margin: 0.2em 0;
  overflow: hidden;
  padding: 0;
}

.vclTree.vclBorder li > a {
  border-bottom-style: solid;
  border-bottom-color: hsl(0, 0%, 15%);
  border-bottom-width: 1px;
}

.vclTree.vclBorder ul > li:last-child > a {
  border-bottom-width: 0;
}

.vclTree .vclListHeading {
  font-weight: bold;
  font-size: 0.9em;
  padding-top: 1.5em;
  color: hsl(0, 0%, 15%);
  background-color: hsl(0, 0%, 63%);
}

/* item coloring */

.vclTree ul li > a,
.vclTree ul li > .vclIcogram {
  background-color: transparent;
}

.vclTree ul li > a:hover,
.vclTree ul li > .vclIcogram:hover {
  color: #FFFFFF;
  background-color: hsl(0, 0%, 92%);
}

.vclTree ul li.vclSelected > a,
.vclTree ul li.vclSelected > .vclIcogram {
  color: #FFFFFF;
  background-color: #0888BF;
}

.vclDatePicker {
  display: block;
  box-sizing: border-box;
  min-width: 18em;
  margin: 0;
  padding: 0;
  border-color: transparent;
  border-width: 1px;
  border-style: solid;
  background-color: transparent;
}

.vclDivider {
  user-select: none;
  color: inherit;
}

.vclDivider> .vclDividerElement.vclDividerBeginElement {
  padding-left: 0.5em;
}

.vclDivider> .vclDividerElement.vclDividerEndElement {
  padding-right: 0.5em;
}

.vclDivider> .vclDividerElement {
  padding-left: 1em;
  padding-right: 1em;
  background-color: #FFFFFF;
  z-index: 1;
}

.vclDivider.vclDividerHorizontal> .vclDividerRule {
  border-bottom: 1px solid hsl(0, 0%, 75%);
  position: absolute;
  left: 0;
  top: 50%;
  right: 0;
}

.vclDivider.vclDividerHorizontal {
  margin: 1rem 0;
}

.vclDivider.vclDividerVertical> .vclDividerRule {
  border-left: 1px solid hsl(0, 0%, 75%);
  position: absolute;
  left: 50%;
  top: 0;
  bottom: 0;
  height: 100%;
}

.vclDivider.vclDividerVertical> .vclDividerElement {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
}

.vclDivider> .vclIcogram {
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  display: inline-block;
}

.vclDivider.vclDividerHeading {
  text-transform: none;
}

.vclDivider:not(.vclDividerHeading) {
  font-size: 0.85em;
}

.vclDivider:empty {
  border-bottom: 1px solid hsl(0, 0%, 75%);
}

.vclDivider.vclDividerHorizontal {
  position: relative;
}

.vclDivider.vclDividerVertical {
  position: relative;
}

/* HTML based divider should just look the same as the vclDivider */

hr {
  border-top-color: hsl(0, 0%, 75%);
  border-top-width: 1px;
  border-top-style: solid;
  border-bottom: 0;
  border-left: 0;
  border-right: 0;
  height: 0;
  margin-top: 1em;
  margin-bottom: 1em;
}

.vclDrawer {
  transform: translateX(-256px);
  width: calc(100% + 256px);
  overflow: hidden;
  display: block;
  position: fixed;
  top: 0;
  left: 0;
  height: 100%;
  box-sizing: border-box;
  /* right-drawer: make drawer on the right side */
}

.vclDrawer.vclOpen {
  transition: transform ease-in-out 0.3s, width ease-in-out 0.3s;
  transform: translateX(0);
}

.vclDrawer.vclClose {
  transition: transform ease-in-out 0.3s, width ease-in-out 0.3s;
  transform: translateX(-256px);
}

.vclDrawer .vclDrawerDrawerPanel {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 256px;
  will-change: transform;
  box-sizing: border-box;
  background-color: hsl(0, 0%, 95%);
  color: hsl(0, 0%, 20%);
  z-index: 10;
}

.vclDrawer.vclDrawerRight .vclDrawerDrawerPanel {
  left: auto;
  right: 0;
}

.vclDrawer.vclDrawerRight .vclDrawerMainPanel {
  left: 0;
  transition: right ease-in-out 0.3s, padding ease-in-out 0.3s;
}

.vclDrawer .vclDrawerMainPanel .vclDrawerMainPanelContent {
  position: absolute;
  top: 0;
  bottom: 0;
  height: 100%;
  overflow-x: hidden;
}

.vclDrawer .vclDrawerMainPanel {
  position: relative;
  top: 0;
  right: 0;
  bottom: 0;
  left: 256px;
  height: 100%;
  box-sizing: border-box;
  transition: left ease-in-out 0.3s, padding ease-in-out 0.3s;
  width: calc(100% - 256px);
}

.vclDrawer .vclDrawerMainPanelCover {
  outline: 0;
  cursor: pointer;
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-color: rgba(0, 0, 0, 0.3);
  visibility: hidden;
  opacity: 0;
  transition: opacity ease-in-out 0.38s, visibility ease-in-out 0.38s;
  z-index: 9;
}

.vclDrawer.vclOpen .vclDrawerDrawerPanel {
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.15);
}

.vclDrawer.vclDrawerRight.vclOpen .vclDrawerDrawerPanel {
  box-shadow: -2px 2px 4px rgba(0, 0, 0, 0.15);
}

.vclDrawer.vclDrawerRight {
  left: auto;
  transform: translateX(256px);
}

.vclDrawer.vclDrawerRight.vclOpen {
  left: auto;
  transform: translateX(0);
}

.vclDrawer.vclDrawerRight .vclDrawerMainPanel {
  left: 0;
}

.vclDrawer.vclOpen .vclDrawerMainPanelCover {
  visibility: visible;
  opacity: 1;
}

.vclDrawer .vclDrawerMainPanel {
  margin: 0;
  min-height: 100%;
  right: 0;
}

.vclDropdown {
  user-select: none;
  box-sizing: border-box;
  display: none;
  position: absolute;
  z-index: 60;
  min-width: 13em;
  max-height: 25em;
  margin: 0;
  padding: 0;
  list-style: none;
  text-align: left;
  border-color: rgba(0, 0, 0, 0.3);
  border-width: 1px;
  border-style: solid;
  background-color: #FFFFFF;
  overflow-x: hidden;
  overflow-y: auto;
  outline: 0;
}

.vclDropdown .vclDropdownItem > .vclDropdownItemLabel,
.vclDropdown .vclDropdownItem > .vclDropdownItemSubLabel {
  display: block;
  padding-left: 0.9rem;
  padding-right: 0.9rem;
  padding-bottom: 0.1em;
  white-space: nowrap;
  text-decoration: none;
  overflow: hidden;
  text-overflow: ellipsis;
}

.vclDropdown .vclDropdownItem:hover > .vclDropdownItemLabel,
.vclDropdown .vclDropdownItem:focus > .vclDropdownItemLabel {
  color: #FFFFFF;
}

.vclDropdown .vclDropdownItem:hover > .vclDropdownItemSubLabel,
.vclDropdown .vclDropdownItem:focus > .vclDropdownItemSubLabel {
  color: hsl(0, 0%, 75%);
}

.vclDropdown .vclDropdownItem:hover,
.vclDropdown .vclDropdownItem:focus {
  background-color: hsl(0, 0%, 45%);
}

.vclDropdown .vclDropdownItem > .vclDropdownItemSubLabel {
  font-size: 0.95em;
  padding-top: 0;
  color: hsl(0, 0%, 50%);
}

.vclDropdown .vclDropdownItem.vclSelected > .vclDropdownItemLabel,
.vclDropdown .vclDropdownItem.vclSelected:hover > .vclDropdownItemLabel,
.vclDropdown .vclDropdownItem.vclSelected:focus > .vclDropdownItemLabel,
.vclDropdown .vclDropdownItem.vclSelected > .vclDropdownItemSubLabel,
.vclDropdown .vclDropdownItem.vclSelected:hover > .vclDropdownItemSubLabel,
.vclDropdown .vclDropdownItem.vclSelected:focus > .vclDropdownItemSubLabel {
  color: #FFFFFF;
}

.vclDropdown .vclDropdownItem.vclSelected,
.vclDropdown .vclDropdownItem.vclSelected:hover,
.vclDropdown .vclDropdownItem.vclSelected:focus {
  background-color: #00ADEF;
}

.vclDropdown .vclDropdownItem.vclHighlighted > .vclDropdownItemLabel,
.vclDropdown .vclDropdownItem.vclHighlighted:hover > .vclDropdownItemLabel,
.vclDropdown .vclDropdownItem.vclHighlighted:focus > .vclDropdownItemLabel {
  color: #FFFFFF;
}

.vclDropdown .vclDropdownItem.vclHighlighted,
.vclDropdown .vclDropdownItem.vclHighlighted:hover,
.vclDropdown .vclDropdownItem.vclHighlighted:focus {
  background-color: hsl(0, 0%, 30%);
}

.vclDropdown .vclDropdownItem.vclDisabled > .vclDropdownItemLabel,
.vclDropdown .vclDropdownItem.vclDisabled:hover > .vclDropdownItemLabel,
.vclDropdown .vclDropdownItem.vclDisabled:focus > .vclDropdownItemLabel,
.vclDropdown .vclDropdownItem.vclDisabled > .vclDropdownItemSubLabel,
.vclDropdown .vclDropdownItem.vclDisabled:hover > .vclDropdownItemSubLabel,
.vclDropdown .vclDropdownItem.vclDisabled:focus > .vclDropdownItemSubLabel {
  color: hsl(0, 0%, 45%);
}

.vclDropdown .vclDropdownItem.vclDisabled .vclIcon,
.vclDropdown .vclDropdownItem.vclDisabled:hover .vclIcon,
.vclDropdown .vclDropdownItem.vclDisabled:focus .vclIcon {
  margin-right: 0.3em;
}

.vclDropdown .vclDropdownItem.vclDisabled,
.vclDropdown .vclDropdownItem.vclDisabled:hover,
.vclDropdown .vclDropdownItem.vclDisabled:focus {
  background-color: transparent;
  cursor: default;
}

.vclDropdown .vclDropdownItem {
  outline: 0;
  line-height: 1.6;
  padding-top: 0.38em;
  padding-bottom: 0.38em;
  cursor: pointer;
  color: #000000;
}

.vclDropdown .vclSeparator:hover,
.vclDropdown .vclSeparator:focus {
  background-color: transparent;
}

.vclDropdown .vclSeparator {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  border-bottom-color: hsl(0, 0%, 63%);
  border-bottom-width: 1px;
  border-bottom-style: solid;
}

.vclDropdown .vclDropdownItemGroupHeader > .vclDropdownItemGroupHeaderLabel {
  line-height: 1.6;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  padding-left: 0.5em;
  font-weight: 600;
  cursor: default;
}

.vclDropdown .vclDropdownItemGroupHeader {
  line-height: 1.4;
  padding-top: 0.1em;
  padding-bottom: 0.1em;
}

.vclDropdown.vclOpen {
  display: block;
}

.vclEffect--blur {
  -webkit-filter: blur(4px) contrast(0.4) brightness(1.4);
  -moz-filter: blur(4px) contrast(0.4) brightness(1.4);
  -o-filter: blur(4px) contrast(0.4) brightness(1.4);
  -ms-filter: blur(4px) contrast(0.4) brightness(1.4);
}

.vclInputGroupEmb {
  margin-bottom: 1.0em;
  position: relative;
}

.vclInputGroupEmb .vclInput.vclPrepItem {
  padding-left: 2.5em;
}

.vclInputGroupEmb .vclInput.vclAppItem {
  padding-right: 2.5em;
}

.vclInputGroupEmb .vclInput {
  margin-bottom: 0;
}

.vclInputGroupEmb .vclPrepended,
.vclInputGroupEmb .vclAppended {
  text-align: center;
  line-height: 2.5em;
  display: block;
  min-width: 2.5em;
  position: absolute;
  top: 0;
  color: hsl(0, 0%, 45%);
  background-color: transparent;
}

.vclInputGroupEmb .vclPrepended {
  left: 0;
}

.vclInputGroupEmb .vclAppended {
  right: 0;
}

.vclInputGroupEmb button.vclButton[disabled] {
  display: none;
}

fieldset,
.vclFieldset {
  padding: 1.3em;
  border-radius: 4px;
  border: 1px solid hsl(0, 0%, 75%);
}

fieldset legend,
.vclFieldset legend {
  padding-left: 0.5em;
  padding-right: 0.5em;
  font-weight: bold;
}

figure {
  margin: 0;
  margin-bottom: 1.3em;
}

figure img {
  margin-bottom: 0.5em;
}

figure figcaption {
  display: block;
  font-weight: normal;
  font-size: 1.1em;
}

.vclFileInput {
  width: 100%;
  display: inline-block;
  box-sizing: border-box;
  cursor: pointer;
  text-align: center;
  color: (--file-input-color);
  background-color: #FFFFFF;
  border-width: 1px;
  border-style: solid;
  border-color: hsl(0, 0%, 63%);
  border-radius: 0;
}

.vclFileInput .vclFileInputIcon {
  font-size: 2em;
  margin-top: 0.4em;
  margin-left: 0.4em;
  margin-right: 0.4em;
  margin-bottom: 0.4em;
}

.vclFileInput .vclFileInputPlaceholder {
  display: inline-block;
  margin-top: 1em;
  margin-left: 1em;
  margin-right: 1em;
  margin-bottom: 1em;
}

.vclFileInput:focus,
.vclFileInput.vclFocused {
  background-color: #FFFFFF;
  border-color: #00ADEF;
}

.vclFileInput.vclDisabled,
.vclFileInput.vclDisabled:hover,
.vclFileInput.vclDisabled:active,
.vclFileInput.vclDisabled:focus {
  outline: none;
  cursor: default;
  color: hsl(0, 0%, 15%);
  background-color: hsl(0, 0%, 88%);
  border-color: hsl(0, 0%, 63%);
}

.vclFileInput.vclError {
  border-color: #d9534f;
}

.vclFileInput.vclWarning {
  border-color: #f0ad4e;
}

.vclFileInput.vclSuccess {
  border-color: #5cb85c;
}

.vclFileInput.vclDisabled,
.vclFileInput.vclDisabled:hover,
.vclFileInput.vclDisabled:active,
.vclFileInput.vclDisabled:focus {
  outline: none;
  cursor: default;
  color: hsl(0, 0%, 15%);
  background-color: hsl(0, 0%, 88%);
  border-color: hsl(0, 0%, 63%);
}

.vclFileInput.vclDragndrop {
  color: #000000;
  background-color: #96DCFA;
  border-color: #96DCFA;
}

/* flexbox based layout primitives */

.vclLayoutHorizontal,
.vclLayoutVertical,
[layout][horizontal],
[layout][vertical] {
  display: flex;
}

.vclLayoutHorizontal.vclLayoutInline,
.vclLayoutVertical.vclLayoutInline,
[layout][horizontal][inline],
[layout][vertical][inline] {
  display: inline-flex;
}

.vclLayoutHorizontal,
[layout][horizontal] {
  flex-direction: row;
}

.vclLayoutHorizontal.vclLayoutReverse,
[layout][horizontal][reverse] {
  flex-direction: row-reverse;
}

.vclLayoutVertical,
[layout][vertical] {
  flex-direction: column;
}

.vclLayoutVertical.vclLayoutReverse,
[layout][vertical][reverse] {
  flex-direction: column-reverse;
}

.vclLayoutWrap,
[layout][wrap] {
  flex-wrap: wrap;
}

.vclLayoutWrapReverse,
[layout][wrap-reverse] {
  flex-wrap: wrap-reverse;
}

.vclLayoutFlex,
[flex] {
  flex: 1;
  flex-basis: 0.000000001px;
}

.vclLayoutVertical > vclLayoutFlex.vclLayoutAutoVertical,
[vertical][layout] > [flex][auto-vertical] {
  flex-basis: auto;
}

.vclLayoutFlex.vclLayoutAuto,
[flex][auto] {
  flex-basis: auto;
}

.vclLayoutFlex.vclLayoutNone,
[flex][none] {
  flex: none;
}

.vclLayoutFlex.vclLayout1,
[flex][one] {
  flex: 1;
}

.vclLayoutFlex.vclLayout2,
[flex][two] {
  flex: 2;
}

.vclLayoutFlex.vclLayout3,
[flex][three] {
  flex: 3;
}

.vclLayoutFlex.vclLayout4,
[flex][four] {
  flex: 4;
}

.vclLayoutFlex.vclLayout5,
[flex][five] {
  flex: 5;
}

.vclLayoutFlex.vclLayout6,
[flex][six] {
  flex: 6;
}

.vclLayoutFlex.vclLayout7,
[flex][seven] {
  flex: 7;
}

.vclLayoutFlex.vclLayout8,
[flex][eight] {
  flex: 8;
}

.vclLayoutFlex.vclLayout9,
[flex][nine] {
  flex: 9;
}

.vclLayoutFlex.vclLayout10,
[flex][ten] {
  flex: 10;
}

.vclLayoutFlex.vclLayout11,
[flex][eleven] {
  flex: 11;
}

.vclLayoutFlex.vclLayout12,
[flex][twelve] {
  flex: 12;
}

/* alignment in cross axis */

.vclLayoutStart,
[layout][start] {
  align-items: flex-start;
}

.vclLayoutCenter,
.vclLayoutCenterCenter,
[layout][center],
[layout][center-center] {
  align-items: center;
}

.vclLayoutEnd,
[layout][end] {
  align-items: flex-end;
}

/* alignment in main axis */

.vclLayoutStartJustified,
[layout][start-justified] {
  justify-content: flex-start;
}

.vclLayoutCenterJustified,
.vclLayoutCenterCenter,
[layout][center-justified],
[layout][center-center] {
  justify-content: center;
}

.vclLayoutEndJustified,
[layout][end-justified] {
  justify-content: flex-end;
}

.vclLayoutAroundJustified,
[layout][around-justified] {
  justify-content: space-around;
}

.vclLayoutJustified,
[layout][justified] {
  justify-content: space-between;
}

/* self alignment */

.vclLayoutSelfStart,
[self-start] {
  align-self: flex-start;
}

.vclLayoutSelfCenter,
[self-center] {
  align-self: center;
}

.vclLayoutSelfEnd,
[self-end] {
  align-self: flex-end;
}

.vclLayoutSelfStretch,
[self-stretch] {
  align-self: stretch;
}

/* flexbox based layout grid */

.vclLayoutWrapContainer {
  overflow: hidden;
}

.vclLayoutGridRow {
  width: auto;
  box-sizing: border-box;
}

.vclLayoutGridRow .vclLayoutGridRow {
  margin-left: -0.5rem;
  margin-right: -0.5rem;
}

.vclLayoutGridRow > .vclLayoutGridCell:last-child {
  padding-right: 0;
}

.vclLayoutGridRow > .vclLayoutGridCell:first-child {
  padding-left: 0;
}

.vclLayoutGridRow > .vclLayoutGridCell {
  box-sizing: border-box;
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}

.vclLayoutGridRow.vclLayoutWrappingRow > .vclLayoutGridCell:last-child {
  padding-right: 0.5rem;
}

.vclLayoutGridRow.vclLayoutWrappingRow > .vclLayoutGridCell:first-child {
  padding-left: 0.5rem;
}

.vclLayoutGridRow.vclLayoutWrappingRow {
  margin-left: -0.5rem;
  width: calc(100% + 0.5rem + 0.5rem);
}

/* other layout helpers */

.vclLayoutBlock,
[block] {
  display: block;
}

/* other helpful properties */

.vclLayoutInvisible {
  visibility: hidden !important;
}

.vclLayoutHidden {
  display: none !important;
}

.vclLayoutRelative {
  position: relative;
}

.vclLayoutFit {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

/* fixed positioning */

.vclLayoutFixedBottom,
.vclLayoutFixedLeft,
.vclLayoutFixedRight,
.vclLayoutFixedTop {
  position: fixed;
}

.vclLayoutFixedTop {
  top: 0;
  left: 0;
  right: 0;
}

.vclLayoutFixedRight {
  top: 0;
  right: 0;
  bottom: 0;
}

.vclLayoutFixedBottom {
  right: 0;
  bottom: 0;
  left: 0;
}

.vclLayoutFixedLeft {
  top: 0;
  bottom: 0;
  left: 0;
}

.vclLayoutFullBleed {
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
}

.vclFlipSwitch {
  display: block;
  outline: none;
  background-color: transparent;
  position: relative;
  width: 5em;
  user-select: none;
}

.vclFlipSwitch.vclFlipSwitchPressed .vclFlipSwitchTrack {
  margin-left: 0;
}

.vclFlipSwitch.vclFlipSwitchPressed .vclFlipSwitchKnob {
  left: calc(100% - 1.8em);
}

.vclFlipSwitch .vclFlipSwitchKnob {
  width: 1.1em;
  margin: 0.3em;
  background-color: #005F84;
  border: 0;
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  transition: all 0.2s ease-in 0s;
}

.vclFlipSwitchLabel {
  display: block;
  overflow: hidden;
  cursor: pointer;
  border: 0;
}

.vclFlipSwitchTrack {
  width: 200%;
  margin-left: -100%;
  transition: margin 0.2s ease-in 0s;
}

.vclFlipSwitchTrack .vclFlipSwitchActive,
.vclFlipSwitchTrack .vclFlipSwitchInactive {
  float: left;
  width: 50%;
  padding: 0 0.5em;
  line-height: 2em;
  font-weight: bold;
  box-sizing: border-box;
  border-width: 1px;
  border-style: solid;
}

.vclFlipSwitchTrack .vclFlipSwitchActive {
  border-color: hsl(0, 0%, 50%);
  background-color: #0888BF;
  color: #FFFFFF;
  text-align: left;
}

.vclFlipSwitchTrack .vclFlipSwitchInactive {
  border-color: hsl(0, 0%, 50%);
  text-align: right;
}

.vclForm,
.vclForm.vclFormInline,
.vclForm.vclFormHorizontal {
  margin-bottom: 1.3em;
}

/* Inline and horizontal layouts */

.vclForm.vclFormInline > *:first-child,
.vclForm.vclFormInline > .vclFormInline:first-child {
  margin-left: 0;
}

.vclForm.vclFormInline > * {
  margin-left: 1em;
}

.vclForm.vclFormInline input,
.vclForm.vclFormInline .vclInput,
.vclForm.vclFormInline select {
  width: auto;
}

.vclForm.vclFormInline label,
.vclForm.vclFormInline input,
.vclForm.vclFormInline .vclInput,
.vclForm.vclFormHorizontal input,
.vclForm.vclFormHorizontal .vclInput,
.vclForm.vclFormInline textarea,
.vclForm.vclFormHorizontal textarea,
.vclForm.vclFormInline select,
.vclForm.vclFormHorizontal select,
.vclForm.vclFormInline .vclButtonGroup,
.vclForm.vclFormInline .vclInputControlGroup,
.vclForm.vclFormInline .vclFormInline,
.vclForm.vclFormHorizontal .vclInputInlineControlGroup {
  display: inline-block;
  margin-bottom: 0;
  vertical-align: middle;
}

/* Control groups combine input controls and labels so that they are aligned
   like an atomic control. */

.vclInputControlGroup {
  margin-bottom: 1.0em;
}

.vclInputControlGroup input,
.vclInputControlGroup .vclInput,
.vclInputControlGroup .vclInputGroup,
.vclInputControlGroup .vclFormControlHint {
  margin-bottom: 0;
}

.vclInputInlineControlGroup {
  vertical-align: middle;
  margin-bottom: 1.0em;
}

.vclInputInlineControlGroup > input:first-child,
.vclInputInlineControlGroup > .vclInput:first-child,
.vclInputInlineControlGroup > label:first-child,
.vclInputInlineControlGroup > .vclFormControlLabel:first-child {
  margin-left: 0;
}

.vclInputInlineControlGroup > input,
.vclInputInlineControlGroup > .vclInput,
.vclInputInlineControlGroup > label,
.vclInputInlineControlGroup > label > input,
.vclInputInlineControlGroup > label > .vclInput,
.vclInputInlineControlGroup > .vclFormControlLabel {
  display: inline-block;
  width: auto;
  margin-bottom: 0;
  margin-left: 0.5em;
  margin-right: 0.5em;
  padding-right: 0.4em;
}

.vclInputInlineControlGroup.vclFormControlLabel {
  margin-top: 0;
}

/* Integration with fieldset component */

legend + .vclInputControlGroup {
  margin-top: 2.0em;
  -webkit-margin-top-collapse: separate;
}

/* Normal label */

.vclFormControlLabel {
  cursor: pointer;
  display: block;
  vertical-align: middle;
  margin-top: 0.75em;
  margin-bottom: 0.75em;
}

.vclFormControlLabel .vclFormControlSubLabel {
  font-size: 0.9em;
  padding-left: 0.6em;
  color: hsl(0, 0%, 15%);
}

.vclFormControlLabel.vclDisabled {
  cursor: initial;
}

.vclFormControlLabel.vclFormControlLabelWrapping {
  line-height: 2.5em;
  margin-top: 0;
}

/* Adaption for labels in horizontally laid out form */

.vclForm.vclFormHorizontal .vclFormControlLabel {
  text-align: right;
}

/* Indicator that an input is required */

.vclRequiredIndicator {
  font-size: 1.2em;
  font-style: normal;
  font-weight: bold;
  line-height: 0.85em;
  position: relative;
  vertical-align: middle;
  padding-left: 0.2em;
  color: #005F84;
}

/* Additional hint associated with a form control */

.vclFormControlHint {
  display: block;
  font-size: 0.9em;
  color: hsl(0, 0%, 50%);
  margin-top: 0.3em;
  margin-bottom: 1.0em;
}

.vclGallery {
  margin-bottom: 1.3em;
  position: relative;
  width: 100%;
  background-color: transparent;
}

.vclGalleryHeader {
  margin-top: 0.6em;
  margin-bottom: 1em;
  width: 100%;
  background-color: transparent;
  color: inherit;
  text-align: center;
}

.vclGalleryContent {
  z-index: 1;
  position: relative;
}

.vclGalleryFooter {
  padding: 0.5em;
  background-color: transparent;
  color: inherit;
}

.vclGallery .vclGalleryContent .vclGalleryImage {
  position: relative;
  display: block;
  margin: 0 auto;
  max-width: 100%;
  object-fit: contain;
}

.vclGallery .vclGalleryContent .vclGalleryNextPane,
.vclGallery .vclGalleryContent .vclGalleryPrevPane {
  position: absolute;
  top: 0;
  bottom: 0;
  width: 50%;
  z-index: 2;
  cursor: pointer;
}

.vclGallery .vclGalleryContent .vclGalleryNextPane {
  right: 0;
}

.vclGallery .vclGalleryContent .vclGalleryPrevPane {
  left: 0;
}

.vclGallery .vclGalleryContent .vclGalleryNextButton .vclIcon,
.vclGallery .vclGalleryContent .vclGalleryPrevButton .vclIcon {
  font-size: 3em;
}

.vclGallery .vclGalleryContent .vclGalleryNextButton:hover,
.vclGallery .vclGalleryContent .vclGalleryPrevButton:hover {
  opacity: 1;
  display: block;
}

.vclGallery .vclGalleryContent .vclGalleryNextButton,
.vclGallery .vclGalleryContent .vclGalleryPrevButton {
  z-index: 3;
  top: calc(50% - 3em);
  position: absolute;
  height: 6em;
  padding: 0;
  width: 7%;
  max-width: 4em;
  margin: 0;
  opacity: .4;
  transition: 0.2s opacity ease;
}

.vclGallery .vclGalleryContent .vclGalleryNextButton {
  right: 0;
}

.vclGallery .vclGalleryContent .vclGalleryPrevButton {
  left: 0;
}

.vclGallery .vclGalleryThumbs .vclGalleryThumbWrapper:after {
  content: "";
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  border-width: 4px;
  border-style: solid;
  border-color: transparent;
  cursor: pointer;
}

.vclGallery .vclGalleryThumbs .vclGalleryThumbWrapper:hover:after {
  background-color: hsla(197, 100%, 47%, 0.4);
}

.vclGallery .vclGalleryThumbs .vclGalleryThumbWrapper.vclSelected:after {
  border-color: #0888BF;
}

.vclGallery .vclGalleryThumbs .vclGalleryThumbWrapper {
  z-index: 1;
  position: relative;
}

.vclGallery .vclGalleryThumbs .vclGalleryThumb {
  box-sizing: border-box;
  object-fit: contain;
  display: block;
}

.vclGallery .vclGalleryThumbs {
  overflow-x: auto;
  text-align: center;
}

.vclGoToTop {
  position: fixed;
  bottom: 1em;
  color: hsl(0, 0%, 88%);
  background-color: hsl(0, 0%, 45%);
  border-radius: 0.25em;
  opacity: 1;
  transition: opacity .2s ease;
}

.vclGoToTop:hover {
  opacity: 0.8;
}

.vclGutterMargin,
.vclGutterMarginTB {
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
}

.vclGutterMargin,
.vclGutterMarginLR {
  margin-left: 0.5rem;
  margin-right: 0.5rem;
}

.vclGridRow {
  width: 100%;
  margin: 0 auto;
  clear: both;
  *zoom: 1;
}

.vclGridRow:before,
.vclGridRow:after {
  content: " ";
  display: table;
}

.vclGridRow:after {
  clear: both;
}

.vclGridRow .vclGridRow {
  margin: 0 -0.5rem;
  width: auto;
}

[class ^="vclGridSpan-"],
[class *=" vclGridSpan-"] {
  box-sizing: border-box;
  padding: 0 0.5rem;
  float: left;
  display: block;
}

/* Grid spans classes for grid unit based divisions */

.vclGridSpan-1 {
  width: 6.66666%;
}

.vclGridSpan-2 {
  width: 13.33333%;
}

.vclGridSpan-3 {
  width: 19.99999%;
}

.vclGridSpan-4 {
  width: 26.66666%;
}

.vclGridSpan-5 {
  width: 33.33333%;
}

.vclGridSpan-6 {
  width: 39.99999%;
}

.vclGridSpan-7 {
  width: 46.66666%;
}

.vclGridSpan-8 {
  width: 53.33333%;
}

.vclGridSpan-9 {
  width: 59.99999%;
}

.vclGridSpan-10 {
  width: 66.66666%;
}

.vclGridSpan-11 {
  width: 73.33333%;
}

.vclGridSpan-12 {
  width: 79.99999%;
}

.vclGridSpan-13 {
  width: 86.66666%;
}

.vclGridSpan-14 {
  width: 93.33333%;
}

.vclGridSpan-15 {
  width: 100%;
}

/* Modifier to center a grid column */

.vclGridSpanCentered {
  margin-left: auto;
  margin-right: auto;
  float: none;
}

/* The golden cut as grid units */

.vclGridSpan-gcb {
  width: 38.2%;
}

.vclGridSpan-gca {
  width: 61.8%;
}

/* Grid spans classes for percentage based divisions */

.vclGridSpan-5p {
  width: 5%;
}

.vclGridSpan-10p {
  width: 10%;
}

.vclGridSpan-15p {
  width: 15%;
}

.vclGridSpan-20p {
  width: 20%;
}

.vclGridSpan-25p {
  width: 25%;
}

.vclGridSpan-33p {
  width: 33.3333%;
}

.vclGridSpan-45p {
  width: 45%;
}

.vclGridSpan-50p {
  width: 50%;
}

.vclGridSpan-70p {
  width: 70%;
}

.vclGridSpan-75p {
  width: 75%;
}

.vclGridSpan-80p {
  width: 80%;
}

.vclGridSpan-85p {
  width: 85%;
}

.vclGridSpan-100p {
  width: 100%;
}

.vclIcogram {
  white-space: nowrap;
  position: relative;
  align-items: baseline;
}

.vclIcogram> * {
  display: inline-block;
  vertical-align: middle;
  margin: 0 0.25em 0 0;
}

.vclIcogram> *:first-child {
  margin-left: 0;
}

.vclIcogram> *:last-child {
  margin-right: 0;
}

.vclIcogram> *:only-child {
  margin: 0;
}

.vclIcogram .vclText {
  vertical-align: middle;
}

.vclIcogram a.vclText {
  color: inherit;
}

.vclIcon {
  display: inline-block;
  vertical-align: middle;
  background-repeat: no-repeat;
  fill: currentcolor;
  position: relative;
  line-height: inherit;
}

.vclIcon.vclIconSize1 {
  width: 1.6em;
  height: 1.6em;
}

.vclIcon.vclIconSize2 {
  width: 2.37em;
  height: 2.37em;
}

.vclIcon.vclIconSize3 {
  width: 3.17em;
  height: 3.17em;
}

.vclImgShapeThumbnail {
  display: inline-block;
  max-width: 100%;
  height: auto;
  padding: 0.33em;
  border: 1px solid #000000;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.vclImgShapeRounded {
  border-radius: 0.85em;
}

.vclImgShapeCircular {
  border-radius: 50%;
}

.vclOverlayContainer {
  cursor: default;
  overflow: hidden;
  position: relative;
}

.vclOverlayContainer > .vclOverlayContent,
.vclOverlayContainer > .vclOverlay {
  position: absolute;
  overflow: hidden;
}

.vclOverlay {
  z-index: 10;
  height: 100%;
  width: 100%;
  opacity: 0;
  transition: all 0.2s ease-in-out 0s;
  background-color: rgba(0, 0, 0, 0.7);
  color: #ffffff;
  text-align: center;
  right: 0;
  left: 0;
  top: 0;
  bottom: 0;
}

.vclOverlay:hover {
  opacity: 1;
}

input,
select,
textarea,
.vclInput {
  min-height: 2.5em;
  line-height: initial;
  box-sizing: border-box;
}

input,
select,
textarea,
button,
.vclInput {
  font-family: inherit;
  vertical-align: middle;
}

textarea,
textarea.vclInput {
  line-height: 1.52em;
}

/* remove clear-button in ie10+ */

::-ms-clear {
  display: none;
}

/* remove spinner buttons from browsers */

.vclInput[type=number]::-webkit-outer-spin-button,
.vclInput[type=number]::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

.vclInput[type=number] {
  -moz-appearance: textfield;
}

select,
textarea,
input,
.vclInput {
  width: 100%;
  display: inline-block;
  padding-top: 0;
  padding-right: 0.4em;
  padding-bottom: 0;
  padding-left: 0.4em;
  vertical-align: middle;
  margin-bottom: 1.0em;
}

input[type="radio"],
input[type="checkbox"] {
  width: auto;
}

.vclInput {
  overflow: hidden;
  word-wrap: normal;
  -moz-user-modify: read-write;
  -webkit-user-modify: read-write;
  display: flex;
  align-items: center;
  content: none;
}

select {
  width: auto;
}

select:focus,
textarea:focus,
input:focus,
.vclInput:focus {
  outline: none;
}

/* Show an outline for elements which cannot be highlighted by border colors */

input[type="file"]:focus,
input[type="radio"]:focus,
input[type="checkbox"]:focus {
  outline: thin dotted #000000;
  outline: 0.35em auto -webkit-focus-ring-color;
}

/* Indicate a klick will do something useful for a label */

label {
  cursor: pointer;
}

select[multiple],
select[size] {
  height: auto;
}

input {
  border-radius: 0;
}

select,
input[type="file"] {
  padding: 0;
}

textarea {
  overflow: auto;
  vertical-align: top;
  height: auto;
}

input[disabled],
select[disabled],
textarea[disabled],
input[readonly],
select[readonly],
textarea[readonly] {
  cursor: not-allowed;
}

select,
textarea,
input,
.vclInput {
  color: #000000;
  background-color: #FFFFFF;
  border-width: 1px;
  border-color: hsl(0, 0%, 63%);
  border-radius: 0;
  border-style: solid;
}

/* For whatever reason, they need to be separate */

input:-ms-input-placeholder {
  color: hsl(0, 0%, 63%);
  font-style: normal;
}

textarea:-ms-input-placeholder {
  color: hsl(0, 0%, 63%);
  font-style: normal;
}

.vclInput:-ms-placeholder {
  color: hsl(0, 0%, 63%);
  font-style: normal;
}

input::-moz-placeholder {
  color: hsl(0, 0%, 63%);
  font-style: normal;
}

textarea::-moz-placeholder {
  color: hsl(0, 0%, 63%);
  font-style: normal;
}

.vclInput::-moz-placeholder {
  color: hsl(0, 0%, 63%);
  font-style: normal;
}

*::-webkit-input-placeholder {
  color: hsl(0, 0%, 63%);
  font-style: normal;
}

.vclInput::-webkit-input-placeholder {
  color: hsl(0, 0%, 63%);
  font-style: normal;
}

.vclInput[contenteditable=true]:empty:before {
  content: attr(placeholder);
  display: block;
  color: hsl(0, 0%, 63%);
  font-style: normal;
}

select:focus,
textarea:focus,
input:focus,
.vclInput:focus,
.vclInput.vclFocused {
  background-color: #FFFFFF;
  border: 1px solid #00ADEF;
}

input[disabled],
.vclInput[disabled],
select[disabled],
textarea[disabled],
input[readonly],
.vclInput[readonly],
select[readonly],
textarea[readonly],
.vclInput.vclDisabled {
  color: hsl(0, 0%, 15%);
  background-color: hsl(0, 0%, 88%);
  border-color: hsl(0, 0%, 63%);
}

input[type="radio"][disabled],
input[type="checkbox"][disabled],
input[type="radio"][readonly],
input[type="checkbox"][readonly] {
  background-color: transparent;
}

/* Semantic coloring */

textarea.vclError,
input.vclError,
.vclInput.vclError,
input:focus:invalid,
textarea:focus:invalid,
select:focus:invalid,
input:focus:invalid:focus,
textarea:focus:invalid:focus,
select:focus:invalid:focus {
  border-color: #d9534f;
}

textarea.vclWarning,
.vclInput.vclWarning,
input.vclWarning {
  border-color: #f0ad4e;
}

textarea.vclSuccess,
.vclInput.vclSuccess,
input.vclSuccess {
  border-color: #5cb85c;
}

textarea.vclSelected,
textarea.vclSelected:hover,
textarea.vclSelected:active,
textarea.vclSelected:focus,
.vclInput.vclSelected,
.vclInput.vclSelected:hover,
.vclInput.vclSelected:active,
.vclInput.vclSelected:focus,
input.vclSelected,
input.vclSelected:hover,
input.vclSelected:active,
input.vclSelected:focus {
  border-color: #00ADEF;
  background-color: #FFFFFF;
}

.vclInputGroup {
  width: 100%;
  display: inline-table;
  border: 0;
  vertical-align: top;
  border-collapse: separate;
  margin-bottom: 1.0em;
}

.vclInputGroup .vclInput,
.vclInputGroup .vclInputGroupEmb,
.vclInputGroup select {
  margin-bottom: 0;
  border-width: 1px;
}

.vclInputGroup > span {
  font-size: 1em;
  box-sizing: border-box;
  text-align: center;
  width: 1%;
  min-width: 2em;
  white-space: nowrap;
  vertical-align: middle;
  border-width: 0;
  height: 2.5em;
  background-color: hsl(0, 0%, 50%);
  color: hsl(0, 0%, 88%);
  border-color: transparent;
}

.vclInputGroup > .vclInputGroupButton button {
  border-width: 0;
}

.vclInputGroup > .vclInputGroupButton:first-child button {
  border-width: 0;
}

.vclInputGroup > .vclInputGroupButton {
  border-width: 0;
  min-width: 0;
}

.vclInputGroup button,
.vclInputGroup .vclButton {
  height: 2.5em;
  box-sizing: border-box;
}

.vclInputGroup .vclDropdown {
  height: 2.5em;
}

.vclInputGroup > .vclInputGroupButton button,
.vclInputGroup > .vclInputGroupButton button:hover,
.vclInputGroup > .vclInputGroupButton button:disabled,
.vclInputGroup > .vclInputGroupButton button:disabled:hover {
  border-width: 0;
  background-clip: padding-box;
}

.vclInputGroup .vclInput,
.vclInputGroup select,
.vclInputGroup > span {
  display: table-cell;
  vertical-align: middle;
  border-style: solid;
  vertical-align: middle;
  font-size: 1em;
  box-sizing: border-box;
}

.vclInputGroup select {
  width: 100%;
}

.vclInputGroup > span:first-of-type {
  border-width: 0;
}

.vclInputGroup > span,
.vclInputGroup > .vclInputGroupButton button,
.vclInputGroup > .vclInputGroupButton .vclButton {
  border-color: hsl(0, 0%, 63%);
}

.vclLabel {
  display: inline-block;
  padding-top: 0.2em;
  padding-right: 0.5em;
  padding-bottom: 0.2em;
  padding-left: 0.5em;
  font-weight: bold;
  font-size: 80%;
  line-height: 1;
  white-space: nowrap;
  vertical-align: baseline;
  border-radius: 0.25em;
  color: #FFFFFF;
  background-color: hsl(0, 0%, 15%);
}

.vclLabel:empty {
  display: none;
}

.vclLabel.vclPrimary {
  color: #FFFFFF;
  background-color: hsl(0, 0%, 30%);
}

.vclLabel.vclSuccess {
  color: #FFFFFF;
  background-color: #5cb85c;
}

.vclLabel.vclInfo {
  color: #FFFFFF;
  background-color: #5bc0de;
}

.vclLabel.vclWarning {
  color: #FFFFFF;
  background-color: #f0ad4e;
}

.vclLabel.vclDanger,
.vclLabel.vclError,
.vclLabel.vclImportant {
  color: #FFFFFF;
  background-color: #d9534f;
}

.vclLayerCover {
  position: fixed;
  z-index: 300;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.3);
}

.vclLayer {
  position: fixed;
  display: flex;
  z-index: 401;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  outline: none;
  align-items: center;
  justify-content: center;
}

.vclLayer.vclTransparent .vclLayerBox {
  background-color: transparent;
}

.vclLayer.vclLayerStickToBottom .vclLayerBox {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  margin-bottom: 0;
}

.vclLayer.vclLayerFill .vclLayerBox {
  width: 100%;
  height: 100%;
  min-width: 0;
  max-width: none;
}

.vclLayerBox {
  max-height: 100%;
  overflow-y: auto;
  box-sizing: border-box;
  display: inline-block;
  min-width: 25em;
  max-width: 50em;
  color: hsl(0, 0%, 20%);
  background-color: #FFFFFF;
}

.vclLayerBox.vclLayerGutterPadding {
  padding: 0.5rem;
}

@media (max-width: 390px) {
  .vclLayer .vclLayerBox {
    width: 100%;
    height: 100%;
    min-width: 0;
    max-width: none;
  }
}

[class ^="vclSpan-"],
[class *=" vclSpan-"] {
  box-sizing: border-box;
}

.vclSpan-5p {
  width: 5%;
}

.vclSpan-10p {
  width: 10%;
}

.vclSpan-15p {
  width: 15%;
}

.vclSpan-20p {
  width: 20%;
}

.vclSpan-25p {
  width: 25%;
}

.vclSpan-30p {
  width: 30%;
}

.vclSpan-33p {
  width: 33.333%;
}

.vclSpan-35p {
  width: 35%;
}

.vclSpan-40p {
  width: 40%;
}

.vclSpan-45p {
  width: 45%;
}

.vclSpan-50p {
  width: 50%;
}

.vclSpan-55p {
  width: 55%;
}

.vclSpan-60p {
  width: 60%;
}

.vclSpan-65p {
  width: 65%;
}

.vclSpan-70p {
  width: 70%;
}

.vclSpan-75p {
  width: 75%;
}

.vclSpan-80p {
  width: 80%;
}

.vclSpan-85p {
  width: 85%;
}

.vclSpan-90p {
  width: 90%;
}

.vclSpan-95p {
  width: 95%;
}

.vclSpan-100p {
  width: 100%;
}

.vclSpanV-100p {
  height: 100%;
}

/* golden cut */

.vclSpan-gcb {
  width: 38.2%;
}

.vclSpan-gca {
  width: 61.8%;
}

dl,
menu,
ol,
ul,
.vclList {
  margin-top: 0;
  margin-bottom: 1.3em;
}

dt {
  font-weight: bold;
}

dd {
  margin: 0 0 0 2.2em;
}

menu,
ol,
ul {
  padding: 0 0 0 2em;
}

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0;
}

.vclList {
  padding: 0 0 0 2em;
  list-style-position: outside;
}

.vclList.vclListHorizontal > .vclListItem {
  display: inline-block;
}

.vclList.vclListHorizontal > .vclListSeparator {
  display: inline-block;
  margin-top: 0;
  margin-left: 1em;
  margin-right: 1em;
  margin-bottom: 0;
  vertical-align: middle;
  border: 0;
}

.vclList.vclListHorizontal {
  padding-left: 0 !important;
}

.vclList.vclListCustomBullets {
  list-style-type: none;
  padding: 0 0 0 1em;
}

.vclList > .vclListItem > .vclIcon {
  min-width: 1.5em;
  text-align: center;
  padding-right: 0em;
  padding-left: 0em;
}

.vclList > .vclListItem {
  display: list-item;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
}

.vclListSeparator {
  margin: 0.6em 0;
  overflow: hidden;
  list-style: none;
  list-style-type: none;
  padding: 0;
  border-bottom: 1px solid hsl(0, 0%, 63%);
}

.vclListGroupHeader {
  font-weight: bold;
  list-style-type: none;
  margin-left: -1.1em;
  margin-top: 0.3em;
}

.vclLoadingLayerContainer {
  position: relative;
}

.vclLoadingLayer {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: block;
  z-index: 250;
  background-color: rgba(0, 0, 0, 0.3);
  outline: none;
  display: flex;
  align-items: center;
  justify-content: flex-start;
}

.vclLoadingLayer .vclLoadingLayerContent {
  width: 100%;
  text-align: center;
}

.vclLogo {
  display: block;
}

.vclLooseButtonGroup {
  clear: both;
  *zoom: 1;
}

.vclLooseButtonGroup:before,
.vclLooseButtonGroup:after {
  content: " ";
  display: table;
}

.vclLooseButtonGroup:after {
  clear: both;
}

.vclLooseButtonGroup button:first-of-type,
.vclLooseButtonGroup .vclButton:first-of-type {
  margin-left: 0;
}

.vclLooseButtonGroup button:last-of-type,
.vclLooseButtonGroup .vclButton:last-of-type {
  margin-right: 0;
}

.vclLooseButtonGroup button,
.vclLooseButtonGroup .vclButton {
  margin-left: 0.5em;
  margin-right: 0.5em;
  float: left;
}

.vclNag {
  z-index: 400;
  margin: 0;
  border: 0;
  border-radius: 0;
  color: hsl(0, 0%, 20%);
  background-color: #FFFFFF;
}

/* Commons */

.vclNavigation {
  margin-bottom: 1.3em;
  background-color: transparent;
  position: relative;
  *zoom: 1;
}

.vclNavigation:before,
.vclNavigation:after {
  content: " ";
  display: table;
}

.vclNavigation:after {
  clear: both;
}

.vclNavigation .vclClose .vclNavigation {
  display: none;
}

.vclNavigation .vclNavigationItemLabel {
  color: inherit;
  outline: 0;
  text-decoration: none;
}

.vclNavigation .vclNavigationHeading > span,
.vclNavigation .vclNavigationHeading:hover > span {
  display: inline-block;
  font-weight: bold;
  font-size: 0.86em;
}

.vclNavigation .vclNavigationHeading,
.vclNavigation .vclNavigationHeading:hover {
  color: hsl(0, 0%, 15%);
  background-color: transparent;
  padding: 0.85em 1em;
}

.vclNavigation ul {
  padding: 0;
  margin: 0;
  list-style: none;
  list-style-type: none;
}

.vclNavigation .vclNavigationItem.vclDisabled .vclNavigationItemLabel,
.vclNavigation .vclNavigationItem:hover.vclDisabled .vclNavigationItemLabel,
.vclNavigation .vclNavigationItem:active.vclDisabled .vclNavigationItemLabel {
  color: hsl(0, 0%, 75%);
  background-color: transparent;
  cursor: default;
}

.vclNavigation .vclNavigationItem .vclNavigationItemLabel .vclText,
.vclNavigation .vclNavigationItem:hover .vclNavigationItemLabel .vclText,
.vclNavigation .vclNavigationItem:active .vclNavigationItemLabel .vclText {
  letter-spacing: 1px;
}

.vclNavigation .vclNavigationItem .vclNavigationItemLabel,
.vclNavigation .vclNavigationItem:hover .vclNavigationItemLabel,
.vclNavigation .vclNavigationItem:active .vclNavigationItemLabel {
  display: inline-block;
  cursor: pointer;
  font-size: 0.98em;
  font-weight: normal;
  padding: 0.85em 1em;
}

.vclNavigation .vclNavigationItem,
.vclNavigation .vclNavigationItem:hover,
.vclNavigation .vclNavigationItem:active {
  outline: 0;
  float: left;
}

.vclNavigation.vclVertical .vclNavigationItem .vclNavigationItemLabel {
  display: block;
  padding-left: 1.25em;
  padding-right: 1.25em;
}

.vclNavigation.vclVertical .vclNavigation .vclNavigationItem .vclNavigationItemLabel {
  font-size: 0.98em;
  padding-left: 1.5em;
}

.vclNavigation.vclVertical .vclNavigation .vclNavigationItem .vclNavigation .vclNavigationItem .vclNavigationItemLabel {
  padding-left: 2.5em;
}

.vclNavigation.vclVertical .vclNavigation .vclNavigationItem .vclNavigation .vclNavigation .vclNavigationItem .vclNavigationItemLabel {
  padding-left: 3.5em;
}

.vclNavigation.vclVertical .vclNavigation {
  margin-bottom: 0;
}

.vclNavigation.vclVertical .vclNavigationHeading {
  padding-top: 1.3em;
  padding-right: 0.5em;
  padding-bottom: 0.4em;
  padding-left: 0.5em;
}

.vclNavigation.vclVertical .vclNavigationItem .vclNavigationItemLabel {
  margin-right: 0;
}

.vclNavigation.vclVertical .vclNavigationItem {
  float: none;
}

/* 1st level coloring */

.vclNavigation .vclNavigationItem .vclNavigationItemLabel:hover,
.vclNavigation .vclNavigationItem .vclNavigationItemLabel:focus {
  color: #000000;
  background-color: hsl(0, 0%, 92%);
}

.vclNavigation .vclNavigationItem.vclSelected > .vclNavigationItemLabel {
  color: #FFFFFF;
  background-color: #00ADEF;
}

.vclNavigation .vclNavigationItem {
  color: hsl(0, 0%, 15%);
  background-color: transparent;
}

.vclNotification {
  overflow: hidden ;
  border-width: 0;
  border-radius: 0.45em;
  border-style: solid;
  border-color: inherit;
  color: inherit;
  background-color: hsl(0, 0%, 95%);
  margin-bottom: 1.3em;
}

.vclNotification .vclNotificationIconContainer {
  padding: 1em;
  padding-right: 0.3em;
}

.vclNotification .vclNotificationIcon {
  font-size: 2em;
}

.vclNotification .vclNotificationHeader .vclButton {
  color: inherit;
}

.vclNotification .vclNotificationHeader {
  min-height: 2.5em;
  padding: 0 0.8em;
  background-color: hsl(0, 0%, 88%);
  color: inherit;
}

.vclNotification .vclNotificationContent {
  margin: 0;
  padding: 0.8em;
  position: relative;
  word-wrap: break-word;
}

.vclNotification .vclNotificationFooter {
  min-height: 2.5em;
  margin-bottom: 0;
  padding: 0 0.8em;
}

.vclNotification.vclSuccess .vclNotificationHeader {
  background-color: #3c763d;
  color: #FFFFFF;
}

.vclNotification.vclSuccess .vclNotificationIcon {
  color: #3c763d;
}

.vclNotification.vclSuccess {
  color: #3c763d;
  background-color: #dff0d8;
  border-color: #3c763d;
}

.vclNotification.vclInfo .vclNotificationHeader {
  background-color: #31708f;
  color: #FFFFFF;
}

.vclNotification.vclInfo .vclNotificationIcon {
  color: #31708f;
}

.vclNotification.vclInfo {
  color: #31708f;
  background-color: #d9edf7;
  border-color: #31708f;
}

.vclNotification.vclWarning .vclNotificationHeader {
  background-color: #8a6d3b;
  color: #FFFFFF;
}

.vclNotification.vclWarning .vclNotificationIcon {
  color: #8a6d3b;
}

.vclNotification.vclWarning {
  color: #8a6d3b;
  background-color: #fcf8e3;
  border-color: #8a6d3b;
}

.vclNotification.vclError .vclNotificationHeader {
  background-color: #a94442;
  color: #FFFFFF;
}

.vclNotification.vclError .vclNotificationIcon {
  color: #a94442;
}

.vclNotification.vclError {
  color: #a94442;
  background-color: #f2dede;
  border-color: #a94442;
}

.vclPager {
  padding: 0;
}

.vclPager.vclToolbar {
  background-color: transparent;
}

.vclPagination {
  display: inline-block;
  margin-top: 0;
  margin-bottom: 1.3em;
  padding: 0;
  vertical-align: middle;
  *zoom: 1;
}

.vclPagination:before,
.vclPagination:after {
  content: " ";
  display: table;
}

.vclPagination:after {
  clear: both;
}

.vclPagination li.vclSeparator > span {
  line-height: initial;
  padding: 0 0.3em;
}

.vclPagination li {
  float: left;
  list-style: none outside none;
  border-width: 0;
  vertical-align: top;
}

.vclPagination > li > span {
  display: inline-block;
  line-height: 2.5em;
}

.vclPagination > li > span,
.vclPagination > li > .vclButton {
  vertical-align: top;
}

.vclPagination > li.vclSeparator {
  cursor: default;
}

.vclPagination > li.vclSelected {
  cursor: default;
  color: #FFFFFF;
  background-color: #00ADEF;
  border: 0;
}

.vclPanel {
  background-color: transparent;
  margin-bottom: 1.3em;
  overflow: overlay;
}

.vclPanel.vclPanelCard {
  border-width: 1px;
  border-style: solid;
  border-color: hsl(0, 0%, 50%);
  border-radius: 0.55em;
}

.vclPanelHeader,
.vclPanelFooter {
  position: relative;
  color: hsl(0, 0%, 20%);
  background-color: transparent;
  border-style: solid;
  border-width: 0 0 2px 0;
  border-color: hsl(0, 0%, 50%);
}

.vclPanelFooter {
  border-width: 0;
  color: hsl(0, 0%, 20%);
  background-color: transparent;
}

.vclPanelTitle,
.vclPanelHeading {
  padding: 0 0.8rem;
  font-weight: bold;
  line-height: 2em;
  margin-top: 0;
  margin-bottom: 0;
  font-size: 0.96em;
  color: inherit;
}

.vclPanelTitle {
  font-size: 1.08em;
}

.vclPanelBody {
  border-style: solid;
  border-width: 1px;
  border-color: hsl(0, 0%, 50%);
}

.vclPanelBody > *:first-child {
  margin-top: 0;
}

.vclPanelBody > *:last-child {
  margin-bottom: 0;
}

.vclPanelContent {
  padding: 0.8rem 0.8rem;
  margin-bottom: 0;
}

.vclPopOver {
  position: absolute;
  box-sizing: border-box;
  border-radius: 0.25em;
  padding: 0.5rem;
  text-decoration: none;
  border-width: 1px;
  border-style: solid;
  border-color: rgba(0, 0, 0, 0.15);
  background-color: #FFFFFF;
  box-shadow: 0px 3px 8px rgba(0, 0, 0, 0.15);
  color: hsl(0, 0%, 20%);
  z-index: 5;
}

@media print {
  * {
    background: transparent !important;
    color: #000000 !important ;
    box-shadow: none !important;
    text-shadow: none !important;
  }

  a,
  a:visited {
    text-decoration: underline;
  }

  a[href]:after {
    content: " (" attr(href) ")";
  }

  abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: "";
  }

  pre,
  blockquote {
    border: 1px solid #999999;
    page-break-inside: avoid;
  }

  thead {
    display: table-header-group ;
  }

  tr,
  img {
    page-break-inside: avoid;
  }

  img {
    max-width: 100% !important;
  }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3;
  }

  h2,
  h3 {
    page-break-after: avoid;
  }

  .vclVisible-print {
    display: inherit !important;
  }

  .vclHidden-print {
    display: none !important;
  }
}

.vclProcessNav {
  font-size: 1em;
  user-select: none;
  overflow: hidden;
  margin-bottom: 1.3em;
}

.vclProcessNav .vclProcessNavStepNo {
  margin: 0 0.9em;
  border: 1px solid;
  border-color: inherit;
  border-radius: 50%;
  height: 1.7em;
  line-height: 1.85;
  min-width: 1.7em;
  overflow: hidden;
  text-align: center;
  display: inline-block;
  font-size: 0.8em;
}

.vclProcessNav ol li > a,
.vclProcessNav ol li > span {
  overflow: hidden;
  text-overflow: ellipsis;
}

.vclProcessNav ol li a {
  color: #00ADEF;
  outline: none;
  text-decoration: none;
  display: inline-block;
  text-align: center;
  position: relative;
  z-index: 2;
}

.vclProcessNav ol li:hover a,
.vclProcessNav ol li:focus a {
  color: #005F84;
}

.vclProcessNav ol li.vclSelected {
  cursor: default;
  color: #FFFFFF;
  background-color: #0888BF;
  border: 0;
}

.vclProcessNav ol li.vclDisabled {
  cursor: default;
  color: hsl(0, 0%, 50%);
}

.vclProcessNav ol li.vclProcessNavCompletedStep {
  background-color: hsl(0, 0%, 92%);
}

.vclProcessNav ol li {
  float: left ;
  outline: none;
  box-sizing: border-box;
  padding-top: 0;
  padding-bottom: 0;
  position: relative;
  background-color: hsl(0, 0%, 92%);
  white-space: nowrap;
  border: 0;
  min-height: 2.5em;
  min-width: 2.5em;
  cursor: pointer;
  text-align: center;
  flex-grow: 1;
}

.vclProcessNav ol {
  list-style: none;
  list-style-type: none;
  padding: 0;
  margin: 0;
}

.vclProcessNav.vclProcessNavArrows ol li:first-child {
  padding-left: 1em;
}

.vclProcessNav.vclProcessNavArrows ol li:after  {
  content: '';
  position: absolute;
  top: 0;
  right: -1.65em;
  width: 2.5em;
  height: 2.5em;
  -webkit-transform: scale(0.7, 1.5) rotate(45deg);
  -moz-transform: scale(0.7, 1.5) rotate(45deg);
  -ms-transform: scale(0.7, 1.5) rotate(45deg);
  transform: scale(0.7, 1.5) rotate(45deg);
  /* Prevent the arrows from getting buried under the next link */
  z-index: 1;
  background-color: hsl(0, 0%, 92%);
  box-sizing: content-box;
  border-left-width: 0;
  border-bottom-width: 0;
  border-right-width: 2px;
  border-top-width: 2px;
  border-style: solid;
  border-color: #FFFFFF;
}

.vclProcessNav.vclProcessNavArrows ol li:last-child:after {
  content: none;
}

.vclProcessNav.vclProcessNavArrows ol li.vclSelected:after {
  background-color: #0888BF;
}

.vclProcessNav.vclProcessNavArrows ol li.vclProcessNavCompletedStep:after {
  background-color: hsl(0, 0%, 92%);
}

.vclProcessNav.vclProcessNavArrows ol li {
  padding-left: 2.5em;
  padding-right: 0;
}

.vclProgressBar {
  background-color: hsl(0, 0%, 95%);
  color: hsl(0, 0%, 88%);
  height: 0.405em;
  position: relative;
  overflow: hidden;
}

.vclProgressBar .vclProgress.vclPrimary {
  background-color: #96DCFA;
  z-index: 2;
}

.vclProgressBar .vclProgress.vclSecondary {
  background-color: #c7d9f1;
  z-index: 1;
}

.vclProgressBar .vclProgress {
  transform-origin: left center;
  transform: scaleX(0);
  transition: transform 0.4s cubic-bezier(0, .5, .5, 1);
}

.vclProgressBar.vclTransparent {
  background-color: transparent;
}

.vclProgressBar.vclIndeterminate .vclProgress {
  transform-origin: center center;
  animation: vclIndeterminateAnimation 1s linear infinite;
}

@keyframes vclIndeterminateAnimation {
  0% {
    transform: translate(-50%) scaleX(0);
  }

  50% {
    transform: translate(0%) scaleX(0.3);
  }

  100% {
    transform: translate(50%) scaleX(0);
  }
}

.vclRadioButton {
  cursor: pointer;
  outline: none;
  display: inline-block;
}

.vclRadioButton > .vclFormControlLabel {
  display: inline-block;
}

.vclRadioButton > .vclIcon {
  color: hsl(0, 0%, 63%);
  display: inline-block;
  min-width: 1.5em;
  text-align: center;
  padding-right: 0.4em;
  padding-left: 0.4em;
  font-size: 1.16em;
}

.vclRadioButton:hover > .vclIcon {
  color: #00ADEF;
}

.vclRadioButton:focus > .vclIcon {
  color: #00ADEF;
}

.vclRadioButton.vclDisabled > .vclIcon {
  color: hsl(0, 0%, 88%);
}

.vclFormControlLabel:hover .vclRadioButton:not(.vclDisabled) .vclIcon {
  color: #00ADEF;
}

.vclRating {
  height: 2.5em;
  line-height: initial;
  box-sizing: border-box;
  font-family: inherit;
  vertical-align: middle;
  display: inline-flex;
  align-items: baseline;
  vertical-align: middle;
  margin-bottom: 1.0em;
}

.vclRating.vclDisabled .vclRatingItem:hover {
  color: hsl(0, 0%, 50%);
  cursor: initial;
}

.vclRating .vclRatingItem {
  color: inherit;
  padding: 0.4em 0.3em;
  font-size: 1.4em;
}

.vclRating .vclRatingItem:hover {
  cursor: pointer;
}

.vclRating .vclRatingItem:focus {
  color: #00ADEF;
  outline: none;
}

.vclRating .vclRatingItem.vclRatingItemHighlighted {
  color: #00ADEF;
}

.vclResponsiveImageContainer {
  color: hsl(0, 0%, 63%);
  width: 100%;
}

.vclResponsiveImage {
  max-width: 100%;
  height: auto;
  display: block;
}

*::-webkit-scrollbar {
  width: 6px;
  color: inherit;
  background-color: transparent;
}

*::-webkit-scrollbar-track {
  border-radius: 0;
  background-color: transparent;
}

*::-webkit-scrollbar-thumb {
  background-color: hsl(0, 0%, 63%);
}

.vclSelect {
  cursor: pointer;
}

.vclSelect .vclInput {
  -moz-user-modify: read-only;
  -webkit-user-modify: read-only;
  background-color: #FFFFFF;
  cursor: pointer;
}

.vclSelect.vclSelectEditable .vclInput {
  -moz-user-modify: read-write;
  -webkit-user-modify: read-write;
}

/* Size modulation utils for text and block elements */

.vclScale75p {
  font-size: 0.75em;
}

.vclScale85p {
  font-size: 0.85em;
}

.vclScale110p {
  font-size: 1.10em;
}

.vclScale115p {
  font-size: 1.15em;
}

.vclScale120p {
  font-size: 1.20em;
}

.vclScale130p {
  font-size: 1.3em;
}

.vclScale155p {
  font-size: 1.55em;
}

.vclScale180p {
  font-size: 1.8em;
}

.vclScale250p {
  font-size: 2.5em;
}

.vclScale300p {
  font-size: 3em;
}

.vclSlider {
  display: block;
  position: relative;
  text-align: center;
  min-height: 2.5em;
  margin-bottom: 1.0em;
}

.vclSlider:focus {
  outline: none;
}

.vclSlider:active {
  outline: none;
}

.vclSlider .vclSliderRail .vclSliderScale {
  position: absolute;
  width: 100%;
  height: 100%;
  margin: 0;
}

.vclSlider .vclSliderRail {
  display: inline-block;
  box-sizing: border-box;
  position: relative;
  margin-top: 1em;
  height: 0.5em;
  width: 100%;
  background-color: hsl(0, 0%, 88%);
}

.vclSlider .vclSliderKnobContainer:hover .vclSliderKnob {
  background-color: #0888BF;
}

.vclSlider .vclSliderKnobContainer:hover {
  cursor: ew-resize;
}

.vclSlider .vclSliderKnobContainer .vclSliderKnob {
  background-color: hsl(0, 0%, 63%);
  border: 1px solid transparent;
  border-radius: 0.2em;
  height: 100%;
}

.vclSlider .vclSliderKnobContainer {
  box-sizing: border-box;
  position: absolute;
  width: 2.2em;
  height: 1.8em;
  padding-left: 0.4em;
  padding-right: 0.4em;
  margin-left: -0.9em;
  margin-top: -0.8em;
}

.vclSlider .vclSliderScale .vclSliderScalePointMark {
  position: relative;
  height: 100%;
  width: 1px;
  background-color: hsl(0, 0%, 45%);
}

.vclSlider .vclSliderScale .vclSliderScalePointLabel {
  width: 1em;
  top: 2em;
  font-size: 95%;
}

.vclSlider .vclSliderScale {
  margin-top: 1em;
}

.vclSlider.vclFocused .vclSliderKnobContainer .vclSliderKnob {
  background-color: #0888BF;
}

.vclSlider.vclDisabled .vclSliderKnobContainer:hover .vclSliderKnob {
  background-color: hsl(0, 0%, 88%);
}

.vclSlider.vclDisabled .vclSliderKnobContainer:hover {
  cursor: not-allowed;
}

.vclSlider.vclDisabled .vclSliderKnobContainer .vclSliderKnob {
  background-color: hsl(0, 0%, 88%);
}

.vclSlider.vclDisabled {
  cursor: not-allowed;
}

.vclSpinner .vclButtonGroup.vclVertical .vclButton {
  height: calc(2.5em / 2);
}

.vclSpinner .vclButtonGroup.vclVertical > .vclButton {
  border-radius: 0;
}

.vclSpinner .vclButtonGroup.vclVertical {
  width: calc(2.5em + 0.5em);
}

.vclTabbable {
  margin-bottom: 1.3em;
  *zoom: 1;
}

.vclTabbable:before,
.vclTabbable:after {
  content: " ";
  display: table;
}

.vclTabbable:after {
  clear: both;
}

.vclTabbable.vclNoBorder .vclTabContent {
  border-bottom: 0;
}

.vclTabbable.vclNoBorder .vclTabs .vclTab.vclSelected,
.vclTabbable.vclNoBorder .vclTabs .vclTab:hover.vclSelected {
  border: 0;
}

.vclTabbable.vclNoBorder .vclTabs .vclTab,
.vclTabbable.vclNoBorder .vclTabs .vclTab:hover {
  border: 0;
  margin: 0;
}

.vclTabbable.vclNoBorder .vclTabs {
  border-bottom: 0;
}

.vclTabContent {
  padding: 0.8em;
}

.vclTabs {
  box-sizing: border-box;
  list-style: none;
  list-style-type: none;
  padding: 0;
  margin: 0;
  *zoom: 1;
}

.vclTabs:before,
.vclTabs:after {
  content: " ";
  display: table;
}

.vclTabs:after {
  clear: both;
}

.vclTabs.vclTabNavJustified .vclTab .vclTab {
  width: 100%;
}

.vclTabs.vclTabNavJustified .vclTab {
  flex: 1;
}

.vclTabs.vclTabNavJustified {
  display: flex;
  flex-direction: row;
}

.vclTabs .vclTab > .vclTabLabel {
  border: 0;
  margin-right: 0.5em;
  text-decoration: none;
}

.vclTabs .vclTab > .vclTabLabel:hover {
  text-decoration: none;
}

.vclTabs .vclTab > .vclTabLabel:last-child {
  margin-right: 0;
}

.vclTabs .vclTab {
  border: 0;
}

.vclTabs .vclTab {
  float: left;
  border: 0;
  white-space: nowrap;
  user-select: none;
  cursor: pointer;
  position: relative;
  margin-right: 0.5em;
  min-width: 6em;
  display: flex;
  flex-flow: row;
  align-items: center;
  justify-content: center;
  border: 0;
  height: 2.9em;
  line-height: 2.9;
  padding: 0 0.75em 0 0.75em;
  border-radius: 0 0 0 0;
  min-width: 4em;
  text-align: center;
  box-sizing: border-box;
}

.vclTabs .vclTab:last-child {
  margin-right: 0;
}

.vclTabs .vclTab.vclSelected,
.vclTabs .vclTab.vclSelected:hover,
.vclTabs .vclTab.vclDisabled,
.vclTabs .vclTab.vclDisabled:hover {
  cursor: default;
}

/* Coloring of normal variant */

.vclTabs .vclTab > a,
.vclTabs .vclTab > a:hover,
.vclTabs .vclTab > a:active,
.vclTabs .vclTab > a:visited {
  color: hsl(0, 0%, 50%);
  outline: none;
}

.vclTabs .vclTab:hover,
.vclTabs .vclTab:focus {
  outline: none;
  background-color: hsl(0, 0%, 92%);
}

.vclTabs .vclTab .vclButton:hover {
  color: hsl(0, 0%, 20%);
}

.vclTabs .vclTab .vclButton {
  height: auto;
  color: hsl(0, 0%, 63%);
}

.vclTabs .vclTab.vclSelected .vclButton:hover {
  color: hsl(0, 0%, 20%);
}

.vclTabs .vclTab.vclSelected .vclButton {
  color: hsl(0, 0%, 63%);
}

.vclTabs .vclTab.vclSelected {
  color: inherit;
}

.vclTabs .vclTab.vclSelected,
.vclTabs .vclTab.vclSelected:hover {
  color: inherit;
  background-color: transparent;
  border-bottom: 3px solid #00ADEF;
}

.vclTabs .vclTab.vclDisabled,
.vclTabs .vclTab.vclDisabled:hover {
  color: hsl(0, 0%, 75%);
  background-color: transparent;
}

.vclTabs .vclTab {
  padding-top: 0.25em;
  color: hsl(0, 0%, 50%);
  background-color: transparent;
  border-bottom: 3px solid transparent;
}

/* Uni variant */

.vclTabs.vclTabStyleUni .vclTab,
.vclTabs.vclTabStyleUni .vclTab:hover {
  border: 0;
  border-bottom: 1px solid hsl(0, 0%, 75%);
  margin-bottom: -1px;
}

.vclTabs.vclTabStyleUni .vclTab.vclSelected {
  border: 0;
}

/* Tabs left */

.vclTabbable.vclTabsLeft .vclTab,
.vclTabbable.vclTabsLeft .vclTab:hover {
  float: none;
  margin: 0 0 0 0;
  border-radius: 0 0 0 0;
  border-bottom: 0;
  border-right: 3px solid transparent;
}

.vclTabbable.vclTabsLeft .vclTab.vclSelected,
.vclTabbable.vclTabsLeft .vclTab.vclSelected:hover {
  border-right: 3px solid #00ADEF;
}

.vclTabbable.vclTabsLeft .vclTabs.vclTabStyleUni {
  border: 0;
}

.vclTabbable.vclTabsLeft .vclTabs.vclTabStyleUni .vclTab {
  border: 0;
  margin-bottom: 0;
  margin-right: -1px;
}

.vclTabbable.vclTabsLeft .vclTabs.vclTabStyleUni .vclTab {
  margin-right: 1px;
  border-radius: 0 0 0 0;
}

.vclTabbable.vclTabsLeft .vclTabs.vclTabStyleUni .vclTab.vclSelected,
.vclTabbable.vclTabsLeft .vclTabs.vclTabStyleUni .vclTab.vclSelected {
  border-right: 0;
}

.vclTabbable.vclTabsLeft .vclTabs {
  float: left;
}

.vclTabbable.vclTabsLeft .vclTabContent {
  float: left;
  display: block;
  border-bottom: 0;
  border: 0;
}

.vclTabbable.vclTabsLeft .vclTabs.vclTabStyleUni {
  border-right: 1px solid hsl(0, 0%, 75%);
}

/* Tabs right */

.vclTabbable.vclTabsRight .vclTab,
.vclTabbable.vclTabsRight .vclTab:hover {
  float: none;
  margin: 0 0 0 0;
  border-radius: 0 0 0 0;
  border-bottom: 0;
  border-left: 3px solid transparent;
}

.vclTabbable.vclTabsRight .vclTab.vclSelected,
.vclTabbable.vclTabsRight .vclTab.vclSelected:hover {
  border-left: 3px solid #00ADEF;
}

.vclTabbable.vclTabsRight .vclTabs.vclTabStyleUni {
  border: 0;
}

.vclTabbable.vclTabsRight .vclTabs.vclTabStyleUni .vclTab {
  border: 0;
  margin-bottom: 0;
  margin-left: -1px;
}

.vclTabbable.vclTabsRight .vclTabs.vclTabStyleUni .vclTab {
  margin-left: 1px;
  border-radius: 0 0 0 0;
}

.vclTabbable.vclTabsRight .vclTabs.vclTabStyleUni .vclTab.vclSelected,
.vclTabbable.vclTabsRight .vclTabs.vclTabStyleUni .vclTab.vclSelected {
  border-right: 0;
}

.vclTabbable.vclTabsRight .vclTabs {
  float: right;
}

.vclTabbable.vclTabsRight .vclTabContent {
  float: right;
  display: block;
  border-bottom: 0;
  border: 0;
}

.vclTabbable.vclTabsRight .vclTabs.vclTabStyleUni {
  border-left: 1px solid hsl(0, 0%, 75%);
}

/* Coloring of uni variant */

.vclTabs.vclTabStyleUni .vclTab:hover,
.vclTabs.vclTabStyleUni .vclTab:focus {
  background-color: hsl(0, 0%, 92%);
  color: #000000;
}

.vclTabs.vclTabStyleUni .vclTab.vclSelected {
  background-clip: border-box;
  color: hsl(0, 0%, 50%);
  border: 1px solid hsl(0, 0%, 75%);
  border-bottom: 1px solid transparent;
  border-color: hsl(0, 0%, 75%) hsl(0, 0%, 75%) transparent;
  background-color: #FFFFFF;
}

.vclTabs.vclTabStyleUni .vclTab.vclDisabled,
.vclTabs.vclTabStyleUni .vclTab.vclDisabled:hover {
  color: hsl(0, 0%, 75%);
  background-color: transparent;
}

.vclTabs.vclTabStyleUni .vclTab {
  padding-top: 0;
  background-color: transparent;
  color: hsl(0, 0%, 20%);
}

.vclTabs.vclTabStyleUni {
  border-bottom: 1px solid hsl(0, 0%, 75%);
}

.vclTabbable .vclTabContent {
  border-left: 1px solid hsl(0, 0%, 75%);
  border-right: 1px solid hsl(0, 0%, 75%);
  border-bottom: 1px solid hsl(0, 0%, 75%);
}

&.vclTabsLeft .vclTabs.vclTabStyleUni .vclTab.vclSelected {
  border: 1px solid hsl(0, 0%, 75%);
  border-right: 1px solid transparent;
}

&.vclTabsRight .vclTabs.vclTabStyleUni .vclTab.vclSelected {
  border: 1px solid hsl(0, 0%, 75%);
  border-left: 1px solid transparent;
}

&.vclTabsRight .vclTabContent {
  border: 0;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
  border: 0;
}

.vclFixed {
  table-layout: fixed;
}

.vclFixed.vclNoWrap,
.vclFixed.vclNoWrap td,
.vclFixed.vclNoWrap th {
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}

.vclTable {
  font-size: inherit;
}

.vclTable.vclCondensed td {
  padding: 0.2em 0.3em;
}

.vclTable.vclNoBorder {
  border: 0;
}

.vclTable {
  width: 100%;
  margin-top: 0;
  margin-bottom: 1.3em;
}

.vclTable .vclRowSelectability {
  cursor: pointer;
}

.vclTable thead tr th > * {
  line-height: 2em;
  font-size: 0.96em;
  font-weight: 600;
  vertical-align: middle;
}

.vclTable thead tr th {
  line-height: 1.5em;
  padding: 0.2em 0.4em;
}

.vclTable thead tr {
  text-align: left;
  border-width: 0;
  border-style: solid;
  border-color: hsl(0, 0%, 63%);
  background-color: hsl(0, 0%, 63%);
  color: #FFFFFF;
}

.vclTable tr.vclDisabled td {
  cursor: default;
  color: hsl(0, 0%, 50%);
}

.vclTable td {
  padding-top: 0.3em;
  padding-left: 0.4em;
  padding-bottom: 0.3em;
  padding-right: 0.4em;
  vertical-align: top;
}

.vclTable tbody tr {
  border-width: 0 0 1px;
  border-style: solid;
  border-color: hsl(0, 0%, 88%);
}

.vclTable tfoot td {
  font-weight: bold;
  background-color: hsl(0, 0%, 63%);
  color: #FFFFFF;
}

.vclTable .vclSelected td > a {
  text-decoration: underline;
  color: #FFFFFF;
}

.vclTable .vclSortableCol a {
  margin-right: 1em;
}

.vclTable .vclSortableCol {
  cursor: pointer;
}

/* Input fields in tables */

table.vclTable select,
table.vclTable textarea,
table.vclTable input,
.vclTable .vclInput,
.vclTable vclInputGroupEmb {
  margin-bottom: 0;
}

/* Alignment modifiers, required to override default td alignment */

.vclTable td.vclAlignRight,
.vclTable th.vclAlignRight,
.vclTable .vclAlignRight td {
  text-align: right;
}

.vclTable td.vclAlignLeft,
.vclTable th.vclAlignLeft,
.vclTable .vclAlignLeft td {
  text-align: left;
}

.vclTable td.vclAlignCentered,
.vclTable th.vclAlignCentered,
.vclTable .vclAlignCentered td {
  text-align: center;
}

.vclVAlignMiddle td {
  vertical-align: middle;
}

.vclVAlignBottom td {
  vertical-align: bottom;
}

/* Modifiers for borders */

.vclDottedBorder,
.vclTable.vclDottedBorder td {
  border-style: dotted;
}

.vclTable.vclVerticalBorder td,
.vclTable.vclVerticalBorder th {
  border-width: 0 1px 1px 0;
}

.vclTable.vclVerticalBorder td:last-child,
.vclTable.vclVerticalBorder th:last-child {
  border-right-width: 0;
}

.vclStickedTable table.vclTable.vclVerticalBorder td:last-child,
.vclStickedTable table.vclTable.vclVerticalBorder th:last-child {
  border-right-width: 1px;
}

.vclTable .vclSelected,
.vclTable .vclSelected:hover,
.vclTable .vclSelected:active {
  border-style: solid;
  border-width: 0;
}

.vclTable input,
.vclTable .vclInput,
.vclTable select,
.vclTable textarea,
.vclTable .vclInputGroup {
  margin-bottom: 0;
}

.vclTable .vclSortableCol.vclSortAsc button.vclButton i,
.vclTable .vclSortableCol.vclSortDesc button.vclButton i {
  color: #00ADEF;
}

/* Alternating row colors */

.vclAltRowColor tbody tr:nth-child(2n+1),
.vclAltRowColor tbody tr:nth-child(2n+1) {
  background-color: hsl(0, 0%, 92%);
}

/* Row highlighting on hover */

.vclTable.vclRowHoverHighlight tbody tr:hover {
  background-color: #96DCFA;
}

/* Single cell highlighting */

.vclCellHighlight {
  background-color: #c7d9f1;
}

/* Selected cell and row coloring */

.vclTable tr.vclSelected td,
.vclTable tr.vclSelected:hover td,
.vclTable tr.vclSelected:active td,
.vclTable tr td.vclSelected {
  color: #FFFFFF;
  background-color: #0888BF;
}

.vclTable .vclTableToolBar th {
  padding: 0;
}

.vclTable .vclTableToolBar {
  background-color: hsl(0, 0%, 88%);
}

.vclTable .vclTableFilterBar th {
  padding: 0;
  border-style: solid;
  border-color: hsl(0, 0%, 88%);
  border-right-width: 1px;
  border-left-width: 0;
}

.vclTable .vclTableFilterBar input {
  font-weight: normal;
  font-size: 0.95em;
  padding: 0 0.4em;
  border: 0;
  width: 100%;
  color: black;
}

.vclTable .vclTableFilterBar {
  background-color: transparent;
  padding: 0;
  border-color: hsl(0, 0%, 88%);
  border-top-width: 0;
  border-bottom-width: 1px;
}

.vclTable .vclTableFilter th > *,
.vclTable .vclTableFilter th > *:hover {
  font-weight: normal;
  line-height: normal;
}

.vclToken {
  box-sizing: border-box;
  user-select: none;
  display: inline-block;
  cursor: pointer;
  line-height: 2.1em;
  padding: 0;
  margin-top: 0;
  margin-right: 0.5em;
  margin-left: 0;
  margin-bottom: 0.3em;
  font-weight: normal;
  font-size: 95%;
  white-space: nowrap;
  border-radius: 0.25em;
  border-width: 1px;
  border-style: solid;
  border-color: hsl(0, 0%, 88%);
  color: inherit;
  background-color: hsl(0, 0%, 95%);
}

.vclToken:empty {
  display: none;
}

.vclToken:hover {
  border-color: hsl(0, 0%, 63%);
}

.vclToken.vclSelected {
  border-color: #0888BF;
  background-color: #0888BF;
  color: #FFFFFF;
}

.vclToken.vclHighlighted {
  border-color: #0888BF;
  background-color: hsl(0, 0%, 95%);
  color: inherit;
}

.vclToken .vclTokenLabel:first-child {
  margin-left: 0.3em;
}

.vclToken .vclTokenLabel:last-child {
  margin-right: 0.3em;
}

.vclToken .vclButton {
  padding: 0 0.3em;
  height: 100%;
  font-size: 0.8em;
  min-width: 2em;
  min-height: 2em;
  color: hsl(0, 0%, 63%);
}

.vclTokenContainer {
  line-height: initial;
}

.vclTokenContainer > .vclToken:first-child {
  margin-left: 0;
}

.vclTokenContainer > .vclToken:last-child {
  margin-right: 0;
}

.vclTokenInput > .vclInput,
.vclTokenInput > .vclInput:focus {
  border: 0;
  width: auto;
  margin: 0;
  min-width: 8em;
}

.vclTokenInput .vclTokenContainer {
  padding-top: 0.2em;
}

.vclToolbar {
  user-select: none;
  box-sizing: border-box;
  background-color: hsl(0, 0%, 95%);
}

.vclToolbar.vclSecondary {
  background-color: hsl(0, 0%, 98%);
}

.vclToolbar.vclTransparent {
  background-color: transparent;
}

.vclToolbar .vclInputGroup,
.vclToolbar .vclInputGroupEmb,
.vclToolbar .vclNavigation,
.vclToolbar .vclLooseButtonGroup {
  margin-bottom: 0;
}

.vclToolbar .vclLogo {
  margin-left: 0.5em;
}

.vclToolbar .vclToolbarTitle {
  display: inline-block;
  margin: 0;
  margin-left: 0.5em;
  margin-right: 0.5em;
}

.vclToolbar h1.vclToolbarTitle {
  font-size: 1.1em;
}

.vclToolbar h2.vclToolbarTitle {
  font-size: 1.05em;
}

.vclTooltip {
  display: inline-block;
  position: absolute;
}

.vclTooltip .vclTooltipContent {
  z-index: 200;
  border-style: solid;
  border-width: 1px;
  border-color: hsl(0, 0%, 15%);
  border-radius: 4px;
  color: #FFFFFF;
  background-color: hsl(0, 0%, 15%);
  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);
  padding: 0.5em 0.5em;
}

.vclArrowPointer {
  z-index: 180;
  position: absolute;
  background-color: hsl(0, 0%, 15%);
  margin: 0.5px 0px 0px;
  width: 0.56em;
  height: 0.56em;
  border-style: solid;
  border-color: hsl(0, 0%, 15%);
  transform: translateX(-50%) translateY(-50%) rotate(45deg);
  pointer-events: none;
}

.vclArrowPointerBottom .vclArrowPointer {
  left: 50%;
  top: 99%;
  border-width: 0 1px 1px 0;
}

.vclArrowPointerRight .vclArrowPointer {
  left: 99%;
  top: 50%;
  border-width: 1px 1px 0 0;
}

.vclArrowPointerLeft .vclArrowPointer {
  left: 1%;
  top: 50%;
  border-width: 0 0 1px 1px;
}

.vclArrowPointerTop .vclArrowPointer {
  left: 50%;
  top: 1%;
  border-width: 1px 0 0 1px;
}

.vclAnimContainer {
  overflow: hidden;
}

/* Disable transitions */

.vclNoTransitions {
  transition: none !important;
}

/* Opacity based */

.vclFade {
  opacity: 0;
  transition: opacity 0.2s ease 0s;
}

.vclFade.vclShow {
  opacity: 1;
}

/* Translation based */

.vclTranslation {
  outline: none;
  overflow: auto;
  opacity: 0;
  transition: transform 0.2s ease-in-out, opacity 0.2s ease-in;
}

.vclTranslation.vclShow {
  opacity: 1;
  transform: translateZ(0);
}

.vclTranslation-center {
  transform: scale(0.5);
}

.vclTranslation-top {
  transform: translateY(-200%);
}

.vclTranslation-bottom {
  transform: translateY(200%);
}

.vclTranslation-left {
  transform: translateX(-200%);
}

.vclTranslation-right {
  transform: translteX(200%);
}

html {
  font-size: 0.875em;
  line-height: 1.428;
  color: hsl(0, 0%, 20%);
  font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
}

abbr.vclInitialism {
  font-size: 93%;
  text-transform: uppercase;
}

mark {
  background: #ffff00;
  color: #000000;
}

/* Define quote characters for q element */

q {
  quotes: "\\201C" "\\201D" "\\2018" "\\2019";
}

blockquote {
  margin-top: 0;
  margin-bottom: 1.3em;
  margin-left: 1.8em;
  margin-right: 1.8em;
  padding-left: 1em;
  border-left-width: 0.3em;
  border-left-style: solid;
  border-left-color: hsl(0, 0%, 88%);
}

address {
  display: block;
  margin-top: 0;
  margin-bottom: 1.3em;
  font-style: normal;
}

pre,
code,
kbd,
samp {
  font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
  font-size: 93%;
}

kbd {
  padding-right: 0.8em;
  padding-left: 0.8em;
  border-radius: 0.85em;
  color: #FFF;
  background-color: #333;
  box-shadow: 0px -1px 0px rgba(0, 0, 0, 0.25) inset;
}

/* Pre-formatted text. */

pre {
  margin-bottom: 1.1em;
  white-space: pre;
  white-space: pre-wrap;
  word-wrap: break-word;
  word-break: break-all;
}

pre.vclCode > code {
  padding: 0;
  white-space: pre;
}

pre.vclCode {
  border: 1px solid hsl(0, 0%, 88%);
  line-height: 1.2em;
  padding: 0.7em;
  overflow: auto;
  border-radius: 0;
  background-clip: padding-box;
  background-color: hsl(0, 0%, 92%);
}

code {
  padding: 0.15em 0.25em;
  white-space: nowrap;
  background-color: hsl(0, 0%, 92%);
}

.vclCodeWrap {
  white-space: pre-wrap;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  color: hsl(0, 0%, 20%);
  font-family: inherit;
  font-weight: 500;
  text-rendering: optimizelegibility;
  line-height: 1.428;
}

h1 {
  font-size: 2.08em;
  margin-top: 0.5em;
  margin-bottom: 0.2em;
}

h2 {
  font-size: 1.7em;
  margin-top: 0.65em;
  margin-bottom: 0.3em;
}

h3 {
  font-size: 1.27em;
  margin-top: 0.75em;
  margin-bottom: 0.4em;
}

h4 {
  font-size: 1.1em;
  margin-top: 0.85em;
  margin-bottom: 0.4em;
}

h5 {
  font-size: 0.95em;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}

h6 {
  font-size: 0.82em;
  margin-top: 1.1em;
  margin-bottom: 0.5em;
}

p {
  margin-top: 0em;
  margin-bottom: 1.3em;
}

/* Anchors */

a,
a:visited,
a:active,
a:hover {
  text-decoration: none;
  color: #00ADEF;
}

a:hover {
  color: #005F84;
}

a.vclDisabled {
  cursor: default;
}

a.vclContentLink > .vclIcogram {
  display: inline;
}

a.vclContentLink > *:first-child {
  margin-left: 0.1em;
}

a.vclContentLink > * {
  margin: 0 0.1em 0 0;
}

a.vclContentLink > *:last-child {
  margin-right: 0.1em;
}

a.vclContentLink .vclText {
  text-decoration: none;
}

a.vclContentLink .vclIcon {
  text-decoration: none;
}

a.vclContentLink {
  user-select: none;
  text-decoration: none;
  vertical-align: text-bottom;
}

.vclDisabled,
a.vclDisabled {
  color: hsl(0, 0%, 50%);
}

.vclSecondaryTextColor {
  color: hsl(0, 0%, 50%);
}

/* Prevents sub and sup affecting line-height */

sub,
sup {
  font-size: 80%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sup {
  top: -0.5em;
}

sub {
  bottom: -0.25em;
}

/* Text selection coloring */

*::selection {
  background: #000000;
  color: #FFFFFF;
  text-shadow: none;
}

*::-ms-selection {
  background: #000000;
  color: #FFFFFF;
  text-shadow: none;
}

*::-moz-selection {
  background: #000000;
  color: #FFFFFF;
  text-shadow: none;
}

/* Float helpers */

.vclFloatLeft {
  float: left;
}

.vclFloatRight {
  float: right;
}

.vclFloatNone {
  float: none;
}

/* Clearing helpers */

.vclClearFix {
  *zoom: 1;
}

.vclClearFix:before,
.vclClearFix:after {
  content: " ";
  display: table;
}

.vclClearFix:after {
  clear: both;
}

.vclClear {
  clear: both;
  float: none;
}

/* Block element alignment */

.vclCenterBlock {
  display: table;
  margin: 0 auto;
}

/* Borders */

.vclNoBorder {
  border: 0 !important;
}

/* Padding */

.vclNoPadding {
  padding: 0 !important;
}

/* Margins */

.vclNoMargin {
  margin: 0 !important;
}

/* Inline element alignment */

.vclAlignLeft {
  text-align: left;
}

.vclAlignRight {
  text-align: right;
}

.vclAlignCentered {
  text-align: center;
}

.vclAlignJustified {
  text-align: justify;
}

/* Overflowing text */

.vclOverflowEllipsis {
  text-overflow: ellipsis;
  overflow: hidden;
  white-space: nowrap;
}

/* Text and word wrapping */

.vclBreakWords {
  word-wrap: break-word;
}

.vclNoWrap {
  overflow: hidden;
  white-space: nowrap;
}

/* Visibility */

.vclOverflowHidden {
  overflow: hidden;
}

.vclDisplayNone {
  display: none !important;
}

.vclVisibilityHidden {
  visibility: hidden !important;
}

/* Scrollable containers */

.vclScrollable {
  -webkit-transform: translateZ(0);
  -webkit-overflow-scrolling: touch;
  overflow: auto;
}

.vclScrollable.vclX {
  overflow-x: auto;
  overflow-y: hidden;
}

.vclScrollable.vclXOnHover {
  overflow-x: hidden;
  overflow-y: hidden;
}

.vclScrollable.vclXOnHover:hover {
  overflow-x: auto;
  overflow-y: hidden;
}

.vclScrollable.vclY {
  overflow-x: hidden;
  overflow-y: auto;
}

.vclScrollable.vclYOnHover {
  overflow-x: hidden;
  overflow-y: hidden;
}

.vclScrollable.vclYOnHover:hover {
  overflow-x: hidden;
  overflow-y: auto;
}

/* Utility to enable disable selection of text */

.vclDisableUserSelect {
  user-select: none;
}

.vclEnableUserSelect {
  user-select: text;
}

.vclZoomBox {
  padding: 0;
  width: 20em;
  height: 20em;
  position: absolute;
  z-index: 199;
  overflow: hidden;
  background-repeat: no-repeat;
}

.vclZoomBoxMagnifier {
  min-width: 5em;
  min-height: 5em;
  background-color: transparent;
  border-width: 1px;
  border-style: solid;
  border-color: white;
  background-color: rgba(255, 255, 255, 0.3);
  position: absolute;
  z-index: 180;
  cursor: pointer;
  border-collapse: collapse;
}

/*!
 *  Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome
 *  License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License)
 */

/* FONT PATH
 * -------------------------- */

@font-face {
  font-family: 'FontAwesome';
  src: url('../fonts/fontawesome-webfont.eot?v=4.7.0');
  src: url('../fonts/fontawesome-webfont.eot?#iefix&v=4.7.0') format('embedded-opentype'), url('../fonts/fontawesome-webfont.woff2?v=4.7.0') format('woff2'), url('../fonts/fontawesome-webfont.woff?v=4.7.0') format('woff'), url('../fonts/fontawesome-webfont.ttf?v=4.7.0') format('truetype'), url('../fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular') format('svg');
  font-weight: normal;
  font-style: normal;
}

.fa {
  display: inline-block;
  font: normal normal normal 14px/1 FontAwesome;
  font-size: inherit;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* makes the font 33% larger relative to the icon container */

.fa-lg {
  font-size: 1.33333333em;
  line-height: 0.75em;
  vertical-align: -15%;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-fw {
  width: 1.28571429em;
  text-align: center;
}

.fa-ul {
  padding-left: 0;
  margin-left: 2.14285714em;
  list-style-type: none;
}

.fa-ul > li {
  position: relative;
}

.fa-li {
  position: absolute;
  left: -2.14285714em;
  width: 2.14285714em;
  top: 0.14285714em;
  text-align: center;
}

.fa-li.fa-lg {
  left: -1.85714286em;
}

.fa-border {
  padding: .2em .25em .15em;
  border: solid 0.08em #eeeeee;
  border-radius: .1em;
}

.fa-pull-left {
  float: left;
}

.fa-pull-right {
  float: right;
}

.fa.fa-pull-left {
  margin-right: .3em;
}

.fa.fa-pull-right {
  margin-left: .3em;
}

/* Deprecated as of 4.4.0 */

.pull-right {
  float: right;
}

.pull-left {
  float: left;
}

.fa.pull-left {
  margin-right: .3em;
}

.fa.pull-right {
  margin-left: .3em;
}

.fa-spin {
  -webkit-animation: fa-spin 2s infinite linear;
  animation: fa-spin 2s infinite linear;
}

.fa-pulse {
  -webkit-animation: fa-spin 1s infinite steps(8);
  animation: fa-spin 1s infinite steps(8);
}

@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }

  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}

@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }

  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}

.fa-rotate-90 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";
  -webkit-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  transform: rotate(90deg);
}

.fa-rotate-180 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
  -webkit-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
  transform: rotate(180deg);
}

.fa-rotate-270 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";
  -webkit-transform: rotate(270deg);
  -ms-transform: rotate(270deg);
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";
  -webkit-transform: scale(-1, 1);
  -ms-transform: scale(-1, 1);
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
  -webkit-transform: scale(1, -1);
  -ms-transform: scale(1, -1);
  transform: scale(1, -1);
}

:root .fa-rotate-90,
:root .fa-rotate-180,
:root .fa-rotate-270,
:root .fa-flip-horizontal,
:root .fa-flip-vertical {
  filter: none;
}

.fa-stack {
  position: relative;
  display: inline-block;
  width: 2em;
  height: 2em;
  line-height: 2em;
  vertical-align: middle;
}

.fa-stack-1x,
.fa-stack-2x {
  position: absolute;
  left: 0;
  width: 100%;
  text-align: center;
}

.fa-stack-1x {
  line-height: inherit;
}

.fa-stack-2x {
  font-size: 2em;
}

.fa-inverse {
  color: #ffffff;
}

/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
   readers do not read off random characters that represent icons */

.fa-glass:before {
  content: "\\f000";
}

.fa-music:before {
  content: "\\f001";
}

.fa-search:before {
  content: "\\f002";
}

.fa-envelope-o:before {
  content: "\\f003";
}

.fa-heart:before {
  content: "\\f004";
}

.fa-star:before {
  content: "\\f005";
}

.fa-star-o:before {
  content: "\\f006";
}

.fa-user:before {
  content: "\\f007";
}

.fa-film:before {
  content: "\\f008";
}

.fa-th-large:before {
  content: "\\f009";
}

.fa-th:before {
  content: "\\f00a";
}

.fa-th-list:before {
  content: "\\f00b";
}

.fa-check:before {
  content: "\\f00c";
}

.fa-remove:before,
.fa-close:before,
.fa-times:before {
  content: "\\f00d";
}

.fa-search-plus:before {
  content: "\\f00e";
}

.fa-search-minus:before {
  content: "\\f010";
}

.fa-power-off:before {
  content: "\\f011";
}

.fa-signal:before {
  content: "\\f012";
}

.fa-gear:before,
.fa-cog:before {
  content: "\\f013";
}

.fa-trash-o:before {
  content: "\\f014";
}

.fa-home:before {
  content: "\\f015";
}

.fa-file-o:before {
  content: "\\f016";
}

.fa-clock-o:before {
  content: "\\f017";
}

.fa-road:before {
  content: "\\f018";
}

.fa-download:before {
  content: "\\f019";
}

.fa-arrow-circle-o-down:before {
  content: "\\f01a";
}

.fa-arrow-circle-o-up:before {
  content: "\\f01b";
}

.fa-inbox:before {
  content: "\\f01c";
}

.fa-play-circle-o:before {
  content: "\\f01d";
}

.fa-rotate-right:before,
.fa-repeat:before {
  content: "\\f01e";
}

.fa-refresh:before {
  content: "\\f021";
}

.fa-list-alt:before {
  content: "\\f022";
}

.fa-lock:before {
  content: "\\f023";
}

.fa-flag:before {
  content: "\\f024";
}

.fa-headphones:before {
  content: "\\f025";
}

.fa-volume-off:before {
  content: "\\f026";
}

.fa-volume-down:before {
  content: "\\f027";
}

.fa-volume-up:before {
  content: "\\f028";
}

.fa-qrcode:before {
  content: "\\f029";
}

.fa-barcode:before {
  content: "\\f02a";
}

.fa-tag:before {
  content: "\\f02b";
}

.fa-tags:before {
  content: "\\f02c";
}

.fa-book:before {
  content: "\\f02d";
}

.fa-bookmark:before {
  content: "\\f02e";
}

.fa-print:before {
  content: "\\f02f";
}

.fa-camera:before {
  content: "\\f030";
}

.fa-font:before {
  content: "\\f031";
}

.fa-bold:before {
  content: "\\f032";
}

.fa-italic:before {
  content: "\\f033";
}

.fa-text-height:before {
  content: "\\f034";
}

.fa-text-width:before {
  content: "\\f035";
}

.fa-align-left:before {
  content: "\\f036";
}

.fa-align-center:before {
  content: "\\f037";
}

.fa-align-right:before {
  content: "\\f038";
}

.fa-align-justify:before {
  content: "\\f039";
}

.fa-list:before {
  content: "\\f03a";
}

.fa-dedent:before,
.fa-outdent:before {
  content: "\\f03b";
}

.fa-indent:before {
  content: "\\f03c";
}

.fa-video-camera:before {
  content: "\\f03d";
}

.fa-photo:before,
.fa-image:before,
.fa-picture-o:before {
  content: "\\f03e";
}

.fa-pencil:before {
  content: "\\f040";
}

.fa-map-marker:before {
  content: "\\f041";
}

.fa-adjust:before {
  content: "\\f042";
}

.fa-tint:before {
  content: "\\f043";
}

.fa-edit:before,
.fa-pencil-square-o:before {
  content: "\\f044";
}

.fa-share-square-o:before {
  content: "\\f045";
}

.fa-check-square-o:before {
  content: "\\f046";
}

.fa-arrows:before {
  content: "\\f047";
}

.fa-step-backward:before {
  content: "\\f048";
}

.fa-fast-backward:before {
  content: "\\f049";
}

.fa-backward:before {
  content: "\\f04a";
}

.fa-play:before {
  content: "\\f04b";
}

.fa-pause:before {
  content: "\\f04c";
}

.fa-stop:before {
  content: "\\f04d";
}

.fa-forward:before {
  content: "\\f04e";
}

.fa-fast-forward:before {
  content: "\\f050";
}

.fa-step-forward:before {
  content: "\\f051";
}

.fa-eject:before {
  content: "\\f052";
}

.fa-chevron-left:before {
  content: "\\f053";
}

.fa-chevron-right:before {
  content: "\\f054";
}

.fa-plus-circle:before {
  content: "\\f055";
}

.fa-minus-circle:before {
  content: "\\f056";
}

.fa-times-circle:before {
  content: "\\f057";
}

.fa-check-circle:before {
  content: "\\f058";
}

.fa-question-circle:before {
  content: "\\f059";
}

.fa-info-circle:before {
  content: "\\f05a";
}

.fa-crosshairs:before {
  content: "\\f05b";
}

.fa-times-circle-o:before {
  content: "\\f05c";
}

.fa-check-circle-o:before {
  content: "\\f05d";
}

.fa-ban:before {
  content: "\\f05e";
}

.fa-arrow-left:before {
  content: "\\f060";
}

.fa-arrow-right:before {
  content: "\\f061";
}

.fa-arrow-up:before {
  content: "\\f062";
}

.fa-arrow-down:before {
  content: "\\f063";
}

.fa-mail-forward:before,
.fa-share:before {
  content: "\\f064";
}

.fa-expand:before {
  content: "\\f065";
}

.fa-compress:before {
  content: "\\f066";
}

.fa-plus:before {
  content: "\\f067";
}

.fa-minus:before {
  content: "\\f068";
}

.fa-asterisk:before {
  content: "\\f069";
}

.fa-exclamation-circle:before {
  content: "\\f06a";
}

.fa-gift:before {
  content: "\\f06b";
}

.fa-leaf:before {
  content: "\\f06c";
}

.fa-fire:before {
  content: "\\f06d";
}

.fa-eye:before {
  content: "\\f06e";
}

.fa-eye-slash:before {
  content: "\\f070";
}

.fa-warning:before,
.fa-exclamation-triangle:before {
  content: "\\f071";
}

.fa-plane:before {
  content: "\\f072";
}

.fa-calendar:before {
  content: "\\f073";
}

.fa-random:before {
  content: "\\f074";
}

.fa-comment:before {
  content: "\\f075";
}

.fa-magnet:before {
  content: "\\f076";
}

.fa-chevron-up:before {
  content: "\\f077";
}

.fa-chevron-down:before {
  content: "\\f078";
}

.fa-retweet:before {
  content: "\\f079";
}

.fa-shopping-cart:before {
  content: "\\f07a";
}

.fa-folder:before {
  content: "\\f07b";
}

.fa-folder-open:before {
  content: "\\f07c";
}

.fa-arrows-v:before {
  content: "\\f07d";
}

.fa-arrows-h:before {
  content: "\\f07e";
}

.fa-bar-chart-o:before,
.fa-bar-chart:before {
  content: "\\f080";
}

.fa-twitter-square:before {
  content: "\\f081";
}

.fa-facebook-square:before {
  content: "\\f082";
}

.fa-camera-retro:before {
  content: "\\f083";
}

.fa-key:before {
  content: "\\f084";
}

.fa-gears:before,
.fa-cogs:before {
  content: "\\f085";
}

.fa-comments:before {
  content: "\\f086";
}

.fa-thumbs-o-up:before {
  content: "\\f087";
}

.fa-thumbs-o-down:before {
  content: "\\f088";
}

.fa-star-half:before {
  content: "\\f089";
}

.fa-heart-o:before {
  content: "\\f08a";
}

.fa-sign-out:before {
  content: "\\f08b";
}

.fa-linkedin-square:before {
  content: "\\f08c";
}

.fa-thumb-tack:before {
  content: "\\f08d";
}

.fa-external-link:before {
  content: "\\f08e";
}

.fa-sign-in:before {
  content: "\\f090";
}

.fa-trophy:before {
  content: "\\f091";
}

.fa-github-square:before {
  content: "\\f092";
}

.fa-upload:before {
  content: "\\f093";
}

.fa-lemon-o:before {
  content: "\\f094";
}

.fa-phone:before {
  content: "\\f095";
}

.fa-square-o:before {
  content: "\\f096";
}

.fa-bookmark-o:before {
  content: "\\f097";
}

.fa-phone-square:before {
  content: "\\f098";
}

.fa-twitter:before {
  content: "\\f099";
}

.fa-facebook-f:before,
.fa-facebook:before {
  content: "\\f09a";
}

.fa-github:before {
  content: "\\f09b";
}

.fa-unlock:before {
  content: "\\f09c";
}

.fa-credit-card:before {
  content: "\\f09d";
}

.fa-feed:before,
.fa-rss:before {
  content: "\\f09e";
}

.fa-hdd-o:before {
  content: "\\f0a0";
}

.fa-bullhorn:before {
  content: "\\f0a1";
}

.fa-bell:before {
  content: "\\f0f3";
}

.fa-certificate:before {
  content: "\\f0a3";
}

.fa-hand-o-right:before {
  content: "\\f0a4";
}

.fa-hand-o-left:before {
  content: "\\f0a5";
}

.fa-hand-o-up:before {
  content: "\\f0a6";
}

.fa-hand-o-down:before {
  content: "\\f0a7";
}

.fa-arrow-circle-left:before {
  content: "\\f0a8";
}

.fa-arrow-circle-right:before {
  content: "\\f0a9";
}

.fa-arrow-circle-up:before {
  content: "\\f0aa";
}

.fa-arrow-circle-down:before {
  content: "\\f0ab";
}

.fa-globe:before {
  content: "\\f0ac";
}

.fa-wrench:before {
  content: "\\f0ad";
}

.fa-tasks:before {
  content: "\\f0ae";
}

.fa-filter:before {
  content: "\\f0b0";
}

.fa-briefcase:before {
  content: "\\f0b1";
}

.fa-arrows-alt:before {
  content: "\\f0b2";
}

.fa-group:before,
.fa-users:before {
  content: "\\f0c0";
}

.fa-chain:before,
.fa-link:before {
  content: "\\f0c1";
}

.fa-cloud:before {
  content: "\\f0c2";
}

.fa-flask:before {
  content: "\\f0c3";
}

.fa-cut:before,
.fa-scissors:before {
  content: "\\f0c4";
}

.fa-copy:before,
.fa-files-o:before {
  content: "\\f0c5";
}

.fa-paperclip:before {
  content: "\\f0c6";
}

.fa-save:before,
.fa-floppy-o:before {
  content: "\\f0c7";
}

.fa-square:before {
  content: "\\f0c8";
}

.fa-navicon:before,
.fa-reorder:before,
.fa-bars:before {
  content: "\\f0c9";
}

.fa-list-ul:before {
  content: "\\f0ca";
}

.fa-list-ol:before {
  content: "\\f0cb";
}

.fa-strikethrough:before {
  content: "\\f0cc";
}

.fa-underline:before {
  content: "\\f0cd";
}

.fa-table:before {
  content: "\\f0ce";
}

.fa-magic:before {
  content: "\\f0d0";
}

.fa-truck:before {
  content: "\\f0d1";
}

.fa-pinterest:before {
  content: "\\f0d2";
}

.fa-pinterest-square:before {
  content: "\\f0d3";
}

.fa-google-plus-square:before {
  content: "\\f0d4";
}

.fa-google-plus:before {
  content: "\\f0d5";
}

.fa-money:before {
  content: "\\f0d6";
}

.fa-caret-down:before {
  content: "\\f0d7";
}

.fa-caret-up:before {
  content: "\\f0d8";
}

.fa-caret-left:before {
  content: "\\f0d9";
}

.fa-caret-right:before {
  content: "\\f0da";
}

.fa-columns:before {
  content: "\\f0db";
}

.fa-unsorted:before,
.fa-sort:before {
  content: "\\f0dc";
}

.fa-sort-down:before,
.fa-sort-desc:before {
  content: "\\f0dd";
}

.fa-sort-up:before,
.fa-sort-asc:before {
  content: "\\f0de";
}

.fa-envelope:before {
  content: "\\f0e0";
}

.fa-linkedin:before {
  content: "\\f0e1";
}

.fa-rotate-left:before,
.fa-undo:before {
  content: "\\f0e2";
}

.fa-legal:before,
.fa-gavel:before {
  content: "\\f0e3";
}

.fa-dashboard:before,
.fa-tachometer:before {
  content: "\\f0e4";
}

.fa-comment-o:before {
  content: "\\f0e5";
}

.fa-comments-o:before {
  content: "\\f0e6";
}

.fa-flash:before,
.fa-bolt:before {
  content: "\\f0e7";
}

.fa-sitemap:before {
  content: "\\f0e8";
}

.fa-umbrella:before {
  content: "\\f0e9";
}

.fa-paste:before,
.fa-clipboard:before {
  content: "\\f0ea";
}

.fa-lightbulb-o:before {
  content: "\\f0eb";
}

.fa-exchange:before {
  content: "\\f0ec";
}

.fa-cloud-download:before {
  content: "\\f0ed";
}

.fa-cloud-upload:before {
  content: "\\f0ee";
}

.fa-user-md:before {
  content: "\\f0f0";
}

.fa-stethoscope:before {
  content: "\\f0f1";
}

.fa-suitcase:before {
  content: "\\f0f2";
}

.fa-bell-o:before {
  content: "\\f0a2";
}

.fa-coffee:before {
  content: "\\f0f4";
}

.fa-cutlery:before {
  content: "\\f0f5";
}

.fa-file-text-o:before {
  content: "\\f0f6";
}

.fa-building-o:before {
  content: "\\f0f7";
}

.fa-hospital-o:before {
  content: "\\f0f8";
}

.fa-ambulance:before {
  content: "\\f0f9";
}

.fa-medkit:before {
  content: "\\f0fa";
}

.fa-fighter-jet:before {
  content: "\\f0fb";
}

.fa-beer:before {
  content: "\\f0fc";
}

.fa-h-square:before {
  content: "\\f0fd";
}

.fa-plus-square:before {
  content: "\\f0fe";
}

.fa-angle-double-left:before {
  content: "\\f100";
}

.fa-angle-double-right:before {
  content: "\\f101";
}

.fa-angle-double-up:before {
  content: "\\f102";
}

.fa-angle-double-down:before {
  content: "\\f103";
}

.fa-angle-left:before {
  content: "\\f104";
}

.fa-angle-right:before {
  content: "\\f105";
}

.fa-angle-up:before {
  content: "\\f106";
}

.fa-angle-down:before {
  content: "\\f107";
}

.fa-desktop:before {
  content: "\\f108";
}

.fa-laptop:before {
  content: "\\f109";
}

.fa-tablet:before {
  content: "\\f10a";
}

.fa-mobile-phone:before,
.fa-mobile:before {
  content: "\\f10b";
}

.fa-circle-o:before {
  content: "\\f10c";
}

.fa-quote-left:before {
  content: "\\f10d";
}

.fa-quote-right:before {
  content: "\\f10e";
}

.fa-spinner:before {
  content: "\\f110";
}

.fa-circle:before {
  content: "\\f111";
}

.fa-mail-reply:before,
.fa-reply:before {
  content: "\\f112";
}

.fa-github-alt:before {
  content: "\\f113";
}

.fa-folder-o:before {
  content: "\\f114";
}

.fa-folder-open-o:before {
  content: "\\f115";
}

.fa-smile-o:before {
  content: "\\f118";
}

.fa-frown-o:before {
  content: "\\f119";
}

.fa-meh-o:before {
  content: "\\f11a";
}

.fa-gamepad:before {
  content: "\\f11b";
}

.fa-keyboard-o:before {
  content: "\\f11c";
}

.fa-flag-o:before {
  content: "\\f11d";
}

.fa-flag-checkered:before {
  content: "\\f11e";
}

.fa-terminal:before {
  content: "\\f120";
}

.fa-code:before {
  content: "\\f121";
}

.fa-mail-reply-all:before,
.fa-reply-all:before {
  content: "\\f122";
}

.fa-star-half-empty:before,
.fa-star-half-full:before,
.fa-star-half-o:before {
  content: "\\f123";
}

.fa-location-arrow:before {
  content: "\\f124";
}

.fa-crop:before {
  content: "\\f125";
}

.fa-code-fork:before {
  content: "\\f126";
}

.fa-unlink:before,
.fa-chain-broken:before {
  content: "\\f127";
}

.fa-question:before {
  content: "\\f128";
}

.fa-info:before {
  content: "\\f129";
}

.fa-exclamation:before {
  content: "\\f12a";
}

.fa-superscript:before {
  content: "\\f12b";
}

.fa-subscript:before {
  content: "\\f12c";
}

.fa-eraser:before {
  content: "\\f12d";
}

.fa-puzzle-piece:before {
  content: "\\f12e";
}

.fa-microphone:before {
  content: "\\f130";
}

.fa-microphone-slash:before {
  content: "\\f131";
}

.fa-shield:before {
  content: "\\f132";
}

.fa-calendar-o:before {
  content: "\\f133";
}

.fa-fire-extinguisher:before {
  content: "\\f134";
}

.fa-rocket:before {
  content: "\\f135";
}

.fa-maxcdn:before {
  content: "\\f136";
}

.fa-chevron-circle-left:before {
  content: "\\f137";
}

.fa-chevron-circle-right:before {
  content: "\\f138";
}

.fa-chevron-circle-up:before {
  content: "\\f139";
}

.fa-chevron-circle-down:before {
  content: "\\f13a";
}

.fa-html5:before {
  content: "\\f13b";
}

.fa-css3:before {
  content: "\\f13c";
}

.fa-anchor:before {
  content: "\\f13d";
}

.fa-unlock-alt:before {
  content: "\\f13e";
}

.fa-bullseye:before {
  content: "\\f140";
}

.fa-ellipsis-h:before {
  content: "\\f141";
}

.fa-ellipsis-v:before {
  content: "\\f142";
}

.fa-rss-square:before {
  content: "\\f143";
}

.fa-play-circle:before {
  content: "\\f144";
}

.fa-ticket:before {
  content: "\\f145";
}

.fa-minus-square:before {
  content: "\\f146";
}

.fa-minus-square-o:before {
  content: "\\f147";
}

.fa-level-up:before {
  content: "\\f148";
}

.fa-level-down:before {
  content: "\\f149";
}

.fa-check-square:before {
  content: "\\f14a";
}

.fa-pencil-square:before {
  content: "\\f14b";
}

.fa-external-link-square:before {
  content: "\\f14c";
}

.fa-share-square:before {
  content: "\\f14d";
}

.fa-compass:before {
  content: "\\f14e";
}

.fa-toggle-down:before,
.fa-caret-square-o-down:before {
  content: "\\f150";
}

.fa-toggle-up:before,
.fa-caret-square-o-up:before {
  content: "\\f151";
}

.fa-toggle-right:before,
.fa-caret-square-o-right:before {
  content: "\\f152";
}

.fa-euro:before,
.fa-eur:before {
  content: "\\f153";
}

.fa-gbp:before {
  content: "\\f154";
}

.fa-dollar:before,
.fa-usd:before {
  content: "\\f155";
}

.fa-rupee:before,
.fa-inr:before {
  content: "\\f156";
}

.fa-cny:before,
.fa-rmb:before,
.fa-yen:before,
.fa-jpy:before {
  content: "\\f157";
}

.fa-ruble:before,
.fa-rouble:before,
.fa-rub:before {
  content: "\\f158";
}

.fa-won:before,
.fa-krw:before {
  content: "\\f159";
}

.fa-bitcoin:before,
.fa-btc:before {
  content: "\\f15a";
}

.fa-file:before {
  content: "\\f15b";
}

.fa-file-text:before {
  content: "\\f15c";
}

.fa-sort-alpha-asc:before {
  content: "\\f15d";
}

.fa-sort-alpha-desc:before {
  content: "\\f15e";
}

.fa-sort-amount-asc:before {
  content: "\\f160";
}

.fa-sort-amount-desc:before {
  content: "\\f161";
}

.fa-sort-numeric-asc:before {
  content: "\\f162";
}

.fa-sort-numeric-desc:before {
  content: "\\f163";
}

.fa-thumbs-up:before {
  content: "\\f164";
}

.fa-thumbs-down:before {
  content: "\\f165";
}

.fa-youtube-square:before {
  content: "\\f166";
}

.fa-youtube:before {
  content: "\\f167";
}

.fa-xing:before {
  content: "\\f168";
}

.fa-xing-square:before {
  content: "\\f169";
}

.fa-youtube-play:before {
  content: "\\f16a";
}

.fa-dropbox:before {
  content: "\\f16b";
}

.fa-stack-overflow:before {
  content: "\\f16c";
}

.fa-instagram:before {
  content: "\\f16d";
}

.fa-flickr:before {
  content: "\\f16e";
}

.fa-adn:before {
  content: "\\f170";
}

.fa-bitbucket:before {
  content: "\\f171";
}

.fa-bitbucket-square:before {
  content: "\\f172";
}

.fa-tumblr:before {
  content: "\\f173";
}

.fa-tumblr-square:before {
  content: "\\f174";
}

.fa-long-arrow-down:before {
  content: "\\f175";
}

.fa-long-arrow-up:before {
  content: "\\f176";
}

.fa-long-arrow-left:before {
  content: "\\f177";
}

.fa-long-arrow-right:before {
  content: "\\f178";
}

.fa-apple:before {
  content: "\\f179";
}

.fa-windows:before {
  content: "\\f17a";
}

.fa-android:before {
  content: "\\f17b";
}

.fa-linux:before {
  content: "\\f17c";
}

.fa-dribbble:before {
  content: "\\f17d";
}

.fa-skype:before {
  content: "\\f17e";
}

.fa-foursquare:before {
  content: "\\f180";
}

.fa-trello:before {
  content: "\\f181";
}

.fa-female:before {
  content: "\\f182";
}

.fa-male:before {
  content: "\\f183";
}

.fa-gittip:before,
.fa-gratipay:before {
  content: "\\f184";
}

.fa-sun-o:before {
  content: "\\f185";
}

.fa-moon-o:before {
  content: "\\f186";
}

.fa-archive:before {
  content: "\\f187";
}

.fa-bug:before {
  content: "\\f188";
}

.fa-vk:before {
  content: "\\f189";
}

.fa-weibo:before {
  content: "\\f18a";
}

.fa-renren:before {
  content: "\\f18b";
}

.fa-pagelines:before {
  content: "\\f18c";
}

.fa-stack-exchange:before {
  content: "\\f18d";
}

.fa-arrow-circle-o-right:before {
  content: "\\f18e";
}

.fa-arrow-circle-o-left:before {
  content: "\\f190";
}

.fa-toggle-left:before,
.fa-caret-square-o-left:before {
  content: "\\f191";
}

.fa-dot-circle-o:before {
  content: "\\f192";
}

.fa-wheelchair:before {
  content: "\\f193";
}

.fa-vimeo-square:before {
  content: "\\f194";
}

.fa-turkish-lira:before,
.fa-try:before {
  content: "\\f195";
}

.fa-plus-square-o:before {
  content: "\\f196";
}

.fa-space-shuttle:before {
  content: "\\f197";
}

.fa-slack:before {
  content: "\\f198";
}

.fa-envelope-square:before {
  content: "\\f199";
}

.fa-wordpress:before {
  content: "\\f19a";
}

.fa-openid:before {
  content: "\\f19b";
}

.fa-institution:before,
.fa-bank:before,
.fa-university:before {
  content: "\\f19c";
}

.fa-mortar-board:before,
.fa-graduation-cap:before {
  content: "\\f19d";
}

.fa-yahoo:before {
  content: "\\f19e";
}

.fa-google:before {
  content: "\\f1a0";
}

.fa-reddit:before {
  content: "\\f1a1";
}

.fa-reddit-square:before {
  content: "\\f1a2";
}

.fa-stumbleupon-circle:before {
  content: "\\f1a3";
}

.fa-stumbleupon:before {
  content: "\\f1a4";
}

.fa-delicious:before {
  content: "\\f1a5";
}

.fa-digg:before {
  content: "\\f1a6";
}

.fa-pied-piper-pp:before {
  content: "\\f1a7";
}

.fa-pied-piper-alt:before {
  content: "\\f1a8";
}

.fa-drupal:before {
  content: "\\f1a9";
}

.fa-joomla:before {
  content: "\\f1aa";
}

.fa-language:before {
  content: "\\f1ab";
}

.fa-fax:before {
  content: "\\f1ac";
}

.fa-building:before {
  content: "\\f1ad";
}

.fa-child:before {
  content: "\\f1ae";
}

.fa-paw:before {
  content: "\\f1b0";
}

.fa-spoon:before {
  content: "\\f1b1";
}

.fa-cube:before {
  content: "\\f1b2";
}

.fa-cubes:before {
  content: "\\f1b3";
}

.fa-behance:before {
  content: "\\f1b4";
}

.fa-behance-square:before {
  content: "\\f1b5";
}

.fa-steam:before {
  content: "\\f1b6";
}

.fa-steam-square:before {
  content: "\\f1b7";
}

.fa-recycle:before {
  content: "\\f1b8";
}

.fa-automobile:before,
.fa-car:before {
  content: "\\f1b9";
}

.fa-cab:before,
.fa-taxi:before {
  content: "\\f1ba";
}

.fa-tree:before {
  content: "\\f1bb";
}

.fa-spotify:before {
  content: "\\f1bc";
}

.fa-deviantart:before {
  content: "\\f1bd";
}

.fa-soundcloud:before {
  content: "\\f1be";
}

.fa-database:before {
  content: "\\f1c0";
}

.fa-file-pdf-o:before {
  content: "\\f1c1";
}

.fa-file-word-o:before {
  content: "\\f1c2";
}

.fa-file-excel-o:before {
  content: "\\f1c3";
}

.fa-file-powerpoint-o:before {
  content: "\\f1c4";
}

.fa-file-photo-o:before,
.fa-file-picture-o:before,
.fa-file-image-o:before {
  content: "\\f1c5";
}

.fa-file-zip-o:before,
.fa-file-archive-o:before {
  content: "\\f1c6";
}

.fa-file-sound-o:before,
.fa-file-audio-o:before {
  content: "\\f1c7";
}

.fa-file-movie-o:before,
.fa-file-video-o:before {
  content: "\\f1c8";
}

.fa-file-code-o:before {
  content: "\\f1c9";
}

.fa-vine:before {
  content: "\\f1ca";
}

.fa-codepen:before {
  content: "\\f1cb";
}

.fa-jsfiddle:before {
  content: "\\f1cc";
}

.fa-life-bouy:before,
.fa-life-buoy:before,
.fa-life-saver:before,
.fa-support:before,
.fa-life-ring:before {
  content: "\\f1cd";
}

.fa-circle-o-notch:before {
  content: "\\f1ce";
}

.fa-ra:before,
.fa-resistance:before,
.fa-rebel:before {
  content: "\\f1d0";
}

.fa-ge:before,
.fa-empire:before {
  content: "\\f1d1";
}

.fa-git-square:before {
  content: "\\f1d2";
}

.fa-git:before {
  content: "\\f1d3";
}

.fa-y-combinator-square:before,
.fa-yc-square:before,
.fa-hacker-news:before {
  content: "\\f1d4";
}

.fa-tencent-weibo:before {
  content: "\\f1d5";
}

.fa-qq:before {
  content: "\\f1d6";
}

.fa-wechat:before,
.fa-weixin:before {
  content: "\\f1d7";
}

.fa-send:before,
.fa-paper-plane:before {
  content: "\\f1d8";
}

.fa-send-o:before,
.fa-paper-plane-o:before {
  content: "\\f1d9";
}

.fa-history:before {
  content: "\\f1da";
}

.fa-circle-thin:before {
  content: "\\f1db";
}

.fa-header:before {
  content: "\\f1dc";
}

.fa-paragraph:before {
  content: "\\f1dd";
}

.fa-sliders:before {
  content: "\\f1de";
}

.fa-share-alt:before {
  content: "\\f1e0";
}

.fa-share-alt-square:before {
  content: "\\f1e1";
}

.fa-bomb:before {
  content: "\\f1e2";
}

.fa-soccer-ball-o:before,
.fa-futbol-o:before {
  content: "\\f1e3";
}

.fa-tty:before {
  content: "\\f1e4";
}

.fa-binoculars:before {
  content: "\\f1e5";
}

.fa-plug:before {
  content: "\\f1e6";
}

.fa-slideshare:before {
  content: "\\f1e7";
}

.fa-twitch:before {
  content: "\\f1e8";
}

.fa-yelp:before {
  content: "\\f1e9";
}

.fa-newspaper-o:before {
  content: "\\f1ea";
}

.fa-wifi:before {
  content: "\\f1eb";
}

.fa-calculator:before {
  content: "\\f1ec";
}

.fa-paypal:before {
  content: "\\f1ed";
}

.fa-google-wallet:before {
  content: "\\f1ee";
}

.fa-cc-visa:before {
  content: "\\f1f0";
}

.fa-cc-mastercard:before {
  content: "\\f1f1";
}

.fa-cc-discover:before {
  content: "\\f1f2";
}

.fa-cc-amex:before {
  content: "\\f1f3";
}

.fa-cc-paypal:before {
  content: "\\f1f4";
}

.fa-cc-stripe:before {
  content: "\\f1f5";
}

.fa-bell-slash:before {
  content: "\\f1f6";
}

.fa-bell-slash-o:before {
  content: "\\f1f7";
}

.fa-trash:before {
  content: "\\f1f8";
}

.fa-copyright:before {
  content: "\\f1f9";
}

.fa-at:before {
  content: "\\f1fa";
}

.fa-eyedropper:before {
  content: "\\f1fb";
}

.fa-paint-brush:before {
  content: "\\f1fc";
}

.fa-birthday-cake:before {
  content: "\\f1fd";
}

.fa-area-chart:before {
  content: "\\f1fe";
}

.fa-pie-chart:before {
  content: "\\f200";
}

.fa-line-chart:before {
  content: "\\f201";
}

.fa-lastfm:before {
  content: "\\f202";
}

.fa-lastfm-square:before {
  content: "\\f203";
}

.fa-toggle-off:before {
  content: "\\f204";
}

.fa-toggle-on:before {
  content: "\\f205";
}

.fa-bicycle:before {
  content: "\\f206";
}

.fa-bus:before {
  content: "\\f207";
}

.fa-ioxhost:before {
  content: "\\f208";
}

.fa-angellist:before {
  content: "\\f209";
}

.fa-cc:before {
  content: "\\f20a";
}

.fa-shekel:before,
.fa-sheqel:before,
.fa-ils:before {
  content: "\\f20b";
}

.fa-meanpath:before {
  content: "\\f20c";
}

.fa-buysellads:before {
  content: "\\f20d";
}

.fa-connectdevelop:before {
  content: "\\f20e";
}

.fa-dashcube:before {
  content: "\\f210";
}

.fa-forumbee:before {
  content: "\\f211";
}

.fa-leanpub:before {
  content: "\\f212";
}

.fa-sellsy:before {
  content: "\\f213";
}

.fa-shirtsinbulk:before {
  content: "\\f214";
}

.fa-simplybuilt:before {
  content: "\\f215";
}

.fa-skyatlas:before {
  content: "\\f216";
}

.fa-cart-plus:before {
  content: "\\f217";
}

.fa-cart-arrow-down:before {
  content: "\\f218";
}

.fa-diamond:before {
  content: "\\f219";
}

.fa-ship:before {
  content: "\\f21a";
}

.fa-user-secret:before {
  content: "\\f21b";
}

.fa-motorcycle:before {
  content: "\\f21c";
}

.fa-street-view:before {
  content: "\\f21d";
}

.fa-heartbeat:before {
  content: "\\f21e";
}

.fa-venus:before {
  content: "\\f221";
}

.fa-mars:before {
  content: "\\f222";
}

.fa-mercury:before {
  content: "\\f223";
}

.fa-intersex:before,
.fa-transgender:before {
  content: "\\f224";
}

.fa-transgender-alt:before {
  content: "\\f225";
}

.fa-venus-double:before {
  content: "\\f226";
}

.fa-mars-double:before {
  content: "\\f227";
}

.fa-venus-mars:before {
  content: "\\f228";
}

.fa-mars-stroke:before {
  content: "\\f229";
}

.fa-mars-stroke-v:before {
  content: "\\f22a";
}

.fa-mars-stroke-h:before {
  content: "\\f22b";
}

.fa-neuter:before {
  content: "\\f22c";
}

.fa-genderless:before {
  content: "\\f22d";
}

.fa-facebook-official:before {
  content: "\\f230";
}

.fa-pinterest-p:before {
  content: "\\f231";
}

.fa-whatsapp:before {
  content: "\\f232";
}

.fa-server:before {
  content: "\\f233";
}

.fa-user-plus:before {
  content: "\\f234";
}

.fa-user-times:before {
  content: "\\f235";
}

.fa-hotel:before,
.fa-bed:before {
  content: "\\f236";
}

.fa-viacoin:before {
  content: "\\f237";
}

.fa-train:before {
  content: "\\f238";
}

.fa-subway:before {
  content: "\\f239";
}

.fa-medium:before {
  content: "\\f23a";
}

.fa-yc:before,
.fa-y-combinator:before {
  content: "\\f23b";
}

.fa-optin-monster:before {
  content: "\\f23c";
}

.fa-opencart:before {
  content: "\\f23d";
}

.fa-expeditedssl:before {
  content: "\\f23e";
}

.fa-battery-4:before,
.fa-battery:before,
.fa-battery-full:before {
  content: "\\f240";
}

.fa-battery-3:before,
.fa-battery-three-quarters:before {
  content: "\\f241";
}

.fa-battery-2:before,
.fa-battery-half:before {
  content: "\\f242";
}

.fa-battery-1:before,
.fa-battery-quarter:before {
  content: "\\f243";
}

.fa-battery-0:before,
.fa-battery-empty:before {
  content: "\\f244";
}

.fa-mouse-pointer:before {
  content: "\\f245";
}

.fa-i-cursor:before {
  content: "\\f246";
}

.fa-object-group:before {
  content: "\\f247";
}

.fa-object-ungroup:before {
  content: "\\f248";
}

.fa-sticky-note:before {
  content: "\\f249";
}

.fa-sticky-note-o:before {
  content: "\\f24a";
}

.fa-cc-jcb:before {
  content: "\\f24b";
}

.fa-cc-diners-club:before {
  content: "\\f24c";
}

.fa-clone:before {
  content: "\\f24d";
}

.fa-balance-scale:before {
  content: "\\f24e";
}

.fa-hourglass-o:before {
  content: "\\f250";
}

.fa-hourglass-1:before,
.fa-hourglass-start:before {
  content: "\\f251";
}

.fa-hourglass-2:before,
.fa-hourglass-half:before {
  content: "\\f252";
}

.fa-hourglass-3:before,
.fa-hourglass-end:before {
  content: "\\f253";
}

.fa-hourglass:before {
  content: "\\f254";
}

.fa-hand-grab-o:before,
.fa-hand-rock-o:before {
  content: "\\f255";
}

.fa-hand-stop-o:before,
.fa-hand-paper-o:before {
  content: "\\f256";
}

.fa-hand-scissors-o:before {
  content: "\\f257";
}

.fa-hand-lizard-o:before {
  content: "\\f258";
}

.fa-hand-spock-o:before {
  content: "\\f259";
}

.fa-hand-pointer-o:before {
  content: "\\f25a";
}

.fa-hand-peace-o:before {
  content: "\\f25b";
}

.fa-trademark:before {
  content: "\\f25c";
}

.fa-registered:before {
  content: "\\f25d";
}

.fa-creative-commons:before {
  content: "\\f25e";
}

.fa-gg:before {
  content: "\\f260";
}

.fa-gg-circle:before {
  content: "\\f261";
}

.fa-tripadvisor:before {
  content: "\\f262";
}

.fa-odnoklassniki:before {
  content: "\\f263";
}

.fa-odnoklassniki-square:before {
  content: "\\f264";
}

.fa-get-pocket:before {
  content: "\\f265";
}

.fa-wikipedia-w:before {
  content: "\\f266";
}

.fa-safari:before {
  content: "\\f267";
}

.fa-chrome:before {
  content: "\\f268";
}

.fa-firefox:before {
  content: "\\f269";
}

.fa-opera:before {
  content: "\\f26a";
}

.fa-internet-explorer:before {
  content: "\\f26b";
}

.fa-tv:before,
.fa-television:before {
  content: "\\f26c";
}

.fa-contao:before {
  content: "\\f26d";
}

.fa-500px:before {
  content: "\\f26e";
}

.fa-amazon:before {
  content: "\\f270";
}

.fa-calendar-plus-o:before {
  content: "\\f271";
}

.fa-calendar-minus-o:before {
  content: "\\f272";
}

.fa-calendar-times-o:before {
  content: "\\f273";
}

.fa-calendar-check-o:before {
  content: "\\f274";
}

.fa-industry:before {
  content: "\\f275";
}

.fa-map-pin:before {
  content: "\\f276";
}

.fa-map-signs:before {
  content: "\\f277";
}

.fa-map-o:before {
  content: "\\f278";
}

.fa-map:before {
  content: "\\f279";
}

.fa-commenting:before {
  content: "\\f27a";
}

.fa-commenting-o:before {
  content: "\\f27b";
}

.fa-houzz:before {
  content: "\\f27c";
}

.fa-vimeo:before {
  content: "\\f27d";
}

.fa-black-tie:before {
  content: "\\f27e";
}

.fa-fonticons:before {
  content: "\\f280";
}

.fa-reddit-alien:before {
  content: "\\f281";
}

.fa-edge:before {
  content: "\\f282";
}

.fa-credit-card-alt:before {
  content: "\\f283";
}

.fa-codiepie:before {
  content: "\\f284";
}

.fa-modx:before {
  content: "\\f285";
}

.fa-fort-awesome:before {
  content: "\\f286";
}

.fa-usb:before {
  content: "\\f287";
}

.fa-product-hunt:before {
  content: "\\f288";
}

.fa-mixcloud:before {
  content: "\\f289";
}

.fa-scribd:before {
  content: "\\f28a";
}

.fa-pause-circle:before {
  content: "\\f28b";
}

.fa-pause-circle-o:before {
  content: "\\f28c";
}

.fa-stop-circle:before {
  content: "\\f28d";
}

.fa-stop-circle-o:before {
  content: "\\f28e";
}

.fa-shopping-bag:before {
  content: "\\f290";
}

.fa-shopping-basket:before {
  content: "\\f291";
}

.fa-hashtag:before {
  content: "\\f292";
}

.fa-bluetooth:before {
  content: "\\f293";
}

.fa-bluetooth-b:before {
  content: "\\f294";
}

.fa-percent:before {
  content: "\\f295";
}

.fa-gitlab:before {
  content: "\\f296";
}

.fa-wpbeginner:before {
  content: "\\f297";
}

.fa-wpforms:before {
  content: "\\f298";
}

.fa-envira:before {
  content: "\\f299";
}

.fa-universal-access:before {
  content: "\\f29a";
}

.fa-wheelchair-alt:before {
  content: "\\f29b";
}

.fa-question-circle-o:before {
  content: "\\f29c";
}

.fa-blind:before {
  content: "\\f29d";
}

.fa-audio-description:before {
  content: "\\f29e";
}

.fa-volume-control-phone:before {
  content: "\\f2a0";
}

.fa-braille:before {
  content: "\\f2a1";
}

.fa-assistive-listening-systems:before {
  content: "\\f2a2";
}

.fa-asl-interpreting:before,
.fa-american-sign-language-interpreting:before {
  content: "\\f2a3";
}

.fa-deafness:before,
.fa-hard-of-hearing:before,
.fa-deaf:before {
  content: "\\f2a4";
}

.fa-glide:before {
  content: "\\f2a5";
}

.fa-glide-g:before {
  content: "\\f2a6";
}

.fa-signing:before,
.fa-sign-language:before {
  content: "\\f2a7";
}

.fa-low-vision:before {
  content: "\\f2a8";
}

.fa-viadeo:before {
  content: "\\f2a9";
}

.fa-viadeo-square:before {
  content: "\\f2aa";
}

.fa-snapchat:before {
  content: "\\f2ab";
}

.fa-snapchat-ghost:before {
  content: "\\f2ac";
}

.fa-snapchat-square:before {
  content: "\\f2ad";
}

.fa-pied-piper:before {
  content: "\\f2ae";
}

.fa-first-order:before {
  content: "\\f2b0";
}

.fa-yoast:before {
  content: "\\f2b1";
}

.fa-themeisle:before {
  content: "\\f2b2";
}

.fa-google-plus-circle:before,
.fa-google-plus-official:before {
  content: "\\f2b3";
}

.fa-fa:before,
.fa-font-awesome:before {
  content: "\\f2b4";
}

.fa-handshake-o:before {
  content: "\\f2b5";
}

.fa-envelope-open:before {
  content: "\\f2b6";
}

.fa-envelope-open-o:before {
  content: "\\f2b7";
}

.fa-linode:before {
  content: "\\f2b8";
}

.fa-address-book:before {
  content: "\\f2b9";
}

.fa-address-book-o:before {
  content: "\\f2ba";
}

.fa-vcard:before,
.fa-address-card:before {
  content: "\\f2bb";
}

.fa-vcard-o:before,
.fa-address-card-o:before {
  content: "\\f2bc";
}

.fa-user-circle:before {
  content: "\\f2bd";
}

.fa-user-circle-o:before {
  content: "\\f2be";
}

.fa-user-o:before {
  content: "\\f2c0";
}

.fa-id-badge:before {
  content: "\\f2c1";
}

.fa-drivers-license:before,
.fa-id-card:before {
  content: "\\f2c2";
}

.fa-drivers-license-o:before,
.fa-id-card-o:before {
  content: "\\f2c3";
}

.fa-quora:before {
  content: "\\f2c4";
}

.fa-free-code-camp:before {
  content: "\\f2c5";
}

.fa-telegram:before {
  content: "\\f2c6";
}

.fa-thermometer-4:before,
.fa-thermometer:before,
.fa-thermometer-full:before {
  content: "\\f2c7";
}

.fa-thermometer-3:before,
.fa-thermometer-three-quarters:before {
  content: "\\f2c8";
}

.fa-thermometer-2:before,
.fa-thermometer-half:before {
  content: "\\f2c9";
}

.fa-thermometer-1:before,
.fa-thermometer-quarter:before {
  content: "\\f2ca";
}

.fa-thermometer-0:before,
.fa-thermometer-empty:before {
  content: "\\f2cb";
}

.fa-shower:before {
  content: "\\f2cc";
}

.fa-bathtub:before,
.fa-s15:before,
.fa-bath:before {
  content: "\\f2cd";
}

.fa-podcast:before {
  content: "\\f2ce";
}

.fa-window-maximize:before {
  content: "\\f2d0";
}

.fa-window-minimize:before {
  content: "\\f2d1";
}

.fa-window-restore:before {
  content: "\\f2d2";
}

.fa-times-rectangle:before,
.fa-window-close:before {
  content: "\\f2d3";
}

.fa-times-rectangle-o:before,
.fa-window-close-o:before {
  content: "\\f2d4";
}

.fa-bandcamp:before {
  content: "\\f2d5";
}

.fa-grav:before {
  content: "\\f2d6";
}

.fa-etsy:before {
  content: "\\f2d7";
}

.fa-imdb:before {
  content: "\\f2d8";
}

.fa-ravelry:before {
  content: "\\f2d9";
}

.fa-eercast:before {
  content: "\\f2da";
}

.fa-microchip:before {
  content: "\\f2db";
}

.fa-snowflake-o:before {
  content: "\\f2dc";
}

.fa-superpowers:before {
  content: "\\f2dd";
}

.fa-wpexplorer:before {
  content: "\\f2de";
}

.fa-meetup:before {
  content: "\\f2e0";
}

.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  border: 0;
}

.sr-only-focusable:active,
.sr-only-focusable:focus {
  position: static;
  width: auto;
  height: auto;
  margin: 0;
  overflow: visible;
  clip: auto;
}

[class^="fa-"]:before,
[class*=" fa-"]:before {
  text-decoration: inherit;
  speak: none;
}

li [class^="fa-"],
li [class*=" fa-"] {
  width: 1.25em;
  text-align: center;
}

/* Common styles for all types */

.vclCallout {
  padding: 1.2em;
  margin-bottom: 1.3em;
  border: 1px solid hsl(0, 0%, 63%);
  border-left-width: 0.35em;
  border-radius: 0.25em;
}

.vclCallout h4 {
  margin-top: 0;
  margin-bottom: 0.25em;
}

.vclCallout p:last-child {
  margin-bottom: 0;
}

.vclCallout code {
  border-radius: 0.25em;
}

/* Semantic variations */

.vclCallout.vclInfo h4 {
  color: #31708f;
}

.vclCallout.vclInfo {
  border-left-color: #31708f;
}

.vclCallout.vclWarning h4 {
  color: #8a6d3b;
}

.vclCallout.vclWarning {
  border-left-color: #8a6d3b;
}

.vclCallout.vclDanger h4 {
  color: #a94442;
}

.vclCallout.vclDanger {
  border-left-color: #a94442;
}

.graph::shadow svg {
  font: 10px sans-serif;
}

.graph::shadow svg  text {
  user-select: none;
}

.graph::shadow svg  .axis path,
.graph::shadow svg  .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.graph::shadow svg  .background {
  stroke: white;
  stroke-width: 1px;
  fill: white;
}

.graph::shadow svg  .node {
  stroke: black;
  stroke-width: 1px;
  cursor: move;
}

.graph::shadow svg  .node.reaction {
  fill: lightcoral;
}

.graph::shadow svg  .node.pool {
  fill: steelblue;
}

.graph::shadow svg  .node.pool.clone {
  fill: lightblue;
}

.graph::shadow svg  .group.compartment.cell,
.graph::shadow svg  .group.compartment.cytosol {
  fill: cadetblue;
}

.graph::shadow svg  .group.compartment.ext,
.graph::shadow svg  .group.compartment.extracellular {
  fill: salmon;
}

.graph::shadow svg  .link {
  fill: none;
  stroke: #000;
  stroke-width: 3px;
  opacity: 0.7;
  marker-end: url(#end-arrow);
}

.graph::shadow svg  .link.reversible {
  marker-start: url(#end-arrow);
}

.graph::shadow svg  .link.modifier {
  marker-end: url(#end-circle);
}

.graph::shadow svg  .label {
  fill: black;
  font-family: Verdana;
  font-size: 25px;
  text-anchor: middle;
  cursor: move;
  pointer-events: none;
}

.graph::shadow svg  .guideline {
  stroke: orangered;
  stroke-width: 4px;
}

:root {
  height: 100%;
}

body {
  height: 100%;
  margin: 0;
  padding: 0;
}

#search {
  padding-left: 1.25em;
  height: 3em;
}

.sidebar,
.inner-sidebar {
  background: hsl(0, 0%, 20%);
  color: rgb(255, 255, 255);
}

.sidebar .vclNavigation .vclNavigationItem,
.inner-sidebar .vclNavigation .vclNavigationItem {
  color: rgb(255, 255, 255);
}

.inner-sidebar {
  background: rgb(77, 77, 77);
}

/* Make clicks pass-through */

#nprogress {
  pointer-events: none;
}

#nprogress .bar {
  background: #29d;
  position: fixed;
  z-index: 1031;
  top: 0;
  left: 0;
  width: 100%;
  height: 4px;
}

/* Fancy blur effect */

#nprogress .peg {
  display: block;
  position: absolute;
  right: 0px;
  width: 100px;
  height: 100%;
  box-shadow: 0 0 10px #29d, 0 0 5px #29d;
  opacity: 1.0;
  -webkit-transform: rotate(3deg) translate(0px, -4px);
  -ms-transform: rotate(3deg) translate(0px, -4px);
  transform: rotate(3deg) translate(0px, -4px);
}

/* Remove these to get rid of the spinner */

#nprogress .spinner {
  display: block;
  position: fixed;
  z-index: 1031;
  top: 15px;
  right: 15px;
}

#nprogress .spinner-icon {
  width: 18px;
  height: 18px;
  box-sizing: border-box;
  border: solid 2px transparent;
  border-top-color: #29d;
  border-left-color: #29d;
  border-radius: 50%;
  -webkit-animation: nprogress-spinner 400ms linear infinite;
  animation: nprogress-spinner 400ms linear infinite;
}

.nprogress-custom-parent {
  overflow: hidden;
  position: relative;
}

.nprogress-custom-parent #nprogress .spinner,
.nprogress-custom-parent #nprogress .bar {
  position: absolute;
}

@-webkit-keyframes nprogress-spinner {
}

@keyframes nprogress-spinner {
}

@font-face {
  font-family: 'FontAwesome';
  src: url(data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAS1oAA0AAAAChpgAAS0OAAQBywAAAAAAAAAAAAAAAAAAAAAAAAAAP0ZGVE0cGiAGYACFchEIComZKIe2WAE2AiQDlXALlhAABCAFiQYHtHVbUglyR2H3kYQqug2BJ+096zq1GibTzT1ytyoKAhnlGvH2XQR0B9xFqm6jsv/////kpDFG2w7cQODV9Pt8rYoUCGaTbZJgmyTYkaFAZFtCUREkKFtVPCsorbhAUNA1HuRggbAO2j72UBAaO+EokdExs/1s2/5o1Kiiwimf3Fl5lPJKaenrF62Fznwl24G3XqwUR4KiM7gSbp6V6LraldwKxM2QRIqecFxZciCUTN9Q9A6NG4N0pSnLEZjvE6c2UsJeIlMLTH7xWVLXQ1hSFQmKNIGO5kb6eVxbv+g3bqHirnwdc+C7jHEeo027jiVLyf8XLtu6DiwL+oT3+EzQdP8n9hCQyU0dLBEVY/eIK2L6xNeH50/9c/le2CSFhtd6Lgf1bcWgDPxoJmdi3vDhdu2H8wEOySeKDzajOrC7w/Nz622jYowx2KhtMCLHghqwvypWjKiNHqNjoyQsMEFUUFS0MRID+/SsPAvtO+3z0mAQ5rYn8UgOP/Fzzqk6kQ9ORJ+o/KkQSRGkJIwEVBSLW4GCYjSKEc38f+rs7yyvzrzX772jYmw2kboLSUzpaX3bjCbgNOOUbSwnyxbL8yO916Wzf1J3AaJidcC2LEuWC8YGm+J2iwPbCG1fLcDA5lxIi537jkhI/qrzk+oHxsI/mJbTbfMLOVCIrdgpOedKqIYkxr2InOex9Dj46Mfazs5+uTvEchWNbr89JBEatR+UTmRkbhshJ66m8OM7s/SsOJm8J9lOpu0eIX8tGAZKGcq20y7g2PqR7livPQwsEgQOkJseImA6GKL/Gw8JCSB7je+e3OC8EstLISefAKEtRkiUnAmJIyR+m1pfhLmdEBK1A041VlU4RsivHKKOJRRQ1Pvdq9rb+wYIDIZDcAgCJARRGaK0u9oQnXKs7KLKvZvuumu7a9obpzPZtxPROlIRJR4QtoEye/SH3qn1kh1oJbspOMkR9gD48QEPGApJTEuQNnb0I+37s+7+Biw70KY2h6BOmjLOaHa3Dw4I/u9/zf7rDE9Pkad0IxaFBuJ4VInvqkJmAp2ehHFeFiOcrp+WP3v+NWKKSeLgJS1XWpDruWKkQaMTDF7kMc3ZbjUZ+a7pitemTlGdWSf65t3NEpYE/JFTBNwYH6YhdCIgBmBiM+n3JZMH9O8zNbsCFNFmdjurndXObM6s7jmcOmpnZj9ncpv1cP94nyCAD3wS/CAkCCBlEpQcEpRaFCjFFCR3KFpyU5DodiubWtkcz9Zx9k2i7B6b7s3q3ZltPyZzW/bldJlTklNqjqc5nK/j9z+tfNrqDfHwxT5HDswGLBBiRNW3Xqn0ql6px90bOmyKM469TkGaYKs1C5wyNrMBTPlwU/IJQd+nL1XrCsLWmLS8s7QnOVy0p9WGdLiFEK8h3/b2+rca/RuBbAAGhSBQTVK0mpA5boAKzWAVEhMoyhBA0iBIeSlN0mRNyg2QHDXp1KQTSCfSkZoc8m1TPPro23Ema7wpXM97O+4xxcNt+QebONt74YvVWIQx3S0zx5qQkSmCQiiEkSz7JfWTELC2to0ExAsFBd3923efb36+mHTt8EhXOGyQ1FoRCXKk47//PWWzGuzfMSvmBwUvyY4xVz/WsHLuEg44OVBMxtIBPnVvOSDFGDEgdMOYq8N1Y6edke7EQLP5XUsUEFLvf2JO/7uSdvuTtNQaqqgouCKKg3nrvbt7HAxjrv+P5vNzY3qmGSaucDWn5QShLGqzbiCia07EIYMug25e9/hVdR8AQHz8GD92tT73B7kdudwckXIYVWHcSFIgCxqPEPq51/jVkQCT80kNRInfy4tRv71+cOkKgNyNOzu4bvn5jUwYFyShdPkJOgloRkNZoe3eVE+gRk4dTn59F/ExImCzqPyf2GHPB8sozT9IIBGXlocfxFyWzeV1yjATTNS19fEnte26vb7NlFBibm1Pv5jrtt39jb8CGEpsiz8CAQie5XOr5wWIMCwOOIx4yULy+va+QhnH5ZFGiRAUn1/fG1JpWh34/7fUfmUjFWqwEbF3/WhPYyomRjYMrFlxwZIFe4l9P8nzPvd1Hvu2LvM0Ds5oJQVnlGAEpybX5yC4yxIpqaxSNRjlSIx9saf/y6Swa9yp2xyQJ0qZ3k+/AEmI2xO2nV/vs38FkXFPYifWSMefAEJZRU2jAxw2yHaEgTWqEE5KDeUVAU+ITgcaRgtOeCgxkjoBXLrfq0Pga45joGI4BVH0CRNk4RhbTBQoZWwcKzJ1Le7QYdaYZKKONTuiTiTU9iKiSKqPEKtTRrpv6zJpqCKK2VyzaAQ3SYz2oDxTQ08CrRm4lsiQSKAe4kV3IQEuH9fp/SFCUxJDqmcexJ2JY+MOueRzKtWnc4koNW2UPXHGyoplovvxWZELJOtcPhBmTjiAcZeMeOojdgqlNnVt7wngGZ2wYNtOTS1KAFz0EEa3x3LpRAKAHrVa0zCTByMn6qWIbuwR0kdqTILahlgUG8qMokGqnfFnWXOZKrJZytwHx17ZtZg7ItgdJGhifz25FhnPmxOYMN52SDyXVnZ/gWObXwBcWYoD7KPodztkQhYCg4sDToOEMxshJM7n57Tn4t5JfFCYIH4TJhPkA2TFLsgDG9Sw6QItYQfz+mEZCSsrwhOSOboubVL46TTjY3mvnrkji1XVwkZX7gh1vQ3cCRdpL/Ccr5RmfoA03fBsg+sOWFP0OcOEG/cxRZ3wvTNAkP3aaxOI3BVAFycjo7y2Y6y92W7qqSC68RXvU187rCX77kmK0MEru/gu80wa2EMCeLHr7h4evvrqhrF3CdrNVtuCgIG6qOGkwMP5RXhmfkhgvekwH7whZJToQFF7T2gxiRcXsUjBtkbDq9V6cxqNN/Pdibazxpx0D3J2zOip0mudu4ZoZVMzt9uHdpk5hHF8q0+C75dLKZVVXPKWQdIlo7m7AsRvHntsPIbbS7j/up3NjqKkjmmzj/FI60eASYV6nT02mldXbzDr2Qt8Fd4lQfcaamREKSENgKlwd67I7l+Cs+s7uPGm22OXRCPp/8uBTZDA3k56nPIFtwRwsF6PQ0R43sJ4aimENU/IOfsNoWDR0kVEWO548Y0g3ZJHVcjA7cuvDsSZqgSp79baiZwuJQ23v7bOiLF+DOPx+j3/CBoWQxNvpikNRoQ388rnJFqk/Si3Z8Hrb0Ktpw3bxpzAQN7lJvLD2mXuewbq4uWOo6AIbKCwZopfxlJ4mU5bp10MrpsHOGAtM5lztKbBknt/UGoB3hm4V3VjOe+FuK6phBtbPh3qLZ8uRKLcjln6H/ebFQ+AHmSHDM/C2AeisisYXnuTrrlD7veJsW3gxNnwLKaxQE48spAd2tnQ+PKJrx9/Di6NlFbx5k3w2hFT7CvTXESeK6LaUqJ80Ta1C+IncVxU4N0CppXzHB45h0SEBlg8fyTtcImA3gciu+mFppL8JJvStwveLPlwH7tz+aVU084a3f6vYrv/1E5rSZEeX+ahYNXmCkboiB/qV5OfVv+UJdnRdwitfqmkxETUkNnCy90q87N4afIeuHlbclqqhwCZW1MltEeb3BhzYEY844WjhbOsIKLBVosr/vMhK62W9/WKuNiNizl5n2vFwWZikTgy3gZz3n1sO1spZSTE+IlUnYaWa62DkuApmnaPtqk5rAGE4xune9N1E/J1j3SPyN6zQEXj9D58Q/baPFw0JQiXUnbhDKW26eXE6Kra9EDXukPMOFyR+H4pFCNrfL65LmHrb6q62gO6MDBHlHEwHRQl8fzwE6GZaHCLqboNTP+c3iKMKz6O7Oa1JaoLXk3LiphOmnPTyAZxjrQ9lRKwD77u5eSmhrBLETRy5y0q7+cl6NpoI9clO3BQ6aaUaNZDPffO+traDZca5SYUKaliYYTGS0z4QL/5nuR0uiGifjLtU11yWWy6WjbQM9GeSt5vtJhPo1b1O7loJmdPNZJSVIgvffnB0sZ7rqXyFxdBWtImhxlT8+LZdNjK+ZzPAwvNrwHpolDq60OhpBSiMBMItLZELPtwYnDQt9R6KacgXYBJ9z4aAA5RXEJswSK6l14zUj5y/Sr7uwRDPsAeHoOn4Rd4UFW6eh6tfVkRPQIP9cyVFrx99dC2xxCaGQrnDRw2LWAvIkgLCm+FJpJEl0kw/0UyWGGJlS0fqXsONcCBmTwNLH2U0RNgYDb6x+0YkGppounYaW08VXVqWala+moOQlxAjGfLM0VqZnCW+JifOrra7eoQV9vHrp+62d+zjpyUznClxLMzYW+v+xGBMYhkYYv4IJwDt92rpf2ImUqC17I/IGrOcTeuvk3D5s5mZplZtWbLHNRzAh6wGySbnAmElUj9kRTmrGyllvW5v8CIlyglLptyBuPSdz8D8r5tPX4LgnmyY1mRYmcpPMtXhCAvVngW2muptJIk5/OPDELwcn7xhgGn0/A5E942jTDRJv6ZX3ZNAFnCJYST0p175kV/iTY8w+mVx8Lt2yWLJas0rYuO36BP3kDv807h+QihgqoiWrcY309Ee3UzUw+Mx1eLTbCVUqftM3M8w/UZp5HYsw2jgKbxsFxJDjCNqy6gxS0y3a3sz+OErTuvCeyDMNUOtn1Oqy9i9fYajk57hEmZs3xiX3LEZfidX3BTaYPjyhQPPhIn3HesNfzb+lJGLNGHiCUeU1mWhLvGV2ijNkxfaeyDoz2am75pMfEz/llJN064Q3CNScnwxJS+wxIoD6hyr769MKvde2qJGfe6hXKLS7yemeXQom8pbNnE9IczbmG/VDF/XKfDSRlFKOltvfeyvd+Dm5PCRPRs+qx/ZbOzx+Ykw4Xfd1ieiMxVrPwoQJWErvdN9WEibqwOLOQqdkezHZYcicyoE3i5iq4+lUfZDFOCEYOA7r1nwMyJIpRRy3akYhQwKnrbyFBF9HnByYmMPzevJBMLwY7Y8CWeHYlHh9LR5HDJZFnIJmbiByHt+8dhNpSOfKgIKb8OO3U3I8IzyTSQbUrEs9v4Cm/39olP+HCtyIGidjhqoOqZ/HgoS8svWtxkuwOKj3jJxYP9bTdW0V9cp2bXTOU3DHCbWPN6Fh7shUg3vi2rDpa1LCgxS0hirWWQqCxyLRkco6ARcKFMy+/G7aAzPeZUmALGMql0kTLZvFiWazqptLX/CFqANcDPcwWJDnAOiNJTc1SruAUa1es6Ll21t0QilECw9S22RbfMkQYhEJQTQY3wkTK6ybYt8EYZfbHLkoAyQseDko1RGpnVF+AFKXTFw6d82iM0hHzcXPfjqIDwyGC3ZmMQLLafI9QHZ4npMTrZLdYWq6G5dHkXINtd+4eY4OQyr1p+ArGEAC4p4+mu8/Sz1wLHjODWHrWh3CVSpUuNmKu/KHmQAmCROJa2QxrXx9aN+rfL93qTuh2KSy1OjgyE8wEO9WBeK6b1i55uCKKoizO528+0GP4C5fSAnRaVVIHyM4J0UeHYo6kGCDQ8PjpKMMOIJeXdkVphYmDovQPqds2s/IZh9lQvWgEC+hScYd6dx9CTSWkJm1cxkBb88f2DX6mQED4pw/qXvkgilIr54+lwkusLg3w3bRRGtV5az81+ZosRFzBK8epeAMlJkRfcM1a5IekYpdx70zxlzC89znBg2tcM3nGtngA4XvbU2dPBSzjM60/NOfZ3MNPqWpC0fB6K3AR2P5FuwxQJ4Awzl4FmgSH9y9+30X6V/FSKIB+n5B37wcryIErTm6X7hAcRHN811wvBcKaPFLpWCbzfM4fLq7jF1/MPLj3G8czugS19p9xbzmflUuE1q/Od827so0I44ZH3g5kzLrsI0jgUCVlnoSMw3ya4va9ThC8uZmdcChpF4mbnfQ6QyCxrh6KU6ZNn/AYU+yQDuT9YWZMHKo/6lKm6Ebwxr5BwrZdFKL/X6/JSU5KkUbqYdJ7uAzYsoFHjalwI8OM8CC9dTq5z+80dpTvNJwwYSFhdjkWYMh45kIdkpmtZ/Q3ZapCOwlI20dTt9wNREiGYygDq7vcgVoa7mQolIggVXtBgl04zT/KMog/6hoOsW/EddjrgyoQ62ehe2pxy17/nEUDq0uwKjUbFX67XEeUBCE5jzELSF/H9wzhwo1xpr6K11zfP7otn5a0DKu6P0c39LINDq50awg7hW4c2tFSSP7q6tRaFJfJ6+8VAAQYYakFwQk418J4iNFSepeD0IpZ9MHVK9IePnpbInH4z9h7ZDtF7fQJ1V/aM4O5Nkx5q+jnILYJdE/WrnRGZJ2xTsiAv8FI+PKUr50+fldvYH2VCI5VCY9Ia2cAC6GpMXBESo8QtvlpolVvX+kk8jar8D/GEGHGodt5+lmtdm0fDztVURL8/U6nL2dYvGsYt1Ncl3ZKJlNnoNwyI/nemaXxDFstJocRx8XdjqIBXAZsUeAyasSDPDC83BIF4rIJITy+u5bUd8G9dkZ4PlEddinmP34Pr/If7I4WHHzepj2LN4ySTdMccqlLbJCAGvpjpf13jtGE3G81Go9Gur7KPLG4hcsvfSXwywBC847g46pJ4/zbnmWdTpmixCbKTUl5ek0Qu+HiKTdFNUz/mvJ4nR/oj/H7hK52susTsCHY0imQhRnlU3DnxLbJmVmE3aPtCrssXNP6rn5boFyypMrzGicT9FSZ2VEhNcXDwNBQ/AlJctL2yqr5YYTyR2DQQ7pYcQE1prEjURF++6AmbRRFnqs9SiXmxTZrT0WxU/tigSt2uDauWeQ9jys4imUhK9CwgNop19i/atJviDq2dBMAPi5TpiXmOAJdWy9nmbkpu259IXFDFUqNCZHzTFDS5X+iOJGvunMvGwMYuuZp3EuqWyhvCmRQBSaBwU739JOT8HJZ8fWrO1vQ5yNrkpOkTw/4RoW2HfIMx0d+Ynre3/G6+OTODOb4fAevurJDUNXECU/p8hpufeFftORPa3OzN6kKyllZaIbqZuMttp0sv+0xuO2mr7nWz7STmFSrOdDMQ1s22E4zXQH0AFLCktEJ79Vnv4rjkn9SRlBR6qzJK53VA32H3FlwZTfuJhw5SN2+z8xhkeuigFaigm2Wz8jfeLyQ0XV6Vwb8ya4ocaCSMEz0cJQCJ5THuSedC0tiDIIPPSHwIAvhOLlvJTVwLTJeM+2La7drpMU1n5vIaOp1OVi5fMLEALJ4rFuEsuKRo3XQ3tGw4jXN+SVZeDU7ly7xN8rLDf/jYkWrk3NmDLaIJb9yuxa9R5MFvEFttf4igauk9cgOc/G0+8X56NCRNmuEXG316INXvm4BzAItoIiKeh+x1N7dWe1LDu92mALhPES2ehUQ5VtbZpWeGScqOS+xMZ9u2QhD/VA+o81C1J4dLF8/KzKbvCg5xVwWE1pLzM2W2s6USBP9w5IYmkJaI25KJ5kyLGGhws6qn1U6DYVOuowx3+aEKJpjU4oU7ZSiHLC0CN3bKeKMtv9t3JFepF89uWPNVn56HhbiJ6vfGdDiJmxG1kZkDWecRiro/S02fY3S7WdiDvnAq1YeO+okFi+It7YQc7svQkWZMrHzCW25MiuecDX00iXs12RjpoKCjM+GnjB0VC4huirCUJCQsK6NETgfUhC1I7VY+mNdIpo6Y2vlPc1wItwX/lS3RO8BXNgBO+JVNid04sp1GaZWR1Du+jaU3GWvzMrE2JQLWkswPHGFdLDohjcqy2r1FLB2f3ntVhP4BC25hd7ux+YVOZ6GGLq3ySQc5cjpqoIQV/5KMGrA8SRNFtTHwYCRgTGJyx5KEgded6s5dEeV44h05PVIZdiYqUTXogAQwen8e88v4eTyI4AHqg2BNfPbUmZpkT4bZpWlaruMZxSSu7hm7KyMeS0jIRgqNw+nE6u2+gwCnjgnuyBj4iR+njyktCb4GOk0ky3ljoK5FwCVBaZWSBTJdlpgIzGzltqiQiRyaGc04hkkavHmy0gVaF0dKs4MaogauXNUeMhrWmVhiGL9Mvvbwn0nCQS39R3JSACHNMKAToNtMK8BRaKpT81nU0hPX8lO/Nf1fHtgopQYOcG9GmqdUiYcRryNrHE7bvupsfHKHbgazZNdIoAceltx5E9uK5vnu5Mgm24YXeONwsMH34eVb6RY4RxqG/tlkdKyirKOxeuywg9mmBgk4tLRCva5LUCJAMmWMZQPmlAuseeYeeOenHtpqvbicBpVKS8KIaMFYxaxC7H3qEaY2CPnDov+1YD+1aRCRKrxbOWUrYtFWTO9hTM2ZE7Omn+lkDAJCWXAus8+ICsZuXDTs57OFxqSK3B6NZOwRPHeg31ciBgXP0z8gnye5TyUSj2EBMhlO/zkfi60sud+fobYP6iGbxeJ/LtN5f5da+a8l8jT2VcT1XvrLdaDPhuJnoCkCTSWWAOdD9c4aVumpB5qeyk0hetQmkJ287dl8FkTCLKZp9X5SLCWx+nxPIr772Qzkzx1oXDMrf6Py/GGrvRqc4ucEgIOeBYjQaTiTgh5cFCQDITGZTIrlYTZztg16EitNwlKtYufSF18Ka+C1dstqxN3pjRtV+K/oo5ItgsNqWPpHdB+VC5i/wKaVYph+iMuawJMb6pa6d3TR+a2KzZ2nUxJrUNYy/4ygKD1jdnTzoiKeWzOZyRcmtq1o6kROBYgIPbfyiI6LUMmb9EG0RxSS+cInE1/oUiOoxk06LtfsEZ8zgAnF7tZ0Sn4XnOQzend4IMCU2DuYN7rpAk+kHAs4nMlZKQrJRFNF+K6E3y+ApBPUzDeXaQ/gDI0hd3nKNsDqtCSgE404RTDqVGHejPt8QAjG/w1n+urXD/EuO23JHQe07zngOcFz3UhyTB43JqqkB5KRjjMbQnME4I58W28QASYSb3XaU2f31a0Yrit7oUFFv9/la1riCaQiTuKKZOoZNYOiOpqYSVa1otqKlT6rRu1irEuFx86oZikqY5amRzU888xDoJgAn5UuZ/QVXQSo669rlpIKGbalgRcgQTDjvi2+09mjFqapdn8EhlQguAUGD2Q0SyioFsVZcWCyqpsodd3leyy9OjAqJHwy7A6DmosvBEm6yyyTYEW8hujYFPF4UBuusyNxhLCvz8xgAJvgL+s66oDI0tPWJzuN2YlWBocRRCnLtAzOC3LJ/OOP9jg5vneifVsB+oZGrIjLCOui+d6cF863Dpy+oR0r5dLCmmieS0jeXODHmlWKjh2o5KyCSsBWJHBVapl8YzDL7tx7r97HTPPrQavaP+hW5j2nNI3y71O6GcW0dGD1xcZkmf+Jb/zZZKViBlVQBpQXzALwSqV4E9FnpK5KUvhynU+Fuc9zCfMdxsGRodoYNE13mKncHg0P6CIi9jQUMvfh6OBgTcQa8US6L04hidV2gjPVubfygeEujBVmK5NAeE+XVshx6ptqXtdD36qpS22u958RLOKxOEgEOYxaqKw8JrhvtoUfKNFA/7BrqfEe39ZNNZvzH42hXbFNhbhVMgw9EHZwQjZEWGpgqXKq8jz1d5XGMeaZWdA61SDnb5E8vwA5ojuMAZ34jkbA1fqTJBw7Mtac12q0sRD63rrseCwWEssayoGdQwTFUsSJdBgWuLASJIMcVkpmHsFmiMU5xykAr2GZOVCJqybg+NHFNk9vvtYDF2ypPJ3U8+ICGfIZ72RzPSMBM8VzFo+1UC3QYkSg1PwijQ/sWzqwd8m6Xmr5idOBu9BRZWpgjIuXVHGSBT2i+rGUSCajb48boRtrxIlMRN5XoU/7hsL5lOvKKkozc1sZzjadajHwQNnYbnI8rs6+24eGI4nN0kAJiDC/m2MGCaKdHwWZP++1nTwyikTV06YJv+h9r7BUc83ZU8790CLiC1LNCq6VpC59329a3s0Y44f5Rm8qmJWn3ZeHtv+3lrU63fTWG8GTvME3ye33SMLy5I2aDqV4obRdxdvHYRk2HnY17RJS/aDMvmUxh+0kWEyFm7rDCkqJYWGaERPdhizG8+yEkMwaIjMtz0fkIRzLpTizt/I4CnzgVDpT3lCTjAIfuLb18XAcTVKuWd5i9Oale+8ru0/9ZdubMvby12cFp6nTda7n91Y9+lU+LcUBa2I2VZ8SkpLQqXBa4k290E+oYP+y3CRX6ETBeRuOEbnxQd+7o1vANAWN/GGR/Ep/P65mRD89l++RiWSwryhLROS0sTrinEQeky9b5SOif/UkQQzF+yNLSC4ROpWeeD8l5ttW9HK3FUABW0IkzH2eY/FvGOGT21M2YExQZk0myZSAm0E8OooHrnaQnsOaClHSflDfGxB3oZLvW+vtKwj3nhStkYaP+wFgK2qjIFbfxyuPnlIq4wG2tXWjbH8hFA6j/up8/isnr0tZ/jabNrbNXwbrlnVk0n1fA4es3Fv/eXXbmJVqjqUAsLtvJMbjWT2geWpSnBFpKYsWmQZikNSLTGFEKL1Y/VXKd0kIq9q7WoAWJPQ3Atq77jkaufomf5nWNFrD3dYnjJNERp/13RBbTl3FfuZkGEQ/VvD2F1GVV6HNzbKBfXZTPsFODgNt98nDKwNT3nHwuA5IsP9h//rKVSH3zpKv5oYaF4naV2JfK6WrjZnoVfT+T12KXhu/7Aj8bDUHOQlAxeQx5id/6+DZQZ9e/oNt7KoS/ckRsm+xEjqbwTm416OjcxkOmy0T3QBOOhq7EZiAdEQBLcZ6a1O36mq1YTTtn3JjtH96D0b727sg3r/hhHj/2naI9zdbALzDpEM4liM3tnA13yuzhrMgHOJ+HSqFYkpKWdx61rN3K/y1zdkC7xAtyOpwmS9MzExbY2fY99HNbvRsY7iTYf9QiYbUy0irRue/Aru+myR90jlgf6Ohy9YYsJFcCoL0Dzgz5hJZbfAxYj6/fsa9Sq752IKvz4/J/HlCcz0ikobozMNm7Sh6S4kFHPdNf8UijRoISGDlxncItWO9RWSF6jpiOK42KAI5sBiJPO8QyWP/bI3dmB4vhb0W/BBrnZtn6gxHpLS9jAGRsMna4F4CRVNFKTXWR+tfXr2Pa9+HC/J2ib/VzJrTEX1UM/87NvEMIFd2FVRDUF+g9tBr88LqjC5fZbzg0ZROStNMAHtUySGzijaTaj5o+Jww3Qy6I+eG3dlbr+rjl5qpwIbMS8MBsXqTLP4h2hMziKbSMpjnBoG2OjZkPh2lBWhpbUXWXMw98EgMutQcWit7NpysQFfKyq8mEWxDJxLCLJIQEdByWCAUEgchFRo4nyhc48ytMpgtwVA4Dmjo70AOkhRDNAuajTx+s6EG2e5aN2olKQxl/rTF62VGy/xwWuonMTWxC9NeNhpCg80FyDO4bmOZbyMUfrqIwsKycZivUttAIdWh99AgesNe3UtzXVTeQINUTrNUIIUsUypAATfQE9kXQ76vicSr28mFmA/2k5JMDp2oaVGGTpUcLITECSM65c5S0aq7iKVq+JIXFzmXBRXiMYAtglmZl1DHTsK/AIpcJrl5TDiv07nN94kmMMtjksF2CBTwxolcjsCKofJKtUHKzTuk8lE7HJVdhYn9SbRNOAnZc68CqtgUTWb0P9SwBxyhSRIYmrJyG7tyIdJLhjnRjzhw2X1Rv+y9jYvnZ/sthCoPc221fsVYBtdQGjBk+E1eCLXwP0TFGGRJgm08hqhwO6F/BnmOBiwi26amNq3kdspwB1RcXspu9Nv3vn8FM22kPjikZUOu8dxOfRCtzertY8Og5tmtJHM327wT+pwj1bU8U0YtQbqnoBTkhvl6rNLiibETzwqAQoEJKnu4BjZjZx2Jh7FUeq1HB1gfMiuTgs322Rn/YQe2nDCbARuGpP8HO+YcIJ1FRWFHmGTxzpgABte/wFvvqk0AvKsG4QquafAbntMPZ/TSOkKIW8QJVfq5rRIzvRlKOd0NMAjKD5pJBr4yJwlvq/2T0BYSXGWgJTReNX2jhrYeAuY1gtQLHf0g0jA9B/MTDZ7BSsd9bX8f5BN5sBImqaipzyKR/i5j1oIJVrvxfWXnSt/a6zo0MnFgR8xP9KabLRMUlfKcr8HjLUKUi+6ZSpdGuOlZw9u+ojN8/8V8KcnkDorg8wasuur2SUfuzMFhvukPnqIIK+8qve90dFARYu/2gu9B3R0YRG8/BEMQjqFntHTztPXQO/K4xEnLXUcdhZgyUkU8XpVtSzOUrPcUpyvhE6w73w2aW4uqFsszy9r5jxlbMbC8wb15hHa4hY8KFyN/D6rccN88atRpQ9NhZuZ+XOcbR6QDQ6U0G+7C3mR1YnQgQqBLl8L10LFRbb0TPc5hm6abVHE8rfZeeufYofGvKMveuZZHflHbvFpvTxj41mPnhuCUD3I+UqV7Yrq5NKb3y3ZNnXGEsxGDbCk8i1aUe8Sb5pmQsTJQmQD6VBmAJx1E2AwKVnS7ApC8zvIVnYdvUK1hVZLJ4zZgiKAB/yLCgYFRZe9dawRhLd9ePHhqnzzkRy7b2dV+raW21+vF6fQ127m9269d01b6Hb5gOM+mvo4Rl/glub27ctceeaN20fQOAhgCm/OSnDvj23Bj/xn3heq1HP3om/zK091gAJvZmL110pnB7RY5cbnvcRCbRanEf6kZ0rnmzexCxRnS5xUUpwfbNtjHkQNht2XcwbZF9dirT+JZlPqtx5EjOnnrEnAcAoAQxukvIS8cpb81c5GnllUnISDgf+sifIeNpULjoaqoCuMPdFwbj1QjGeLz0tKdTY4kKzJuX8Xk3iCRur5i09ocHOJepyb1sZCSqpmPyGUXw+kUaZkbpmPgSeo9FRWE+gV1JUUWpqOMyK3z1pMfCs3K02ZqsGHYuNaQoJPOzUXA053gE+KrX9FlAvac4ChyffKebW85Gbr7VVA2ekgkZ7A0BPHZujapUPP3QEDiWA0oMc3OmM0Af+F4XwlKeb17lTPa5hMDrScsvoPx403rMW6b2BWFPnbwT+r0htWzhv34xGr+3xKY1rByzTHjZjRjc7pfJXYlbJPjS99aTmmSK1b47jPfJ7ekxNTgfueU606bTeBHQEjv5B1C7mIr0/3K7qd23VZGcUAYm92xdUtanWiqcEDs7UUw9/iBv+R1YYGXzvJTWGSE7oVVuJOYS33Ur9I4R4FYx0sCGWlJBKyC7aMlmgvH+4MABxl1UimxRZ7gkkktqNqWOJzGfA4xB9YSy0cSgM6e4OZmNuvIgO49IRZLwEY2klFmHltYsRXS2n7AEPSXX4/gaqJcXurNi14Ua4WUmp1gk4j++UT4tXP1BQUGR11+luOkm3kTB28QAgGKfY5/0TsraSWLCBpOfYdRvJwwv+X+1KXtVb/JdSlNtt1bxlpgIp83DbniGg4/L1tD5HvMbPGCKfIkGE1yifXAmnxeugSRCWGZu+K3EAP+pzqIoM0i6daKndthCcJsAvI+G95oAMfheaJ/gBRh0c57njI+r/5DUK6JkLBMxQ8QIJpqP9FuCHRn5Z7Y010DphbhU4i4+Ph74bVV04cFkSgns7Vi56MnZo/mZzDTg93qGJXETFBBpU10ZBUHzCnjszLDuuNZIdZ2AI4mYG+Fr/4yElBbCxudYd6UhLs1+8AMU4d8IyuAsgE3SgWkigojG8i4zF+r1WRVqaQ2I1YZRK6GwJtCIkuD99Z8ohq4wMEZFoApAm+Q0BCqdGv9bAOa5sgsrhT7bBHooesP81Uf7CnduWWYNYE8QboIsB5cMJzrnl/sN9jZ9u1efnvYJA1xUoLOsGaTEwH761AKEGEaIWaXtPkWWFWDsrNoWBvyomzbvV7B8ToonwNtoD+SxUA9Ymhnmd1PzZZ7LZNp0DqSJ7RBFYs4P2fC8HpIRnowERD3Ww9EI+OQQYwZLvbguiUntoB3rT0yDzMapMm4t51aJ/KhSHiGk6q77psmB0mdkjTQMUnvnUpppK2/m2XoepTaG8zTzY+X/W/i2bSbj3uDqYH+sGnnw584HQkwW8tLuC/uAx9uKu2oYTXzEdLt4bCJEOosYwKQmKzo+5gYsRLXK5rVQb63B0JEcmxEb7ifEfEiJB9UaNpUF7WZiqI55q4kxuWyo+n+J/fy9rz44RAwVognfOMizwWSmOLrgPShHArAkddTlkEPSiGU1Y/fkdI2xkY2UlyKNhRcv7s5tAgXLfhfPabBUbMiOUlXLlwuDnpta3rLRs21VfR4Dzw539DJkaokxjdp/EZT6e/P4f7Kp2LfgkD+26jqlH36z3XlAfRv9qH+z768Ed7Rqg8HEGq9ND2k7v6646VvZVVLC+Z4ZOlXmOu7uDFuRKVYzfWY5XmWIo2u6TXlgJjAyoKC1xSV1UsBlewX0fukvxQtpG83QiK04BLEmykemKV1Vwzi0R9FwWg5rBABwGIpGlDkJS6WJIRHnMEoQCgWkRHxdaPWUo0b7GZMVCAGz6obSjYN6c7qKQ9IKnnT3/EL6J89ztLMUQsvq93S2HVJLr0IujyP2++QwRgslrByI4J5BHy+AwZsyTxg+sZR+QfqPcT71PnrqUYkG+ir0kGSdOmYjTLa7JRkNgFjzPOCV8el5IejNH72Je92G2IZ/GH/0JVfQ9Wu41nebIfMqM52GnGkGoBzECRtOrBH3/TjXLxXW/azqbNDCRnlbPH0fQ/TUsVenzJKqUk23lj8bDmh6K898f/7gxGMYHQH/dOR7xUv9ReUGYNQrNlqZXMinKlfrA1MGY3Ed6dtq8t+wKZYFLrizU77Fk3vMXi/1RZ/qtmbIwK46k5telMP740lYreWHyzv8uOgxb2bfrJCne4JYP857/VWdTZVqn3Wukemfx0MrHXxbot3T761A68csOccZnNDl1wcgbIIvRzP/tvPZ/0atBOHuP65s1aX686mro9Am7b94qw6ql9gYyt98f3+TJU80Vu0kCNVq9YqH3zQ5q26W5PbW+Wnmeu61KdvuMrJvAK5v1w9R1L4SywhWzyLvkjjP46FO4U54fjGBYE6kdRJzaMrvsxh/pj5Ib+37SqPyD8jkidH0AfjPZ/txFE2FZssGuNny20mO7aHiNTz187rudlY5pWFMPL14Qr5wB+Akw6d7AuPO3FXqXHNJ6s0jK5JC/AMQ7Vn7dzxzoNZrWDGE34dYDZpeBEwDk9HuhlnYM7u3lt+k+A/TkPgUUDq+MiENuaQTs6BhKqeQX1qwI5CYfPBHDPtxaUp6hXDz8u0OnG6SasA7a+ewR1nWr4IMs92GmxmLN8Q0KOizn9Zv/OH0a7s3WLUqeoc+Z4Z2Vhvw0kSxJfLnN1YqIGiDl8nAcQS8sM19ccVXRpKhLj8MlDSCDkysKhDzYn61P8M/UDxmaZDpaCG+ZsYNhRFn2XRAEJAiwsG6KzfQZE5lN+HwwLn5se06HkGXQD1BUjxCQeJAy0c4CDbYraoOQ3R8E8e9RkwDHV3p6xJ4sjxpgI3SqZ4lcWrMq/zXMoZVmY9blaRVoCrpNAiIzmTrNZ2OHgK+7ZtFQ8UcEFo9tMT6HnikTOCu3BRCQ4l5NB0Xq+R2CB8g8KCXZ1ZQjhqQ9esbsQjBybLyYcL7vy98Mq0dqzLklChPhWWTwN/oamnBJOTrwOJebVVQXQy0F+34P3u8dHuAwvybjUzZSqDgzG7k5N29BWwtN4oS19ItXZWy8qJM30SByzVxkG0Q+BVxo3YghKUQ3UImavJdA6s+WnOLV25YOYFztbp+RvMN4RdUuYPDSF6c7JO+5Z0owSKkSa+xcyJzIRrKbzOU0ylzfSbD4TMua55ETeCqiS0sM+lREquTh/KZOXsIonU+X85HOkK5jMxIEnNF5daKF4oDWx3Ng0v9UCOWYpCjl7e2Nl9sE9UfjljvmPC8o5d+ZqVe+Ipy9197rlEOO0kE3sT+/DeE8d5Y5YsEsqkgHv2dEG6VzN6EEhJuqttw/BExjTcpFUE/dpUM2SmD0nSDp3zRJIpDRKM4EnbrI0uAWTrfulbDC37S5ZeMoBaYwyT2grdOP2Ddb4sWem0XlzZX6as1IHBX/gr2hdjSqXaHCSjXDI6WlfmDNVi1EKg7Xc919pbMSdOA59ZVno0kx47s/wol2Z6TqfEf+BVgfNmKH9w1pngIXjXI4OX4LbPTKk9IxbFi1TlaG4F02KL5GHLsyLWxSzMVOJcb9QhgvBAQHNOJabWGHwKlcfndOjkWGq7CWobs9MJv1FvNbr9ip0amLmz7W+PZUYDKRlvEPn0gZAg6znLt8864WgqJ2NK5fXlrY+YvFvO2XsSyIQGTmalbnqZXThGEb8v6qcbfJK6Mcp27Qz/Z0DUSjqxWczv1bZOddo6omTq5mhIrKLw9m8Kofi/u3S8TZDGYISEUsyNv1L092nBOnxO219QIqCi/YhCQLC5tMggbWBhnvWLojpN/QuL0AISCWMyy8WoPMgVpv3Yk7SWVQiPT41TApJcnYEAJWFcQQW6cOf0DOT46oSv8rG9ZcZc5shBkqypqZsuzLB7p9brrHeGx79+PGRYSWjB/VJOvWdrGnbg5m/ce26m1JyifY3X7h5IfGWsaVaVV6mh2BzHP6HMHCPNKEs6tLkHbR1gEe8m5kz+eF5GrpIBKyel3QOZ6x7G2Jxa5oWJspTFjxoeMT9e6wdFDgSmKKDdnR74ROCpyHXkiRbyNq/hVMKY7/uQE+3BoUxTjrs2T7Fhbe/aZOsHypkOeccy+ND6mXySXthTEt5L8KS9fSqMMkwvxZgEKRnPAGgIfvebwvJcMe3JIA1EucyFjPfoJKYY1TGTRy/OlW+pgDADXgzq2/qH+198cSzBrQx8q/xg/ty3BwYqevB8lKbGJ+x1HHN2FYNqKB9x4KtSq4l6TD7RzTb/jrqZv4gJ+Bw7CHMygxTFi2D4sYVXi2D9VHlQ92eoAWVlMBaH9wwR7fQwMOp9L8eUvI07aFt0R/lEuzXWXkW/xiPjaPfIjTpmPwn7BXUzejDv2o7vJOpUqKieXlTPQWh6BRKXCZd4CuhJew+B3TUbpujO3cCMi/gn5HLC/BmlSwqAm3qObyBs1qI8up7VTmyyjJ0QZqinTX8qzH7QVcqPh1fz2l+fBD8HlnYeOyhBgBmFqM262lLDXv8gM7c9NtI2PTLmbut+fWOvvRUHkE83k1gMhpXgZLqsAUoZ1nyP3kxQnN6dfg/Nhan68TiaK1FE7PTgXK/U5tKtC8OtU8MXXKc991XZdswNTeSFmh5jImH7q0s7z0GuHBY91KjEmqmUudZrgQFKhE6AcJvoTSVBUmDR2Yg72PkoE/u9hzXDEFeavds9tQiLhlkgnWct5F4IdjSB0Fh/rtmJ+oVK2EDu1z34Y8czxer87H3KKikSCHWS1sr/Yhu8VLkTRpobJ9N8uU4zl8G55kXf3gCyzjmJu9qqKTGQ0CESR9savfdrOJKtNpRE7wp+SK+4vUdwwAQlqEZ6M+4ywcRNGt9KomFa3tY/q2ON4G4wnik/i2jhBE4XgMB1ns8fmgWyHf4LbTMfSI5+ssEf28oxckT8J72s1tcx+57gx9V/kUtynXSbcwFK1EoPc76j2fazpn++1rhV1wXMz831BRCeMrT1FHJeoCtoTnpnlrFsMCdcHC9lkdt0WNSQ03adbCDJaudjbX0hUdYdz7yO43Qj1OZ6iLYjXRbb1dofoR/PldfeT5zR14dqReE6kyMJ9zaBbjo8kU7nEM3RdcdpsaaN4RjJe4V63hgPtdcxyp6k6v7jo+tVVsnybP0MK9Fhwk7wwler5I3JaLvLKU+nMnltRWzZpK9B1tU3H6Slq1lRcPAV9gaxZkKsijw4ip+FuzsCxh8Fj+X0lvgnZ0tSNW6Z9swG5r0LwVRACa5uvCq2F4MhPRZhNX+JnqyioYOIsFp+Q1eX0VBeRFgtWGanauj8ToDFsRC9cTT/TxIGwUlAFfnoU9IS+sD7ffJYaC/tPtwsYpbj5/M4ObXJ9O4tOkd8BVcFkZIp3d5i3x/7Qcfq+DVHk948KtmV29o6xJ+jBiEUXWdqfqtPB98m/4tVh07rork419sgrviU5YcTZ/EMXQctVxpXfyhX7IdOSbwzusMaTtLGDmdy454zfLeSbQ3ybY2gJz1bbpTtnqxNLD/mjCSwCNFIRK6TRLItrttPGD81dQhYrV3Lk+wU0zP6Eh83+T6rFyrmh3eAAWc/mqiVKiGS6fj6SnlUokALVbNnztN6xdFJ8bqVz18XpAaFN9Im8lx0jBB/8EguH1nxWuYoNFkn62TCDNdUhw2RRrjSc7wt7HF5umGtEjcb0w1bjYQ2N0smw0qILyTgsWMvw9R4jBD3vVsXxAGhgOG2jw47f/fEqqJ6MRpGdvinXUeEJ9qP6lGvQlNPwgP7iQ6V5bvt6f3QhiTQARN5mSjeE/BUU5P8LRgeO5ZoxbF6vswRVJrIJUTho9d0cwSgiCKJiT3qZ3dVEoF1RD9ioRgkGh5aFnL8Oej3R7zO6zyZjCb8w5FhPMV2NZ+TMNFdGWYlUxfyiQieYR9/birx1+vYip2dHbNv0Lxi2s79gjhwSjmfwYLY4qCawieYLXPOQIZy0PDrhIW8qVSwuqVBWIGkBkkM0Vw4bV17g09mC5VgIxzK1hNYs1ReZroZNffUJycb2ezE7NAYFvhXyjLPtyB2xXNF4lx/nu2IURhztZ4omcuQQEHoFGpSFB4qWuj8GbDlYZGIzLPoHFNsAdGWolKMW8vcnGS8Kimdyam7nMAMUOTCosS9SHQYo2/9vDWc9DiJyS6Ewl3AaMtcc+DQhtiL4QvaAxDm1z8Y9VZz8djoaC1VgyeJI0X2Z/KJum1d9MQyTmpXbBn2cm2pWs3jEpejw8MjMuf2QkUYNzVeXoekA2E0B9oExXdVqe1LyydnP2dlk3/I3xMyMTPO5ue4zMe4m29g1NdsS3pQNl6XIIgk9yQ5ToqQFItXdmcy+UgCz4+Tr+ZDUu/fnGE3Rg6hL+O58TPxXDit+61GhFy5L3oMUMzvLz/9vewe6Afup+n1e3jW49O8912vD7O+uwD5iesXL7QXXjn6QDdjo3/epQ4aRxs8SBdvfpdGivIhzDaUOoZqmSqar05i2mxOebqJ18NDxGNHodxkMltkN4ZXNF3TCtE1wDRpzTKppsEqGoDdaNHv+3C5HCqCHR45287W+W1Zbdi3ih63a2giEsmLxYqjV94LIfmoQfCKYW762UqufOtW1064Y3yHdarbH+9qK60n+h3T0Bk3tBgVjsgUC7jk0igndGNuVoTjZBOqG1VjngyM6vcpkEnilbXA4xs4KCn1S98PGc6WOdtVJ9ccGLSP1brBGmqE5j9W16RAQpIdT89F4BBHDRks4GNDpCJRW2K4JN/1FTkZdGTShok9lORYpiDgZEyDkOoXTf/l6c2LCLKCaN3ps36IyfjKbKNjji4U5s/Qtpx06HHVDD9ZJ3sSJ96I6kHkY1Px/VaBTRj2JalrRJgNrHvGpu0YWOQ93jrrxip8pM28ZSLu7tHa5uV+wORPdgk7r0dfUhrPnv30XLzU3EeRJDQ8FKuJaWXFZjN/vdLGUGi0SLb7YjDS6DbEjlW6vpIYt3P7wbK0TNOonxqXqFEe83xfUObRyufcM8Uwnn+Zucv2G0QerebiQ77TBEjvoaEcounGLH9BMV4n3000i5Ibi+jkAttdJe1FSjUzzuiVgg0rzapCUB/JXiRSusZSCkRCK8lNLe2yCbFzAtrgYoxSDIhWRmVQBZ87N4u6gq5J+ROrb5fbbbXCXqzUTaWK/Ypr3wzFKytfm5WioMBbOUuekhHGEthXpINSugN2CxB/26etFxQ/ZshxMsoFc6rhnn2/WAS5QHmaZquzqrrCydoWxUjKLz33mJsb+8rWr4xBfiD+rDAG1cycCPUZeHJhoSBHRL92q2y/AFGsrulaXFyRRCxolWm/SuIUGV0mKEEvjSJGYtwXE4Bh0caavggNDIjpbTKjbF2C5Yl4JOz7kuhFNXjNw5AxeLWTe5mQ1wUBueFBhTE+XjKf4OZflsbCQmWaO2KWon7z1oMpx86MMrNqgIvQIA6VcvE4XSeHN9rzsA31i4nJIGKMQ99ox/pU5sVkl4fumLUM/SkEpisLkonFB21EKbL11S41hzHRLRQArvwbznxZefXxkuAqEgGxum+N2qQc8kwTIKQG3/I0QeWluT0CCsTx9lSDmLhAfMxYJKYVaRpuLkvcSXzuUoQCoPdA31CChv7mQIWR3FCP470cKrGWG4phspfD9QS2a0AMztufjA+Vf6+jlJftPUmahAngPZtsF5vBAbuOW7ypvNeSIsRo7Fgwj1HSnAhmAaf7y5Lc4u2Olvdj3B48HSM5YHxjT30kbwE+ZalYPIxgLPpvvpARqV+x6EuJMwvnDIyNjoMVcJZ7WRKxBYeV4R5BblvtGTmrTdsIDalUKCEivqgGP1qwXQODaQVFxG2yC8Sewj7VJ5aGmeV7R8h0nRqvIKrXKhF+pvzrmnm5letgiSerQfs/2ZgjAfzUKQK3EG/GKCTi9ePIiduVTJ+N1Px2WU8xbx28nPNfPOwvx5C4AU3KKLmAtBRXf+iv6JeRUZEnXuobIzD6TXyXM314N3SRyTyIzmH+1kC+zLsAy0idbI8xxz6BwB6fJiAuE9Rt83aimiEq4PQpJPN6n9xtcsfYdL2FtBUoiDoesLeDR4gcR4diZVamd6JpJEO+TzH0+BAgkNDbY+da3FrsPEdjPHqs/kCxOgOrSi3A1cTfX2DoqQM4gKGZfg6A2oaIDORNFooJp6kD6CkNdUWNtLORAnNZMfKNjEK1ozcW1zR33zDrR5fTNYnBeo3CBUEwH+980KCWn1un5ECcxFb3z9yf7P2fUc0WcV5AVwGcci2O/dJVjJ5P7bcD2f7FJDkn58hJQmpmYDUNmyIU0aYOWXjI+Frv9CCBVe5PLyY4M9/cLMg4zg5rrDLi+h4mp74gJ5k/mmVFdockzhnVTGCPQhCJJbY9s1SHvWZ0RjXlr744kS7Fzxu/PDE9Po4wy0fGIAg3AgF6QEp5lq9+wuVwKWcf1Cxn7dlZG0wuJLksH6sF9yCXxi3ePKB/axfO+dL5e85/efxjKjCuMsYvcTGntc7h8rvBq6KTEr9nwg/ruhaBg+DkSxa+lfFNJsBSPOgO5cc3eEPmnnlbTfSWypsNI826+QCOo+dEGHlhuf6pM1yup3dmnndyyBFGPEeaVz7ZxLi/t00Ts10LXLOoTvjYHrBzsVfdjWSdPNOh+9IAg1flALydCKowNjTf/nQH1ci079B28Mi7MD7UrwzMBIjv0DsgBAi9kylmryOvKgmiMjwC+w5o/c0g9x9+J0IYwnesC5IPum2iSC/iGZy90+y3A5Cv4XdxTbAdD/AUydj2b+5nDBMQG0MpzLU2N9sj5YhCxlOQ+D5fLRVbzcRMfFK+Us/xkMvRbBRRg33uHFxUvkgpCp85RmGxuyJe4GKmQTqR3bNRNLG7JyDKPb1zTwkPoQMQw/EngxsZQAIumujZWSY4egqKLGk3FRqytaPq/TN52ME7jYHrVX1wL99JnwwB6/8LeFb5eNbeaWz4Rr1axepmm//L+WhY2mOHmNTsHi5iDOjqQiqsfCa/4o98Z6u3ZS/Ka8h1u/52XF9Ih7aenmKCoAwH+mTZcOFHm74v60GaffPACOOsrCfs93jInK7Vi+G5O9ZF8N3Y6QrLIVe43N/oBAeAaszMe6rtnNlaSSTfer57T94UcK8eO+d4phKwPde6mHHee/3T9aD1yTX6bDK4M0+ODOU9ARn5QO0TaoZqIwwT+EdZv1STbqE++SberA6vzSODz0NCz6n/ekwedXm1+d1sf1MfAu9hvWGXpe4wx0xUdoLAM5biLIwyCuVzZFQBcudVfUXdA5Wc3WwAMeC3eqJgWA9hKmh7H5pxGml1VeNc3hoWqiJM/rrQtED5VJXWWNlSVYe+RgNn9l1z5cTdF0XBzhSzNatWMN/LWKzSFi/G73XrtcZrunqFnUL1vCcH2YPASrp4GRuizOffHAnmSXrz7gGA0jf6ipH1jZLSWf6GzpXtMXS0v7Z5r4i3zppffYGhfLR4beNbBMB4Akp9evxs88j+RJvXVpf7hnLz12NzZHNxunblW5HjtyYRjo5gn29Vtn+4vmzrPwc8HGrbQ/QhCU9lEnFCDpO2PZlK3FycHmCexExyseWtiOFkMU1oHfdvq3fR0blLaQbqxKPqZIqVKjteGNKLyxi/JLW1eEix7xjHVbizVWBdR7VrQ63qhoLm7PezAwaasf1PmO1RU4VDleJ3k2+PFgtnfuEfeUc4UO+Ze3tIrr8uJPX7F98VNsUhFhF9CBxkNCxxHz7kYBaABGxstVVNQlKTuVBlAoYy5kGNMVKEueJI/HG84WwIQpBRv6amJNJXoyWJx2Lit2hCibL5DsOaVhxAKD/8HR22f0b3CJ5BmFF9PEdE9DIcwho6rA9lQJBm1CQiA40XOOK998iNRvqXpplm8+u3NWC86nupFcCCDEv09XV23Fymz1jntSuYn/IMdghqE4XgtgJeND3ezzAzT5ODKODp+r7aMC1Jh41mS9H1UqARyMdvsJuCT6i8zWnjMhMGwinYhgcUs0fyx54KWDzREseYZcds5+oabaPFU81coOf2h1DM3CEh+m947iTDKwwXiQiDBD5kbO3F4CuM551iipsQ4U5JTQMWw2RUIisYDoLGjLmwGG8w7cVgxBg4OcH+18/8XHw1IN6j9LvYpijH+pOgi5LYeQvxaqVxlBltKLLs94Dm0zxcR5EJFd4y1wfp8WRUnhjzUJyXMK/06CSIp7Zuz+UfQKEKAsSSIQHXWAy/47qVn5aWHI3TTumDxhlr1bOteGlraZD23vOcf92dzajRmyIwP85eMuW2WEbnjSx7c8Dmcl9lEEBWrvoVksHxknmfZ4iSFP4aEwzOTspf52n0CI6X+3cCcb07WNrIHEVEg6Bcoa1iMRoeR6OSKLakEI2KUnPXwJKqVMXL3fQ8G1zaiVH++ZECMnRUCYM7l58LYJLV3FsbB9kssOpBa76jS6PqYkRsI+NiOM0sXZlpXKybsf58a0OJ2eXQeExxfnIW3QrUzoY+fIt6zIy7D0KK3MPJYZ/oYsT3P2HfEPCAh2EOZzO8MKDoDtLjKAlq6twiRrVBKu1736PLZLRdxZkrWEjmlHrAc//Z1vcL5QtaqQJT6eJMHQ/gDnU6p5nLheEp0tKywN1uuEocjkVCD25TvvbsD7Q+xKbxAhOT+sLNCW39aCzyUs37593SVIp+fek5LAmQL4Klp77i+7WvLu6EAuH9qkiAfoUhxeCFy2DS1wJF+bsPvBh4GfsU+BRP+duWINsbbQR3AUmwbOqntNGRVXqdevZrKr0qfG3lmcoCKgsuP/31937l/L4NyOVj6/i5wAJocNfTP2XNWZdduSpIfMybMc/0kfnIZT+pVjsJ2KcJDjIRmlBRVoi8kmxXNm0cNU8RpDMbJwPbXv2iqxx4ExLgLKjSuRuzYSlU7JnzpWVV+65zMTCr29kWhGZ0ORcTgPyAw/4c/FS7rnvSIbCKTMCn0UDvT0yOl9V0x70hyQ76uV7jTCF0reZpIPakll64+TpDEvjMUu7WCYK9mfBLnP0NEj8yVMnqWXj/26lGcSMdMIWKsAo88r0Wr2jRrc76mvXDKZkG9a4ba2VzuWG9VJNs1fENeIO1qsn/ATm08b3SZI/JJSv+s2I4WP1ayiDryDtnnQN2OAxuFzeTz7vU2GGTgCa9XhyKwdRvnGJ7dwlPT+ED+xU3v2rPr7fYss6ewAXDLOl+ovNXWRa+8Ni7ccOOep0bsI6zVm/Ou+lnxic1wo33KKvqItWlDMMK/kGW04MGW506lNNQv/F8udOSKz6k8iPRBjI/JE1uZL116sCoZdFTn0oln4yt/hJl2J5+nf1Vn3GX1fEYmgq83rPZ0oh62QVSbuDQvyw3hAWLy7Ho9xK199HFxT5gF8UVBgrNL+t1RhJnh4cTT2cpUOeVSvSFXClYG78EayBWRiLx6ANcdPbX2Mpy0gIj8th3RV2zcxqsOlmgI26HmjjBgAtMbSI2RBuL2gqOHFYAG8ShrkhgUSDgr6Kq4KjSr+6tURdrRwzT/10B8jwykk6IP52RpOBVDefQJuQZ8nyGYZW5vQJfR9yPsX2bZGmfIZA6YMi+BeWF0cEbofj1WwTtXCxZqcRdSrO6/hnpz7nfkIisxMOsfru2l08QEZOeHN5BJT6dC7bxmQRd1eQTMlCZbDVwuOBPk8PRkAj2gVvKgDRPQJ/CoREsAMcA0qyKh4MtgywZmTS9HexYN58tIz+QM5K4BH97Hh+L/akWTc6H30O/jTHOOKMVYb2vHlkps02/ImvqE61h5l89NKdKcU2F5T+izG5oNo5rih3JnJgQnVD/GiAQCZoyoDuJMwyzZ4I0AR7VjVrQptOpp0da7GsobY0McLZ2q+umDHJpWhFGzX2KuItpOskv6/uaEB2MY3pQn8V1VsVROUWN0iYnzC/sC4eRduWc8q35BDyAMobf9NuK3vaMFoXpWVEpgmouGs34SE6s+6LaFzExmXPN1cqXremS59iL4HvmDZ2lJ3yta4OqbFSrJe8x8uqqix1Dpc/dZ/ZRVUpb7ifyxFX62JT7zJ2X1rZ7vzgx6SAfio1ypW6a7+Ka0rmFEs19HbrOCgU6ExEALMTQudz3NhpYN6Sfru+sZqzBGmWbJwUNB05NGaEVMnB8gjTZ9HA2BZC2AlZu65OBcCZTPchbLSDfnvHgv36dTmrGSZ6wnFn1L2NgWUFxNpot/YtZrjMwI1Z+GmgHc4b+RVBUO6F1HZfwYjbW+IZXRCPFB04xbz7BGeopzpip/0MbeDSMJLUvaghsMfcKeZcu2C+brfIsl+7yjVJy1/njltD3W1lFKkcQ0JXiS20v/Xw3/cfu/Avv/N9TSbjqglPGl7hxpkbV1+ONufiMqDb9zBUFOgVj5vpWcwfCC0DY6neagCvaa/8xgcRjzRzP9WHDreLpyf6k4XceMAs6WTXNUbQiCsCK6p8rFmciEiUqHqMyGgHpdMv1mmCNR6WQ3bSlDcBmOmhOM+wWM8YWXgWGfjxQEANN+r9aAMsEKneC+cbP1tKQ8kkwoBZwISJggVBT5gILTOgDFTYLCjasT9zUE3sDJri8rWAoiQLbhZITBb+5TXELtGFQyAbM2Nk9UJvrWl9do95wdvVXkX97ba9oOg31VQx1BiwKQemHajn0XverKu+l1QQ3I+3AQ69mpQWcXbcRjBAUZ3KLe05ZvLK0IDWsjxTEHiSgT4AIZf4NR27FxnOY4SSKjFwG72n7YONE1tjZ0e0/tN++BTvyAOrod9zM6zVVgnhqfu60zKbW3LWGqqf01p2fPod506nf9uApHNJvKWwq3u6RSPAtHZY7+8j0AwMr2XyRGNIrW6WKLdnYFVpHrhNY+WZ+PEaJhsRfzvTMneEc9/2Of3IdvWZeBRBSzAW+Dd+CizQvKSuO2DFMYTFQFUV2fhqSOitMPo4STcZllWI3DzWkt9NbCd5IbxZ9cBADaTh/8TsdYH+UJJA3vZh+71l3ojT35VJ5cAZKknOIoqoDgr3gwYeGAn3YISpZZtd+kbDxsOqmV/mBXbRUS1YY4DBGefnabIMbiSQimc9c1vnCQRq7g0U//qLUBFcNLN1bYvISHjBx+eYQ0y77fJfMeLVaHo0vysuBBMGV/12S8NVQKjQaA5QkKiiTlMGJCBlSN9EBtEygJr6i4BLlYGdvEFTckS4ZoiScVsyHiWgWtVXuTPBIbqhlvvppX60igZPYA2/fgQD9FrdlKm1i7p3kRDKao5Z1e/T0Ht250YgN37ZcG5+oie/Yv+ip7ITZ7VqnRMfcmsb0Cnboev4OMVVshxDgUmwtd2syVvl42dWRO53YgDT9MDCFPdSReI9+3r3aqwMD0dcMbzICUtttf9SUuNc9f970X3+d0XLXH/uWWiaW158vfxvfuKedr6GrKOfNW83hQ3voJWJbZgOFLuHMPE5jMEcyuNq8aqv3fkiS5WlEUJzCY2Xef3w6UNw3acUvcRiX1dct2o+nG81/+lzsYtE3UvQ+r1xsJH3tVhG1+ILL99qGH1X2n8gdKkIz/WyUDhRSUGbrCdFkA68nDr76zTxqxsEOFEWt7MLLH3j8C/ezfcQ2Zq1z0BcoxLBTyMsb7mV+ATSeBFXY4OgpEdNDMeVpi3MlQ/WscqMaSCL3M9jmDtrYgx4pCZSLTFvY6NOpKcxtagwUpQHmA1XthhsD29mcIvz+xdlJiadSC/C3xjbNVzOulm5QpdfRSI2HtdXfmzVRN3Nc6kC/jhNTd5WvrlJoFMaE+GVx6tyNRzA/3r1+/NiRWhs+1Q7e1gJHTO7u5dvRxWMBW8Nk/U4KjSVDOYtYpTz6Ue3tXmn5u9rvi3AsVSDIkRQXCx9Uw4n2fpHtVa4yFygnd3zWL5qrQjMUAMLqsdfo50oILLt0Cuoe3PGsV2dMTiTyIFvIVuP8Dnzevpl2wGgwWJ1Y/gzp7JrP0Dzbao5o5/mcthmJajDQzntyTE5ts63mW1tMHvYzU7EkWQiDEfel8cqIE34N34elf5KRS56wuq3xGN0h1VFFKNiLmpOLw9lQOiZ/l/l7r8a806w0c8WTiYVXTDNBjDaFUg0RaXYtFTcFUxA6n0yxM62wZQaa8e65PV6qi4mvGaLFpjTLs780BsJPQ9/pUn7ckIyFTkswK2MkJjOWTbH81ul1PDqlIhVak5ToACydisduMk6WxtTORUeWEOvRJVfVqSFgEN0DNNmJwof6Gw+6X9rOHGDV6oB9tC7xS3Hf9MV+m0rHa6andLnKa832U8N5KssNs8r7KfdJjPlrJFHuhoze9oZy1XEziVSUtX8pQQpSc/7IPVtEuApqORxxqu/idh5/z0Pcbm8D4p1LUh4yhnbfKcbN1DFknGN9RJkyazw5P8BdDjvEOP2hf/q6QlIpePbLoztI02m0fXvNNzSezcoXNM+PWxbECwzeOmeaVgctfUC4IN2hGl/XgEpQehels4/6h42VWDuXKWFESs0/pY+cXBUjWJLB7HLpmud38G2+yc3+QfPQjjJcqQ3dPRHmNjlqiVLwC0xtiqGLAi5JwmVH47X8oFKwJ5yIdvckmAlQ0Bk+NWgMXwqAqgFj1dKgV64/vIYr+sLgAPX/vPfjYN6Dz4eyI0O9gJfLCBjFQuqb6VcnQqvDfrOrgs39Y+FiDQAT0v7v2jV+fWDw1UHWRSgSKHKiG3sybWU1+xQKdD5gdrPDAwPvZAIsDHAqPa7Plca8ARgn2OG5ByBvjiTdpao7ZvJgosyi2Px0sbnJn0qvJN/746pIH/7lWuUABBJLlcPUioOxHM9rA8ArEEwBbe2tFN7f71IyHqTlrjH0LLBx4cfD9YiVh0Ye7wvBo3CSzLktl71KJWLH6x+glc89Z/VW9aONXol5gZC9fs8Xw9e89RUwfi1Qx8/Xqnv8xptCovjGMliyWto/6whvRyF4zW4uytt9Ja59TxtvCV++P2K4G0rcEuGJ506++XYbsiRibDt66c5ghiZLq4d4Xl0iEZLlFcNkmA8rEeRnCwFlSTKA+a+LBPYg8oEUQiPwKGlqTk4+U3dGwQxXANMMoXyXA2K4GAn+AojAV/lvV15ccRMajz+/pjE+BEIATNAvPdFpUv/bLL7r+ODIY3lrV74YWinHQlW8oI7Wa2p51Rs0WP71x0vD5iwNM/EK7kYAAvvlvDkY4nBL63WOr7DVt4MLl4zZcZBA95yYT0F2/nlHNPD6kMve3i4sbbmjI0QiXszRo4cBOGykUVr1pTH184Kr0EOUrp/oXKs0b0rcqIzo7Z6KD5WmoIUdk/1kRDbnaFumvHwamddM0Rxd1Vb4foEuhtc6tukOjMYSzNQweioFGBz6GRWaSFjXLIDPv883n5F6rvZV9FFOvGUuNyQ6uobFLs3KMNajTb3larkT6zn/F2eqC3sy2qxDjRv+G6tPGb2i5aK40/v/kE7ZmH/DQC6L1FfUMQVEsQd6HFsQwbDiW7BNJVbmNexyITQmVZlyqw1z4qA3JXl/AOdO2UooP6VuWW2JHiJUE/pDjU1tcvsuBO6Y3bR7YlNOVIwd7F0qGX3okht2YKqkmPuilTHqXkid5e6L03aTTm/uVduGQVM2V5lP2YllC1so2s5CEQPlos2dHoV0bzFiz6sVWkiC57x70cD1pH7LToB9Vh3Li9m5AG+ykhU8iz4jx/2ib6rw7r5URkQi7xslN+8zrqzXLvUoPxW+ZreSg4rl5l3f0vVgIfWcwLH8wL+8MSVV7/RxTDronKeoz7h8kgT7QDgn8xcrrvVWqLZXHnXboIKdMH+LC8t9ICtUL4nuUW7pE6DibBDqnn6GY7vye5dwq/5h7T2m6KNWOiN2bfjpfpDiyDHugc/tkPZ0CTCNU1BIgV22L8hq4mcvIbuSiBt7LxujYyDlap3Q98lokYXiW+M9khBV1fpAyo1xi0lnNs5Nlq3/+h+XlW1x6fslWTjsvmRjf9VgIheN2liRdK6k5QGznROkrz6dFwciA7f7e+KFxXJpuMUU6VCdTz/7rDA9hi+/ObPSRgHtE24eVn2mT1lbEtWcDxu9ta8iSe7ZCul7R0V6CWAp04dyyhLswR22T29L8f9ZAuq6p/5T7+nHApU0AzugpbuUvuu31B5MJ/SxuaI+4bBj6MThkk5AGZW94KrxOCDhF8qLinvsgpV6FGL2BDgFX3gIVuLU8NPc2igeWCJdzpSsxJtNNnf+LKRm6GdmlNMrzZwpVKrVShtVCHQ+DS3oXXp9AxuGb6MqkW1HB8W2H5YxiVPNHYw8u7G6u9u15Yf8tyaqhRU6F5eZUYN68Ujt4Wq6vWwapmr+uUwB7hwN2EYs+//B8PiPYehZqiInTMushsm0pbJiSnB79ryXNq3Vq+akDmiT5tFdE7+NEG2qDf1F0j2uC9J+kupmobvaBEZ2HIrf6odFu2BFV2luFnV44DghR1ZZ5z8/N0te9hUrm1syt5bdJV+sbXfkunPDWrXq6U1aP9x24myes5M5o7lmpIhPygzPexz5sqossyc5qy8bfRUADVR95cwb68rnNtneVut6w7T/dlUSuVvi0WRUHixfdepWyu2j5EXNK0IWOoF44uFhj1kuTDSNct1QyzHyIhGtoW6v72pbKVhz1hE1NI31AdsgyTRz5VPKNt3Bq6LyDHuZKAUsiWtXqocQ+wqrOhpEbaoz/Iiwji8K8FTFKt0f1wWpeiepMR62b/EnM/8Y+G+Kd3zQixSlqT3KWYc8EAoEYZ5EqG2CHj9GX6NZM+dmAl63TBKVZutmJxoVQNQYJk03t0Ywe4KM55USR6eKsVTIQsTRztMvrx9muNV6cWP4XS5MLkkRsm5eHr2k2dJXoWuU1ijtEGgait1jpCHInPrrrnziiiXYPyXA0Fz9hDbdFVHGwLRuKrmZMMAC5LMnGKsZJ4qNjtNXrmjEqeOfPfsA7sWdTJYa3ENnCFIE8ZuZjImmOVbulOrnjqvYm0GlENOaVL9R9a55zAXEjSZp/dmjaPWc41FKLCP2fGTpqboFes3K8aJ8eVlItMjn7tF7qkZJEiWZrE/YEegUghZSRJIm1mvqJ84JF/WRKKis/fFr1c23X9x14VhUBYGwNINK3RRvrYHddMeggPUdYBJYs3/oC+zziGwE2i+E3i3d1KmqrK7BGQoUVEJJaqLUmy8DnQqC+ErAbjAspsSnWELE991Vup5I1Wgd1xdGZagCJQzWNo4lDNQvEsbBtcYCFDomekxssRlkS1S19AqxXrxHds2KosoPU0E0ijrkRMEESYEG+d4Dr8qvkfDoPLgLliEulDE/Hm5U5Z7gGch6HQdo1JPlsLUMn1qIQuQYqvKpF5bO74evQ24W0u6XtR/57kmdngD4j7OJfgMr2+9zAm2mOLlUf7DFPWYhY7comksbSPeK6oNTrcvoSDchTPBTvy5ExAI054sk/tl+Xcva2bRhvEfpAppzr2kISzeQwOAif2TPuH2/rIm1mnyfe52p2NywUZI33nItD8odeaf7x+CIzIJ6qxVSYVbOXQh2NHS8lp6gj4u/sAUy+gjt5AT6wi3mx+iuqFlEjtuMGe1T2ECqJV/RQihG1hPj3UhrZX8lJgQ1+9U9J7wbakYsp/f7mLpH9fRvV/gQOeg7/Cjv2qSQwfdY0DN6YPdmnU2D1Dy1ft8x6sv5YlL0NnSm6BQwbL111kaaqb5JahHLr/vjyx5Kb6uIScxxqLm2xLQQKIUbrmN/A8eYx1XvyED0uqvb0R3RoiMCZc0mm7FWlbP3qczzeSgY+gnye8ynS3Wkz+GYV0sTZQGUkFoKXj4od0RJphmS2xIV37l9eMjeCv7axrriNbxnWYBHMqYcMg/I0/smi/P7ngzTc8+DIXEZgMpcCaHBnrysjI4ZQ91QJVWLDWZi6xP1BfdTta/l2ie1SIVMYmnMLJxzteRGA8C59DbkBKauN9+8ROQK5qZnHcyjb0dhKWroUy0mnT43lNJ5xs/nFR5DQ86WCGniXQBNUhyToLsMQfEajzCZ8AwNS2aTtEY9eguMxmcEZ4oDr3RmmzcXS3ggkFvQEuWrHwxMXi5bs6bUrT7zWtEBY/sZN+QWEweNhTM2/hZjHs2XmddxzAeyd6y5KkND+VY8t/wOXSlFjR3DOZqfKajPm8owbJRTTesfLiT0YkFTmOqWSGliEyV67LJx3ZNWEAPdzxvet8qAGDfk9is44Pp7ClziSKZB4VoeACNblzjEBaQwnirGDNFyH1stnHN3G27beFAr7pSoSEVs+xmH5VkuL91rNncZS2KuP/s41jhH9kkHAS7fC3WhAZa3ct68mWw5jw9Fad6c+AESooaZYIYigsaDnpGPyIefy7rz9iZ2ocxJzNsE1aJ1KkpcW9VeA2VuBvRRBSVqCT97625XK5sQszELgrJagNjcQ6vyCRbSJK/XM/evIdvuNur3laP+L6VTR8cgQKk0zowdGUW4IcNSGmSeHjhoZz+D00p+EY8QorJ1PwtaaaG/RBiDhzSj7Ut7aiUYKYgnGbcFeJrpTWH+/1l2a0V0gixs1gTFAf0TYzrJw3fhhVhrfHwy85yFEuskwi5FeYY9HwZ4kscqLUxNmrlfFr6273hDg9PTewXAdNPniDQCLp+mPBmgBFDwcvHNmZnhEXO5Mbm8L5wW1U4dOLB1daK9LtO/U6pfcoRqq124XK2lmmF2XpXkG6Kp4XP281ERiJ4MWsWc9S3F1ESMAHW1U90PGI1nizaDhA+Gsnske+YWcg+mMtrP8AD+NfM+tvgbhSwJk4doD2OmGxZisUrWis8/JHtvdZVvPs2o/qR2Q2yhkii2wjzcLzDnePsoDkQnf2HUp9hSmTDc3yLgb0CahqikPk4ImznfllG5XbbiqBp9uLcAM4EoiyB6Hl4pKNKuZbQIfUUxF1wEAt9wGp1CgCh5+5VmzLcTxUjw8c/IWYTEL0hJ/o0AOyz/p5QIccKrPZWn/ARk1sZ/PHpssGhpIGZ8QZfRZsBnXXlcxegPOmXU5P3OfY8fi8fVrxPnRq7ZTbEuTRelLUzaQ6PkRYhm6bqsv6x17eJcUSgUS43bhKBSaq2ruVL7EseP0e8vtfBbzQS3dQ5UT2IOpItEOxND2LdjAo1Fu5a9RcZUU3HD3fxoM2SU2y17BfxmWHAWxMPwNqetaA9dornbVqNIYTM8rdXcAHaZ1EpAWKbi6b7n9s1NxHpkUspMYgWjM6KRL5gC9AiYh7hkeqgil/jzP9SAAx9n2jpEX6Ud0cJQqL43va3CX9mgy1NjFX2+FaGWwv/fqPTKlfwwkCT5nTACpaBz+7vgm01HJV77lljiyQM1093+VG47m73APiYCEVSmBDzljRaZKTMIU2ZWMfPl2pMnrP3UdmiSyspE5vSk/AvuboYkNG6rtbcn3HJ9YhIw7+RE23hv/FbqC8ED0PxVnUpnSR8YTv6JnKd9BrLWNIO7LxLBG+6KfN+lXJTsJE2VjHmBuyKZaqZ9BWqPuQDokcNpCH9i0/kh1A9O070QU0K2dvNDOa53cJ03ferKNbH9+KyEHnEy6NGq4MbStAD3VcONuyzr1em8gRtJnRb1ff877d1ZzZzInZRESm1b8Pbl0E+srXPepSRGbOVYio5+pj0vXxi74VPpTOyx7BdKxNPdJqjHXigNcXd2I+vjvwke7+qSjvv/LtFQ39nlFjpiQvixZhpWiDJxy2duidmZC6+LBWw4VtOFuLRi0eW0MBeDYUctT1RsTz1BjGaTsVfsT9etT0qf/h17m9XMkc2yuWfG8CBrGTqH4fntSf7nM+TPKnoQFeabQSQR/4fzlb3Mimu+UA3JYObms271Rkd4KetH/1JQRSW9NcRc/X23rtoSwLypM9u1UnV1m94IV+ctzOjxH5n+mN/6MtQU1Ob7ufr0pUeJohL+qw+dkov0Gg4lds1vTf/dzWsgeAeG70L4dUaO6U4314JrVikxMvBkQiEINA354K4uCpKKTpEDOE8sZr36pxKcfzJUaVYNdYux5MRk20zyru16eaf5G8p1mGfR8MKSzDumGUtz3ycPXqSnEqB5K4MaN1VVT52o+0KZ+NC26iutJLQlT7s5ZWzVpSqR2mNAqokFRokE9WM2FGdnBfRNVX9f2X4xZoSmdr1WuzUNiRDzLVYNm9wwHY8YwSAXKV9E8Xu989SzYjEbGZYjUXzmg2ueOT2tP4f35FBvmcGeY9Zzux8fgyQm8RadfdNCb1dUh+IiTcIMp7w9oER5JCxJnNcITgEs2oaxCXeZA0nNePtFjY8RpzaQvXjgbqFD1EMfLaH4HJksnc+V0trMslkNOt15pX6xzMqdyxfYjKiOPVmiB8PinmPPLFR4ZaFxVaJr5+DdKk/r5lRx9FyxRRzYB6yAKoTiLwDYki+Jqk5T5H9VHmY67PWJlmKN/D/VxKunSNJ0AyTZtlVmdYeGZEgihRqkJLYya1EMzC+Lrc9XF2lY+/7NGk4b7rbOeA0csHI2/Zy6X3l7PzLCF9q9zfNDfnuT7tp11TjlmRt8hg7cgRy5U2aV6Svjou97BpbqMxeYMGC7dxdiY0Pz1Q+RUdj0K3rGqlxUn38tDxzpH3v4Xd4Co86+NtXRrsJjkT/COJZafnyCJsRlE/McrkSdljlxV5MyUixZK5a9E7h5PGBPd+9BmmJ6Nny2Xdw6cafkWt9PF/dW1mdN8dLMpWljzGtKyzAFwD0snvqJ8szSNNosYW0i0x2IGqb0UkMj+NssY+EMZqKsGspaHjZSY0e9xaI6uikRH2WMCQn9msJlSRe9Fhvdcg82LuoQ9Fo7l81QsCtP0ymI0yQWXMF3SaJW7MIoaO/2YHq0eyXPZnC6+3hsCX3opRpvn9FuG3INsZU3miXTp/8cuHueH68NmxPheAOqbaEdpwa9MW/QkrP0aYPxcROw5CASStbK3E+arydWIYmZIrcSsD2JJBUKDdGXNITC+EtTuivqkcLKJlra25mDkSek5oalWY4O4NBe2xa3BWW+BQLM5n7///d94pYshcJ4JyJzo2/frmSxx/2xH6PfvX17Lgjna+jIyFRKWTtmZuqW74WO12qnS1aSuBy8Qu8r0fZqxdwBHXFNrldMryKbG2X1L53Xtrvfu1lmmf2M9Hh3okn18jpr65FJ6+hxLoaHx7IInGRMV2lt7vy4s10eAMmX9cLH+10NZs/iuCmCQuHqe2yy1ru3wR1g7oyxymrWfqPeht7przvEgTt+rTexxS16QcHv2NdYwSeszg50Yp+N2ByDV0/VLpjLHyQA9AZHUzBSyeQTEWGhESPlUbje/gj9UModT8l82lBbqpsMhuP5JWBDEilj/5rFwCIX1s29ZEQxyn94cF9zKjXFYWM8m3Yf+shQCx/b7GObcWB7RDiGU2h2EJLskGkg+/rOVwPZCafzd/pwa+7g5lISfBj2vRpPmjIvbtBAkjZN4bIAzVLo1atCfKkQmFwVVW6hpAtew2yvc93CBbQ9EFt7rJcepUEDrgU/svEMekpfEFI2AgSt/lNBg+W/4wm/jPqPoLX8b5io/3dutpb7fuHhnkdLDyv3KHVoS7k32QMB+uEULLkHBg/OFudIgQz/4rqUx/nIEYdRuNsvsJosv6e/Wov0eZIoTlro/Yz2eQqIi/u6yae1s+b2ZSt1zmitQ748xi/vLHMJd3movyPxatfYSefwwKbor7Wfe/HSjhL+tPrJLNm/8iXupYPOYAVTIls7tN39X35gGyE+7F363I4TKs7adF04Spl1G9e3D811T8ENidUO1aFIPoiKCGjvTGtxN2fiErhSMhb2LMqqkboYWl3GfKCQJKxDWqWs5G0Nttbu9K3D8nGiFwNYAaeBCZxMclP5j99LYh+fzO2Znv6XEtMlSL6JhS+6zswad40+D0ebOcIofPJ27XYP86BObk52WA1OCtCAYHC70scOwxnRKwPJeyiku3UDXB+cIHMEjLtRyPqzcAuHDt2oM7mZccVckvbNn5zoJBIZ0e+1p4o7UdhTxZl6wQ6JW2psCYo2bpggBjiFRFTkG3216bnjlKj2UIpFAgklgbpCV/D+r9itFhSOWasadxeFty7A7R3R4rTliSGhnL2nLxResm1kU1p+aj24KlFnZP3iqI7RMHTDxhyxXYafBQWigcNxFsEt7i5Qp0pCcJbqMQng2KvgxGF0/2yJL/qD8XnycNf5ccZ7fsfR+FRPSNMFjKY29wTX+7QdCXWFTqL/o3dZuXzD9gpBmFZyz+x3RAhoNEtrlhai8cErDeEvvkANQNXGTx6c+wf9GZS+SvzsAVpCMVuHP2x7+UrVivyjrRtxpDlQdq1vAFk2x0NKsIK6uIP3qf3MDtLJ5yS1t5RIYDcGRWmNr6gpKmVLwaPYglkIOH+pl3tWu6KrKWKn0AxwTnYvQdkl5YI73XUdaIcod8yDvGx9oirRNMt5fHVWOgcm4CpQO0zxGFHumfPzZyp9T77NVzsTeFS/Ibi62PZGglsMpfmtb+kNbJWIvir6GrCntMBLBgGVhEuH4lV2tty8xozZq05ZNJskR2QrhDOVJEvAVlrRGL4OuEYmEUZ1Uvalai5HTpus25bKNca0yghyZRkTdnYWnxl2pfz6BcisMk366kNbzCnPGHzI3wFlR3liEBine/gp2rsDjr2QLhVJe2zaMaem/KBDwAaXZYVzWuh0EY3DaNHGybuRUsOmAUdwxsMVNz+9uCinZLHGV4RePbcNCAqgxNkm9WbwVgO78c2eB7dpz58SXBu0h5FHF871mjYk3gWwJJK4dVA9B2/ndTg3v9QeveydW54lPmA8FQ6eLvfLJMdNdNOXtkIpR6pqU65R4+bGVWT8YI7oU7YiuKcfM7eZHcm9hX1N17GzVAt0aD/0FzefsQbtXZvh0PeE8pdpokVI5RWJn3rFn/3lfBWnLZ/BGRTVdGSGp7/bkSz9OstEzweaG5KpFtBqN2zB3QREADbZpxct/IaPArfUwSunfVpVNJ9erud4T7XdvJ2fZsX82FEeSPgbFBALjcLqVTsiSXv3KZHcMYUEjVrAsPgaLvXYF8UH4ZQSQPOImzLzhJapYgMrcbp681bwmwuBc17GPp8fHq8EAlZbxbWl78UtHxg1zna+gKG08V3omq6Wl9pjpvsi/I0iZoj5xFyl36yv45w8jNuLY3kerZgjtsVRap82ZHJ/IwGnyJGzgt4USu3LNGwSGvJPFgbu38YoeQ6HFu9O9c19JG2ODFuaBC3LfPOT1Igq/REdlFPxilz30ZyN/uiHiUAS/wvLQArd4KQIqGllJ5ptgp8ncSSdtBJzJ0IDmn+BxuCpu0GpuWTzKfbwLgaIKgn5X3m2jiN6XxcZ0Ktf7g/P8fR7vRPqX2GsXz0r5IqS04zPnidQ9Ny6dw1H1Eru1mwui7r9cqhx+1rIdh9EKJ1EQxkYR48m40Pp2LHDIRGh8pOvPZLHo3o0hYKKdiijJDsDvHsGiBsyGhQUIECPaceY/HXf7gdwY9JFwxTsChoJaGgACXPkzz4NE4HWTLZe66Jm79q7d74NVFfen7b/B1LZDcwvX7lJHqrEpsRNJ0J/Lp602CxQmi3o+kjKain9/iVQf/m9vvREcDLbyF7tXneNYEvWq4FL6ANQYT7Ovu+rpWrPqGfq+Cn9S1P809m8Eu5kR0ZZR8wkkxWqlRX4WGCIDDclktKAY7JLkdpRFk+5G8GPgSJC1aEbQpUnq+i2XhAu62Ai8IY7ykd/ogbT/4DIbGXUkq1PXmyJgzqZURmhPuw0NWUbFvgaPVs3JHq9pwWDtH8M4Wm/5UbwXCpC9A4UJ8edxkGWDAVrb94CuJDnTUZjvMDdEL6EhacCFzN8gNOsJXbxoj4h0hy0r13YwoCln9j2iSchCfAe7306eGmJFy/qeGNSsV4BV6WLSav2hrbf4UP675um33rk819gfmP+oppWpu9GdmaPXTVPbhT7rEOC8j/F3dK3ujesOaGfJ12mL2d9oeeC1oNpBIHeVUnIg6muT5J0Ftrwvq3MkgbCP83Va4zn5xcCOtLI1dBb+dw+VFNpw/ShEKAEmJucHEU8N/caRS3vTgnYkHc7521ECI2vddbH5FvFHerKxdMGesQrOarJZ19QGk8kH97LVVlOlIFbuyNqraLc+w9JJvXD0zOWXGU0boXP1xGFKR1SdmN46y/0VtJDxD/dS/WHnYmbZ3sfR7n6WPmSsrYiYhes4yjjNs4LvMqbvXy6qfbyCVLwctFJnMngJsAtTtWx3M/5Kqc/joYyQnBFWVAL0RdbAKTdLv+ghXI//WdPowFokr8vJWzkr/1ST7gTRbwNumYdIE49ZCb+dV9xYsA/DFjCsILcE2YEOtjMSi+sC5N9Pyh1iza+i6PPUJgi+LNMftdpVi3fZzHt6FlCHGeCBgkUmBzcGBT8DP7spH0XSKRLMqA0Bem1lnIpCKnbocgjfHRpCOtAQKMdhkrmUhhbxRnEaw14ppPJD9hjAgNFXvHg7A7ySTLfuLBkVm+VcVDNH4e5a1phMtvXSIIvjhs9KLhjW2xXJWnWG7gfo7djWACCY4gPwaNoUMZxt9PpNokSGWP8TfI/vgt9H2lTaIdSbdDoXR750BU2O/Son5aN2j8nr6zyBINCfWfF2U2rbfTux57r7MtDaix2tJzP1LGvoD6J+qcPl0fwwBZ/kit6WWw/R+jcpip7grESLuxtN+RBx1SqXjFE5SKlO1KOVXLwoBCEImJo+KYObHF3JJKx1C9neb5Sv21acIclFIswQs4Vz50jNP9iwejoXHEwbu0ICe5OXU2JPL5x64jOTpfU9XvUiIbNaMxA/vwxP7vbfot0+fLA6sI2zZzY2sFUnbhrp47VzIYPHtKZGQ/Sh/tcTQgA5XzAdCAQ0zVPPDQ+IEoO532+3hks/1EdclEqza/2m0FcFSf1KXkFetQnhh0TS2TYrgZEjfZXZGm8QGd6dScxXBV9u15xwefPSTwGPmVe1mgpyFEqHrn0FGx6rX9CgGw/C2fc+bIB1PeKi8oDzUfW7lqbGhqCvjBgErMH5X773QfqkzmjPCE6BJWIziuSqXjboyIicKpbhVfFffePFSLiWXzKkpGqPvcvaWUrVbZyrx9Xl+nRV3M2CpRn7SqdRH3seoF5bivhiIV3VdOL1onrzWapFA9HvwMlIam7iExbI/6DItFoMplmbWj/0nxGcWJ9KpVIiAipI3qctLEfblbLtICZXfZ4QSCYMY2uoqVtAbepH2uxCgnXglYSEHw9CMRAuz2FwU9CB7B6xlC8ZPPAyTVWcmwkAL2h0VrVhDiQu4O0OF7Pj5hxcCg6QTZKNVBZMgkJw6hWHpm1DidHlInOzHBl5uGdrVy2qmhqkxYfHQ6i0nChMWGEjsp3xcqTU7lBAwgkE9N8vUjB9UUjN9GH1dLgtNx8/tBwst4cKurKxAqbB2DlRF1a85SMQi2SgFw2yxNpVw94zIhHjQT6kPr+7w5HR5IQoNeufo1ZukqpvlQ3TXFewui6I4Iwgafk2MO1cYe+BBrz18vqYoswmktWb3TxWw2KGdWWbREOXudrIBdrtLotZMtw2t2ff/+vXgxK9N1k9jOix92VRhoTj0bPVObPutuXnTlvk1xT4wI45wMZ0XFrEOoigQLPg3hMXzqv+BxQnIpMaMClMCHc3mnLjA7UF3vo6DgbtTq5nvN6RQ0EIBiuT3n6q4sv0JjgbA0sKfO0R76G8ueNxXHO8lG2FJgbUhnzDmCBsFwVC0r5PluLGwCUpqFpcCbVgEChrPGtGq6xDa6pACSviQU6wRBROLKioEJ0OkBgez68p4UWJ/th596ddTkH5+n+9zkQ8J4noAEIqUweEvlj0LjKxJFIaJH0ZM2e8ofr4VlHj2aZqQEEtqvBEtbfL58JTuYCPfD4U2a7MFSrO1dKJsMgxkmcCzK4tPL6AuwzMZEA22vDiXJgyNR9spJBzLau/Jm+qxOBg9T862QIhLyUQB0MXHEtEJ45KNZC7KwsdhHRo60SQUxYwnGqSFupIclm5IUtdHz475/ZBIluuVDOpFIDXrBiwuzV+MNHT59mhQA9K6WMpOVo/rSwV/BEO0tm3ngxgsheFwtVq12SM6BAavxLOHtW2y4gIms1AoEPHRGw0f5opUfCvrVwQ+m5krMq+TYEBmmq01Mr0L+4dTQ0OTXqZGqQKwyGnUtrudJOcelCpRkCBZRN8IgTDisrP3sHxjITTYObTkp/VvF1EPw5MNEkI2RWnC/VLCmRzw1BazCUxoJeG4yHgflGHJTfm80FwNzcbrECi/f7upQ8JaIRnEqtwJz3jHZxACScm+oen8nor2QJQOR3d/W4P50E5VLA/RhzkApEMatGEy2gX/FFMX39emPjkRbGnVqMGWjQ9FvcER4HlMbPJMP9nSYFAERXeBgmZmXFJentIH4pCX6OEoNYTLd0y5vd0oWWjkoGS90vLyiXRlsMmEtZPTvKH8rYlWL/+peDfiRWZLhdmqI42tx81PcaAoFiStMWKTp2IP/6oxgzUoZSl1G0jwR9y7rkf0/tDNYJawbFVVDEwYt9s59TVpWv/QzMf3h/cwBRynJvr7GfMx6j/3rnkDKJRhCkjNL6J9avo9jdbk4/8B7XeyJd9TEWQisfxNW1pQ3jsDsqqwqK7dFlT13C3dYtztJOfrW/+DL1zJzyo3UlbMUoWr6tu6OdYn+hOU2ZaF1aHw4zJymiFDmgI4c+zCrXAzxjjDvaHNSafWw+4qf7Jfspt1ZgEGxlWRfuLjUq0A/ZD6VEfuotDIn2B2Q1SuHGWvUhUQO1udOmp15mAVCAoy9mar4LgVTKWJESogRYJihmIQiIw51eE/KYZy9qPAmzL9rH66WDUydK1pM14VZeCf6V+t+fv55exBltvHugjwYyvqw7oqUNMGk3BCQB4A8HFibiqbX+07WOjY2rj1hFT1PoH8B4xjUOHsexvdmKdCKOFWiqEYh2569fQ9oWg+VTlZu9fkEkujyGQAvRAbzlHmaKXDtTzGGMKZqmNkPR0V+d3t/OigxnMCg0aS1rwhM8BQojNXSLXENDo6sZaPU+DDuPIWC2CJCpqAsgM6rzLdcABTaVaHQPiURdG+lTsGVOh6jq6w2NfYN9jY2LqOYird7OzxMjUW6Tt7IWumBGOp/DGRAEPhWhNzkkbFbazGV+zMvHzIgWShBh+iWTiXF+1tyjs8u0r6deD2yHQ7H0swMNZisvDq4Luf7htGVCYbvoEzztuie0IFwqAEbzmUPbO62NfByEYw23htqAmE66f/ZmviHg//lMMml+gTxbDcXYxe1w64QIJprRlUG+a27ubrqQcr7ti6f97Okbbia7Zhd/dhxuam6ULc3oMh/cNSgh7NHyovTV3cRyQ36H5IpEBLKXzSJgXFSfJ2oJvsxQYJIwaRrcT82a551G7GtyZu11yZn3otqpalwnrx4zgyFCuklFbN9RP6bzbTEyPFS/p/MSUuekpXzAWH3f9ecL73aFq2bpKrc/X4hLfElZ9d7E+6OShXu9JW1gKhA13ES7pNFgjIdOgZ85JCOTY72HpAzYFKAFGHrhS4vKzxeEdLHYgB8LZIK6a9iB3TfzB+xbgzOoA3qiGdyQLJ6mwb1iPPcafFM8l37Yui1WRYlsD8ykqgLtaUFAT1u22C41PsRwUfWlpeJliz6W4VLHd+fYqkTnLtuL0N7kDVhOI7EnTqKkympqAaKR0L40F9UhBpmxdEtfveKTy2alUoDAIUDmo7xDEpRKLagSamHJHkgq9s0M4/uNgZ1O7stwtEB3l1a0Wzu73Q3d6uKehHPsccLl0UiKpGyBttqcQbs/1P55rQkiumr9IYDkhNY8f9xVtD/daL3lwOV/pmvhpzGxpm9h3rv429Zl6f04U4CcMffQneSLhLYEjCHT87riOZNohdhJDRiH1kKO6woHETlLq29fKABbAWYZMLe4iG8h/AuFkvkzMR2eQ7e+wTtYDpZJaCSlyYDnprlAhMVAMFdsDR/dEV2GJilzNvDgqDR38aRZkDNjLvzjTQJnC168FMgx0sfpuU+zcXMjTXPxgjNaTkxNafZ98PDGDaE5jX9Vgn6H6LN4fnsWriQ2ugicqANG1cmsUa9Fae4yV3aGWRRGpgxB2+eeVhBsqAsUuAbt1uQEVkRYZXLiKLTAsFq6ZZ6S682wkBYzKdvKXHQAGor5NVxe4SJy8hnQqOdzswrcd+4dUOQ1jqpmN6FO30skZrPIXnF7sCJMjZ3cXa+IGXpgQPiVRFFol8wE5jZmsp0WlRx+aKtHqTXGdVUEN0fk8O3ruMQVfvcKwbjj9S6IIzPxUBMLjvpUVsohvB9uf6yv79qYBVBmNqDViT5s2zYJOUDd0pb3ppkej6UC4DXPmjYy8vl0QDcKnuFMjs4yCR321xcgdPz17SfUr8BiSMrk79S8AYh3EsvmV2by8bfJijc9zNv8Lj1ieA0lBWQ/Dbp/we6NYbPKyyCSOeBl/3CQp4u9SI/SqQxLyOX3XPCQxduP+52EnoSMJKCwmOObQyWWMKiWHMHmDcnGygXmgwGd3W50dqO8OoC1Tchg4bORQoSN22FzcJMmCykCIi0ScWODo6oJm5NAqUnix+jzYmvc2RS5nanMBTNlUJwWRjjdAYlabVVMKNkRKHFQMDW/GW4ZJ7ylwUP4x8JWibWKacC1qpvaEpOhjmqV0PDJvwRYP3HpZ14605vAW1tQsFY4qZwZsguhnzakANo9ScmJKAi1YwbNR5aaFdtAqRUXveBMYiFst2wF3MY436xNdtr5+p12VmL1cd9+FdzSEi+k2s0lx0lpH4iFwLbSgs+h1qNU8509+iFCs4MEUAZTBjqmbZ11rHaL0AQFUASfyHPPz6XvO6e/F6bPWgR8cywWR4UPyzrgxnBI9oqvZ9npVhV1gKMXWghSPmbmzECd4gBlFOKLrkBGwzw2482y4C4dBZO6TIEN1hAvgSmTWJQLBDMiTE4+lF6CbQvUFJh3J9bB5RWVqT7b+tQbXONDPOvxhUP9S2Jgnigu9u511sHWsJqBpdZUnhgnyCCCb+/VBvNNR/SYex14uCQKdgasG/o57wqrfOieRrCNyXjKyoBhEEBRSdvWp/Mn7X89z3p8Uflv2PxeQuxm0/+iLLNaZvpX+gE05qkjnQgHNJPOeYFJrAeVmDkj2/Q1DA5a2q0ORQyn2ebAMh0H4rdwkyfG2xZCh6R+u6X2VbhqfRUa26MQV3dF/WDuCQ0RbfcnP+gWIaxAIACAg0MgMkPZHvnRAHBjrcQIbBPdu0/Fodgfeyi+QzIOyeBrQ4mD8dFrgfYnjFWYIq4W6UM/CL8MVPJRXpDuDNqduKRrS/HmbcUzzult7OokutudFoEAjh/NrrC0XeA8aSgAUSZ3bGRtWd0xnyAPc7voM+yVaE8BSqal//E6nE6JSaKVN07B2CSpehbauLr0CyMjHARvdDR6z4q5cOPk6amanDCPpGv+eOUMyKxVqre2GM/DnEZ+Oih8tkK5jvyUy27p6W3GCWBOCy2rlY9kzf5snZ05oy8ZXFTMJjGJzMIDvhcBOZtWPHZuHwYDtzp9O0Ir14cOZN5TjlxIoBHaCAzJbDUU7SBqi6imZmVfiIzW6eZOzIFhxDi/gnx8Z/WAwHjM1FdGjGnwyCURQ89GASPt9k1rp4wxl+j0sREGnndKJSKDEVzTvjfF28MXpFINGBnr3Da9O5R7PLFVS5E5YNw7JOrRvrU84bt7YvFhKk13ZtSxurOoT1/uZ6gyww8O+UUXBmqJXVYRFgHk1zTyWJUMKo/pZ+9TMIxL97yIY/7rjkGkgVQa7VD53Y+4YH6PZT+hFkb6W766brpqWMxu2LHbVZSVNVogGxq8IqCSDnCIc3OZtNY0MdhAt4TPAQaU1hBHacA8StvEPHumyXrT5QGfDgveok3WfaAMYZvPIUJlOuHcjW+5YC2TQ1zYLnlrrBr+JAP27IJleMezgE7wSJUBHtLokCiBy8hfjKO9nQEhy0tGs6vXCG90dlfV2Hct5cRztEwA0j6JzF05YvOwCYhKbhKZKXNunHRf8vIZ618PeEVLrZRElAYgpbxCCZkkZ1mYQb9WPh9nJJUlTNAwTCPu43sbJs6dmJZGdA9k61zApVCUEz2c0hthNOLKDY8fDzginDzcnYqLc/xMXl5O39zyRWOcx3a5rO1ILV8+6Zfyp/HWi9ja+AI7fCuHY6nIIYupBL+2v97qCzi+H08v0i7op4TB90puxji8Jqgs7BGBliXrc/N0kF02KAtrB5ZINvEMiUZxIyjbiVuWeZeMj6Z7+8EwKJNe4MoL1r/BYtb469ejrMWsDgODkoDkFxQA3NoLnZ39tJEmZobOekNxSYnPEhAV3TzOnCSSqygoaFzSRUTpQ9H0HwEdFa3dHNzz6WNf6Hj2L8GDRYIuOuQc/fxpXvjGK4rOn54xfxjXpsnz0oJKaTRAYGyHeBBO70wk5pCYNsPSVJeqxRIunZY/0OqP5A80B10MjVikMWh8fWc4PDHIpDwL7kBLAo2aLxbH9aIvC+Ol0TXtcAHIf9ecym/r6JF0kq5whxBhIGrppXTgYkWREpwLRal59rcm0KY0YNivEYm9tSTSTIcEnfkiq4V/reeDSnZpvgzBbO4AaqNaJT0nKb6WOJYYZeaIFMjhYDj8VMrhx+wqj03nOPWbuy6sgIe7jdZ3uH4PyeL1XChIlHSkdgtyqyJqRG+9RxBHDeaYaQP+soRsA0hljIYlaWEmObNkibbPHGQ+8/wOLWkNt2xNEu6+3LDZFqFUQe+UJLacVkhHfOez7AqIFyTHDwsL6vk6HccSMVIMFXNc8FogFCSRUGrX24e9j13Zi8Zn2Dhg57CGIBb7et+S8qTLVtRYjxkVo92VeLpydFgvoEHRcNcytA8IXlsxflJ77wjrmqyXGbK8yYeiOmsOQxFVEic1bpiQHCWhJ9dDWAJQMDZHg9uukftsW+k8lhtOg3NjT0ZlUfrKLZJnaSTzGFJO6BOy/W8ZN9JXepoNX3S6uSI/6no8UdXrbCa1kUIsNeylIvp9ElzZEdtpXpN8fcPwsaJSn5y92BnotGwPO38kiYzRu/knZHh34fJBKsbNujEPX3fwZiRvcpd3plalFSQKyOlUHdtIBmn58wP68tNMFtviFvzkbFYHY1ygp7y+N08L7IqaDrf0xblShkQp113u+LyMQu7RAdPktj0zlejpcUbJTU3J6MiThkLK/Ge3ydjbCq1PTVv61LBgEhD0rVdbcELOiXQMu98Cacpc9vFg3nsZWOrR8S8p08apY0S7Uqf/UHZ67ot4n+6mNDlIE4Zfn8HZh4Uj6boxovkm0+tQwi/W1dahp9Umrn9VnKh1jqjgKZbvbDn20K32OiHlfcmRvD1b8hIqspk7p62yAYR1e7C0sQPrLhqklnARveIi6iHq4gYs/rx8HHYOqw9uThmbSwwT7TYzdQBkPoP2NoyXBLvPeS9IFqJ93BMekvHRkYMCe3FMgR2c8SSS8g0K55zgLcTE9GGhj1uO/vlzdAvdblOMbjKOxJ/gQKF/ku4a0beKjQ+/Dg+PjHhITnDBoonH47XeEB7SMvHQ4wgmBOHpCzMDCafxhPORzcDGZoz3eOMPKef6DBEBV1AnaII3ZvI+kdoglgJzIag7FfxwgdUmUf2xt85jDk4fBD5PZ2RI90XeMXUJEHuEzF7L2q/8VuR98ejjMttA50rKSAWVU+EWHvYUPiF+9RabTOleZBsQCZjmcsDSNS/nHZBHeU4PV/4ILfVgBaSxG+LkyZpMSgOeiz2p1ChSpVYyw8iP7E07vjqLLc/sQQgwPBnIpAlMwwcxTDxGKNJK7q30FEwOhu5DbKhZ9/bDTo/8A1837QA6KpVcOM2P3ncIoOoLDWQ1J0yy38/lpu71SPdzNU0gnjJJRI4lnrZXUFxweXKifoWD0o3pKXFOMAfFRfd8KYko9UAB/NYoIjuRSkdakCGjo5dVpdssV0yKI0XXrNJFtq2EhxwYmU81Lkv6wZGxkab5mVNsc28CjMV6iWSSEzfj6dOzOyUFbjyPDzX/Ko8UD/fZaXW4jrY/b4yTbUmWlyJtkPcuHecUWEzz3vfGRqWRtbWRjhly4sf1cwzqlgu9n/m0jg04syGiyMt7TpNjxnnZl6PtBIr5TmaA5zLj/SH8bhsiNWhVxEb4hkon0GSEQgDEMuXyc3Y1Ed4J1tfli/DKQ6FyEz5+GC6BrBy13KQQiWtnx89MaW5O8WSbkI/zvXUnrfLS42ZdoR7xtUL7cxRMt7dByQE1U4do1Uujduacdm4tyl9lvDkQZfVWByJtk68HiUISOu9HA86rvnjWY/VaWAquvslvGhvp2nn+5fkA8sJIEEtnVJwcfmNOB8K4F+3iAIdPWks63GLcQQeAJTlDCV2dw2/yFcqXF5i5yNV32zGN3SkbKKN0uJhesj+xgXWAxqaYAy0UQQGduoo5rxmLowCn6TlO1tmEHUyt9sG9I9pBMll12unh4b01x8YvXx4fPWYScWwUysdq9sbl3oeIvxG+y6E/dfb9QXKpWpmaFs0C0V3TQetYIBRf1XbvTQ+8jzFWHJa/JhlQXO/qHcU2WKOTMuvrnW035KWxW2zSjye7HkGpyVE2UrsLUwvtUX3r65StU4fsZX+V7O9THFxELXdMclRDXbnTjm9ybHm93YJYpc3bSl5mb+6jDC2K6Qvwy7CHlSiVWDPTUj5c1iPqlgk54haJVlDppZhR1ZDbkR4sHmH5ZaTP5KZYmyO/KoXf52dW7FRucfmPzUdMlyiYwlop02+ETfPBaY7lISNa0RgEykgFLoPQJPGJyYBX+vW0oK9csHCpuBXQKsi29Y0LFy8PlJUuZ77SeSA5k+9MMpeBGnCnKNEjWi0paY7BuPO13WrrtNJq1K0ZPR8avDBik/PyG2BuozDgYV2cazKTSSm6WO1F2zhmlm5Esc63uyU4kkNTLt5v2hWLxJsY9k5n3yd/ZN1wrS2d2UqTPWG6ir1ZPGzc7MegDKNPGllkYslIbF9MAUMKBl4bXcfK0h3Rbw6q8cfgjz6rybnYqKj8TmuxWQmlkdS1PYGa1MPj9RdmhedOpazsA0jOXpW5A5/OGZ9m46g8lpcfiSh84kXT5ChTTLXXXPmfij6cdcI0D3ZkTpfpvvV+tEhO8gCrW7FuRMTMymVoL9qIKDKpMaJoZV/KlFFuVj2RQ+T28JKo+Uj/HBt/RY3vZxtpfqclqkKl4zE1/sbgY3rFlQt2DYE+YetZgPElsWW+JmMhoIkVcElCDcs40LNdfkEtbKE2NMMxpZiSLxWwW1wSXFoIDEn1ClQ00BxXufnwYWE4J2z6iHhSWazfTpJl+wDGajM63O0tBjpHkNs2F+UZdtPhYWQkJGCDTSzclEP09r4EevAztyFxhjGTmPeP4F3Ti9kX324jeI61Qg6NyufGwGxduL5Lw163D3QOlfS51sITX0BZ0PwXdeycZ1P6tWuu513QAk/GpJcmdjr1mB9Og9th+kwZ2BFld8mLnvUtaFl9Oh6owXhpIE+5BSCVinh8K16Lw7GyQ3EBJYR/A+a4XXtbWxse2HEimgnceEBMB9Z1cNWUHdXDarvqgwsL3NYtAd3oo1s9yX+LwPWT2KayXAzxZYmLanFb/iXvHLNeV6WHlBoZJ+JIatN5wmPq9CVKOIoYSW14lcLlPehDL/pdLibBdzTNRN7DLMaYF84Tyhwz+bnqlCK2epYUn4NgxVWpkBbqwQ18TTofM1FjIZNfx6Pl8VcoARhXaoeQ0/lx69ZT8iNmKEc0R96XST60p9TgheRu1dqERZIGDvzZqf/3jfJehJuSgOaXy5eL2jxEJD5u8UhHW8cWTYknyUPUJpLHuCdv+HJVbQgFgByKxhH7zU7Lz92+f3dKAT+JEuU2l1xBPIiPTsG29w5aSzUSokTBKZj8he8dSGk9F4Jp2XFsUwXO1TqcQhoytiZ5WZHtXhvZBhdi2K51feYQWStsf2P8vlrbbUzH1SU5pBXjpnPBxsyqWe9P8jHp37pZRDIOTLYKv/2/yqIl+KL1YxUrN50HVpRfLnJzSXENcBvXqfC55bogPhAEyWJH7E56lcW9MrJxlliT/UT5Sa7WYYr2ltonSP8QVoNUoq3snLyZnx+VRcl0j3z62ke1M5YoDW9PdHJKbA+XEnMCPOU71fLcMylZUfnogWBnd4c4BSJvvSbv3zc+F+5j0a2CiF6i9UAmC+bRdOpUkwcSfWe7HLEkgn2I7LAwaLpovRMpiEdU+gG+AMdzlON5NHLsxwANIBQAf2/qDU3ySDsLzqZ36n58qiAhKOvv8vfP+Qv2htngthn3YWTYByIJuZEL2y1zUWcj4iwxTbAWnHyvrS+pdc1o9lKUsdMtxy5rJEf4SyzdhTFhFT1hq/yMWVDHQcYscZQlIRHW/wpPTgUVenZONtdepcYDPvDuxqxB6XbcSodG8NO9zSmwyQovnZmK3qpszJKpQjNHTRmcrydbGJAaLG5cFr7njFwda97Row1tMQWlaG20b7U+IdMa9Lvw1WpNMEMgPKbp5//zB+WftYC5345cvby7u5G+YEt/fAdfeE70ERFgx4CcuJ5wVx0dSgzoDGpITPZND6k8lOpflJKJPQf5f5+qkEMFFKiKBk1AB1fehc4l6om3Frj9x4aC9OGTZhSXf6OOJeSnTW7YcOahC1oA1DP9QD4n9k288GQN/lm6LEIEVLOXdbHCSvU6+QMbg+bYbz6vtWJeHdW54ciRkt6LR3iOul9X62DPBEgMBI+SIj20z5+j/gF6Jj3eBQgcQP4l04xI2fPYcWmTeBewREi6WHjPauqEr0sBIBZ8QAAEUVQWsMZQqOQrBxjjOnUe7rJj3X3Qnr1UspvLC6HwhUI1jNqoygI4MYLWaMipqqqcp2G3mUZ19lhMY1uhbk7XqHh0Tt9Em1jYxSoRTjgEAv3wxtzhw3M3HgIWiRV8+PYYhs0yDX+QBVJ7Pn03OPjYLsfhuUeOnQTVeRHVgrCfT2fBI/hRDpaRmnHzJ6BnEgrPZpKquBLCBxhL+FmItGCyOY9o8zLqwoTJNtr9JH2THq4OHiCXgyjDVD+777IYfUGtYPcPNxvUBTiU6IAYTBlIRlISA4lHigoLRf1GSghYdyFTw0vScoYdjgAE3kBFS2H63DLL9ie+6bHKjJQldlvYn1s3voIfU65Gs2q8AehqhhSHWzXoaKFNBnQsobnhXv+h0mkj2uFDb6+0znHCp/tap2Xo5vOavXSsv2XjGVdp/pW3h+5wX9d0qP9eKj6yuLH5Vmxo8fkXWppRo2pYB6fPHELf46iqgjmpcQI31kD5GbGLgq+4J7QS0O0WHuOe4fodq1s9ZR4cicRIK17Rl7rF3uphL/VHhRM2jHrVPPA2KXnQtoflREjkd0bLz/PjE3bl+voybka9KSXDZPjz7wO57i6dKeEIFMbblVA2XsO3cgmN4wR7qmj3yDyKTMo/s0loLqe3mI60ZGh0WySd5R7jFl0J7OKyZsWYsDkmNC7aOwDmczuPQoyvlf32ChKaa/b1Gdzm9fWVfs8+qGopz7B5IlTL4528ar1NVRuBAulkzoJNvN2xrbRb/4RE8Wc0D3saK+HdnR+pjAKhFzqqPIM5cakCtwH+Qc9/FAIFf6EVdwcJTH27xUE9wqM2Exuv26BldvjdQXURlCtV+l//H/ZR3jNm3j+f5OKVG1K3XJcIMAVSxgAYfw2kUl4g8yz3mOtW0XeF3FeiGx0Vgn+y7jLiYEEJH+V2qUepPDkLD5PKNG5YO6E/uwuJP/KnGyp1VjD7q+S00+0De1sBNCKuEMPOgiy2F8TughUacdO8sec87OeSUkuaK4IIB98dhms1yFd4Y0bshPAYUAhP/H8fPSrC8KU7RRL7gwWZ1RhEg36/zzoX1AmSbVxBtr5w+LLa/cvrGVxYWKcIZLf/q/Urv0gOazb7/1pi3uzfV3NYDOSsL9TNAyRfuq1RhBMS8YRaX5epvWhokEz1dXzXxhA4+Q0JwtbkWpSmwtR98UlIwjrGi29LfbuMCsxhLy3Va6PzeFZxMMQCwnLKzn9MQ5Bf4IQIFEQQNmgm6LuTU6VxfXDfqPI9mhi4fjM4vhCh8V54jlPfoWO+qNU4VW0RsfdlfjewuLYe9JlWVVrHOvR2xq8L5Ftt6T6FvxOAP9MN0QjgcBt99F8G4fkQZ0sGQt30ofrDXwol61+kZz33SWh8Lt2lxIXy/lYOXjHkk7owCSJ7k5Y3hoNthnPQOcgP6pums/TRQuD17E6elEnBE3CHzGl7Cl1KrCDqEPY6TbiqpdJ55CWJxXWG59UGAL/6R+YEzf9W1oGhArUL5tIBawJrPG8pGs57PB1P8UdK16WheENOajMty6obqu/xEFctNxczOYofQsaSKFQKYNpQDB6qr4hYH+m+aYqRC3cIUeU65Z3XwdvwgDbjuCkSIlMRICMTFrct6I8MCI8sriJ2CQj1hFzuGupkfm4VsJEycnIyT2K7NoJbllSB1tIKUhgPq0tjy1nz54qL+K80Y12RPrQUpI0GjHB54KfmgWoGcDoaBEddr1rQ6NjIJBIwCov0+l/qTitNN/pZMhhsFQpAB3iH6jYHcZ3hCbedNJ/V3zU5T9TQopx9EVSTkHL8ZjX6nzL/axYgdAGq37K6fbtwxFVc0nVyupu3sXNWbLjXqoVhh/W83rKODX1Wbdrxx34z/2dtho3NLBhcN219lS2OwYQq45oQLEVIm3ED5yRZeLg9DkUVmPz+X1YnnvZD6hmyUplph05Etfo59QOdkS8AC0MZYrKzwdj4eJ2hQDhgwTJJzKosIfHRwgNm3YSybkXx8zjeYvH6KxJRkJQy7KqY671DWl4/R/f4Vmbi7PbnoLGyBPsXKELr4Ell8/wrFIk5rRbuOg1BDA4Lw/Wc7wr/vHaopdTQNNRSQrdIINd659Gzeex8/3gbvq6c1qPbVz+ARRv7Ehp0tNBGTw7P3JThk2Me+5Q99ZoxReUkVihU85Ka18F9C+arclkYDqMhSBxoUSEuRi8NZBCe9vTVq0e0g54w/+/U0TtqFwc4NnQd/sDE6qrFFq7s0Ak43NV55PgL31FHtP0vWrWQYTMGPQYKy8/0T4Gqh8Jf1dikSpqZUNeSokmxUnOjWj2OkHzavEEjkYysrIzwDiORc3Xr7uabuzsu6+ndGga7+i50itepOupLFklUJxeBNpgalcptN5jSIvI67xrs4r5zBwPFYhLHcdd5TOJAWixZrwliZ5iO3cUswf6/bp8G+4mYew5PuDtdk8mqIV/jIj1jF/jTugKGmoJkaWqbMqRH7EK/WLUkgOO14Hypqxd/adshsaGCKm5U7gElmwIT+zvPFSrqxfbkXjPOL2PtrrlFwJ8Tc58INPa6QwN3TGp9KRmx+eI8KIaeWXBId+Ld81eLXpL9SEyMLQt2y9twhPnEkUABd97E0J9wxcy5nVX6S7iXwKE+Meu3gPHETMu+qWbiBDBwidDOjpcbPdRf64zxnyELCTn+ccZburrBxq2u+XSELWNcDdUJQNVx8V2ykuBDQUq0r3DNUGFvfB55qWxO3uqRew9GhvMqM7NG0PjLeEx/VHaitNAw1JtWLJGQu+Te+/PUakj1QShcyfTUeOIH+vufvgd4dFC9DfWvqlKlXqnX5eUAU7/vaCKRSLDG/UpuI19wvy7CJK2yAhmNczLwaajx+0LM5ubxe1TRdVpLC3Rc1EwaSYcZJb7t8SqaC4y/UPg9Fnv5YuAiVbhRhyJW01J9CT5agtbxitIMpYHFik6xs1bdrgLpLftKyexoAgzPg+HNDcNeqdnVwQwRjDuSpkZRw9QsKivorSL1ItUwMCm2Ojs6VpSnElA4KmUoN9JKbJe9joubMG9IZV7GiuLleSWBYLyTHTSnx1nSW2VYFn2yNkv8SgXLqYSREswAAF4jPMmdyQjPSd9fL+6uMjMtQLFsszSWy/tgyuxQ4j0B5ksmPS4p6c3VnFh2TKqIxWaxb9kLnYtCR13ero0W0isC8ovm2IJQebjQSY5uqVZg5mstflOMxWTQ7RFk/QLYY1W3ly7aZ8aXJ90gMU6K/fWtMFAh9AAIoc6vgodIle2oXUhmsBKeD1u0WsJ4yx3ixQVcLsIgkeCAvSuiXF8WNBNimKZPdq8a/4KKkiO7rvaxiMV2IYJszAQs1Hg87BpEE3hJTgItRhOC7GUsL4lcbYLe02S0UHmYEsRJcoaDx5AmJIoRRxu8S/FLthaE1ocxxHESl3pHnyGvo7K1QQXtu8ARuTM4rRHMjc0EOTdVO8i0VmXmZyCw6d2MHr9Mu/jOkG+cdHCSUjxzmuVrMARV4C0LgqLAgrDmnD1DmMsBvkOxnp7R9hxXakGcsrUM2k9pw+2fjKWSaWwwBxhHdGM9B1SjCax1NZ082YTxhfonTYo+IwWOqw3uQadEiBaiw+S2hRCiKehtgyLHm/EZWCEQDi3ql86cYb5SHpWqgrmZX630kX0pO807NhPF79CfsiiOjm861pT8cUNe/fnHle2p+63btemtQT2OevkaT+8HYsoJhWSEfvjKxdvb+7aN1+5oepduL0p+mMeqxaR6U+gsSoKmSiMyxa3D8xBpC+H/Wn5fontju4weXW8HlmJSOvR2Ouuj4vY/ZT8JdFpd1rjf1aDfZ9WqTWsO6hYUJo56ep9xsx/lJcNVQ1dcWd7au2Vz9baGN2l2ouQHuaxal2TvCBoUEZ9UqRZW5qxRzEOOHCRtBMSMa8BpDN13tMa/BRIj8+avOw/N+MyLyQklectHH604QDU6eXEptKisfOKMrE7d5z39tMbsxd1C1oHFXlz+qVP5OF0HAuv1ql2aP3u8oHJX+bXy0lt/Ley5K1cPGKRx2SleMtX43/3HLcjMG0tLoBQwZzSJTNK87iZP+bJTULxk7eACncWeLW2yFYAFxz73uN3zgIdu7HgbylF5WeW0jgBi4RziiXmmQxJRmgibzsf6QQDPGZMpCJiPQsvrRGA8YJKI7JnB1xizsbLwBem//jeeyQeRuyVmIqVZiRaTFY37PraS2dCoR13cVH3qX/Pi+p3D6shUGMQsYX/S7N9eJnjUoKuR5yx2pTSYRXBX8MK2n/JThEEU/U7v4oWtCGdq3ineyeziJqqKZJkADLo1C7g0rX/k/ijaBAjn5CTB/eNzROJC3aZ4nfBPn2gRqlhRn8xM4rJ3mAWKYO0fcY5uHVDuiHNUoRdz29UnQMdUesC9LO0yH8zoSrUqbmreiPs0X5h9M7m4F52cu9eZx2rF0qstqyVp+ajypb3pCoDytwG9wlCST/OkRj+PrWtqU9sj7QcER/on68pwG/Yx5o4dvUrDGG3qYgba9s3VYVvvMu+x5T9rS3EBHKeyIYyIQC1eWTk39yqdlm8w8IGRacVN0mzkPfXfuvy2tO2qv6WS9r4o6Tdnqby/X6vfx5nHBFfl2KOk0y4u+40KjA5wzdse6GukjAOfrgvuIw+s8/j4wWNdBkDg+QPul5KNcQOLb5pzFl2sdkuOwGld00MVKx2aSzbWCy3tLydTosvoe1aq4UYjcAXGpnVPJuHlZx70eompdfLgdJKqeGVMlC6KqHbec9xNZu/Rn0Av484p9nWVsO/IG0HjKRswIdu9+AApL1m4CKLGXyRtVT9Tf14V3glHcdEB2ssTyFbEi2oudt3W8VVIofMwwcptx5XW2CozEqi8h9BiB3QzgKPaySjhzyRGI7HEUINoelqYsrJvEbYU2lyiyGT55rKgcG0cTJF+9kwMag4TYhDLbRBtS+XQxwmocXNO8bYiUV9RaDnRCS2RG9vjs59DVc8DAdGf/Y9P6j3ehvZ51DXxhNEMWWvI7dQfisNOLmUcdZtprSN1ueXakuCgoLmtknDVDCqT2CGh9ENf37szjNVR2nCDYXoEbaZnGuctloyZCbkt5Ynz9AcAAmsKCziJq1oHxMPojqcWlllQlGTMH02qnLHxYFRHvLXQHGjRpF06q2T41NBWTs12AmOqVzp3mRPrjXxr0oEuOtOrHo1P3dqRc4B3HCBwAFQSytIfDIC2JXrOgdmHwSrsMCnYDOoeQQcmM6+SE1BQUV9pLt4tWukh4Y3R9r0l0VR09qj4ZjPra9e03iu08LT/ZoPQ3TaLneO1B6ULq9U2bVDQ0Y9INLHXhxiFwzL+1fwKsXVtTUPNpQbnoXBtKlnLrauL0jkOAcJfu53y4hVKEVvE8/O6Ljm01ybz4SxygEi4ad+DOMmFoO9hws3WyN8Zl1u/Th6YbrP+PI5DcnhMte9y+Uoy4nZjGBT+5D54zQn8nO7WEeRKHoIjdeOkB7c6blmTFp2YfRps9HrC06606V5ZO5625LF6tOqzF9OJrDHAYDd6g3Yvmphf55yTsMoOe5DPGz0nVIcgYErZvF0YAvjIh1XLAilLe3b7W6WEFLDVnXmsYNctMC3TP52awV6Cmv/HW8ltAw9TxpAewj35A08jX0StrZ1xyHEajm1SHzAOzRrC0ymVCmmiYhFKnbF9587t+Dzdd/hv4mGBARk2ulue9oG7XkSF3hyEWnpgr6uc4My2LkTmS8/yp3/NGj1isQUJm8bi7mKIAOSdbK3esnftl4JN4hia0wY3ZBjWhqWjCIWAFYDtI3dRXSGw9tjLmJgU82cxfUJK2jmJhvrEwtSO8Umu8z1DVlKNuSXOTNVNVaJdQyj1KyNP9zFRrmRqyjK+uX4SJsdCJ9mpcL7ZY/BR3hw0zBsxI7CWmnEdyrhMj8nMrq5Mm+KekhYIm4YZDkdadCpqGJYeSbZg6BbbUbWijS/QAkhKZX/WbLnoh9If6LGOlZuUeFswlESj1owxwsBTVEuJYWbUO6IM+NkzYBdMmLB95I172KdKESY1s4CxxNnqSoRet/z1tEe9j4ahhusm9faeeK3usiVuhnEjI+lHs6E3lqT/cCgvOPmEndfKtkobR3nRG772ONE/lqT/sMgrPkkItKWu+I8Q5YWLV+K7VNxtCkFqmPcvYogHpoizWUZOR/91F2P+BPe1jlyuwYuIzzrraSW6luFmVSxwF+aCSeyNcCD/ll55tuuVHwj3QsBjeMIyitDsG/fKFg1WYuCnNk4Bv2QL1tmN05lUgOTmnWwUxleGe3TEiFR78JboUxEeL6VRlVn+pUv9jhXVN7fkIxKuu3AWUWNHb5He8Gf7UaCARz9lPIDztOgFdBmG/edKoPjprDi3M9dZtbXeqPxGXjqezIrjfO6Oypo4YHJ94FHnwWhG6TTV66K6aiKzOmuiMjtro84uLO8m/tZ621RJRrdUefg9nUuZwjvCcHICJNzRsoA4Zl+bk1RJH1ZbhYpbAbLFumD2wuYuTg8wzlW4qeM4SQBZnpcNx0Q1D5U39m8tChwh8212OamPHFwvtUtSmZ2x4iH9Hoz/Nv+IDIFi6R7JXLUrJ0nnZS+xnWH2ykZ6G823EPu1e+2L8/BQfPO1d43DNGVqLaWgdMLboF7CXN9TS9crJ7xK5vtSm4JT9I4AHWaZ8A7I5oIDNL6W1JYrxmX50Mci04PWahpckfPKjOBFzS4CxT5wtubtlyHNXOy+9UL14LjDfXbahk4hByJmxeu641KLMHLWR8Dfu8AqudD9HyCtxvaVjS9KleTz4jYbmE2a/vFu/+vKfourfX0YPPHtjh1vE+Gw4JjnbM+4+3Dv/L1mJe3e/xBuft3YV9VY7lXhvGwRQSG5y40h06vC/f0462lEKrl6EjPJ2UC4hUVZb8oFStJO8UM4ZqQEt5IsA+NSHRIJnMaPg23Wd/CsRRsOwfEoyWn9d0yMBd9l7uM363jQrLvy0zLt50x6AKwgQqIIwSzkJxpcbkBP3qRsC+/3/xhvPGmRveNZVcjXyqOWOoc4lt5w7IB1o4ha5RM487kmPuZzNFBjWKFZ+xOWxd/P7wvlEY99dPKscI8ttAmJjnlDHCbqH4N6pbHKCg5aYDehKao8aZ8dqaI2T2dndH94vApoVEm6H3cxYe5yzMzeMztlrhceu5nlMHT+0Ov8Hv1Zc212y1lF9o3ewxp7Ka5LHpKS9lkbaAH0ox0mjduRx7aF9xtYnu7W4bE+VCmrMP9qSqL52NevjyQ3CqC/k6KA27dvEsFVY2uXsXfx1Fk7OKC2PszrgPErZ9E2dyYkHdE+3oJ1y+u27vo+G8IK3VZa68GISrQFo5EatLhngsu/5T2K/oM+T4sB5Wnptl1AnMkB/+VRWdb3hvmn99hP2uba8r/Sxr0MQUmuTiVGKJ3gmgRZ/jnMOaPeStVDCDTOUUBK/bi2OaDhda4zcD0FgjBBo4oxCrjkLF4Z9T4FhCi12khSqdRCeI21TNSHiGotGPDt72HacDOt//s3dWID8E5WNHwHEXWHoOegi2FsZQyNmnoIovaoSkDq1TX6q+J5uEMXB41RQFJScYJP+aewPC8d5CbxHUlHJgItcEBfUy+7bW6m9b/YwgNjppBaNTv1PHkECRjjyxgv6aqeUJbIZX8g4J22+oGtAvCiBJTTB5ZQLldr9FmJRDTOATztH0GK+qXTF6aQTseslZppxUSV9g5OJH/CNyDt9y6GINIry8BnHEmcZ6HGOrUjP+G4pFB1R5cXcSs1PCiTGc/ari1Iu0pEnxuvuOBVMSZn7LvOviNZuQIYI33Eg5CJBy2Uc6MVPEmayrmNYM57NsKBcNhTpPuadUHrnG1tFotHg3A8EO2Z3Ppz+E9pYzACyraCdb8Y+AWdlJxmHsI1byMPrJKckh/a1S7vb12FbK48KH9J69WWK9AgWxRELZax0xJkofEEv3Ed6p274SkZyzxVUHF5b1FeNDlLHJsSIwkqwb/xJV7+5vaPIlYfdoQcKi3C5upz2XkxIk6kIcM0xgjwXFUk0Z/Ki1utzMBNfYHfkU++f3ICPZn1Sy2RBwqJvzgySeWt/t4rkQjKKLEdWWRtaK+mxZCInAVMYaC8JFWZVJeuCvaUQ/coBg8Evtrlih2OHScgSCgEeA4IGcsVtQr2AwPKPZ6qPFhVl65RlKTKA4nCBUwOKUZNi4deqz6GwryFcMXeGIXvMQPMQriParAqvQ4IGU/ygO18T7EODBQsgu4Civ2R7jDJ37CvyrkC0L3ziCwcde6JgMPohPzAwgq0SHP+EjW93sSy2cpSpdXqKKWH8/WNK6TQRrtMxx8/RmgjfkoX9PK9MQ/1lJaWAhwLlLShEHApTyLNLUrIEv1xEA2bAsmDN8d1NpXXKNuEor/3q+z/7pYhUECB6gg+GsOBMZQKAKQmFBknjnMzrdmHhlgs6zlZgxd8v3Maq9NByENFdnDGfMy6JRSYswQzuDcff5RfKnhD6+Y4zwo8oyKMHxsnIkfBtfHn0iEH3cKjxBCk51b167Op4HPAJjw2RC1tno/Bm6GLDoF0rnSeeuhxNf63Im33jK+8Suvc7H1f/CheDr1t7SdWoLObm3MS3gLbtEb3PhIPfSpz1lbJFdOHAxYisKagzPdt/Le3rQbv/Pyo1Rb0qTlvcai5p7rR+XvBlG+skCEMPA6if113B79AYQ7wI2GMxOm5WddZfWnBopTEfCPScu/SXPYG8omXSQwClF/fmYlXK9vLIu2Rjv/cTtyegjCXfJfnpzmnOOjWvQouxXlmkKS4CO9u7P5zy6EA6GKYv85+HXAqNUUjAfIFcwrLdk7eOT7QY8nk6LNRR9Uh64DDmscPgTj+/NCKkXmzNiaqygy9LTKzflH7lssAgVv0YeG5lpjr0L4pNdUf4+PZ6V9bl5F6719pHu90quXzYijfrR4aT6SNPehDL/rJ4JwM7Q6wGVA0PwwPOeZUyywC7jEAoq/VrNIUhjnRzSL1Zr3gyVDurKZdU7v12x/UnH8oHzB2NPtzz0oHc2K1mW5Rt3vp7PwGfc0MI8FApP3y9+7Jj6DxnxmYVdnB+xO9pl6+nFIrGIEvNvcnChKkl5AZi4sRyEtop/ct7d9G+HOBNZNY/rTellj8eVhR9zOI1f4H0ukNgLid7VdL/YrUYiKNqCbLw6LRe9Zb7W0TlnDb2hpaor7i1rYvyrKWw1pby9taLWwk3k6KZZRXSFcGz03IXxjRClbTp+R45nOT5ICxWA0p5NYcH5lvwUMmqTbZbJhrdElwiaFdAC5AP3caU7mehmiXcy3ihiThOezobrFQWwO2n/j1sI5wg1mP07JH5vUfOvWlr/X1mUXrdNHX5+4DYia4PA2YRehf6/HRcNEwSnR6H8BYDKetQrSy9awuUvbt+vUKLkXC4sSOoJR1LTBPU0LDvhhtCeLb1ceinKDx4pPsGgdddpQW32SdYLd/y8OdWBn/UP/gnOL6m1sNF4zqVu5D0zRPEJGMkbWQv/cwJnrNzXWgwDTGJtEQ1EWhypkndNlB7vbNQsG1Jdorh0TLjkccf35B7XjWHvC8Q1BLWqoAl24WrJ/nvlJnvLx4wivO9BtpfBu4b/HKnOLxkjist2+cF3FKs2ADnBTr/EcU3OF+DIaJyZVvIFAK5zgQsHkPdXGC66K12cIIzPrW8JCgtfqZp42Nn5nVjD3Gtp8Tm1TcwrduMnCtErm/YUEdL+FGWw1dK3BetrVGtRebxCjK8/3CP8msM2dnAfOz9dkOBOxRKbQBw8TEirUORExtNPeYRzu/Pzgx11vRq9RU2D4gPbFROBrjE6opypLeNcGoY2srZ2RSvvYAhogdwxJBfIZ25Oz9Yequa0Jjev/t5VuV6clDOJReJ7PVpIbUz08HgFMwt4MqICmbNXKP63yfgMikipNezD/4en23W/CiwIFTVwdV970e9huxBOxUfRqBjT9M18D2+Q5VzV67wIzNfRhMCdI2aLg42w3uYuKNx45F2rACbrwvhE0B0dlBhQ4E7DbK4uv7tpM2TWsUPOnMdTmNbzUpP3GpCSPGMDE5daNBLsptWAIWqWnIqvJmZ8ZRfxqTt7pXb/H+Z61AxusYdaw7wwnJbxcjCJalzPUmj280jhFPkTpvbtP0TV6pnaI7Pp7ncoIwti4nmn0XvClY9eQMIqI5mbpP5wywiot+qS43QDO8tPLxmr9ffkkq+o+VYPqFDuvWo8GxEnGtFMHKXgxRKFSGlc8D2ATfoDH3YGAGwvN3Mo2+3sZ1raTgr9WTBa/XBdijCMvaxTAGEoxG77UoemM8uchtTKloY/L1LXATFIY6knxtA+neLseiuVZmaEri6k34fpog7VvQtbR9/PRyisoyiwS4fvzooHd6SgWQOtWNe+lzCRCeMxH293jUutcsR7cgnU1LZLyasHYXJWLtsW++g38H1nwC4Pyt2mw2pXoJXmFDRzt6Vmy4DiB8X/XDD6b9beCvt0WpWlFsnO5aHOvuPme36RBzU2+YrL9sB5sDh/NQj+SuGzj/Q+g0PkAVmo/ygGUxYhTPgh/cHZzgCSAO/sx60Nf34EYIXbU1tgNRxoOML1kN4XZBZkfbVxJKO/+oPd55dxZAvFK/2+X+cboZXAMSa0swezJ0du0wBj0idw0wf8RO3heUA/W8cg2vRO5u2gaDSmAzxDf5JS8twyqdUp7ugC5VK/xbbK9RnYY3SMIWf8HX8zB4G/gve8eGAXGwkME4PjZGsr4OJzAqCEdc8lHbYdckOwOeaIlmFABFQtf8p5lDErqWhLctYBkwgd0BKfCPg3mUW2jKkZH2E7/EVuqVCkgynnBDihm0eFG1UMKl8Og5mhI+Jnpn4YCtjyqVK2vJvIQnxRS/yldfpH5J+bWOwVBnX/cQQ097YvHizsyWiaOqYdW387ZOycgg8ND0Cqf7fkEnDpUvAknZ5e2Mn2+ymfXqHyKnDNrcrBoqMHcCp8G587CB645LGqNPTHiL+4lpMcBNKn/LgHrcl7F7mSCbbc1lSrohLE8n9qhaMk6KbQ7CDwbiOqi0jtyiKkfHYOD0eF1z0rYjZkRcmBD9AfK6FaPERkmCnUh38+1dEquqAJJJC/uikT+4NyMVyIJViS7xNXc1ya7OUj83+9YXkA+u5DAckTq9M6m/bhMBcCY5JudWdXCwHbSkQUZzkBSbjBtVYztJfbshXI8YrlV2whu05X2ohAFigr8PmXo6zc3OOXke3CEgUtnU2NfOvpPuk978qcoKTkApiTDfl0RkOyhBsFhytFtC+RJO/mEdHyuW43vHzT9YgYcT/t8vp6pK2r3VnHbW3bbDNvZs0qRnjLSHTyW6pcFQCijFL1arzSDqag6E/j5NVI3yYzc0YsmkXux+XuwoKXnHFEm9isfY0IRlN2EneIxVJHU4lZHmL6Gc4pz0TvLOqCcWbrrgzmjotJGeNTHb6Bk7vl5uNIs4677fllPNcc9GO+IgSngOiaTcyvBd8F3m5v5ZIO4d1k1HLVdNqMbVX8kJSw/jpsfpVqRnR2cXx+Tj0z6Eld1XJvrCGRlpvSYN+wzJmdujzro1y1iYbrwT1hdGPmdsYdHip7KPMMPmEcJ4KXuT5RviONzcfT47fM7EOQlpuCA3P8TJa07BvBvOwVe2vabm/xbis/wg+dVB8vJQ+UVq9odw5aZZ0nLSitIT8h2SShbhEnAYN8N+VqG72sC3OOC0y2+fP5ej2u+7y9f+6yCHq9rnrfwzI0pGCTtTbDYQUUGAaRLdf6sEpPEFQ98P7GZ/VDBZ8nceAsJJ+/e0K37UHrRbl7BrQh2xBeKTNNExTPmoW6Eq88Y7L2rT+kwBQU0wWOV9Pv0QsbmksvUu5HTYunUVyMN0H2qNssRpWo246jbE7KEp4xCxpHUR7B5k+Jr4buOu/ATAuZWrv55/P5S02crKFe4Kg3xuNG9au/M4SNsvo9Bo1SGr3QQGfYNJPqnXFh/e/N9k/uQJ5H9f4xUIWfYzo3JEkHdjNtNa+bXPS+UF2Kz498ZBHr87+J9UyfidBQEgR1gZS2I07nAAOkk56Ottjcp7Iz97/8dYJfalQ7CHS0074YzrwgBFjSh7dlQSNgtMYZtZfcZq40+TjNGtVPbQsr9gEHUgsbkAhJXtu8sfSsTa24P1MmaEMfbfRJrp464vn00a/OhSjTGzQ2KHFiBAIw/EXiR5SCK2YwPhJRvfgBvkwJDiLhNNdL7YQpvJbDcg6pTVXoSnyF1dXb0qlwK/CBAYEmXCZ14xOo6zCXYidKq8xTLt5T1NQGZd5026zJ9EX5zxd2B00Zj87wKGwf+mbZ2sqpXIdR5Kd6UiQmibloW0TzuTGxv81r0ELoSFd4kzLMNlSvtWS20ExEMyTEMUedOdT9gHEUz9gVWVe8ovXCKI5vHvS7EJaIGekKoJv2J4GlqIv+tMUhK+mrppvU/HKD3utnzS7aT8x1Z9iLop8LXXvp3gW1sB6R/aUPZbz/Pu8W4dzPPkMuw2WRedS6qVCb9VGEwTmn0DklcZMCR/2oNSOqCnDKVPAP0zSWq6KM6SH1LWhUqNgAvwkSmnndQW+e23prGxBfsGSJtJ+4PZbpxTtyjLZ5hL6nALpajvMptcn4+mDm9O3e+BHXlh6Lua9q/BnjiUJ+SQ2nC2DrElG3/XAUurRUWpZ08YxVs6KszXuBAAzw9wupjis4cEV94f3vr8GcfIRsvkdPi1IQNX5W/j9tqngiKyy7IiQ9aAb4jFb77lQq1K5mSGlzsnS82S4F9f9vqeaKF26ivb85MXDAyBZMCBA7bkyN6NiosgJwF/l6ych5KGVpSv4bhtrBmzDqpJLl7Fy4UJwbweON/wQp/jr3N/rWaJRzDY/jjj1bwasirKriC8mRTqqZCtEVTSlYSjY74bszaIc374B6DuAkppbbAXFumxFqR4WX6t6lbTKYlJurfGmxWvwCsI1OEeaBf884HKzpzFO131nkWexNAcQgFB0JAFUZmJbCKUVdXaf4bwtSzeQ+wp/hDkJ2abQ3vcS0SGXdpwIygcBV7xzt8eFbrlefcOcz28mRg9Vbncam8Wbv4Q8GxWZRT2dcn4aUorJM/aZMVV3SO6O/W2BU/r7ZwKCT85rzKcC5U81zuycT5vCVSvcqQeeCbWClu1uyct0nimcKgwaqdb8DszDpxJd+mKDry1gDZOPzubsTxtJyqMeETX/T8kQeDKgvEaOA+JZiIiMMbvu8paSfk7jKMgX9+iVRJjR2uoIskMBiOYKwtRRQn6oHAPm1hkC3zErcynxiF4M6NmMvb5W9D0RoOH18lL4BHBb2EAneYMrUt+ttu3Uqk2CdxZw2Nq/NM8hJdMXegXgyWh0hHSVFPLtlLnT42eV8O2YmO7wqPHZdBQhH2OUwwCFr2uvBBcFvXcCh7e4ftUhB/d9tF14aQgaMGMudCra6a7LngIBvt/ewfI6AjfE3paCUoOVG+MO8c45s1IyxCviQ6Ay1AfXkVzVAoSJ0ucQMHkBu7PBPcMCoR09oFC8yVGauRkQ9N/g9fXqgYWDW+xHaOuhkBYViuuF+PqsHouBZMHVK0UBPMiISKmxhuN1MNCw56y4AK6zEbziy5+i1+HHJlhY6hhCxs7odgADRD0OyUjCU82kEyb9z1CDR5kWJiZ4W/awAoI9N+hvHPq7+VMniEuiEEynVL3IA8gmzQKoxmpmII6HWe1X40qW3QEl4j0Uypdjr82FewsgRtPObszA6ak47bfNf632JYjXqGebIMb6YFtvBcEk1vKZaKF0J++qAVXqAoHPeg2OHXHULwb3aTkX5fnDdnHTe7UcIIiB0uOfXEUndxmGW6OVn0UW+BboCFxqGWLrqMqYGcgaWbN8qB8FlTsEdsvXAt3hEcz6wmVuXpD6lVsco65s+K6zs0TUUjkJHH+fXJglpP6b2ceqtWaZ8lPM8sZPemqxPq6K+V/G7wb3Pke9sa7gd97AATfTp9iAdzzLXCpZ1ty7zqm9I+Dva/r7JbwfkRmGiywFSGzPqERqUsGmqOaOVlSMrrwdvFy+UQz78Qn+grD+JkPS7Zn1YI/aD/Lcl/61PhLJgxgdM2h8Z+eiajO7Xk3hdQmLp8+/XT1AfR15zSY35vNFEe3Crnu3TroXhZNinB2hO932rTcWXp+HNqH1bH3Tdmq5SHBUlebZMU7syP03wleg3oc18qIg7TwxQZRFanbDHRco1d5ArtcFE9KFzE0vsc6NdJcsv4M8JdTWFSFt90g3ZMSHJr5Z+d2tx5WOY9Va1gsbbZpTbJc6ui2/g/G7ihujp4+RZ1JD6EgYbu370nnaYVfFB+TvSyDmNrix+ofKPcNFTsuc54psD01nkGeSZ7pKNzLd1ihZ6d9NFmTlLGRRHDENJesexrqanEoUQrMt1pKslWNWmaxS7H1KsV4AEN+cCLSEjKvrHKDI+skIQ6MSh6GHeR6WgVZ0S4OoF58EmjQ/X2gnch6jsAbslhh444VSaeLqEWqWGfQdF40q1J7/rNmFBqKTMkRedN/cAjR4ZqayQYAMd6ofLBPBw3eFDLb4DXeIgwM8nTJVeOSQenel/KVQPb/EXX7G1Lkof1QGgROtljGMaJaTgaB/v8vqNyov3im9v2qlUlRr8OXBwaWw18DBI55NpBFS/iqoaUgL7y6oRG198cgY3VElm+/uoA31aSvCdD8B9Yd23wy/NBW5vxD5QvOZitIjL0KtTpgvnef+QFp8sR52/9+d2u45ZPWdEDLNE9FXSz7PLv6/8nNpj8Pc+YSoWIYMS2rhA3ySr+S38NBnLSnqIzS8f5BMuDSLT2GyXTt7LmZQ8LDtcyN4H868MAPCumdQmGzOwX1VxfpkkNFos6eFnL/5XvnYMkmicQsHyf023T/3ewVjopbOMEXceGJde74Ci0ox0rsXbuYNA2o2vOZsuvKuTWr5/Bhefy3Cmho+lmx/Zm4Lu/+yzSdB2omsLYakzTf8oK2YfYcovYLg3HLJyiaC4U14JcVEx2E8rgUcxqKWMNH9GpXQpnsht5+rZKFyWNtCNu2GIwv/ZkuATYdymH/XxtBNbz9+ys9ZLzc4ww+xLlfLhnuqmjPz8joOHRC4XO46DDED0hKxh+KbJzhoWxbVUg09nYuCbvKPl3GKAprjDkuoCBVlEE6LEEtFay/xnfmhXnKsJDSicvxVuBqVlUMnF6+mIF9sHx3f1RIwdOYLB8DQXHIMDss81pEKq7cI3ufvK1szEg34NViHlJY7zBDgcdkzXVC0aL1NdJkqD3NVrBcVD2bUTMAE4s3bwvtcRNBzJBB+4zrT/z8Bmzu3L+in+ch+617X3VEDEdfk63Ocmv2r9+YVJRemJCifVfQbykYLjgamJispXxnVw9QlUNl7kqfvfaceO42TrLT/v8H3x8ow352B/xfmTuizp4Oqv7gUz8Ii5mLVyMYTfzLv9/XXorbf1PpyBahz21H/w0bzrhKf5/tUTUwBwYg5ZlpujylJiuuyDsXHoXxVj30S65yVYS8CpwfZQ+TtoOg5sQj9gKnLMsQdKyeRqRqw6uqws6TGphVsgTJfE4ndUyk4sMcodF4pYcmiikKqTZ3cnJvR+agNAEXDbG+3kzbUre6CWdulIhaYZ+jucCUI3QrFTLkPmlmIQh/Es+lvRwRKce++T4wJCbbywRxpMC82O1xSllckqfaSQLWUyily6Q3uF4cKw+tJ9XA1hmDxHeU2ZrqemUMAo0h+GWVhi3L4c/dmXuYhWG6BY53HAPPhMT8GCCk7b1LHCKrSmQNweYdTHkiRonN1bsP41CMABxuiCkPh9C289z1DHeXLVlVuP82TPo4Irgh0aH/Gd58zkYV/Go9Y/ToyKDswIDs4IFFne32yM5S+tDDeiH5PKtuVRc8pFFjquaM5/Da8Pf3byvx/C1gKHzJjSCHyO6hTyzwinQcCxZjUtKHE5/Thq6eBYovauRu7UA8l1GgZ9gamxir+fc09Pw2n6GfVz1ajdqSkjmZrp00Y0uottYme57b3n3uOCNa81jzHu1XVRdVK+n8UUfO0flR89zG3+QzLOTrL+AlikVvnKMCjt/D3ocOFNW86A7n9JVkzTd6fQQNIx1Pt3R7eUQiM+GsC7vC9EuezmSulfAge0N1N/2QJ9INGkMpboQwex7PNKxrpq2QKHwJdSg1/ZV1KSLrfLYUViD+lFdyFJ6c8GWuFPFu3X9uk97rWFeETx6ke4+EkkJ1mVdVhwYfqZIsMkwhjSiLS324ouSK9j3v86OGCbJb/01QKeJzMvHbbKI2JeAYag0jXEp/ZzFhXhw5UewaHx4XLpn92EbOLwr2Cnl8eKTk+CaOPnrUfCUlTqmIe5AGObS1Y9eJUydJ5iPm+sDcsyaRUUa+5YxutuC5lZISGaEMIRpKxoRlA5llkW8cfSzd0FjWTTBj7H8Cczld6ZjDZQMwOHX4eKzk48Hevv1C5KaCwOJAaH5UJMUlCj/uzy0m7Lk9pd3ERXObAqZuz6jb7GYnJIL20IRgOeXPd6ej3+X7dsiSnN+W09LiJHNOebE3etSv6TMuyYlBuz6F8mO+n/KxLHaZ/EHo4sU/cC0/2vUj/kfOdsunpmhtLN0UUXaWpkeiPUvUvgmG/268a0BwKoM7cvTeUfv8s3ecWroq2pP4x6TN5vQg+jPOvZPVpXdS8gEthWBRelzv06eNdukAgWP0jzyAcwgAibjQKil/4sbfJW3nv2dO3Kbuuq1JebJ+I+flK1Vg7re5foJVj87t8q/njatsJ+N/LQdxEvQnEomE1qOi1QGP22gmyZoCLNhCv0wTpAfAPK9n5E1JTX8JANmnAOX7jhIYCOHOwkBuZuAAhlyg+H3BtGQeHG+YwoeJjO2MWxc2W65CJKy6OS23nlJd1YKT4gYGVM197XUSQSSbK8Fl0qIUNMZrAPq7jnYn7+rp/J+WXksIzuzSyhwYNg1hOzhkLXgrtdXhSgdfhnUVXzIMzqJHrwEHynIDZT0dnT/A3PvbKLb9/QOBihN3h5QbLy+UKMcCX2C9Nfp3zi+eLys6WH23WvxY1sIucnXIkFGWgJeBVybtA9xlVXM/f4F68H9Og9J8amoEGl/ITXczMYfkxxEfDyNxFkpbdf9XRvB4+dSOsH0IB9p5fU2Fcr0uKXLovjEriRu1FykJ86VRbrUifEQfwlUXKV44czbc/u0M/WOrxCP7kg+oQew7fZcvC98Ko8IJzxu50j/vG9ZLf+TwgM64xLvsR5+f+k1n3Wm9oA85XiMw88872I6XEkpiGIuP6piZ2Nr2I7I8n+jrTet6fR50dW3+uGv7jnCHlmFTFqyYrp7TFiAy83AYLkFeUzGeXy53Rx9hbyU3rixTVVeplNWVCjfnbWS0JUX2PSzbUIXe6qlb0rDT5YqaqvXtbIrt5/FLkD0zuj5oOnBaN3/Xnx+7Z37/3iPvitQ7HHhEr3Tb30+7pv582d500rp91NUmWTn95+cUusaucGJ1VVtdkInxmFS6otjOuSPC4apV1kZvf375FnnO1aWqpWrYzGBh7rLq5YXLfqouOxUmXFVCwUSuyAgZvZM84aIS8ANqwJrBNXmk0YNv5Slduo3vsSy9hLYr6F3HKtFEjKw4ObvFvOKa9hWmoG1Tit1UpUnM9jniurkD4+zbIqr+rcRfS0tnaMXwJsNcXmE9pAsSWIanHhDG/SiJHHVg7rMdpW1nTxssi9OJhgJofYH7kt55qAYkmQPbkhKkJAzfRcb7W9PpYpLH5gyzXB3aish4bH5bxfC+ANHTbDqyDumIvPYstRKz3c1nA59caoEbEa1nWRPqCY6IJwe0HOUmZinhi0dMfJ/GrSrhhxxR29xwcqWjg37uGjvOWvG0kn/DSV2s3Q0hPPlhUH9Ct0nu8w5iuENVeNCPHA72/UVn/8ZDf/8opjwVf2e3ZO/b19Cgck17TFfSrkcHaBI3/DmzV/dGyZwsc1IGhcvflXpIN9J6z5nMRnJjSEv8//ga328ZU67h40ZhMBnDFq16soGVaMdDqhzO1zorBi+hna/V0q39Wy1XmMAgcAKUBMDQMxR26O1cdXHHR0cr1JtEWCnd4J4DJ9YG47cmTet1GcaX08ObfkWtvN6IjFd/F3Cn9ts1AkrZcEfVoNPS9LQwzOqMX9XUjaqOAN9xV//EmJSYCn9dNZh4DJIAyfagnhbg+THLeXXSJuanDq84SMiPJxOf/juk0kC7PFHudvU4uYSMrb51Vqw8Hua3yaZFWSkWK5nvdG65sXzO37LVS7X0lQzUH93ptdUzKonLFqjqItv8tgL23qsjIxv6HvC42w2S0I5O2WkiTUOjRphawXVUCArdwYOmN/TtEOp5XD330Ya+0ZFjBJUPWFkkKuZe2klO62jucRwFwYdoyTyHsOyHotLqHFu3AOethpG1JcGJxVVZ9s5B7kf0OJxtG16O0HMfrbJ1F9bCtpOTJDYJecA3WVZQs9++1MDQAwL2dEbzKGp/kTqor8HauOcVJGoaGsHC76CFltF7dyVwaBHsQrZMkd0e8Vw9QJIiMB24i+E0KVUWEKoMd/EEJyCqT6p3HjQHysr1Ix/imfBOPnGiptmY7O4Lrz7E6jBTfNtfQWWRZ648Msw4EP1ArSvpsTWUCTP7Z0twOtbp8KxFB+pM3v9Cdv9Lr66LiWr7OuK97iomeoWU3eCp+jDiDlYgCz4Ooc1HtFgd/kNKo+pJ8k+y90VysgOy8OMQE1ff7cYC7WKVJJ9XK8JeapLJkqz7+/b1z5b2nhCIhTbgHUjTWCMxOAuNy4w1mJEV1gMUl9SLovSW2WCi1qmOd0euVRfKAyzwt5/+MDMJj6Cr7Kv02ufMtTELwdBRmSbIHqKcZzshj9BddppY5ut+MJxh9rkLuZvB1QmP+Fy9TYG4/KGGRjRDJmjimSCNVtTTvtOXfI6sruaAmXc56qN9wZw5jS+17UiGFFm8tKWaMermlcuatVcFhSjUdTJpZxZv1H05qH4hVjcb1judOkipCfN4x5fXE34I47K/p4oPdgVX3Niy+2qhyw37d48kGeLEa8qqZZq+iDFaXp1XJFPXK8S80ZosqS2rM63WByHsY23umWgW/Lo5lY6boSUGIFEqOyWBX5YP7gCoOIhGViiz1fiGm3P437dmzDgUZPWbnRefEJzYtGdtNUBAN1bWibXJISmR3sJeYKzWI22ME9yKpbu+h0exa4IhvQbjBnnDdeiophmz5NQoK8tx/tE63sKt0UTdiTUvgMtijbN3Ge2e6/DyifnUyGIrGe1iDxaf+OGOgZrtu9c2zn3rSK/Qm4dtJJyadGXWMS0exJsK7vy1vLsIR11pudyY8KiZ4Lkku7pROm4acHnr/nOGx6mJ6ULZ4HE4+aZ/SK9yLTuhLWP/Tr8q75qNpRJys0pdFWPE8vPo/UfWG1n5zu11Y3lVa9t1DNTKGL9EUaAaKY2fOjRenJ6tSzx851hFld6aLhRIeKNy5LqeqWrJ+M6axqHxhgX74y2bXf3JZVU2pf+jeKxia64XE+QeoF9sb58Y0+Kwr3V2prhvTA6UekEr1CRe0pVcd+oCJT7qW6FQoI9HPKqamakyGpXT4vaPPL1Vx+Tlju53sJWcmK4rPdynVPMyYnfdoHd4tr2f8grIYXmZI0fl5cGo53TGcyvHc6rkisrK8Q+WW/KrVdFZMYvNbh4spiwopzSc92MkoVXMU5nrOZORnULnjCXFWv1Iq1xS6LcV1671whlt6FlahCxd4UtIklvaRbcQw7/H5C9sO99mvesSCuifJIA2qMIhW2FChXLv69ZkB7da9QyMzFbPem/ZkogEgW7QSO+l9qUdS7BWFlWFJbbOD9LDKUeSjkKZJL5FN1xm/FnWtVTkru24xwr1Bktn3t/JtzuiNxvvIHevqUJo/in5a4XNzTSyjZf/6Vzzs3I8wnp1wat0q1Plb9f5PygYI60IIqQqR4SZDLYdugc8Sz++JwM8aevz+JxUP/qZmu9abQ1syxUVlNex/n9rpsawQ9LrZLUJQNJQtkrqixoe+vWUrHVVuSA3IkMIKokAqKbJbM5lvNUQgPFBtUkY5pDgyBHlzK5CWnxH1X4Q25nnB9ngUba+AqzvZWMpWEio3yMPu8CV+pVrhrqe6eYzpJNLVsMgPVsS3fTy41jAX8bH35Dm/e/pVx/WQ2+nmP/YRqt4tiMpyIF0OOatNutdm+VIr853MywRa3mrlNGheK28woHKLEGG17cJZeKpyyOGhS/U6P1023N1rJ0j+pzCOImz5+bL4fk7Z8yXDJ3aXcf+HFuHf2RgFMZvs65BgQhsiPsYZyO3IG/9QN5eHvPRdkkOo0O1uYYS4c8X4GvP4xFyAoj8a4hNcAsW1dSA4fNLnY3ObW4OSvg2pNHNIcQJe4V6UUlWTp5ygXJFzlqWunDktdJXpXcoW3ka+R35q7INKgpO+UP5U8UOgyF/IX/D2KNj1O6QhKP+wsItca290B5Vd0r7PWoswhvwBZ3Q2Ou90GwAHu2xW15zTe4c5HXnizvXm86nvzp94b3SnPUJ8QlxZ/vhuQa2+84X4mNOaJv7lP1Uwn921ylXm+NkwskZ7V3HXccdKknZHccdxhKcbr6kD8HlTfM6xTKx0rGBdXjkdoc+6w+nqhmLRqGsbuNEIeokAVOreDiQoDutisTPO8UoupMApX4bDapXb3W6XBjLHQdIdNoqR8SeDnbKOqrTW+O+TNdymN4toKupefxH0G0Ka4MtNksXvz2COQHYRD65R2v2vuIOm2FEGO5sOeA8at0bVZgUcq+dADcLjKzg9Gq0uSrtBk5spbvAFI+TFyk4wRFqkDKU0GLi6VPLwB4tYYqbc/Pv6DRkICwZpgFgBII4BgEbHmowX0ZDKrgSNqUUp4kqv1skX1wgcSc7GEMybETWSdL5Ez0j4hfxOt5WcC0oX5vpSGHMuSSkJD13vyMWbQZDKkHhMUqLGdVQuSWac+BkKqc61OElCX3ouuvRNKpBUjjuvMQFBoWZk/h6H8O4p8HHwD2BP0V1LHEtEReutdijgYLDzMO3pa71LCGWcI/iTtD+mTq+C9rFkDXZ7LlWgEk0qpSihj8+qypLMoPNFIvtSjhPc/zTHr+PsvVQIuWBmRPzYk7bJa4NvhYEcO4GeGPIzE6SJmEIeY17f02LbMaqBzMeI0yNbU7MlSbVPhjs9LM0dxLNENjVmd6owxeGlhh8M5Hg5JbafSutZdX/fYfo/qbhjfj6X4PIENcsvixBy0zo43W0W5manPkdz7JRSjXaJ3qZlQ+aQE7Unc9azImnRUTOQKMoUFZkbJOsXDhO6SYsnLApSV22ZKvmpE7z/s/eWRY4K7vKnupfuwZ3oATO++z/deKliuw41yP75CvzMQJk7ThzNoGSA/Wex6wbfeWjrwyf4tH0VXmL8mZjkMGZuCvK1PshKY3IprPeMZu3Fb5b57JO67D06td9M8euSUes23Vdjtt4ft5ehcqUmDQKnZmbcWTp5pgDuFsePpQse+yuMSPxXjOq70lE75vrPetxBySxJfKgyaXC8zpBKoHeQ2cKC1LJwcRADJVClIZI/Y6YQOQhHlRu/ZsV2ne2bOLNy63wFdhhCBSxXe7N88msssMR9AN6NRObC7XSGPEIe3rfFsXxMdIEUiaAj2yeXFfRn5T7Z4LwmACSRUnZkXQphx6iCIQ4kFKoVHAqA1lNm9qLm0ZmUr44VpdZwmJKaXIWNUbEjQlONGWsZ0glpzyQ2bylDYS8CG6KasxjKnaEnTzhp7wVIC/vq+PiVfbbamFvLmxHBYvlknZBs3ZQwAKy8gTYoIRaq2qqifvqObdJZEHg53bqxok8n48Lak/v6zO1r2oaD4k1z0to9GkDTXR8sgaoB2Vu3yo9LUEAQorzmAVR9fiV8B7XjS58pyI/qePDj3O57p3YXFre5fsbJdL+G2eS83QyXkyQIztLnjA+O7Ifw84hkJMS+VNTSdXH/AQhIa/VB0iHPqBT1RTOfLxCvs+1xbUeUU6vCCwkqxYsSu/LLAGtn3nzYY4+QaLwAvciVAfgU+iDTZ3P1g5Llr7+0e0HIsNJ7KuInCupOzul07zopVvv6eE1kK0qXuWeMSGJ3TsAbcktLT93Yl5lmaJDaehPFXvlKoKdA9lO+EMv+o3vLk1/43Mn+M4LH7UMtvTQZit2mlP4J+vMmIgMgQIKVOtrT/RIjEyWxFTacFKkj3MZhyMyBByUWd/WFECwMrzmgU73Nl5Umr8pdVvMFT40KG4j4xEqd5/CskpintLd/64kyKSV1kYP+lR4TTMEEywiJg303LR5ts9XbRvCAQLHwIHODOeq/mshb78gqoQJ5Rb6LAsSy5LSZb6qjaw2mUeMR1xyXVUyJbboOMxXSO+F5bAKQ/3ZHKLEUW/lqKOWKbOfwCrpW3piwzLlbqOu/LXNtKguQ0w/m9xn+p9s0zLbXPWUI6cuV5iq8llg6R0eV0eBwT5yOPSOphPuZTEbirrP+u5qrslC883j/fMN/9VVlZi/cTilYHsfbF9kPEPJaB1qrGiwu3zRdvtvHePQTDmmocDf+xdnigat8eSHhKhiyCW8JreyaMgg3njA1kygrSl7CxcoZm/2m3/sUJtIGZbrnsd+bBeWkx3x2DiiIC1z6rQzuyghzd/dQ2sZYquFw2VykQpBx0XSSNXz0Iptx3G12KDMrpB4ghm2wCs5JlaeHMtITGHEAsoOsvXn4GpLIyMwY5Vlo8VbYWJozUD2Lzna8+Tx3Ep5HDGeTUv8uzrkNWKcb06+S8JUkr9oHnfa59hRHpfGF38JurAp5Z2B3SgKvWmYx7YXJnA5kZyQmJzdHkajZPdJgMD2U/CferHV1KKl5wLWdXGbFxVn3t206VZE0Vr0JmD/V546Ou0qwv5e6yHdVsYA/3B9nYWZn/lhExmB55XrLD8Mt/DnOJDQEBYH5pmb/EuGnl+Vr7U3zGfiPwTQcpsRVy5V5VvW5BzFY+o+mOc5KVy+PK26/rFywS4tlQ8HXogNoEJ0UkDku82TxmadBDjxd/HRBQE8X0nI7oLArRgFYc7At8LGnxAYzKIE+LMowYERQ5tVggPcLymrXFLWDn773h+CP37bqArDv7dkWgzr7ata25VHxpCD3hgRkYD7cmfCD9nxt0pwX/0ifftJZc/1Z6asuq69zJIWNi0XBEfuO5vRy+IOSwvGPqkBJG7fHN7W7fgMyiv/skzBW4CRb90ioE6fPvSJjfG2r2Xr0FmRZhqCm0Mtm70CXFF6hPQlgexzZewdHWe0p4OsQJ+5Je2p8PP5ByAWSfPF/rZe2IStvM/8i9jzuSrN06yIlRzl7B5E54AGmDySrcP1iuUhqtgw6U8hDfR3IfWVhqnennv7f8EbwLxE61Oa4+zTci6g+n6n//5Ctnrj5iuFH0Ia6m1B6ir2K3m9rwv7HdkoawDDyBP49XfrX+0zZNwf3uIWVq67ef7U+TQv3LrC31mtgJloc5J2hHpK3gUw72HhFHA2Gzefmli93jaknq/FCZ7pecVuAc5vFaP/m31sp4ZrAfKDjm6ecjcKeXloEN1EpWJLpfRT609SNXClOB/spy5UrGFbDKuRWbtoS0hDSl1jQLkv5YlzAS0dYM+8uKKLRbaOYaRHa6ZZcpoByoeFSzzzRcPBCGWOm1fwVgOQUlCthfx0rEcrJO+N0LT3ILSK8eVSsJNioM3Nhx5Q4MdURVtq0oWPDd4O9Oi9EBgqsYW1TlW2plqa8nsBplY8ytX3jvS2DK0cUfHmyv7grdh3/CqTP5vTgzdO6pUMc/tPo4IUCWqTJIAwYNux+8GXLxwOkU6cSx2fXc+rkl0NaVo/Oxo6d4iB2f4fPILG9Ien9dP6N9KGw9KHlR+836a02agfblbud2znfUTFyUGEJfx5do+YBIgrhHckLMbIWGwbDz7dL2r9HTHDJw8kWacQRp2XD/Vc/IMoCP34yEHQg+pdeO/BafFaa5Cw4yQ1oOwFVdyIiD8DWqq1Tv4DOjXcWr+/AQJD5gUnWurcpMp9HxR3oafafkhF494BrVZOJ/NPOqlSxf0YqHxKJawSFNihGALM1EMuXuC5x9qO5WDL2mfNkCgzIbaPYQ2MWzDJmA4QwrsAI6CoY11qodsbKZiBYBIb79Jyc0ohpSpqtgUSE2P1CGZgFJS9b8sr5g2u7+0dGRkbO214qLy4eP+BILUcMjxzxhU11fqOQINIVMJ9ia9ejeBQgcg6FXV7/R6sUCe11+3Z+C+1uq0+PQ19CEpLb6ublRkNYQrlqepYTua6LeEEvku6AzsUeExAQB3BtomUYR2L8CwE4onIEaiqzHVdHc+6qZ1VLFn2O0ntYdjLr6wlFnnLwlwJiBzAI7kyIqBkucERiWFF3rU+UJV+rz9uxaB2XXdaxO/MWdesAs7vjrGw8IC3YSmI5t4znTN0MtDx4+8P961U/v3bt01O7/g2Pe2cP0PdudPekIEHZP99MfAZeSI59WdW4BUOysuaIVoxA7FxeibfV7qxd5WNLWajUpwIhEN8Sw/CPh0Owf6oJ99jdwBBP2A2JCzYfEPDa9md7eQw6S0+XPcjqMu9yPfC1e+f9DVLHO+wTGnSVG9t8cxcW9qpTkpYdY596pW1B9uhGJJ4/cbDW0A0q3WrCatnhvf38vuhAOJAwB2L/Cv6IoAFk1IuE0FTkFSbK64HOFMHgJmxM3IKUCxx3ZVWXoRmBboA3dNimfbanV1kfGuwChp4dFEL3MOkPaITOuIIBHFDL9G+30v6NuQ5QM4RzKa0/zjbg40pr+M2Bm3Va4/Pix+FEnp7iXb9tbXFQxIL6+1HE636H9Z228ygZPi8hQ1sQxGIyIfnYJdoFpaVcoCxpK78AC66U6ceRttt7tilPjLtkYi6lW78mVyPeQqWvNkzw2vYGpA0M2KRP++C7HPNTmqXhuTph/pUhYgSmeYl0mG/KbT59jKfELJ9HjcK/brqIEmUnewKfUE2bYUibyeCaUxJjB2eSQ81+bx54JfjPwCBhIeBfK/WVWUth9KizGhi6+c9z6oGE9uxX9ICKieAe52IEGidHjNyvOrQB7N5IjqWVUA+53HC23xK2f8h7Pm1gJX2146675jtp7Q3MhBazp28zQldgnAfGyV9BY4ZgCxyCeRUD4OW5cSBZbN12jEndA6EzJZY+23k2alYJDpEbD6AT8Xy6uoFHvP+7YVLWB1bkju29OGENEXLaCHIQkGty99qF68TWsk8fDpmsRuhogOsXgOLT5vvaDWtgAFhlSD18PyAhK/5S7KTqb3lhHUbkIWdpC9iA3qsdJqAd36bOGkk+ahvb6PvdLJeBDNRP3LV7UzListmrPdvy80ISQ9uz/VI2BWZzR1p2XFVZ2fqjeUp04emFGke9S0aYav9dWnMyzQsYXueIG6+WSSwuJv5SO1rShlj1M5KCAE4QIl0MUGSeY/q+6U4o1JRziko5w3BcXL+PLXC6asnVMT/lDJRVUW+81SIqIcUvxeiDNSrCp7p0ipEPCEElBLipZhg8pSrBbldkjBe36IrPcer9apJfAlevhJP/WF4o7snl+OJRNBUUxJSPD2eTysSXy7Fy+OoirEHowi4u2T1lyfy5Ql0bPw5ibqnZTWm5CzGmRJPdicHegV6uHvEU8Jd8heqpnjjC70IqttqCkRdgR3DoktxbyIKqY+nTX6rEBOK/jf38LsqADXXrwjl/O0WU4VwuUWNy/FCPldWLUoo8vS4WVdafl3PXtUFzG8fUOU2ewqeW6XE6T08b3oRUQ8lHq/BCGeEZngLGfcQjwc+kgXyAN/KpMMFxpTal4vyiT76ohn5gh3hIcH+iEMFsC/hORegmYZree55mXKtTCs+O6OaypKxmK+1W+Mv8LH4CQXPZvdu65AD2j7RTzwLgzHoIxRyycp5F+p3hQAZNzAiAaKQE9hhwRpZTYC4MH9JYr44SF4tcuRprQ1hDAWb3rRCjOKQADeRTjmzIbX4Z0kgMuuDBGlPQh+5rAu6KnvIqiG9JrpG3BBzqMFToZ/v4ehtdNMqVsbqkWNofLWSyqKMJhBFPaOtRQSWK4LTQkqgJlEiL3HCZJHlIos4WW7Z/aO2hIAknjoQ7+8ZpIpXBrt8DqY4nYuaYcElCeNGjoLlqOvW7n69XNfa2Opc4yDKBLAFgQc9D/bpoXfAjhbluJnkIqrkaao04Mh9QpWpVzOZ36zu4+5bbzRZZrnMIosd/tLSMzEDRH9v2pS9wHLBXUODqoRwz7xBeWywomvJN1MgTK7NasGqDfVA2T79+XP6Jf/x6jDbKXURtUG6IN05/YgtXnsaI3j4L6HepkxbFmDiMC+tliiJ3D/CqFnNKYbYm2EKjHdJe+KtZM1kQwgxr5W22d347dqQ2kfwjGSFEmqJvDyW44DxGvKkUq/rMPAqZVlDsU5zSSh+LuS4EUQ8gZ9vdQ93z6ov259FUJtxAtz3e4IL22PbiVgkNgLj4usfE9Bp3eCLRQYA8+z3mII8qC22jYC1b+VtcO9W8xcFdFjX+2LRS73Nu/kOkaUXL9Vtamj16KhvqecyLDtXnsyBzHi/SZZnxq3YjDkwc9n0UfCmThNP8gz3IKFIHlAEsjHomP4nvAFnS6QsLcjezCL4ejLx89eY2m2ltIRxEgpaiShFepJRTmWWc0SkEhEcq6M91YY77AcsY6tQmF8iYnB5sR4HSQxrPMaJdJIsX4LwQqWmjuot93GSmJcgoOzckC6YX7YVBtPW/69oiyJ72Bj5Z/JH2xFqrt3nFOF5EAbhwhWthzshWIw7isYbg/wWQwpIqJIqZ/ZyLZD+OzJJO7KB8GTj+lSS11jqxCUSXN1mF1Ss9weVm8eaUnOg3235EMct7i8sjh3LwjtVsL1Vstvf+bEQxHYte4Wnkz2Vbk8JOYIAnfJrgB8RVa7rlZCdqu7ikxIeBO6LEuH/KPpuF2R6tklp/hMM/sNQX+2tDaZrrZBhihW3NmQ+Kjuf7wIJ2rvre5VW2uDV/nHQzVOCB/0b6ocCW5hC7k/vbF15V57pTVJawSQuqd0lmJKb+K+ncWoitsyZsd0u7905Ku23q6cHFKudSCruOpxIqMlmY6FFcN/mUrWWb6W+uVEjImjV4nRMwslcl1aXCbCowU9m9dri2s/AlH0FPVFdr5pMvaXxvkivl3ybPGznmCWKy0PTNgdo/yVgdDSoNXvbKc9EvBck70Odgr1XMk2FsuqgRpeYy0SFq5dwjpeY/lZJNGVAlCC0DImsRyL5wZ3GwgVTs119s6fbhfONgviWTchi5EbcKb1LdN24z3+VGpqymU1xOSVxG2Mrj4+iObqxusBzZvgK0baynPmmYhiSIRPzdIpPZa0NyV43dXzPUK3c44H6kF5nLWoS0YooQpQJcQ0FAjf/fsbUxhA/Vlx4XaJvRoZvZyaedzVPp9Zv6ywzlduqbExU/Z/Ww7XcGYZObgX5VWB6p1xU5OzD5GQaka1T9OnpXPqva8be+ytdKFBYnNHxmPR4JTKKul/K5Z6Y5zJnQP5FwJ+XyWeGpEhqu8t06U3t+w6JTRHqNvZGTr4N22NeusoF8NmyvO2t8mOR1eusfy1K4ETUX8cFLivxoUxRbIFPkQMIwmTlAGB1k7unH7w7qeHWplX9Yu1omCvoEX1PkF3m5rPx7sHwEw7aicO1IcwZf2JomAnF/OIf0wYSjsd5Mi/2JH0tNAO+rZAtAoH3Eqii2xx9luAZfJB+XMfPL23p2ojPscAEIF6EJDIDns2U4jUj3Oe+wFwPgVBcgmtYs7QOjL90eE2sKcaVFE9sBsApXvhWOWYr+xR0c41qvBHayMuXIyPz867CgXj16tU/Z+FCG+X/mFB8wUN2Dd62sRNx0z8vuSbttdX7yuiS7Ah5dLtnIrlnJ10Rq09JafBX6XZkFewWjS+/H5r2zW7fELDy8SnQ+TCk++tQI1gyP/lCx4azEakpizUL45NzYvJie3SqY4Z6Y843+1XrFEEZH/3UkjEpIaLYKL2Nk5FT+c7xLIQXNJDyH+RI+EOOJG5wPyTBPYLHAmlbnu5+xdeJq50PtaPBWViWhQPEQSOTXzCCFpKoipZqhSUdFyNKyfM4X6W8mWYu5+/EyOEtzopexi7g1icKjGR1wf7s4oPQeAgsPXL/7pyyI5FlsZO2pYHyKkFazcrdhcUTW1Mqawyh9bXE7LSA9OhITr0EF1SysiX5RZ2EHZUW+XaMQYLmyGOKUt9ZlDaA4gBk68y7q1ncsgGlABsUhw4C/PTK74Efio1HJgf/GWMDiDzj9G+el5Am4mzzd3WMvT9MSFqUs5RunI2rTSlEL/NVnHHWsju/G/a8O+oPBQ2P7I+M7gy8xvZnHo23sxGbuN0pAcrR3aKqn6WM/7m3eQ53fF5+ZN9sA68WJsm+QOPjwVMKCP1s1ocHFxwGxs6NcrhTHu9aHrYuYn6I6wrFEH6OlGV5+XllveK/xWb6H2n9tokIUwff1cDUkURUupUXnpWVTRXiGMkAgU8l5SwlEWQsf+5M9D3OQv2pLYOCMeo7LIKPe+p9F4Qs0pzcPa2/c4/eboyJPce6T0k79iR/qu7ScPLtwidpJmuMH9w3rtn6vUcu7vaxEub9jboP3fbNdPQAFDDqG3IFtegNJx2t/GJcOYOqcn+R2+4NbGdqT9zaLXIM3P6SbPEDYxLF7IvDN2ljbSvTIRWrRJdd1fSJzmExPdGkNXGBi2wGf44PrQ5s79sG1aOjJRGVkbQa0pH9asQJR/dkVArCD3YCL6P0+Qn1iCP27I8fqb1O3r7VXsEMeJOc7EKuOsbB3FcYqdq8yY8ImBukRdF2UjRxzwNVPXpqVWRBUksW1l3kldDUFO+5aGwh1VeZn9h1Qujrog1tDyhjD9rnJwpIAmWOqHTt3BVve1KWfSRvRRRi+7E/mcPZFYHLrO6jQaEPeRWzZtv+mrFDL86fnHvd1rN1N3rkko8djxqT0FhHtnahstX+2tstVz6/ua1ffplrz6OUyPGPiJSU7r+qdu5yyJtpgiYhryopgbMIHXJJ9ezSYkDl7KqWJU010J1zkyFOm73rPdUzaMQlYIEdVTMGso6P9XlWfAyOjeRwiA8I02ssNq7W1a2KXSt7E/b0xkXOl1zAE9Re2dMEytYDeW7blC4qHVF6lU1Ps/PVv//pEETvEe7dJ+xUlf9TXKIwmFdVJzX7lL46mSPhaM6FQRUlykVat8qcNWK10pyrFDZNLvtecefV7dO22ljX2yiSpgIxhafYXWyH7tQoNBccoqdB1OaY4o3Sou3bi8DCAhOtVlhrdile25rcbjbjq2WlCFGifu6AcWDrYTRFpJuVrdTbbBHZWnshnrPO3mWn2bkQCAzCUruWZm2lhHfFoRd8tfjaTvZ3AGRheyVR9Aljn3nY0WeR/VKznqCcxUE5eu+gWLUHQk6efDX52ZGzEYdPnPs0OV937JzOOaW1kKCvuxAcLgeZ6OWi/2btb/qxKPsbRN/mmVwTAxxFUGydnH6LULyEy6JBqyel98ePbZ2ypMMgEHzF1inMXcuNg9oxj988fGApe9nt+Hk/y0o7fMaT5RU97djIBH9KN7axTeXl/U1Bvr3vfndl+4KkjUj4rWJezb4r5s402PeW9VQbs+KJMRrnurLRs+onWk5XUqhmEMMdWqZ4qZINUrfNHq99HpMIzPfUzR6rRdfaonVewPetfdsNmaywF/891rwz5LFDQexsQ1zjoydFDs6pKdcui2IuLfrH90dC/LTunNiE8u5IQXxaRYd5jMut03nxSOfcOv8M+ySNhhMniliF9nYfyTMmu3nzAlZRSi+5uf+aSV7p08XbCeonNFrv/1lbGX0+/MSTbhafnNjrxNGt5hnFo3boq/5Ub+R3KPJreMeC1SDP8tS/rV5nV3rbvLhyxjFrDX1QY/AuZvrFnen2EvtMQOS3XoMt3dA38HBqhG+psbuccs2k8PpE4ra0C3BwS3TygcIDchT6j1V9yiRnbUp0kEFQg7TDdq3dywwcaBMq2bLlzZst97X9WtB2JsVkSKtqfDS3UMYOOaDz+7HeP11df3oFdxsY2+4CIBEAgAgad/j/o0yb4Q8HmMDaes0gesCF6R64oNCpIdX4LgUrJyx6nGI4++4Ig6cPKt+uJIve6obOas6GLIK1N+piQ+aFARXj65Jvni/a913BRaxoKx66ErcjUE6qGcg6DR/SxzyfROJTEF9TNBA7Ds7WTEcfrK6Z3e+z7FZf/SFHs6k4l4jKnCWw9wIdrWdxXbB3WLncwhsYElx6C12IQpdXsPsMh86713r97FRT+Xag9GzTyvDwyhCFhla4KyP6iuGhnKq1p6UGtwLmFfofDPJMIPSUvhW+V/+n/rrPmz3ddTUO0mYehl3qWTrdNXRncThoxKIpo6qhqCup2zweNWSstFCvOjnbP3R1biThrntgHOf7HlmsEKu0PyHFJl3cs5LfcKNhgYa7UrIcPNTSsaVua33LRHB6YXdZgdYk1noV+jqh35OJSBl67ObVERuD769kWZwQR2qxYe9yzT7x7/dxzbhFQMrYR+OsNI3eE5u/2ivugPzU2+2TArfzNXyo2SLDRUCfn+Lgz+I4H/14j3k+18FYA3FJp6YzJeU0Jo2VxVVl0aN4jN6cKx/WG1ZbCle4Dj/SJP5VjKSLmTepiuxInZXskDKx3JjubQqHJhrnrnt9tDMD8X2dvfeM1/WiHZZgUgdVBc7VPX1paSr2oyJROrPrLCAhOKnzoDaL3KRQpSfgVJRzpOvWcnZ3pqyDTRIAREtPeO/byWluTYInXFenrQltRpOI2WaKUIKqT8QcVqYNCbvmXISz08pgvg6V45ETJX7ySsL5SnZDbaI4j2sddjm9BUWKt2fdZnaeR9mhzncy77Ew8STbLadc5rTGSZhNRDecTxbbutLjrXJV+gzKFDpR2oObMTw70gktq5jrOhjheuuv+l4l8XGQvEK+WkuKUUTr6MZ7BdKXlnjHb2UltCpwDNcOFjd8tS10PF7deNij0GJU/u0qbgyV5X3O25lv0MrLntco890B77Syg6cE19pctp+nXijvHlpuxNEzoGaC8bFapCwyy+2HOoOnr6oiuhfQbrtAe/O21Tgspi2iXriddxJRs7eDUh7rk+Dt0EV+p3/q6wsFwCc+0RVAXlW2Pv+S3Vc1C4DAJTMjWIk19AYi37bnuLXobXd/DK636CMs6H8ssUP1OOmWhZ1Xjs9PPcS74oYY3Ej3Gzfr4z3OtsXMGjor0Q3hk54oTuWsPM3CbiJdO9ms4UQKCgorh019BLVZYNbnKkwQl+d2bCAAi3HBqoeeWmaj/LZ1Jq3KLX+Yo0E4s02y+9TugMAQHLfm6tbKNnUKdBMQMml75jXwleL+BMZrEL4c9/kNCcF2QL6+5dlKZx12OzFwaLcCBFACddoyW+twjAe/Q5GVVW2jlwqpXkiFv26qfDrMfeXq9EoIdKAeON3hMkWepLCebD3rVS2706196NXbEJMwFRPkxHOpCS4+Uf0WoKYaz3inoFSu5hkWYTck7m0S+n0ciTthw7//bWsuxDTTHtznN6rxtgO4S3Tdi5RC+3v8EN7PH/OeuVo9o5F/+yv4SaEX+qbh5Jf3d/T96ZNvTqkur5BS8SJrrk81aLK8FWG5vUOVS5AwG0+viv0fUKskhC+7e3HLdVvBEtbAX2brXyIukHfkeSTsOCkib1iIOzPANFon5PKTokcmnqz0b9nsNRug8mfIrAlb5O2RgnCueKMkflZsWXnSP0E6p08wTy4/SXbCewWx134MbJZ6XSXyvuB4gfnVpK4xn0cy9bINza8e9zRgCzF3+aGzuQ9e+A6xIkL2ftnOPNeOa9Vo+jql+78m9TlEg8mXH/zZQAnxuoFJuMjiNDzsbJxDIu1gv8g25/ylwd43FtCLley9gHvvlYXtpz1WnyuvlQ1gl+FUA/h/D1UQMOuUjqCxcypPyo8bEu28sHRqjeHUeegyls+gisJ8KgUoVHfYbKlktsVi4m5RL8jLN1pbm2l9D5pow61tXombV6NMtm2nP+QBLC9va2sCWMVGdAa7FQKHthO7sSudLc/ke1aaqrpYN4xORmQM9xT9F84zOcTIkYVWvdF7B1yPFKhvzBSsbx/9yv2XNyoPHzrEXssuZp3iPWf2o60KOzp1UFuwdZ0rz1rq5QdQBMnuz7jldX4oe5y5tLfLzcr9nghSpPzuypHQsyWkP85M2OEnbaNPI43IABs4tHgKgPQPJBpOPsB8kt+WXh65qh95fnIH2xaJj9eu25l81ix5La5u+79REemg35ZC007PIm4P9/wGjSU7VHPTA5URQtatZuwgPTPoRVhYmTekVxcN+cZzFAnslP8SmGkqKCorIkFDLsLV2qUY7bgrnTqPgp/TV1JebZFTUU3DwJ8YeiuDDC6lIO5zU9rmECHaRl3++2JaeEy3fU7I4k6PCoEBJOvQcGd2nYdFngzpbUF+RK+MglBoI+OiLuQwa7PDD8jjsqfEb+K3bo1/8z/vzdatbP8PjYkvFU94v/kkXZMM10yiYBouXCimUACCKzpyanvUeH1jT/ru6/0jViCiBvsdzKUpnToMz+5moJ6oKMO98lEe6vAgHPTHgN4qqcpbw9W1n5Ks4X7ELWBo+MAxKTq/iMMFhtKZnBi3wm4PQC3Izt2B2ic+YxMosp/x788+LKapsZFVMI4uUZ/ur3/u2y+MpHNVKrZrot6RUjEmJjt7nD08pB4JUQGlFrWQZMOFUhUYJaSVHaWxUq8JwKS9xeKnRkAiEonO+HqGhkVHMeNN6308KjpR3xU1CYPVeleawaML1Z+okPhEFosO10tqfh/cB1++8P8fDB7zz/8MgcJbI6nXx8zhELxaBrfu2i/AhBA5WE1Gnajbh3sS4MHcN/L+HgLImZCxnNqp5PTP4hu3K4oFaIazw8P/c0RmISEv18XaecbZC3vcuPTQPfXuZzA8iRXM7ynlOKA0sAdU7E3Kpnpqt15LIhnDfwPiJEyfK8rcj78hXqWGXCqS/GQlXMH/JR6gik65GMxzu+TGJITNy/haG5aUOsu8GASNhiaFLBPAdAwnVdx9lH60I87O4gq9XBHosumA9MmduIwvIS3sbVnCVvNCLUVpOMm3OazQyTI8x8hTfk4JS9upxHDTJ4fDgqCHB4AqkRXWnNZ3Y1dG3/Zjpx6onks/wlpBShDZxrqlcDfUt7zzYiDRaYf49stLTNJgXcfrZ8mOcCRsKYdx/Au5osGx0o1WsUIfpkOPKmPvgPxLr2lyen8hkTPo2oe2HLazfDDj30azig1g9Adam0IEmVFenvZ6fSIh1alNj674ciILv1veGVKyjBrvkcBNP+3H8A+GuCATvR83luwL4QmHZExkHEgrWNPp91Rwnbu29ZcfO52M37tXtc/P2zOPhms+avqnV12gW/cFAfrRgpdRVH74Bzc5tUWdPJtyBZWjo2pPAj7CM69T0aeKQjCPbiv5D1xxxFxYaB3AO2VkkYfgSeZ49uU25T7xpyChoVhDp/2gVh1yAZNwTqZGrxOVS+98OTlRUOeY9hpiYS39fgokFQKRRxZuWJCAPzphLnABZi4fHgILIcKuQ+FmiACE34RaDyT53O+A+r4XCurh1t2eXNiJara0q41ydtJimzH65MBGNAsKJUIgEAgfuUINayK9crIsHSSn9CTsyf1ciTdLla013nP3825fxAy+0Sv19bGjFXa1vacgivJQJJLPqTPML6GlGHi+HT5KgoZhdy/L8lTOabtY6oZGkU6thylAH9fMHh7UhUH8oQL1pEskcj76R9duYwlR7lJdDaG/XWVcFUMgEHcQXurKus0A8JGer1c23qp9TEJ8+ejSsZmoszYx851SDA200XBuPZKHDB0MYhCUHT5Aawaz/hZEtlLX18aMQgzAPGTrFkTMT0ud595nekrrMoVtbwW/3XpNbgVF531FS0fAV5Tkt5RIoUODCWmnovMzs7UFPAVJPu1NGVH7gZuCboVo4O6pHjXrMK0WcWI5agtDX8B+UOpv1vXwYa2ZyoDAMfCUPmLXqYqR09xp1naG/5s2Mxl1XwicyTtmah4DuC8xJ3mwGTm3RDibYdEgBa26bisWLlrA8hhmcf+5PsFaDszD81SQmhbOn86sBPVzNqfq6csaDdfuH+2gd6NWDB+sQCn4weoIgfbgdxcxqBH+u7Ng0mjvCQOmfFp3spCLqob3VbP/afO3Dx5hrn97+F3nsv4iqpcQNQuIWPcgr033oURYZmx8Ns9ipskzz9JaHz1joWT4x4YvwOJiV0/80MXi2mcWxEwgFQsM2MOBXrAMftCHb5Q7THif1DBlt18IylqakiyZkLtDw7XdtyX3IpjECIe5ESgbe8EWmsw+1O05gjYHP8LBgwSlA5i8Bfz774XpQ4eOYAYZGS+HoMZ9vUfXKBABBj8EpAARlAyaWmm0Fwm5Nv1t/fK5CXZ7TK/HM+xaq1tho5B4t8rZ+iewOTYSIae0MbYysRcn6XC9wMjNpeZbpMuUxh4pzSmxTEDGmVZ+K3KYnq4yn9XKkQdra4O1OfIDWu3mCTBOR7uFhssygzVy2WFRShYLDsMjzv1/K44WWsEsqk+o6c9o7U8N6Dr6GtZYFQc9YKdPv+YwiMEMjhTfixwcjLxXPPJOHcw7wMp7W7O+Hpz8HNNlMMVet0fnyM7drMAteww6viYc3Jb1VqEWGU8ePXRdhvO8tcfR9jTGj0tGfTFRrFcBUMp54hNAT6V+a/fxplvvK4G5Y58RDATAFESZxsr3t95A+Y1rLL8VVULUI8WxJtZyQ4y4ZdYs5C9hdFsQWE9k69Saey3+QPJhC6QUGWlgIFHuvC+wDaIGqUKCWO4YSfVIVYgsfaPIpF20C095qiyuqt7t9LkbdEdkCBS3ip8uQOeH676EjKwA9n3v24D57hrHDzlTrVUSr1cAgSFPyhqi0pWk6WBowLo/my+YPZ+k8wog8G/H+SL3mRoGjzo4gvhBNgJWS8YjppFYrh+2iKCJSXH0cY9LhY7t3Hks0biDOl5QQXUQft/d8luwAbk1oIDfPItgZJGZbDJ12Nod/3YNNp01YtL9C5nHra2wgUvT93br/O3RFo9vC4iAiq7LDZ1vE6OZCknRkKU4EIroEDCK6MhNjPz57Ql/U3/J2BcSTh/2/AWW1CZR/SXCwtn4trZ4Wx4iuqU6hnbLRQhiDkrak/UwkJRLIpBg5Ed/Xrqk4CHx3L71FDMjR7LMx/2LV1SgYvhBw70nmvL47zQUSc7DSW++oTX1S0CzZCnGu6JIOWVXGplgnKNwklvL8Sc67fFxzlx93gGOxzQ97rBARDd/4FrA8xOZd7YWWTXl5p7e6RswFDaT/77TmM3q0JKBILQqKQOz6OyA83q3RxbqUzwBLkY5IufgQ2HOIXqErqOKW75+xVA+mpLdtGMDkdhaQv+PYsw0bB4QwpLZn+Pdc5+d65vUs9y7WYkWp4FqKEqVtNWcG7I6iHFabyU5IiCMFZ/J4oVdYyw6t1pyFfSgUEE80wVAcBHEL44i+5zG1A2fj2fLXb9bdRGzb8VXnCi+Qce4M2FJg0wcL7EIjyleasGLXxPZ7nMTk8c7kV8TIv6ArdUUS5VZtQkJbRHEhJoiuG9q6c09MUj2nmbGzqQ7RiDP2Q1VXFY+s/Afe8DFOVljNkqcP3jezIBX8zBNLaulN9IaH9iZnqLuSHJWqDIKt5EUHUnqtO48++AI6+LmKLfc5rkVBu0PnA01dXl3akJ0hcv/5RyKBkGRsK/Wj28XD4b1XGUbM1nhjvq1TFzuyrprbCNz/3PQy3+UDsuvzBsURxMO6GL/L2vm0MRCWjCW8nIVzkS5aIVE2BpxOeH+V+vzn9J6s0MdjB04IECsyRMA00MX6gU0kYS24pzxFYouN6PCVZt7X6dc0RCAj199IyF8epQoMTK4T4ePna8EurFk2UD6Qz/5eDfuC04uP3mTanZHQ/T9AuXSjIq5IgX7ypoUWbxsQ6pgvYbIMusnJRLG9+yAYltp3Ks2h4npaExGkgqtGUhPXb3+hIbe56MNjU0VneHuItvcVe3SMZ9Q4NUKD1sQ8h65jTmvsqTIEwb7/ZbSwlisnQ0UuXxV7q+16sNC2PG5HInpIFN+enwuwjT80+9UUL6Dey71pWI5jnDeecwtvn4AXnqsswr6XPrWQBVKqMpYYG7uYhBEV3BrDjlfYywaOrEy41lhARGIykbOvNKm160UYtQxuvr2RExj9mH1dSLSnVTpVAyTNytvdv0EeqAf04DGoww8jm7Lc2lEdx7ZoS+zxaMHw/qbsfDVEzNtVy7JezIrB9inrO7LdJIXYvCAlcVKnYIElmPXCwQi6r3LBTkLxc7D5MqTGZui8wu50zjjbMmtQLWc0aTMpCWuPmnw6xb6jgWnTxfg9AECx8CB3tnfFPZ+l9l9JLno+mZ9Zabz512m1LcOu+85k6Q5eTKpNldM4rr/+Ld15VMLTXb6icbacaHSOXTZKWlH14nj6DCmzu+HNvjypadHCS0wSeUAI8gXGXXgyRMxl419xa1bY7QCwZN6qZShNhJXxYEhLXBpPxZLoaSknDj+J2C4UENycrvx7BnTE8fPcFz8jZtCO/lrFskDaf6FfjjU369JiId7J9FEBYnxg9HyyqrxnErgEyJhbUAhr0KVtlPSgrGx/CCPPx8fe77jHQHmxYIaa33upE1xuleFxc5X3iwvv/UboFIrT9jsQ/1bEsb8kVl3M3xjf/jNwvzkaz19C1G+/7bbYztZqTTA5eIZ+/bOzBWHB/tlZDZuqn+R7ZP72q9sY2Dj1yy9yanfpEAVBw83aU2PkT2Zy+JHc56tNGcD6ueFJdZyR44Gpt1w9EjqqkMcAwg1cL4js4JTL9qdKpGm5AnPk10FNvIPgx8cfRf8TuB4/py87buhy/e9vI2Ly0VyrlA/U3LK7mK3/Y9P1hx7FlGArXCJydhoKky1/tQWD2LO/e+OzPxZDFPrbssNL/tCWvw7C33WbX45Ybk0spkdrKItwmisW4cLstf06c2OH8+tlkokxTGzBZgATscmzXwnu2PH5KylL8q66ef8JuGnpbMspxq5L545NOydCuKzZ4eRKRleRAYUgg4Ixy+tFVAiuNyIRWTTvQsfJh0IUyOW1QJwS6DI74BEHpjbAUT8pAr7yJoL/PDqGk2IOULWxTRH4R7zZUDxZo5+3rs7A2F+t1dPawrXQ0wB6PGOIFSG55V8oDuW3XboKeKQs2FIFpK3DJbAufB6rj1seU76FKJTXvrrBt94R4fprzAYqgVm38Z4IWW4A8a4Lpo5labA4lwoCgf/KG5vQWlP+UB1dDopk1PYUNZVNr8mKr3f9kLydvXd7XAMRn6zW8XDwRq6o0AOiwiH4RxdHNzP7UqBFRiYYTDIyGRUpXjNilqt0KELjZjkcRwwLo5XMnbhzffCMWhkjS1DWvGkv1bVQUC1R4TDsXxnO+7lPRlF1hg0yidLPPxArbp8CIuYNF6AcQl85Vzlf/uGVhUf4u0bnzFwoA8lW8YjU9Tv4CPsRumL+uL3z9gjsqgtpkOkSfHazO3Mpb4rXBYpLO1XeXnyOiPs33Pt91GlvKiY5VBePPHy30X+L+tQmJ6slE55h4S684j/356SPymB6GXA/VP9kn9iOglqHnelbmGmjdLuXLhUx/ddbj4ssuZKeqO7jUYgIuepvKLGuTAtvMnhaIsAh5b6y3HztLMoQj/W6eZaCHspsrHLNnuzb6uNm92U7pjaMldDwQbddMuLgt1ngjXzVDi+w/aOsL4sK0/NZTAbSFXg3LoHt3ZSckHWRI8Nmac2kYYS28WZqf8hFugCBIZEKW46qZ9uYwmlYYvqtT0ytt2r7+odd3M59E/dWdhWQF6N41hJ+wN7K4sS6vsL1SOW52Kfrp6J7beqV/UWG6B5FSsCQCUNsaowLrl7uid+e2SEetJy7dMvEd3bjmzzf56/5Z1Mjf4YKmLb2WTSXwe9v6ASnA5FY71m/9fu4RVhkyLDc9i14i0J+512BRTnJJUOOTWGXdwmLKfMi99QF6zLTK5Z4d8kOPDAoD720g/RPfjCW8fWd9w8BioJQxh+ziQCXJilnlnJWTf/m1ckWeGTf7GsXpCcceJGJUWF1tnXQdMUVxOyUakUN8p71fDordFFSDKHQwbmKUPaG451zZS85/oSLnc5QcVZFMiTkkuasRLW/4GcuGPq65nryeflZArRScyjlzzlGwzxjtfjHXeClBpUUE7lkP0Id2Kyj7vUobyisiJ+SKfQNsg2yl8CEN4wd25ES0FBTo6R3mU5uL7O0hip02lGVmcEtD/8+KwPwiPA0d58n8/n2uDWvF4OMqV8iMWae+iEQSbwWBCEfLTjrFtRaFmIXqGQy29HfL6d4SNXKoOKZmVgLcbeo6xcBgcWAIU2xmn1hcu6ry50dS9e7bLRHnn8+eC1a0GolPXtyQUCHp+vL+HLmYLUNZnsbtFu1556110x59raWlvPnW9tFVY5NQ/LhQhf4TbjnAllXuVewc8hTeXqGxkGzU2x/elIoQjRh1Z4XW0k79rVj5FLSk3PDzRGLauXGG9R60Mbnaq22jLRx+2zBrozcS+DVJ9dvSnxHRY8Ni5qeG+/L3xDQV6mW2NC6jKp43xBCbl7b3/QMa2VS3vxBjJBFWBPrfEMG0Y4u8I7p9UnIL6LORIEEsaAQGJSw13ulKPKt9FxLFbabxefPCrwkvr4bL0RXpTcq7UYUWNUpIpfFJEUNT8ks1XYEDBfOdeKIGbJ0SkW/AMchhJDwsUF16WVtCmnjAvz15nohFCmWyJxLDaZF8YKFrqo3TxzHlqNbU52Lg2DsoEuJ6Drug0f1JyWEbnf1fx9OYm1UMyCvCQN/LnIaD/69+rLgxsyPffzgisLLsUjRz13T5OZHEc+hCPMYcgA5uqbAGNkJKBcHsfZgIfunfi17927+orhZ+O1ebRaumeL63aMYp+899S3YXoCOBape8ibfQ5CaNJBt3ttRAP+hq6FhS6DHPQnKku4208baWs7op1EIJYjmROBgJ0cri8AaJCGkLo7k0Aa/+DCsQ0h9Nsr/9qrDswtshZjnGtuLvrL73YZliQ/OovviaaB79yX38XA/mLHe98TzWF6A8BLwMPq3qNkmUdreVbWtrzBhada+a/NpTq3zCdajhVzZ5suArsBT1wXLyvfafsuhKU1aso+KKGOCz2C/z7yCMt2Hgrb9Hc9N1yDNL4f2eDfiHnx+n4p2MlxGU5LAQIXAnOpc37yOX88otgLaw2c4Ld7ZAGGpt/Wb/nDnjuftcda6I2EsATmQcRSiTSndnLDrU3NgZbRsvkSyoCel4sm8l8+tXA8YVwmEN1SFvNfcZ+/zW8NQFgiUF1UVd4web/ovnYZ4Ha0C3fW6v2ldMpd5VXVlxbtad8LhzwVQ9Pi8WmueD1jMXY3OYooZvkK7E3qa/PahDqTJ9qqCrtJ6ooMlQb3YHx5zgg5RO28pvE1km6O8FUOOrpDKy8+OVXHRigjZUmUfJVLIbra4dCSk2wwqKQzNrHZbsdMR5dlKjZOZQ0vy4wa7dSO18WqamrVmuN3+rSt82X1xTdyfNGCkOCElOTWlJTW5OQEmajorp7s3Q2DQeqaWs1TqkNyCtaUQuNJm7JudIfa1n61Lc0jWuNWu3+72sh2+tYdG0yyrEIBG3L5pyI5xZc1ntjDOeAegDhWBr7quHisB2jqX2ReyzqTfHhtVwEon7d+q98N+k3qeYErpSkjEiXKgrWZH3X9qoWdgn7er74W+4fRiYsqt/Skt8VLE6OUWI6Dr+88+M/RZ6v7NwB8YBCAzdrWehKwxkgwlRy0z2lrWZg9MscWFuTh7/vlbg1f+9d1/1i//kdXVtK5jo6zgVldL0s8Su5UZG4Wnbi4WbPt5vVKTTZA4Ody3Y2cG/NO+2Jqvu/TRB04tXwgzcIn5CteDrdqjYt0fYzzB/vOgbRiRkFHxIqQpL3Mg/npoi+vnWOWRKc7J2a0e3OIKXmxwBgn+gn5SzE3tPqTReXTbfromLfSlNN/G2vhPCP6BOv9r+HqqI9T1PhJuMBWkDrgCcdl8PgbOB5amSh0IGm790A+BvY4W4TmwOs0WEzv/fD7h3uiwEou/hfKFC4KNXxFvM9eXXPSnWOdQxF+6eEbB9gSTED+IT3hSaUUF3V/euptDprKkF6920lVOpQQgOmYZP+Nw92MEmEOP2EyaAIvkLDEae55xTvY124GUbqJ+OdvINjvkJMoi/6B+dEbJgufPVg7Ldk/j3ZrQ8op/J+dCxtmbTnZ3NKfRfOV7GZeHRqi8IUtTdeWSsvnPe40byxxl8uSoWlegVhcbFjes9zbk4aRl5cPey06f66dsuXD++3951Z7FOIP2j8/9SbcDvMqX2n48K+SXaLFokC3kMHjVH4R3DkZe8zsHVW0cK38Tf3ZWB3XkKEFavrEyVPpm6lXOjrv0UBWFJNW2b6vqj0tvb19X2X7m+N5DgN7isSOnV6/Zx7UaWbnaOhqonIPltSuDJ3y1zAoicd3FDkws46ke+ZU1ixPVOE8fg2KisgMERKOPs+3WBhWWBXQF50YsDi8s150zqqs8byZxC+tmKSnhnkKt0YeJsCRJFpMxO0DpOTIjyFECOLmxgfKSG7LgzjhbbHJHhK31uhMupD5tzqPZO1KBCeqIQZjXD/TPMa2fcQcv45AfeHfHc4A3snazubR3YEKIgIn4Xx8yzL5X32w+FcJMzqY5OupB6B9NilYtC646YKIl0mTAp+rZYxtBsWbzQBb0DrenRe35nKIbayMTCNoZCCYlmNeb6WAEaYAoDvRNuHA4Yph1Pghbaz3GLXTTNpTiYUd4wo+lm7Eyk4tuubwAGon3DkYQlD5Qt/fIjfVJRwipszPSp889IuT4Q4FFFqnr98pjAp9pwZCCeJbAVP9hIr59GfUk2QlgZGjHDcN2U+yC02gEBRtZvGbWo1kUT/B8qc4a5Se0OcNsLM4VuKAGtBqV7u7e3raAAqTNRu5etWEkZTx/39mZjIhD4Nd80rFGDe6/Jft5TPG3wECQ8aFMlAHt+/01iyoTXeIj8e5n9fWKimpqTVI2On58xigwCUBIHOCOdKPdO5J8VQLSObJJwUIiQ5+HKMGaWOH3UsBFtscIrp+WLDrPX5LSKBe6SFP/AAEGXEm/grkIooaXq748n9TOWMqbGB0yeqBMTK6MspRhWQW+QxAGsC/2Vox0E6W/6NbCjr+qJCsSFzBzHTchtAC4xrog0Nll1OsU/BSfEQWyw4V4pBYRUN5ZOmDaHDhOUAGADwo+Sv589/43cgkzJk0psDFOy4ZOeuMiyk1mfdkp2UZpXPXt3okAb+y3/5Vm9dmH+rd0NJ7f/7lPCbddgjSJJQIouli8ilLv4ELV/OJ5FT/sczy3xISUro4WcFqk6X5J6m8P39LXkdXgdh7mG8OJTju84z51WR3tQejssN/tc1K6wcGZ9xN/HoJMy6cijdTzVv9Xqhuhz/B1KMD0AGKbL7ezUM5oFhkvxPSQz8cBJLLNXsv9sLtlczsey/u29V7wiDDFjJEe0QNded3b4zpr8Xq/8ynD+AbgpAN9IH8f0McaptjhuuU+dhU3CPImgzbEwa9rut5K0yR80B3Mcjw/enR9Z1jwEDPXd3pP+ylfP6dw0sM9os5r4NkzFixg4nb22Uscoz3ujc1NYXnz+u8vNDZkJjR11xcNUGz1OsJ3jeKCYFb881C/n64tcHRYukFjXMcz153+UUeKWBzT3LRjyll3qYFbENa3EBLZ/6xnt+dnb96juYvbWmxTSkbunwZRBHfUp3Rv5OvPaWoyi/sDvx8ugTHcHpXpFBDPMH8eNl1Hz0oOZYWbTht2Iq3LUxXrrAubjqxWn135p2gNroKd+CCJCKdBdlPNabwdIg1/77pjMDlTtaB9DsmzKLtpQMgJ3xeMN/86gzV9VKrLvJUKHwkcIL5yLKbGKfLIb6FTTrADXRvVMSmS/6ZlE1IJ4LSHZO6lelPiot8MrU2Tq8174lrIDFKLdkxEepZWXP1uh1WaVXbOG8Y+QTCZllwyXMbsCqVbAnJL9ZFdnMySqriL4A/HXywt8W4g0akYi3RVkFjRu/rOqLUwcxs6mzN73vnsbsT+xUuS/T5vk0oGDZNWRdXv9UsM7oeq3cMl5eXRWPCqRlRneHBi+wbPAqRqdhDVD/fbPw3VVq23xz3rYoq0RrMewRFjfJpcENUtDS+Yylm2SgxLwb2CFoRLPFPoKIQLAu8yFSaZUXW+8YWQ5X60GvYlhIc980SS/ws8Q5LSDqnJsjwIxtI97EA6UQ1bXJIr/HB4z8zsVHfRiKtv7xE09CJj6TCNtjxisW3UM8+uN/iCSG8FVVxhnXyLu/dZtxj517ktHTd78CAWKxcWlrjSrOwOQBWXa3QsdmIKw9882bv5HGBLMTn0o/x5UGuXy/lhJjlKCPrIDqUzpOJlWuAUdxuz8t+Q6EKmZubmhY8r8+zTfdmjYHJpaYkBDw7E4Xl65QOZY+i5M7apDEYHSWJiWnL89FFVQ5n8XEqO/OPUubmMT1YjsNoV2CHVlXYcje3784uWRIiznH3pgJ5zVezKJ8DTazuJp/+cbT+z4j3lwdi8r7+FSn/Yw+AtvLW1UFuat5J21c0eaUamXQH0p3XMaja7FHKFgLcg4p/7Gr2CTYDyxyM91chaO5kNxcXN/KLIk64vK/LtPj0jjruQ/FNXAB0hLtpMXKxqFseP9CDb8x7441URXq9crIJ4zarF+NrP1q6/KxRW7vr3zfPL4yIwIoZyFb/ey7XCD3VrtwishUrm6r20zk96yBL00xlLGBT6Qyyd805b1fNocmT/GzG2goduBlf1NJHl9eGYVKSMLqYZcPiydIaX8eBH3X2ibYDNQWTy1gyhexrnj4WCKaZ01u3On+CBRL+a+HRly83OvNZw5KU9PQrVy4xQWTWD2U7wWbt85009riJrY1ZLpTK2+ZIOqboAV6ew8rKzrhgIho8nUjkp/xXn932RyGXdbhNxywZHeqmWkBMFFQ33WNDg8LdEq/ejobAkgq5Ht4+0Rw3JTG1sCRFNZSaOkSWa1CpvOCNhYwycqITQIimg9j7NX+FE7b9qpLdlSuKWoX6mBKrZn2kykfGDQs3m5rijFIdPbk0R09i+udUy7eyCn+548+OkwcjX/t3qwxUYdKzpmr6pqN0vcNbmsz9jMn6SL8JgS0EeXOJ7uJHsGQYyBNomUF1LlqRNTROXr4Dsvrr67NS4dOyE0fbMlHRkfX6XEkWh5gfvd4+GfOOXXocUM/F4Nc96D4nO7S9cpvL6pg/vjhExXhbazVqkzRJCLpUp1UJs1frMLAqq6OnqhZo2qzYRmel/UxSZ/pYLM3H3GNBjCGK7+zmKvzsfSWT5AtzFfdZfPp7BMhGu93r5yuR/M51Xfgk2F9vSaxyEisHc8W6Gf12OL2Y7rmoc7vnf4+WUoKo3D8sJRhfirknTiwXgzgrIMvZBLFrxKfxRt9nZC8kW4Y1lw4nnK5azsehHimVm7QaQeJ7UJOg6A17rTJk/tZm3KXpt0MoqIO/UVWZZzHOcvlcO+JI+YsIYr7NFWLXCwfPhPSF/x+u4B6Uo2UrbEmPItwi99OcpJUNrH8uvD8Ik6k+aWvt59HlVjJZ1nIULo/CNunRi888GtxPRn1L3+VsY8YrJKcjy6cIe8mYCjZTsDnSkHW00+bhZITp0WD77ukqtBLZlQRYz+y51TXcPfr8Zefo9L8Sb3U3fv801C3SeP3IZrnLJp9827xj5a3/o7c7wrylLLta7Zxf3aXDJmvjr6nC/entC1wm9a9jd0bwCJFjFuugrjfqHofYlP78zldLxfeLXdp9UYFZpzrS3EgMEkE9ci9LdVdU0hY3/bLMVm9ppQGwnvngrcztO+QH1Y2MvRwYK6wZ3ZZPP2WTvo+/6sptiyvXOVeWp/8qhjOti9UGTaqTdT0CF5u7LfhaUinCx+fAhohRiXYhRRCgUWG4KDmXFVArQnbHe0DUBUUcEjWWKhNxrV0/rNMf/8nPdlOS2A6JIVfjkLjENxkUZyHaToyC58KjSXK4hldPsOa8xwTUh2QWbWKDrpJX0EK7lL5NxCHjuP31KkmYsD4FdNMzPFobq/FvxtkzMFjguf6fhoMWBn+9mNynAP4/i3mcpQtJPbg1YNW8pTTcav1NLIqPQ3mqPfBv3YmvVHBHWMrORm/8tM1+Vf5vjLQGmitabUfR7P56LfVWGC2Sloo7H3rtaY+mm8qBQKU1GX5jOHvut5n28u5u1lBM41See5D+oCvTPB35VDTqjuxC4+Yt3L5bpUBBptJkL3lAZbbzQfcqbcVoyZuWiDAz6A5OPuc5oSDzM/foRKDWy5O1f5geHIbKrAjv3+oGHqOD0eB5AuwqH3srDO5JGfRmRCQCNXe/CBiUoKJbRQaLRxOmZZOGTN9lvnVygEjy4LoPyecCMYydEbQblR+8VP9+zqcddFd5d7MkdnNqGBKsZjIo/WTo2+9G12dda1N6IX6gJ10eOjQFYASJbHlpMZ9ZyriAwDd58witVOGjxCkSSUrR8pt1i80glrKlvl7EwgPVsxKDxLeYJ15EoR/ndtLU0NH3g9NJd057KyQ+x3wM8tTYv/N67EZk+RfeGZzeYQztHrqRzOaiBE+832JETB/Re8ys97VvwL6dPDV8/8qQloAtREmfoN+aa/mt13nrtUJvV8Ur92+Vy8le6MQnXk4/8cHoIBY9OFx8N3JwMOJ+SXHAC4dYvPaKmuyq+rOjyjOtCliUntpkeXrArGyZyckwrUUYmAtwKfXbSxWMZK0eykLElCyLROVLhKELzp5rg7n9bf/x7j9eJIcMZlJkOU0iUajIJfjrp8ao0aNm9Eiqx8Onh13pOV9S3PlVm7BBcfN9PNzY+YTWPYBe8cZGLdqL1Faau/K8BuyavVZxvirEnaovf3PcAHKUmuf83QcPpLDrzRl1IWBE69ze8ltJ63f4PSkJRWuKdt4aq9ZryL9nb3X9U5QsYPnn69EqDuezozqIC2c8hE63o4mRz74ke9ap2pdtmL7flZ3Luzo3bcpMzJ1WUKgJifkPhFpvnXjjhvRc2WInQ/jaTH16cSE9FUV3ogpoOKqYk3SKklvBRjNYY4TV4VhydfAuvSQES3zYM4pik9M4pfWZcgWl0our/ds/TRx6Yt6oqkEf49SnP8prK1GzGeoQPYpKWjtU+Gdy+b9dTRoTe0PUfUJLxNQVJjCfjEZ+fqJZ6+M6jVBdmlzI5ApCtoySVKQqJrH9LEYfn3UE9FW3eZem42BIgf1usw1uHrGaDQtG/uPAfMpLj2xuhtF4wIoZXC7ljfCY3kh8rsPSSW2OLMVpXbMmGqcBK0OKuTnz+KcbRA5aiYbogTeDK+b7Z/2PkMdEc8HuPpyphfABngSGiuSz1gxtYph/fHvshntxgE91eWXih9qsKCs3BN/kb8qIejAn8CMysVZRB7Ke2MeXFE2GRbOvfZ4KHB+rh0xL7zTUCNZ+9kmJOp3WsseMNSdK0GU5d3NlPntoUJmKZ42LFpQsq4hmIaZr5cvY5ZyfXtjCxoaM6Gx8wHf8dXzDkd+sujxl1PISzZvU+AbUnXx3WkBP4mkaUMnyrgmAbPQGbnPRHZ5TDI/WlLmhpEzOyRZ8kvvGQnLK4CVJlNCgo3XWoTtF28xSLI77xU1qN6ubl2x9vi1bwc4SgGAU5HD24frB/MmuvBgw2YEudZ8Pw0kWInURQ0MRNqdMAJmZFblOf+XmLZJKHaVizDtChCHBIJrpfimLmIrmNGRukmROajdzmie2RQlvjjlK448LCW4wiJKQcNwzngM7k76168yd0TAVNypdFPhS3Ye1xonoBUPXHPsg3Jk8P9zBf5A0+qShPxi2e3SacauesqqzosD4G57GYtdY4bAf0N2wH3+88/GBEGUPEOHCbfU3t5YJlwl35L92uUOof7Js5Pz1V4Zq3G0MJ+Z8W2S2HPY+yRumpkSRUZN4BTNDa99wFim7nPNlDq+ejUM+qOXUniQe2jJmPeHk/ObxOkjK+mg12qIIEqH6aEbs/JzhTLYsQJi+OpyQn6OyGEWYsn43geZCVj9RI5GYvDNRQeYu0ZjarJDueFftdWrNVAOCYTccYE66IqMqjGtLYlnAy0pEHLU6Cp6JFCxU+rO/zjNzccglzYMhTI5vDAQSb1CMTbxafjhfHkJV655ovTJ8pfVIFECVh4TzvfJt4q1Fal08FK/WbR/IGO67CXdGyYe7fOohW6PKJKwF5lGLpSPPevWWmOsAVN4a1p5O6Mo2EoQJCe/oro6hSA8dTmIhG2InFnLIVuHKxSFSBZVuHq8mPne+id13/qy72h6YuKoppHJSGWDyPjxcuud88aZhAJEgCcEQkCuPjlF/27lvo+7wvj1/AmIkSmiTmdySIkHkuISjdXU/+QQEXB7vnsRoRyHuNxXKy70mSz6qrnA1MKtFmasq5dTafiM+xKRSlD5wOCXfHXH8m3v/zX3LIwu78nCHidPEcZPNv8ZmT0dbcFZhoOZyEU7gdsj/CkBgSJRy6nK3nVVIa5rOrXx6rJhnLHT/8FGy8ODsza3oTmL8Bw60KeXtWRjEMEfffXdzPZd/PxEx/V0G+M6fHi4659Pm0VgMAYnv07sko8wcVrfejdqBc3fXBS+M4kCtQAEF6u7ee1csfXbinKUi1Lh60AP01NZFSR8HSUuQHVXtAIHFj0llm1AAkWCJm2ZxmDTqkoA8RXS0XHwPNDpDKHoPHW2oO24JlGloHTA3mLkVMSiLWFj/Yj7ZeV0lXfC6IJoILRwi1ZM5EeFzh+Z6EBhSaRGVIA3Zqh/TjeufpDETjCGkU2rxMw33x16spy1TYFk5AASEnB+xBIAlzKXKkoE+ojKXLr4tfbdw0bfp8zf3uV4W5i1SuNUy6VXvs1vi8vcOS1aPH161to+7avHQXRLuTueJhR6BYY7GIn36trot6ex89rL6srogax/dMmH6Al6moJ6UIWIpLUS00hUqNQ/PN2hv2dGg++iCSv7y0j9czrZuPBr0b//xUZv+tDBepjA2niUGZ/IVPinAZt7HVcwqNwXdwsdV6P2c/ye5f4hNJCvrz/3GNl83CdSkoPofWdUHfGr19POMwWlw+v9Vese1QZDbE6rI+8/W8o+0DlvSDAyTki4QYAj0ewxmuyJb6qiDo/ac30gxN9Ywg651IGVlybJIuWsukr7CYTA80WJHUdBKaZkluZFfyish19PofVf3atuRdShHa2bi3EVzRpgvo3LZAXl5xSOKWH812kaZzxNI4sauNRD7nxpZy2WZ6jg88jEeZ+2cqBqYfWZQq33VLC2mXl+KStrGHs+3Jn0k8ds2x3bGuNvupAKx/2XX/tbEb5Ewr4seP+sfCgF71GTCluEiAOL2KwaVFD2Z+JK+KqfaY4wUearieHnLWiWtPXZTI0PG6TkKcCI4KuxeHVp4xN03U9bNijvP2cX6c7y5uF8ilcyvab/XIyfJKyrHcTIaE0kF0h6UeWwlC5eKRY64pKNeW8aJ+IU3sDhBrC0C0xY0HPPji7L8Lqv4QdN1HkbqjUVPWpph3hg7UjNHBdVG5+TGGBjpfhQDI5HCnhjoiVS6XVx7amehV/SMD1gHswh+9jwMm3BEbbFFyt2t4vTtUYYajke9DEMEGw/y8Ij45z1wiSRzQ6tUIruRjFkftHVHP9zWMXrLoHir/GkBtXaRNTroaKxg0giH5LqfI58qHZCQkZqMLPe6oxjrkmYGEPgjFT4zZbNUde2T1HUrKO+BbIU608sqb9h3xuTQ/gP6UZP75cqRj9NHd0W/Aq04+IXxsHeum6+/VZWy1Zv8buunD0uMLbcg2wvNjkuhTe2y43KGOb9drWF5+rYr9NAytrbecCvSue4frLqoeKSXP+RfUXv4jCjHtg47fwrdLRchmOQxRlIbOW7/FGaLDPchrdCa2scPmqoR65E/buv4COaMCgAgYwNEJD1LjrZuLFCJWWf+yxp4cc/NqdEnQ/HQBiAK3n3WR+ElM0NnrVH505xjDiTWbvclbGNm6KxVy4ygTuq3Dl723qQeugijTYYt7idLVrzPms05uHmR82XyerFiUQOmvsi1oRCzxo94VONS0FGml6Y1fg1enY11OWcR5vAz/xxmIMx7ia4mI1SKiHXTSJ1/BDglFfim3TJ08ik69U4j44dzmj8/JZLrqD8wNaUSp7bS0Zm0VCqtA1K7A6xn0ylT15B5GiLSh1NB3LvK6Yyqrxcpcf73pVLTSz1XEJdIxBKQnT2wvC4oPL/Uyz5Mff8szhk38Oaxq83GjhqXuFCnnp8gf3PtKx7mZkkCvdBYXGiWj547c8ZiKfS9LlYA4a/TxKYs7NV8cFX3/JnpWVm1GA21rn3SMNOQVKR6FvutcdpNnmVScAz8CxHAzxYtTgJTXCDgwC7jXfALk+35SIdkj3YHx2nfZEs5fe9kcXqBD+LiS8oQNfNuWCBlh+cQ/DViRr+gwTapyo1th0PK1EA75T+3e++IrlIsbLA93vqahnDE/WWZ8Igo7xavRk0t39djFsQ8uzoLR8jQnRtuyNHllooF3uYU29wmGFLGYVJWztV6FCovg9K0VJkj85xINgisgPGh7HbZ9K202yPKD0ndKNfh2+lWIVHSoITNGEfn8H/p34SdBBcreMRtMmszqKYDGLvhelXmMzXVsKcDhfeyMm8amX5HcYjrcpR2IA8EwbO+gvMPKuMNpbVb1ZLhQ+qsW346620mld0k3gc0aWql70I4rzR8l7r62I1wSNzmcp8b19UrxrpRKana+9iCmUneCvI8RG0eaN3OCWyzuUge4zdJeQyqQ47lF2qz+c/8vfxBR6FAG7DEyl7kclUEZTWQ9sO0Y/pHGyNbIUPJIkoD6VTcu3I3K0wDVcq7+pB8Je8jToBNtzbVdD8SJrKD+EL98K1EvW/6hTvlBjw+ydBnskilUwfL6q5iYS11aS2BH8Zs/6Hb9Pgv0L7QMKZcTct9S/g/5EZkRJOWez3IezwH1I0ff+XvCIpe0aCS74w78IoV93x4u92LCZca8vldHTk0avvM3BsRRhFh+qFm33wSxmxcFhu8UbMhjnI1ufQzTN0fYxs2mj9h42H2ucM132ONzUd8ry34AcfAh9lsc17X86vEOJolyxc2deCbT4bnOeNRuL7HnwuXjm5YSXiv/Y3yNHBh3L0aZr3Ott32S37KPxwrMnlJBWIporE75ij5GuVK/JGOzpXQRki66pH48c7YK+CEKjEmIsmw4eHJjayw3VACxmHOJSdvBpFmP70clYRjT8pPwUsL5Owd38I4nFZ66uxNlYzDqZFjZ4jO1qcT9Rw2WV999wnbDm/8lG288/8remdUfO6FVlE/J6n1EY7pmSKReKYYF+RSjztnT17UTNvEODvU3nHG3N5hsIffmGytTGKMTFz6V3fIPmuw+YZ+W2d3a+PxBTrb0T4EMn1ai0Kfe52jVxMKLPKRd70m2lOuIGvXyxYXYUCW1LjzP7k2PjOjobaRbj0pP3vAMvjcAaWEyu7w9IaaxkgyHSwLKXGTwkgIYAz6vt6VujNqa1TEnkIZHvqYyD+SEt5RbSQl3Cn6kJT04X1iVdpxX+WxY75xWQkthBvX1MsTCF/MMdOBvilq1j8VqKeHRT03PqfjLTnkNuVsn5AEky6qmyBz8ZaCeCLhaOCWgo1jvre4W8DPeZ67N4c/rE4NLf4WsYDVErQYoiBU5PEQS8340sUFgvT3N/cEOeV8sdGweBh6lGrSZ21oHORJ9263SN9vkmcp64h2h6rZftoW9e+zG+sNQ/87EEyaSnHtnRp1C/Ob0nCvBf1tV+c8Ffe2s8uXPRdsKyiEbENQ/PEZnm0tl1tJs0j3SEsohZN8TFFr4GcPgcKqP0P4RRFCeLi/fVFO4CLN8Tu2sEZOVbGKY0UP7KlcazVF4UcK0L3IEl5Kdtg8hCuXp0RrvQuFz3KuS+xDrU4Nf713wrkqrnuM8cF/wva4q8+a8ak+6AYWjWqh42j4/8OJvVd+f3uvfPRrm8O/q88kBmH/Pbmx/sjjZ/Ux2WkPeufdwINm0oZNrItts6UGIAHrDPDRH3pg0vusMBpYEP8qtMsrR+N/qG4a0dEgP0oPHQzrPgPIBgBbU3SBZLA+KReNEgNgemRNH5G4tCvIOYLBrixaJywgxK8+GRBjdX1uwKptxJDYTumQPZl6OAEkEVIC1aPMM/JjDLGoFzEBTUUQrMRLpFm9JLe2jYuj0/CG2ASh1A016grkXRxZPHqIKLCNs7upOh7PT2LqTqi9QZtFjAM12KUsu44vngHQDgcALaSx3kQM2cqw5gGyAROtc1WEMgpizEM9h4eVKLBGyXNVAdc7y48oLvMV5CaJ70DDtxE/S5YqFwHYlcoxpPy4RTyHCg+JfGfXPLQlDnUiCpOwmgRrQ/BEGSXKq5HNcIB6Rald72g/pCpks1BnyFz7HhFSCkTbxIcA6lW6JEbAoybRaajmqYfxr1o+Xj0VeNyg5ohLSFVOeRiPnKqIeFW0wfYEcZrmWckCyPhkKtVnZ+ttAm5MFbglroNyFuSwvCHaQJTUWiITxvKcWx4iKPLNmHBm6s9rrpYbInaHguAbJA6+z4E5Jn9Mm0m0URyhke/gVvw6vr2yV0la1GuKN+YC41RUviHMWJs1MlGpqNxJwenBZSiLWoQFpoZQm/gEFQpip8V9TEzdz7DfOtYuJ6/PAoEYVBIvDIlriFMWLYs+qsGcbKyRVBLREsc10X1UBNdyAwWK6iPEZeQop/xTnEePnDoWridXEW2aUCAAOPnhn29WlVbH9b/QHRrujjdTfyqqigIXNuKLq4OSLYL/qDdrw0ngNVB8Led30Q+YheBTnFiq0cntvegtEmek1fILYCgI2lSsj3pJfygTahLbYVqSY16Udy6ZljivmhRnLclmVpnC9qxdaGz2My55T4V1HOIyJvba2/euF7qlBzhFQUR8THxa2jO4yaGl0NEy1l3p25H1NexLcU+fW6HYtNy1LAQf1YQ+3WsqmdXEatYetA5zzq2aCSqN3tGufFztD0FbCpbHVO+uywULialPzN09Na5AJ/0P4dLWepzmAj1dWihDG0cGRenfZhFNtu04HZRH8oNXh8lQK3GxTkWAt23vRjA24zhaOhJiN7nPxS2MGtCsm7Qlf8Z7mM1DaMcZsKPvhDGd9150xd5tLFKsqR9cjwXoSOIMVAGjWiN4sOOuvYmXyGDf7FmzJ+7c97J9P7G89p4YfQGj7GlvdTjMS9jWUDHrwvIIu73jpZnlpIZDsrnKAJoev+3i2+uwwJJakSKzOAaNs6yn1thAeNcKGMK1Lc9gYJxQaox9Nkxsl1Ka+fv0VVzu+4M2WwzN0UNarbefu4hO3CId9MgqWbPRG/U9Hh0zQ5PIvjPF8/SW2qOB3Xh+r9AS+yxjH2UbvUcHip4UCzuXLDXOUj5Vs3fmiDbUvLRTQVI3fARhcffpdQSH8F7Y2oEYO1ayYNu8PK6uVpH2vfGS76BW00jJqkUt6jPiEo90OcmFaJYRhkfrO8bhmn4ZE1bobjxyAS3LpdbmyO5/E4iGVsTWP8AligNhc1L9MbeUPjqXmISZe9h+25R4/Qg5OtY3Ttv7K20x3d7W42Y3NWQZRxdyz8d62e+XWkbdrCg6298lt1CfFgo58ruoR6yGYZx4TEngA3JsMn2J0do+Fk2sbj/Wz0v7d0Uv2ROSOlTjQNcCv1lft8fvk2Hu7u9eTwD6BU1FXjOgCb+Ij5hPp5BcELjQA4GTnMCBl3MKDV/mDF6cyTkcJC0X8JGRUeYOrck1jKV5uQ4nrcttsNMPcwcS6cnnutGBDQLDY9x24VYg5QRJqIm0wt+HnCETP+YcSYTmAtkkN8rcoepcw7NkW64jha7LbUig4dyBzvSz/+5Gf8beJjgc7yQQKrWksAD2cMrWdyzmhI/saGkbaMyndN8tBiw2EcMAaTCyqg5JHOleryxgj8WaBjek8Ht+qjVR/FILPD9PyIpjJVOHkIoomqBEPBEb00PJk86s4sfu1yqZBgKichqc9/xXL748NfOZSVSYh64s/XmLH1Do/wn58vU0nU1ev1bLv7fXj6+rZT8x5E0c9/xCT8NQuq08cUJUfavXGDZaCXwHLjx/o5sMHDNwyEfLMnGvWm/duZhwfFVOYlVxa+jEd35trBW5OWDGTJZF1UVAS2F9lsohDCwFtIwvipABcLegmTeKlfVii60gXd4Q4UcTtXvgyO2xkLOwTzG+GFIx3NkNO8SNjORB0dz2Jpq9pHUdwrNGqpwAP4dtCcL+xhrCnV2A6xwxm+v30gzPmxS+R2cf/drD2euPvvz/SVmkleW4xoMR+yNKsqJqumFatuN6ACJMKONCen4QRnGitLFplhdlVTdt1w/jNC/rth/ndT/v5wBAEBgChcERSBQag8XhCUQSmUKl0RlMFpvD5fEFwjB9Kr5YIpXJFUqVWqPV6Q1Gk9litdkdTpfbx+PrBUAIRlAMJ0iKZliOF0RJVlRNN0zLdlzPD8IoTtIsL8qqbtquH8ZpXtZtP87rft7f3w/CKE7SLC/Kqm7argcQYUIZF1JpY90wTvOybvtxXvfzfj+xqHlk9ew9IxQ/pKJquhHK37Rsx/V8AIRgBMVwguTxBUKRWELRDCuVyRVKlVqj1ekNRpPZYrXZHU6X2+P1cQAgCAyBwuAIJAqNweLwBCIpAKBQaXQGk8XmcHl8gVAklkhlcoVSpdZodXqD0WS2WG12h9Pl9vH4egFAEBgChcERSBQag8XhCUQSmUKlWZ7OYLLYHC6PLxCKxBKpTK5QqtQarU5vMJrMFqvN7nC63B6vnz9fIBSJJVKZXKFUqTVanR4AIRhBMZwgKZphOYPRZLZYbXaH0+X2eH1+hAllXEiljXUemxUD07Jdbsfj9Sm/FgARJpRxIT0/CKM4UdrYNMuLsqqbtuuHcZqXdduP87qf93MACMEIiuEESdEMy/GCKMmKqumGadmO6/lBGMVJmuVFWdVN2/XDOM3Luu3Hed2f5/sCIAQjKIYTJEUzLMcLoiQrqqYbpmU7rucHYRQnaZYXZVU3bdcfzi8hmNVtKWhyWXpimv4zGu0z3lOOSGBdQcJNeDFBsq6APl2BiPo1nWqBnV4dRuVptVRcPzhFfNOVibFfk2XV729Ie1WOj8Sg/adU6SZMoS0z4FFXzW69ktSkAhF1Bf7rtQerjk21/pGIv/oqCtult6Oq7qK2q0Tc1iseiCW7ajvoYuDNrqAHJyBZD7I+DSjYn5Y0ju4LF3fzXXwX9B/4rC+ZwvuGSlcjyKQAxvVaY2E3xMGeiJK7Qic4OnvefSCR2k4d7PUkgjilb5KYE1F8V4G/nvwg0G1Pbky3FCn4jFFeIR1XnLBDTTiHfTpOj2jbkWMmNNmdcbZvkH+/pl/u1kCWeN6JGwH7yZC7xTUFsu+GyNoNUbcrFJYGdO8qXNoBwV0Di3cJ1PpDIcNX0cNeIoB5d8bebv7Q8geFwuaXEWXsqy/r+NxSqj2YYL8atu4qpeKGNWL9Sq4E0feSnXqvA013WqqB+B5OCWjdwQz+UAgOUZk3f960FNbhFoQtveKQnKFF0t9n9ryPnAHZQ6UyOcryKljf3X8TxvfuWUu4VWvEJgVE8g8Dje0IXMw0nqqA/F3NB2F/d48tng41xCZfa0TwiUDGO4ONr0kxZrXNq7N7zkOKW8WPWX1FqQOBeBVk9VPPOcmHiNz9QPR+srokHu+XYINL/NxQuKPzBZhLfcj0kso9BZJ3dheN1f5aUgo/ULqpaHunJbCev1pkz5nmJx+2YmmmEQGDeXMtS2hPlMO8nvYaANUXLvzmIFt/NC8lMHmVXdR8FOEfKIWU54+rRJ33zgVCy4AonkSN0xXrurnyHSLxY8Xln2Z3hog4sbVOZ6JQF5Rt+5Ech3pk7m8MKsSiajZo6YluzmlbAdB912lZCkzo2bHxRY5m/Dnd8xplRro446Nk/cejk9dP86Jrn0CXcJTC7esjHUJc+xmp5CcCTW8G/j20KQWnDXXEkEW9Qj466s36NlFsb4WbqswVlDa19JBdp1oqIKQp5A3LuGvJARHWv/iQ9cHpIN0vhmQ/NhzuDVHXG9LIN0SQf9Z4qvbj4ydleTrzyh9L/e+6FUNhTYHbvdVUJv11Zs/rVIHJBOPMeF+Br76aF7pX/kTFKXs16lBKN5tBtgWGzO+3DIMyg7p3V5ZxlPtvLUO072cqk9Lf1Nl0G2X/DfSXitfEagteIt1+7zToeztmby29V/I/g5Mqd6NX5DG4e8XLEvN81cT28WupLlG4WiLG/ApY8i30kuhKyP6SL36tGebPDJj9D9zbtY9kcLiRO/EAPFeusQLF8TTVTdRTvPUPL9zyK6lFbpPrtdbYtOYw7TuYjj23606q9dEde5gzjf2rpCG/USk5XT0kfZOa6N61ydXMMuMPl8UXm0scvaJQEx1nKNurUFmRKWvn5o+aoGYTCJMsrn36ZUsC/NRmaNQYwA8jD+m1KoMzV+CLqq1BK/y4hOrbCHh2/KBmZRa3mCsR+yvcLJixZlRy7n5q67jxKQnyh7pbVBZuks3h6Crj7Y80cMjvhV2n97pXMceznyUMtma0pzUqef7wxufv91cbCeOK9AlAWdg5fpn86arqw4v34djJhJhUFzXYWM/Zs2lfjhdxIyD+Gjud/N0P64XKSygdrTU2rTlM+w5GUcwAL/x/Usby70wDsKFFRSZSC3qnxE/8RRtLvtAtnVF9WZcOawV23eDlDQiF7aSbsM7xpgHhcXNPG0xj90cZpA8yye6jvxBo0sncBbtu4qq7pyA6YAgIoNalo+Eki5rykX/Yx5g3VdGschyUsMtfSv9RIXdKhZeiqYeqOjb11c5t0Oe6j2gZ9SWw62KftjS0ErDP3wmSVIdN1P6uXwKjM1xqwnqZ6kZzMWf2LhH8YwWOYp2MR5tkPzJSWWABb+3SO8TU9reGqzJ1o5gluXuZuF5yf7kpYCvwducdFbXbs52L4AX50d0390ZzPYkfoNlDdUPwvXveQy7VPRtaOGtWwFllBIaSGdhg9tSuX1mJ6pOjVXVA0GnAhFIbfDqRgAUUXtB5r9Qlq5iL9YJ9LtOAH1Q0T4e9wgMuXXFxpVotdi4bd+muZYj1ab3aw38bkb+0wOZv+465OsL6G+ZmLx4xSXxG3WLithPj2UTSWP+P4uUHQ0WszT97nv+LVfstTnj+5PO5MIt3ipaNNtt+VRy9fn0uePiokJ7v+WPZ02bsniEBFbE293i9PuJ9ngMAAAALV0FEPGnb6zP88rbXtCmPPvR8UcS3jeZ+2vqKlIYOhYpYm7G7QwLe7fz43s7vfcLz3zxBjz4UoKLlA9fvzxmFNmMOAFTE2sw7a63d9psjNy57N2Ou6qI4nARUxNr83dP9X5vj/Mw0gIpYm7E7QgIqYm3G7ozpIyIiIiqllFJKKUVERERExMzMzMybPzmqpzfN1sd0M1prrWeBExERERER0YGoaHr2ir8c/beM/nQm3q93Lo7D4VmbTvnLi9W+GbtnSEBFrM3YHSEBFbE2j4329RZ+GWKVct20wZ/IetvJXURERERERERmZmZmZmZmVlVVVVVVVVWzabq6e3r7ppOcf4Q2vU5krQEA) format('woff2');
}
`);
const app = require(303);
app.mount('body');
},{"303":303,"74":74}],307:[function(require,module,exports){
const assign = require(248);
const ndarray = require(243);
const clonable = [
    'ATP',
    'ADP',
    'NAD',
    'NADH',
    'NADP',
    'NADPH',
    'P',
    'O2',
    'H2O'
];
const cons = {}.constructor;
const isObj = o => o !== null && typeof o === 'object';
const isArr = o => o !== null && Array.isArray(o);
const entries = o => o instanceof Map ? o.entries() : Object.entries(o);
function revive(o) {
    const m = new WeakMap();
    const set = (k, v) => {
        m.set(k, v);
        return v;
    };
    function rev(o) {
        const x = m.get(o);
        if (x)
            return x;
        if (isArr(o))
            return set(o, o.map(rev));
        if (isObj(o)) {
            if (o.$constructor && o.constructor === cons) {
                const v = Object.create(module.exports[o.$constructor].prototype);
                set(o, v);
                for (let [k, v] of entries(o))
                    o[k] = rev(v);
                assign(v, o);
                return v;
            } else {
                for (let [k, v] of entries(o))
                    o[k] = rev(v);
                set(o, o);
                return o;
            }
        }
        return o;
    }
    return rev(o);
}
class Clazz {
    constructor(attr) {
        assign(this, attr, { $constructor: this.constructor.name });
    }
}
class Entity extends Clazz {
}
class Shape extends Clazz {
    constructor(attr) {
        super(assign({
            x: 0,
            y: 0,
            X: 0,
            Y: 0
        }, attr));
    }
}
class Rect extends Shape {
    constructor(attr) {
        super(assign({ shape: 'rect' }, attr));
    }
    get rx() {
        return 0;
    }
    get ry() {
        return 0;
    }
}
class Group extends Rect {
    constructor(compartment) {
        super({
            compartment,
            leaves: [],
            groups: []
        });
    }
    get id() {
        return this.compartment.id;
    }
    get label() {
        return this.compartment.id;
    }
    get className() {
        return `group compartment ${ this.id }`;
    }
    get rx() {
        return 8;
    }
    get ry() {
        return 8;
    }
}
class Transform extends Rect {
    constructor(reaction) {
        super({
            reaction,
            leaves: [],
            groups: []
        });
    }
    get id() {
        return this.reaction.id;
    }
    get label() {
        return this.reaction.id;
    }
    get className() {
        return `node reaction ${ this.id }`;
    }
    get rx() {
        return 2;
    }
    get ry() {
        return 2;
    }
}
class Pool extends Entity {
    constructor(species) {
        super({
            species,
            refs: [],
            clones: []
        });
    }
    addClone() {
        let c = new PoolClone(this);
        this.clones.push(c);
        return c;
    }
    getClone() {
        if (clonable.indexOf(this.id) !== -1)
            return this.addClone();
        if (this.clones.length < 1)
            return this.addClone();
        return this.clones[0];
    }
    get id() {
        return this.species.id;
    }
}
class PoolClone extends Rect {
    constructor(pool) {
        super({ pool });
    }
    get id() {
        return this.pool.species.id;
    }
    get label() {
        return this.pool.species.id;
    }
    get className() {
        return `node pool ${ this.id } ${ this.pool.clones.length > 1 ? 'clone' : '' }`;
    }
    get rx() {
        return this.innerBounds.height() / 2;
    }
    get ry() {
        return this.innerBounds.height() / 2;
    }
}
class Graph extends Entity {
    constructor(attr) {
        super(assign({
            nodes: [],
            links: [],
            groups: [],
            constraints: []
        }, attr));
    }
}
class Model extends Entity {
    constructor(attr) {
        super(assign({
            graph: new Graph(),
            species: new Map(),
            reactions: new Map(),
            compartments: new Map()
        }, attr));
    }
    addCompartment(x) {
        let c = new Compartment(x);
        let g = new Group(c);
        c.group = g;
        c.model = this;
        this.compartments.set(c.id, c);
        let i = g.nodeIndex = this.graph.groups.push(g) - 1;
        if (c.outside) {
            c.outside = this.compartments.get(c.outside);
            c.outside.group.groups.push(i);
        }
        return c;
    }
    addSpecies(x) {
        let s = new Species(x);
        let p = new Pool(s);
        s.pool = p;
        s.model = this;
        this.species.set(s.id, s);
        s.compartment = this.compartments.get(s.compartment);
        return s;
    }
    addReaction(x) {
        let r = new Reaction(x);
        let t = new Transform(r);
        r.transform = t;
        r.model = this;
        this.reactions.set(r.id, r);
        t.nodeIndex = this.graph.nodes.push(t) - 1;
        return r;
    }
    get stoichiometricMatrix() {
        const species = this.species;
        const reactions = this.reactions;
        const n = this.species.size;
        const m = this.reactions.size;
        const s = ndarray(new Float64Array(n * m), [
            n,
            m
        ]);
        let i = 0;
        for (let spec of species.values()) {
            let j = 0;
            for (let react of reactions.values()) {
                let n = 0;
                for (let r of react.reactants) {
                    if (spec === r.species) {
                        n = r.stoichiometry;
                        break;
                    }
                }
                if (n === 0) {
                    for (let r of react.products) {
                        if (spec === r.species) {
                            n = -r.stoichiometry;
                            break;
                        }
                    }
                }
                s.set(i, j, n);
                j++;
            }
            i++;
        }
        return s;
    }
}
class Species extends Entity {
    get label() {
        return this.id;
    }
}
class Compartment extends Entity {
    get label() {
        return this.id;
    }
}
class Link extends Entity {
    constructor(source, target, reversible = true) {
        super({
            source,
            target,
            reversible
        });
    }
    get className() {
        return 'link' + (this.reversible ? ' reversible' : '');
    }
}
class ModifierLink extends Link {
    get className() {
        return 'link modifier';
    }
}
class Unit extends Entity {
}
class Reaction extends Entity {
    constructor(attr) {
        super(assign({
            reversible: true,
            modifiers: [],
            reactants: [],
            products: []
        }, attr));
    }
    get label() {
        return this.name;
    }
    get compartment() {
        return this._compartment;
    }
    set compartment(c) {
        if (this._compartment) {
        }
        this._compartment = c;
        c.group.leaves.push(this.transform.nodeIndex);
    }
    _mkSpeciesRef(x) {
        let s = new SpeciesReference(x);
        s.species = this.model.species.get(s.species);
        s.species.pool.refs.push(s);
        if (!this.compartment)
            this.compartment = s.species.compartment;
        return s;
    }
    _getClone(s) {
        let c = s.species.pool.getClone();
        if (this.model.graph.nodes.indexOf(c) === -1) {
            c.nodeIndex = this.model.graph.nodes.push(c) - 1;
            this.compartment.group.leaves.push(c.nodeIndex);
        }
        return c;
    }
    addModifier(x) {
        let s = this._mkSpeciesRef(x);
        let c = this._getClone(s);
        this.modifiers.push(s);
        this.model.graph.links.push(new ModifierLink(c, this.transform));
        return s;
    }
    addReactant(x) {
        let s = this._mkSpeciesRef(x);
        let c = this._getClone(s);
        this.reactants.push(s);
        this.model.graph.links.push(new Link(c, this.transform, this.reversible));
        return s;
    }
    addProduct(x) {
        let s = this._mkSpeciesRef(x);
        let c = this._getClone(s);
        this.products.push(s);
        this.model.graph.links.push(new Link(this.transform, c, this.reversible));
        return s;
    }
}
class SpeciesReference extends Entity {
    constructor(attr) {
        super(assign({ stoichiometry: 1 }, attr));
    }
}
class ModifierSpeciesReference extends SpeciesReference {
}
const create = attributes => {
    switch (attributes.$name) {
    case 'model':
        return new Model(attributes);
    case 'unitDefinition':
        return new Unit(attributes);
    case 'compartment':
        return new Compartment(attributes);
    case 'species':
        return new Species(attributes);
    case 'reaction':
        return new Reaction(attributes);
    case 'speciesReference':
        return new SpeciesReference(attributes);
    case 'modifierSpeciesReference':
        return new ModifierSpeciesReference(attributes);
    default:
        return attributes;
    }
};
module.exports = {
    Pool,
    PoolClone,
    Link,
    ModifierLink,
    Transform,
    Model,
    Species,
    Compartment,
    Unit,
    Reaction,
    SpeciesReference,
    ModifierSpeciesReference,
    Group,
    Graph,
    create,
    revive
};
},{"243":243,"248":248}],308:[function(require,module,exports){
const url = 'http://localhost:8080/www.ebi.ac.uk/biomodels-main/search-models.do?cmd=TEXT:SEARCH';
const cheerio = require(8);
module.exports = function search(term) {
    let $;
    function toModel(i, tr) {
        let $td = $('td', this);
        if (!$td.eq(0))
            return null;
        let id = $td.eq(0).find('a').first().text();
        if (!id)
            return null;
        let name = $td.eq(1).text();
        return {
            id,
            name
        };
    }
    return fetch(url, {
        headers: new Headers({ 'content-type': 'application/x-www-form-urlencoded;charset=UTF-8' }),
        method: 'POST',
        body: `txt=${ encodeURI(term) }`
    }).then(r => r.text()).then(s => $ = cheerio.load(s)).then($ => $('#tbl_modelslist tr').map(toModel).get());
};
},{"8":8}],309:[function(require,module,exports){
const ndarray = require(243);
const fill = require(241);
const traverse = require(271);
const {assign} = require(242);
const {simplex} = require(313);
const {Model, Species, Reaction, Unit, Compartment} = require(307);
const proto = (o, c) => Object.setPrototypeOf(o, c.prototype);
const deleteThis = new Set();
[
    'graph',
    'group',
    'transform',
    'pool'
].forEach(x => deleteThis.add(x));
module.exports = function (self) {
    function clean(model) {
        traverse(model).forEach(function (x) {
            if (x) {
                if (deleteThis.has(this.key))
                    return this.delete(true);
                if (x.$constructor) {
                    switch (x.$constructor) {
                    case 'Model':
                        proto(x, Model);
                        break;
                    case 'Unit':
                        proto(x, Unit);
                        break;
                    case 'Species':
                        proto(x, Species);
                        break;
                    case 'Reaction':
                        proto(x, Reaction);
                        break;
                    case 'Compartment':
                        proto(x, Compartment);
                        break;
                    }
                    this.update(x);
                }
            }
        });
        return model;
    }
    function fba({model, options}) {
        const {print} = options;
        print(`starting fba for model ${ model.id }`);
        print(`restoring prototypes`);
        clean(model, print);
        print('setting up variables');
        const n = model.reactions.size;
        const m = model.species.size;
        const constraints = [];
        const objective = ndarray(new Float64Array(n), [
            n,
            1
        ]);
        const lbs = ndarray(new Float64Array(n), [
            n,
            1
        ]);
        const ubs = ndarray(new Float64Array(n), [
            n,
            1
        ]);
        print('getting stoichiometricMatrix');
        const S = model.stoichiometricMatrix;
        print('setting up objective');
        fill(objective, () => 1);
        print('setting up constraints');
        for (let i = 0; i < m; i++) {
            let coef = ndarray(new Float64Array(n), [n]);
            assign(coef, S.pick(i, null));
            constraints.push([
                coef.data,
                '=',
                0
            ]);
        }
        print('setting up bounds');
        fill(lbs, () => -1);
        fill(ubs, () => 1);
        print('starting simplex');
        return simplex({
            objective: { coef: objective },
            constraints,
            lbs,
            ubs,
            print
        });
    }
    self.addEventListener('message', function ({data}) {
        let t = Date.now();
        try {
            data.options.print = s => self.postMessage({ debug: t + ': ' + s });
            self.postMessage({ debug: `starting fba ${ t }` });
            let r = fba(data);
            self.postMessage({ debug: `done with fba ${ t }` });
            self.postMessage(r);
        } catch (e) {
            self.postMessage({
                error: {
                    message: e.message,
                    stack: e.stack
                }
            });
        }
    });
    self.postMessage('alive');
};
},{"241":241,"242":242,"243":243,"271":271,"307":307,"313":313}],310:[function(require,module,exports){
const work = require(299);
const {Observable, Subject} = require(266);
const services = {
    fba: require(309),
    search: require(315),
    parse: require(314),
    kegg: require(311)
};
for (let k in services)
    module.exports[k] = service(k);
function service(name) {
    const srv = work(services[name]);
    const input = new Subject();
    const log = new Subject();
    const output = new Subject();
    Observable.fromEvent(srv, 'message').subscribe(({data}) => {
        if (data.log)
            log.onNext(data.log);
        else if (data !== 'alive')
            output.onNext(data);
    });
    const error = Observable.fromEvent(srv, 'error');
    input.subscribe(d => srv.postMessage(d));
    return {
        input,
        error,
        log,
        output
    };
}
},{"266":266,"299":299,"309":309,"311":311,"314":314,"315":315}],311:[function(require,module,exports){
const text = t => t.text();
const parse = t => t.split('\n').reduce(({pos, obj}, l) => {
    if (l.startsWith('ENTRY')) {
        obj.id = 'rn:' + l.split(/\s+/)[1];
        pos = 'ENTRY';
    } else if (l.startsWith(' ') && pos === 'NAME' || l.startsWith('NAME')) {
        if (!obj.names)
            obj.names = [];
        obj.names.push(l.replace('NAME', '').replace(';', '').trim());
        pos = 'NAME';
    } else if (l.startsWith('DEFINITION')) {
        obj.definition = l.replace('DEFINITION', '').trim();
        pos = 'DEFINITION';
    } else if (l.startsWith('EQUATION')) {
        obj.equation = l.replace('EQUATION', '').trim();
        pos = 'EQUATION';
    } else if (l.startsWith('ENZYME')) {
        obj.enzyme = l.replace('ENZYME', '').trim().split(/\s+/);
        pos = 'ENZYME';
    } else if (l.startsWith('RCLASS')) {
        obj.rclass = l.replace('RCLASS', '').trim().split(/\s+/);
        pos = 'RCLASS';
    }
    return {
        pos,
        obj
    };
}, {
    pos: null,
    obj: {}
}).obj;
module.exports = function kegg(self) {
    self.addEventListener('message', function ({data}) {
        if (data.href) {
            const href = data.href;
            fetch(href).then(text).then(parse).then(function (reaction) {
                self.postMessage({
                    href,
                    reaction
                });
            });
        }
    });
};
},{}],312:[function(require,module,exports){
const base = 'http://localhost:8080/rest.kegg.jp';
const split = t => t.split('\n').map(l => l.match(/^([^\s]+)\s+(.*);\s+(.*)$/)).filter(Boolean).map(([_, id, names, reaction]) => ({
    id,
    names,
    reaction,
    href: geturl(id)
}));
const text = t => t.text();
const geturl = id => `${ base }/get/${ id }`;
const search = t => fetch(`${ base }/find/reaction/${ encodeURIComponent(t) }`).then(text).then(split);
module.exports = search;
},{}],313:[function(require,module,exports){
const assign = require(1);
const {SMCP, GLP_ON, GLP_MIN, GLP_MAX, GLP_DB, GLP_LO, GLP_FX, GLP_FR, GLP_UP, glp_simplex, glp_add_cols, glp_add_rows, glp_mip_obj_val, glp_mip_col_val, glp_set_obj_dir, glp_set_print_func, glp_set_col_bnds, glp_set_obj_coef, glp_set_mat_row, glp_set_row_bnds, glp_set_row_name, glp_create_prob, glp_set_obj_name} = require(63);
function* seq(i, n) {
    while (i < n)
        yield i++;
}
const DBL_MAX = Number.MAX_VALUE;
const defaults = { objective: { dir: 'max' } };
module.exports.simplex = function simplex(p) {
    const {
        objective: {coef, dir},
        lbs,
        ubs,
        constraints
    } = assign({}, defaults, p);
    let log = '';
    glp_set_print_func(p.print || (s => log += s + '\n'));
    const lp = glp_create_prob();
    const n = coef.data.length;
    const m = constraints.length;
    glp_set_obj_dir(lp, /^max/i.test(dir) ? GLP_MAX : GLP_MIN);
    glp_set_obj_name(lp, 'obj');
    glp_add_cols(lp, n);
    glp_add_rows(lp, m);
    for (let i = 0; i < n; i++) {
        let lb = lbs.data[i];
        let ub = ubs.data[i];
        let type;
        if (lb === -DBL_MAX && ub === +DBL_MAX)
            type = GLP_FR;
        else if (ub === +DBL_MAX)
            type = GLP_LO;
        else if (lb === -DBL_MAX)
            type = GLP_UP;
        else if (lb !== ub)
            type = GLP_DB;
        else
            type = GLP_FX;
        glp_set_obj_coef(lp, i + 1, coef.data[i]);
        glp_set_col_bnds(lp, i + 1, type, lb, ub);
    }
    for (let i = 0; i < m; i++) {
        let [coef, type, val] = constraints[i];
        type = type === '>=' ? GLP_LO : type === '<=' ? GLP_UP : GLP_FX;
        coef = Array.of(...coef.entries()).filter(([k, v]) => v !== 0).reduce((r, [k, v]) => {
            r[0].push(k + 1);
            r[1].push(v);
            return r;
        }, [
            [void 0],
            [void 0]
        ]);
        glp_set_mat_row(lp, i + 1, coef[0].length - 1, ...coef);
        glp_set_row_name(lp, i + 1, `r.${ i }`);
        glp_set_row_bnds(lp, i + 1, type, val);
    }
    const smcp = new SMCP({ presolve: GLP_ON });
    glp_simplex(lp, smcp);
    const result = {
        objective: glp_mip_obj_val(lp),
        x: Array.of(...seq(0, n - 1)).map(i => glp_mip_col_val(lp, i + 1))
    };
    if (log.length)
        result.log = log;
    return result;
};
},{"1":1,"63":63}],314:[function(require,module,exports){
(function (Buffer){
const through = require(270);
const pipe = require(231);
const assign = require(248);
const omit = require(227);
const sax = require(267);
const {last, pop, push} = require(316);
const {Model} = require(307);
module.exports = function (self) {
    let p = pipe(read(), build());
    self.addEventListener('message', ({data}) => {
        if (data.data)
            p.write(data.data);
    });
    p.on('data', d => self.postMessage(d));
};
const getChild = (o, $name) => o.$children.find(x => x.$name === $name) || {};
const listOf = (o, what) => getChild(o, `listOf${ what }`).$children || [];
const clean = o => omit(o, [
    '$children',
    'annotation',
    '$name'
]);
function mkgraph(o, opt = {}) {
    let m = new Model(clean(o));
    for (let c of listOf(o, 'Compartments'))
        m.addCompartment(clean(c));
    for (let c of listOf(o, 'Species'))
        m.addSpecies(clean(c));
    for (let c of listOf(o, 'Reactions')) {
        let r = m.addReaction(clean(c));
        for (let s of listOf(c, 'Reactants'))
            r.addReactant(clean(s));
        for (let s of listOf(c, 'Products'))
            r.addProduct(clean(s));
        for (let s of listOf(c, 'Modifiers'))
            r.addModifier(clean(s));
    }
    return m;
}
function build(opt = {}) {
    return through.obj((d, _, c) => c(null, mkgraph(d, opt)));
}
function read(opt = { strict: true }) {
    const mkparser = () => sax.createStream(opt.strict, opt);
    const stack = [{}];
    const write = (d, _, c) => parser.write(Buffer.from(d)) && c();
    const dup = through.obj(write);
    let parser = mkparser();
    parser.on('error', e => dup.emit('error', e));
    parser.on('opentag', n => push(stack, assign(n.attributes, { $name: n.name })));
    parser.on('closetag', n => {
        let o = pop(stack);
        let p = last(stack);
        if (n.toLowerCase() === 'model') {
            dup.push(o);
            parser = mkparser();
            return;
        }
        if (!p.$children)
            p.$children = [];
        p.$children.push(o);
    });
    return dup;
}
}).call(this,require(7).Buffer)
},{"227":227,"231":231,"248":248,"267":267,"270":270,"307":307,"316":316,"7":7}],315:[function(require,module,exports){
const {Observable} = require(266);
const keggReaction = require(312);
const biomodels = require(308);
module.exports = function (self) {
    Observable.fromEvent(self, 'message').map(m => m.data).distinctUntilChanged().filter(t => t.length > 2).debounce(300).flatMapLatest(t => {
        if (t.startsWith('model')) {
            return biomodels(t.replace('model', '').trim());
        }
        return keggReaction(t);
    }).subscribe(d => self.postMessage(d));
};
},{"266":266,"308":308,"312":312}],316:[function(require,module,exports){
const isDefined = x => typeof x !== 'undefined';
const func = fn => (...args) => isDefined(args[0]) ? fn(...args) : 0[0];
const last = func(a => a[a.length - 1]);
const either = (...args) => args.find(isDefined);
const pop = func(a => a.pop());
const push = func((a, b) => a.push(b));
const reduce = func((a, c, s) => a.reduce(c, s));
const getOrSet = (k, v) => func(o => o[k] = either(o[k], v));
const empty = t => !t.trim().length;
const maybeEval = (x, c) => typeof x === 'function' ? x.call(c) : x;
const get = keys => o => keys.split('.').reduce((o, k) => o && maybeEval(o[k], o), o);
const byProp = (...keys) => val => x => keys.reduce((o, k) => o && o[k], x) === val;
const isPromise = obj => typeof obj !== 'undefined' && typeof obj.then === 'function';
const words = s => ({
    [Symbol.iterator]() {
        return splitGen(s, ' ');
    }
});
function* filter(it, fn) {
    for (let i of it)
        if (fn(i))
            yield i;
}
function* map(it, fn) {
    for (let i of it)
        yield fn(i);
}
function* splitGen(s, x) {
    let r = '';
    for (let c of s) {
        if (c === x) {
            if (r.length)
                yield r;
            r = '';
        } else {
            r += c;
        }
    }
}
function getAsString(i) {
    return new Promise(function (resolve, reject) {
        try {
            i.getAsString(r => resolve(r));
        } catch (e) {
            reject(e);
        }
    });
}
function isDOMData(i) {
    return i.kind !== 'file';
}
function handleDrop(callback, e) {
    killEvent(e);
    let items = map(filter(e.dataTransfer.items, isDOMData), getAsString);
    let files = e.dataTransfer.files;
    Promise.all(items).then(items => callback({
        items,
        files
    })).catch(e => console.error(e));
}
function killEvent(e) {
    e.stopPropagation();
    e.preventDefault();
    return false;
}
function dnd(element, callback) {
    element.addEventListener('dragenter', killEvent, false);
    element.addEventListener('dragover', killEvent, false);
    element.addEventListener('drop', handleDrop.bind(undefined, callback), false);
}
function toKebab(s) {
    let r = '';
    let first = true;
    for (let c of s) {
        r += (!first && c === c.toUpperCase() ? '-' : '') + c.toLowerCase();
        if (first)
            first = false;
    }
    return r;
}
function defer() {
    let res;
    let rej;
    let p = new Promise(function (resolve, reject) {
        res = resolve;
        rej = reject;
    });
    return {
        promise: p,
        resolve: res,
        reject: rej
    };
}
module.exports = {
    defer,
    noop: () => {
    },
    toKebab,
    dnd,
    isDefined,
    func,
    last,
    either,
    pop,
    push,
    reduce,
    getOrSet,
    empty,
    maybeEval,
    get,
    byProp,
    splitGen,
    words,
    filter,
    map,
    isPromise
};
},{}],317:[function(require,module,exports){
const html = require(19);
const {li} = require(326);
const capitalize = w => w[0].toUpperCase() + w.substring(1);
module.exports = function calcView(state, emit) {
    const run = what => () => emit(`run${ capitalize(what) }`);
    return (function () {
      
      var ac = require(302)
      var bel2 = document.createElement("div")
var bel1 = document.createElement("nav")
bel1.setAttribute("class", "vclNavigation vclLayoutVertical vclLayoutFlex vclVertical")
var bel0 = document.createElement("ul")
ac(bel0, ["\n          ",arguments[0],"\n          ",arguments[1],"\n        "])
ac(bel1, ["\n        ",bel0,"\n      "])
ac(bel2, ["\n      ",bel1,"\n    "])
      return bel2
    }(li('fba', undefined, run('FBA')),li('dynamic simulation', undefined, run('sim'))));
};
},{"19":19,"302":302,"326":326}],318:[function(require,module,exports){
const html = require(19);
const draw = require(319);
function modelView(model, emit) {
    const load = () => setTimeout(() => draw(model, document.body.querySelector('#graph')), 1000);
    const style = 'height:100%; width:100%';
    const node = (function () {
      var onload = require(249)
      var ac = require(302)
      var bel0 = document.createElement("div")
var args = arguments
      onload(bel0, function bel_onload () {
        args[0](bel0)
      }, function bel_onunload () {
        
      }, "o0")
bel0.setAttribute("id", "graph")
bel0.setAttribute("style", arguments[1])
bel0.setAttribute("class", "graph")
      return bel0
    }(load,style));
    node.isSameNode = function (o) {
        return o && o.nodeName && o.id === 'graph';
    };
    return node;
}
const callout = inner => (function () {
      
      var ac = require(302)
      var bel0 = document.createElement("div")
bel0.setAttribute("style", "margin: auto")
bel0.setAttribute("class", "vclCallout vclInfo")
ac(bel0, [arguments[0]])
      return bel0
    }(inner));
const noModel = (function () {
      
      var ac = require(302)
      var bel4 = document.createElement("div")
var bel3 = document.createElement("ul")
var bel0 = document.createElement("li")
ac(bel0, ["Drag and drop an SBML file anywhere on the page"])
var bel1 = document.createElement("li")
ac(bel1, ["Go through the file menu to open an SBML file"])
var bel2 = document.createElement("li")
ac(bel2, ["Open the search tab and drag and drop reactions onto the page"])
ac(bel3, ["\n      ",bel0,"\n      ",bel1,"\n      ",bel2,"\n    "])
ac(bel4, ["\n    Start creating a metabolic network by\n    ",bel3," \n  "])
      return bel4
    }());
module.exports = function contentView(appstate, emit) {
    const {content} = appstate;
    const {model} = content || {};
    return (function () {
      
      var ac = require(302)
      var bel0 = document.createElement("div")
bel0.setAttribute("style", "overflow: hidden; width: 100%")
bel0.setAttribute("class", "vclCenter vclMiddle vclLayoutCenter vclLayoutHorizontal")
ac(bel0, ["\n      ",arguments[0]," \n    "])
      return bel0
    }(!model ? callout(noModel) : model.error ? callout(model.error) : modelView(model, emit)));
};
},{"19":19,"249":249,"302":302,"319":319}],319:[function(require,module,exports){
const cola = require(280);
const assign = require(248);
const d3 = window.d3 = require(34);
const {get} = require(316);
const either = (cond, defaul, ...arr) => d => {
    for (let a of arr) {
        let v = a.call ? a(d) : a;
        if (cond(v))
            return v;
    }
    return defaul;
};
const le0 = x => x >= 0;
const getle0 = (...args) => either(le0, 0, get(...args));
const margin = 10;
function makeEdgeBetween(source, target, ah) {
    let si = source.rayIntersection(target.cx(), target.cy()) || {
        x: source.cx(),
        y: source.cy()
    };
    let ti = target.rayIntersection(source.cx(), source.cy()) || {
        x: target.cx(),
        y: target.cy()
    };
    let dx = ti.x - si.x;
    let dy = ti.y - si.y;
    let l = Math.sqrt(dx * dx + dy * dy);
    let al = l - ah;
    return {
        sourceIntersection: si,
        targetIntersection: ti,
        arrowStart: {
            x: si.x + al * dx / l,
            y: si.y + al * dy / l
        },
        arrowEnd: {
            x: ti.x - al * dx / l,
            y: ti.y - al * dy / l
        }
    };
}
const makeRoute = d => {
    assign(d, { route: makeEdgeBetween(d.source.innerBounds, d.target.innerBounds, 6) });
};
const translateLabel = d => `translate(${ d.innerBounds.cx() },${ d.y + margin - d.height / 2 })`;
function setSize(d) {
    let b = this.getBBox();
    assign(d, {
        width: b.width + 2 * margin + 8,
        height: b.height + 2 * margin + 8
    });
    d.innerBounds = d.bounds.inflate(-margin);
}
function insertLineBreaks(d) {
    var el = d3.select(this);
    var words = d.label.split(' ');
    el.text('');
    for (var i = 0; i < words.length; i++) {
        el.append('tspan').text(words[i]).attr('x', 0).attr('dy', '15').attr('font-size', '12');
    }
}
;
module.exports = function draw(model, root) {
    let {graph} = model;
    let width = root.offsetWidth - 10;
    let height = root.offsetHeight - 10;
    let d3cola = cola.d3adaptor().linkDistance(40).avoidOverlaps(true).size([
        width,
        height
    ]);
    let outer = d3.select(root.createShadowRoot()).append('svg').attr('width', width).attr('height', height).attr('pointer-events', 'all');
    outer.append('rect').attr('class', 'background').attr('width', '100%').attr('height', '100%').call(d3.behavior.zoom().scaleExtent([
        0.1,
        10
    ]).on('zoom', () => vis.attr('transform', `translate(${ d3.event.translate }) scale(${ d3.event.scale })`)));
    let vis = outer.append('g');
    let groupsLayer = vis.append('g');
    let nodesLayer = vis.append('g');
    let linksLayer = vis.append('g');
    let defs = outer.append('svg:defs');
    defs.append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 5).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto-start-reverse').append('svg:path').attr('d', 'M0,-5L10,0L0,5L2,0').attr('stroke-width', '0px').attr('fill', '#000');
    defs.append('svg:marker').attr('id', 'end-circle').attr('viewBox', '-5 -5 10 10').attr('refX', 2).attr('markerWidth', 3).attr('markerHeight', 3).attr('orient', 'auto').append('svg:circle').attr('r', 5).attr('cy', 0).attr('cx', 0).attr('stroke-width', '0px').attr('fill', '#000');
    d3cola.nodes(graph.nodes).links(graph.links).groups(graph.groups).constraints(graph.constraints).start(20);
    let link = linksLayer.selectAll('.link').data(graph.links).enter().append('line').attr('class', get('className'));
    let group = groupsLayer.selectAll('.group').data(graph.groups).enter().append('rect').attr('class', get('className')).attr('rx', get('rx')).attr('ry', get('ry'));
    let node = nodesLayer.selectAll('.node').data(graph.nodes).enter().append('rect').attr('class', get('className')).call(d3cola.drag);
    node.append('title').text(get('label'));
    let label = nodesLayer.selectAll('.label').data(graph.nodes).enter().append('text').attr('class', 'label');
    label.each(insertLineBreaks);
    function tick() {
        label.each(setSize);
        label.attr('transform', translateLabel);
        link.each(makeRoute).attr('x1', get('route.arrowEnd.x')).attr('y1', get('route.arrowEnd.y')).attr('x2', get('route.arrowStart.x')).attr('y2', get('route.arrowStart.y'));
        node.attr('rx', getle0('rx')).attr('ry', getle0('rx')).attr('x', get('innerBounds.x')).attr('y', get('innerBounds.y')).attr('width', getle0('innerBounds.width')).attr('height', getle0('innerBounds.height'));
        group.attr('x', get('bounds.x')).attr('y', get('bounds.y')).attr('width', getle0('bounds.width')).attr('height', getle0('bounds.height'));
    }
    d3cola.on('tick', tick);
    return root;
};
},{"248":248,"280":280,"316":316,"34":34}],320:[function(require,module,exports){
const html = require(19);
const {li} = require(326);
module.exports = function fileView(state, send) {
    return (function () {
      
      var ac = require(302)
      var bel2 = document.createElement("div")
var bel1 = document.createElement("nav")
bel1.setAttribute("class", "vclNavigation vclLayoutVertical vclLayoutFlex vclVertical")
var bel0 = document.createElement("ul")
ac(bel0, ["\n          ",arguments[0],"\n          ",arguments[1],"\n        "])
ac(bel1, ["\n        ",bel0,"\n      "])
ac(bel2, ["\n      ",bel1,"\n    "])
      return bel2
    }(li('new model', 'file-o', () => send('newModel')),li('open sbml', 'folder-open-o', () => send('openModelFile'))));
};
},{"19":19,"302":302,"326":326}],321:[function(require,module,exports){
const html = require(19);
const menuView = require(322);
const contentView = require(318);
module.exports = function mainView(state, emit) {
    return (function () {
      
      var ac = require(302)
      var bel1 = document.createElement("body")
var bel0 = document.createElement("div")
bel0.setAttribute("style", "height:100%")
bel0.setAttribute("class", "vclContentArea vclLayoutHorizontal vclLayoutFlex")
ac(bel0, ["\n        ",arguments[0],"\n        ",arguments[1],"\n      "])
ac(bel1, ["\n      ",bel0,"\n    "])
      return bel1
    }(menuView(state, emit),contentView(state, emit)));
};
},{"19":19,"302":302,"318":318,"322":322}],322:[function(require,module,exports){
const html = require(19);
const {killEvent} = require(326);
const fileView = require(320);
const searchView = require(325);
const networkView = require(323);
const calcView = require(317);
const optionsView = require(324);
function wrap(tab) {
    return (function () {
      
      var ac = require(302)
      var bel0 = document.createElement("div")
bel0.setAttribute("style", "width: 240px")
bel0.setAttribute("class", "vclLayoutVertical inner-sidebar")
ac(bel0, ["\n      ",arguments[0],"\n    "])
      return bel0
    }(tab));
}
module.exports = function menuView(appstate, emit) {
    const state = appstate.menu;
    const selected = title => state.active === title ? 'vclSelected' : '';
    const disabled = t => t ? 'vclDisabled' : '';
    const select = what => () => emit('activeMenu', what);
    const li = (title, icon, dis = false) => (function () {
      
      var ac = require(302)
      var bel2 = document.createElement("li")
bel2.setAttribute("role", "presentation")
bel2.setAttribute("href", "#")
bel2.setAttribute("aria-selected", arguments[3])
bel2.setAttribute("class", "vclNavigationItem " + arguments[4] + " " + arguments[5])
var bel1 = document.createElement("a")
bel1.setAttribute("title", arguments[1])
bel1["onclick"] = arguments[2]
bel1.setAttribute("class", "vclNavigationItemLabel")
var bel0 = document.createElement("i")
bel0.setAttribute("class", "vclIcon fa fa-fw fa-" + arguments[0])
ac(bel1, ["\n        ",bel0,"\n      "])
ac(bel2, ["\n      ",bel1,"\n    "])
      return bel2
    }(icon,title,dis ? killEvent : select(title),state.active === title,disabled(dis),selected(title)));
    const tab = {
        file: () => wrap(fileView(state.file, emit)),
        search: () => wrap(searchView(state.search, emit)),
        network: () => wrap(networkView(state.network, emit)),
        calculate: () => wrap(calcView(state.clac, emit)),
        options: () => wrap(optionsView(state.options, emit)),
        [null]: () => ''
    }[state.active]();
    return (function () {
      
      var ac = require(302)
      var bel3 = document.createElement("div")
bel3.setAttribute("class", "vclLayoutHorizontal vlcLayoutFlex")
var bel2 = document.createElement("div")
bel2.setAttribute("class", "vclLayoutVertical sidebar")
var bel1 = document.createElement("nav")
bel1.setAttribute("class", "vclNavigation vclLayoutVertical vclLayoutFlex vclVertical")
var bel0 = document.createElement("ul")
ac(bel0, ["\n            ",arguments[0],"\n            ",arguments[1],"\n            ",arguments[2],"\n            ",arguments[3],"\n            ",arguments[4],"\n          "])
ac(bel1, ["\n          ",bel0,"\n        "])
ac(bel2, ["\n        ",bel1,"\n      "])
ac(bel3, ["\n      ",bel2,"\n      ",arguments[5],"\n    "])
      return bel3
    }(li('file', 'file-o'),li('search', 'search'),li('network', 'code-fork', !appstate.content.model),li('calculate', 'calculator', !appstate.content.model),li('options', 'wrench'),tab));
};
},{"19":19,"302":302,"317":317,"320":320,"323":323,"324":324,"325":325,"326":326}],323:[function(require,module,exports){
const html = require(19);
const {li} = require(326);
module.exports = function networkView(state, send) {
    return (function () {
      
      var ac = require(302)
      var bel2 = document.createElement("div")
var bel1 = document.createElement("nav")
bel1.setAttribute("class", "vclNavigation vclLayoutVertical vclLayoutFlex vclVertical")
var bel0 = document.createElement("ul")
ac(bel0, ["\n          ",arguments[0],"\n        "])
ac(bel1, ["\n        ",bel0,"\n      "])
ac(bel2, ["\n      ",bel1,"\n    "])
      return bel2
    }(li('todo')));
};
},{"19":19,"302":302,"326":326}],324:[function(require,module,exports){
const html = require(19);
const {li} = require(326);
module.exports = function optionsView(state, send) {
    return (function () {
      
      var ac = require(302)
      var bel2 = document.createElement("div")
var bel1 = document.createElement("nav")
bel1.setAttribute("class", "vclNavigation vclLayoutVertical vclLayoutFlex vclVertical")
var bel0 = document.createElement("ul")
ac(bel0, ["\n          ",arguments[0],"\n        "])
ac(bel1, ["\n        ",bel0,"\n      "])
ac(bel2, ["\n      ",bel1,"\n    "])
      return bel2
    }(li('todo')));
};
},{"19":19,"302":302,"326":326}],325:[function(require,module,exports){
const html = require(19);
const loading = (function () {
      
      var ac = require(302)
      var bel1 = document.createElement("li")
bel1.setAttribute("class", "vclDisabled vclNavigationItem")
var bel0 = document.createElement("a")
bel0.setAttribute("href", "#")
bel0.setAttribute("class", "vclNavigationItemLabel")
ac(bel0, ["\n      loading ...\n    "])
ac(bel1, ["\n    ",bel0,"\n  "])
      return bel1
    }());
const empty = (function () {
      
      var ac = require(302)
      var bel1 = document.createElement("li")
bel1.setAttribute("class", "vclDisabled vclNavigationItem")
var bel0 = document.createElement("a")
bel0.setAttribute("href", "#")
bel0.setAttribute("class", "vclNavigationItemLabel")
ac(bel0, ["\n      no results  \n    "])
ac(bel1, ["\n    ",bel0,"\n  "])
      return bel1
    }());
module.exports = function searchView(state, emit) {
    let {busy, term, results} = state;
    if (!term)
        term = '';
    if (results && results.length === 0)
        results = false;
    const setterm = e => emit('searchFor', e ? e.target.value : '');
    const clear = () => setterm();
    const hideEraser = term ? '' : 'vclDisplayNone';
    const hideSpinner = busy ? '' : 'vclDisplayNone';
    const result = r => {
        const {id, name, names, reaction, href} = r;
        if (reaction) {
            return (function () {
      
      var ac = require(302)
      var bel4 = document.createElement("li")
bel4.setAttribute("class", "vclNavigationItem")
var bel3 = document.createElement("a")
bel3.setAttribute("title", arguments[3])
bel3.setAttribute("href", arguments[4])
bel3.setAttribute("class", "vclNavigationItemLabel")
var bel0 = document.createElement("small")
ac(bel0, [arguments[0]])
var bel1 = document.createElement("b")
ac(bel1, [arguments[1]])
var bel2 = document.createElement("small")
ac(bel2, [arguments[2]])
ac(bel3, ["\n            ",bel0,"\n            ",bel1,"\n            ",bel2,"\n          "])
ac(bel4, ["\n          ",bel3,"\n        "])
      return bel4
    }(id,names,reaction,names,href));
        }
        return (function () {
      
      var ac = require(302)
      var bel4 = document.createElement("li")
bel4.setAttribute("class", "vclNavigationItem")
var bel3 = document.createElement("a")
bel3.setAttribute("title", arguments[3])
bel3.setAttribute("href", arguments[4])
bel3.setAttribute("class", "vclNavigationItemLabel")
var bel0 = document.createElement("small")
ac(bel0, [arguments[0]])
var bel1 = document.createElement("b")
ac(bel1, [arguments[1]])
var bel2 = document.createElement("small")
ac(bel2, [arguments[2]])
ac(bel3, ["\n          ",bel0,"\n          ",bel1,"\n          ",bel2,"\n        "])
ac(bel4, ["\n        ",bel3,"\n      "])
      return bel4
    }(id,names,reaction,name,href));
    };
    return (function () {
      
      var ac = require(302)
      var bel9 = document.createElement("div")
var bel6 = document.createElement("div")
bel6.setAttribute("class", "vclInputGroupEmb")
var bel0 = document.createElement("input")
bel0.setAttribute("type", "search")
bel0.setAttribute("placeholder", "search")
bel0["onkeyup"] = arguments[0]
bel0.setAttribute("value", arguments[1])
bel0.setAttribute("id", "search")
bel0.setAttribute("autocomplete", "off")
bel0.setAttribute("class", "vclInput vclNoBorder vclAppItem")
var bel2 = document.createElement("div")
bel2.setAttribute("style", "right: 1.2em")
bel2.setAttribute("class", "vclIcogram vlcTransparent vclSquare vclAppended " + arguments[2])
var bel1 = document.createElement("div")
bel1.setAttribute("aria-hidden", "true")
bel1.setAttribute("aria-label", "Clear")
bel1.setAttribute("role", "img")
bel1.setAttribute("class", "vclIcon fa fa-spinner fa-spin")
ac(bel2, ["\n          ",bel1,"\n        "])
var bel5 = document.createElement("button")
bel5["onclick"] = arguments[3]
bel5.setAttribute("class", "vclButton vclTransparent vclSquare vclAppended " + arguments[4])
var bel4 = document.createElement("div")
bel4.setAttribute("class", "vclIcogram")
var bel3 = document.createElement("div")
bel3.setAttribute("aria-hidden", "true")
bel3.setAttribute("aria-label", "Clear")
bel3.setAttribute("role", "img")
bel3.setAttribute("class", "vclIcon fa fa-times-circle")
ac(bel4, ["\n            ",bel3,"\n          "])
ac(bel5, ["\n          ",bel4,"\n        "])
ac(bel6, ["\n        ",bel0,"\n        ",bel2,"\n        ",bel5,"\n      "])
var bel8 = document.createElement("nav")
bel8.setAttribute("class", "vclNavigation vvclLayoutVertical vclLayoutFlex vclVertical")
var bel7 = document.createElement("ul")
bel7.setAttribute("class", "vclScrollable vclYOnHover")
ac(bel7, ["\n        ",arguments[5],"\n        "])
ac(bel8, ["\n        ",bel7,"\n      "])
ac(bel9, ["\n      ",bel6,"\n      ",bel8,"\n    "])
      return bel9
    }(setterm,term,hideSpinner,clear,hideEraser,busy ? loading : results ? results.map(result) : empty));
};
},{"19":19,"302":302}],326:[function(require,module,exports){
const html = require(19);
const notImpl = () => alert('not implemented');
const noop = () => {
};
const li = (title, icon = 'angle-right', onclick = notImpl, selected = false) => (function () {
      
      var ac = require(302)
      var bel2 = document.createElement("li")
bel2.setAttribute("role", "presentation")
bel2.setAttribute("aria-selected", arguments[4])
bel2.setAttribute("class", "vclNavigationItem " + arguments[5])
var bel1 = document.createElement("a")
bel1.setAttribute("title", arguments[1])
bel1.setAttribute("href", "#")
bel1["onclick"] = arguments[2]
bel1.setAttribute("class", "vclNavigationItemLabel")
var bel0 = document.createElement("i")
bel0.setAttribute("class", "vclIcon fa fa-fw fa-" + arguments[0])
ac(bel1, ["\n      ",bel0,"\n      ",arguments[3],"\n    "])
ac(bel2, ["\n    ",bel1,"\n  "])
      return bel2
    }(icon,title,onclick,title,selected,selected ? 'vclSelected' : ''));
function killEvent(e) {
    e.preventDefault();
    e.stopPropagation();
}
module.exports = {
    killEvent,
    notImpl,
    noop,
    li
};
},{"19":19,"302":302}]},{},[306]);
